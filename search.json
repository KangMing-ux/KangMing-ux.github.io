[{"title":"第八章第六节 event_base结构体","url":"/course/np-ch8-par6.html","content":"\n## event_base结构体\n\n```c\n/*\n    引用方式: #include <event.h>\n    evsel: event_base对象选择的I/O复用机制\n    evbase: event_base对象的存储数据地址(通过evsel成员的init函数初始化)\n    changelist: 事件变化队列(考虑一个文件描述符上注册的事件被多次修改, 那么可以使用缓存来避免重复的系统调用, 仅用于事件检测算法的复杂度为O(1)的I/O复用技术)\n    evsigsel: 信号的后端处理机制(目前在signal.c中定义了一种处理机制)\n    sig: 被信号事件处理器使用，其中封装了一个由socketpair创建的管道; 管道用于信号处理函数与事件多路分发器之间的通信, 即统一事件源\n    virtual_event_count: 添加到event_base对象中的虚拟事件数\n    event_count: 添加到event_base对象上所有事件的数量\n    event_count_active: event_base对象上的激活事件数\n    event_gotterm: 是否执行完活动队列上的剩余任务后就退出事件循环\n    event_break: 是否立即退出事件循环，而不论是否还要任务需要处理\n    event_continue: 是否应该启动一个新的事件循环\n    event_running_priority: 目前正在处理的活动事件队列的优先级\n    running_loop: 事件循环是否已经启动\n    activequeues: 活动事件队列数组(索引值越小的队列, 优先级越高, 高优先级中的)\n    common_timeout_queues: 通用定时器队列\n    io: 文件描述符与I/O事件之间的映射关系表\n    sigmap: 信号值与信号事件的映射关系表\n    th_owner_id: 当前运行该event_base的事件循环的线程\n    th_base_lock: 对该event_base的独占锁\n    current_event_cond: 条件变量(用于唤醒正在等待某个事件处理完毕的线程)\n    current_event_waiters: 等待条件变量current_event_cond的线程数\n    flags:  event_base对象的配置参数\n    is_notify_pending: 工作线程是否要唤醒管道\n    th_notify_fd: 工作线程与主线程建立的管道\n*/\nstruct event_base {\n        const struct eventop *evsel;\n        void *evbase;\n        struct event_changelist changelist;\n        const struct eventop *evsigsel;\n        struct evsig_info sig;\n        int virtual_event_count;\n        int virtual_event_count_max;\n        int event_count;\n        int event_count_max;\n        int event_count_active;\n        int event_count_active_max;\n        int event_gotterm;\n        int event_break;\n        int event_continue;\n        int event_running_priority;\n        int running_loop;\n        int n_deferreds_queued;\n        struct evcallback_list *activequeues;\n        int nactivequeues;\n        struct evcallback_list active_later_queue;\n        struct common_timeout_list **common_timeout_queues;\n        int n_common_timeouts;\n        int n_common_timeouts_allocated;\n        struct event_io_map io;\n        struct event_signal_map sigmap;\n        struct min_heap timeheap;\n        struct timeval tv_cache;\n        struct evutil_monotonic_timer monotonic_timer;\n        struct timeval tv_clock_diff;\n        time_t last_updated_clock_diff;\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n        unsigned long th_owner_id;\n        void *th_base_lock;\n        void *current_event_cond;\n        int current_event_waiters;\n#endif\n        struct event_callback *current_event;\n\n#ifdef _WIN32\n        struct event_iocp_port *iocp;\n#endif\n        enum event_base_config_flag flags;\n        struct timeval max_dispatch_time;\n        int max_dispatch_callbacks;\n        int limit_callbacks_after_prio;\n        int is_notify_pending;\n        evutil_socket_t th_notify_fd[2];\n        struct event th_notify;\n        int (*th_notify_fn)(struct event_base *base);\n        struct evutil_weakrand_state weakrand_seed;\n        LIST_HEAD(once_event_list, event_once) once_events;\n};\n```\n\n## 事件循环\n\n事件循环由event_base_loop函数实现。关于event_base_loop函数的分析详见代码清单12-10。\n","tags":["网络编程"],"categories":["course"]},{"title":"第八章第五节 event_add函数","url":"/course/np-ch8-par5.html","content":"\n## event_add函数\n\n创建一个event对象的函数为将event_new封装后的函数evsignal_new、evtimer_new等；event_new的实现比较简单，为event对象分配内存并初始化其部分成员。\n\n创建了event对象后，应用程序调用event_add函数将其添加到注册事件队列中，并将相应的事件注册到事件多路分发器上。\n\nevent_add函数在event.c文件中实现，主要调用内部函数event_add_nolock_，外加调用前后两次加锁。\n\n关于函数event_add_nolock_的分析详见代码清单12-3。\n\n其中调用了几个重要的函数。\n\n* evmap_io_add：将I/O事件添加到事件多路分发器中，并将对应的事件处理器添加到I/O事件队列中，同时建立I/O事件与I/O事件队列之间的映射关系；\n* evmap_signal_add：将信号事件添加到事件多路分发器中，并将对应的事件处理器添加到信号事件队列中，同时建立信号事件与信号事件队列之间的映射关系；\n* event_queue_insert：将事件处理器添加到各种事件队列中，即：将I/O事件处理器与信号事件处理器插入注册事件队列；将定时器插入通用定时器队列或时间堆；将被激活的事件处理器添加到活动事件队列中；\n\n## 向事件多路分发器注册事件\n\n本节具体介绍evmap_io_add与evmap_signal_add这两个函数。在此之前，先介绍要用到的重要的数据结构。这部分详见代码清单12-5。\n\n## eventop结构体\n\neventop结构体封装了I/O复用机制必要的一些操作，如注册事件、等待事件等。它为event_base支持的所有后端I/O复用机制提供了统一的接口。\n\n```c\n/*\n    引用方式: #include <event.h>\n    name: 后端I/O复用技术的名称\n    init: 初始化函数接口\n    add: 注册事件接口\n    del: 删除事件接口\n    dispatch: 等待事件接口\n    dealloc: I/O资源释放接口\n    need_reinit: 程序调用fork后是否需要重新初始化event_base\n    features: I/O复用技术支持的特性; EV_FEATURE_ET: 支持边沿触发事件EV_ET || EV_FEATURE_O1: 事件检测算法的复杂度为O(1) || EV_FEATURE_FDS: 不仅能监听socket文件上的事件, 还能监听其他类型的文件描述符上的事件\n    fdinfo_len: 详见fdinfo_len段\n*/\nstruct eventop {\n        const char *name;\n        void *(*init)(struct event_base *);\n        int (*add)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);\n        int (*del)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);\n        int (*dispatch)(struct event_base *, struct timeval *);\n        void (*dealloc)(struct event_base *);\n        int need_reinit;\n        enum event_method_feature features;\n        size_t fdinfo_len;\n};\n```\n\n### fdinfo_len\n\n有的I/O复用机制需要为每个I/O事件队列与信号事件队列分配额外的内存，以避免同一个文件描述符被重复插入I/O复用机制的事件表中。于是在evmap_io_add/del在调用eventop的add/del方法时，将这段内存的起始地址作为第五个参数传递给add/del方法，fdinfo_len则用来指定这段内存的长度。\n\n### I/O复用技术的优先级\n\nevent ports > kqueue > epoll > /dev/poll > poll > select。\n\n可见，在Linux下libevent默认选择epoll I/O复用技术。\n","tags":["网络编程"],"categories":["course"]},{"title":"第八章第四节 event结构体","url":"/course/np-ch8-par4.html","content":"\nevent结构体封装了句柄、事件类型、回调函数以及其他必要的标志与数据。event结构体定义如下。\n\n```c\n/*\n    引用方式: #include <event.h>\n    evcb_active_next: 详见evcb_active_next段\n    evcb_flags: 详见evcb_flags段\n    evcb_pri: 指定事件处理器优先级(值越小优先级越高)\n    evcb_closure: 详见evcb_closure段\n    evcb_cb_union: 回调函数\n    evcb_arg: 回调函数的参数\n*/\n\nstruct event_callback {\n        TAILQ_ENTRY(event_callback) evcb_active_next;\n        short evcb_flags;\n        ev_uint8_t evcb_pri;    /* smaller numbers are higher priority */\n        ev_uint8_t evcb_closure;\n        /* allows us to adopt for different types of events */\n        union {\n                void (*evcb_callback)(evutil_socket_t, short, void *);\n                void (*evcb_selfcb)(struct event_callback *, void *);\n                void (*evcb_evfinalize)(struct event *, void *);\n                void (*evcb_cbfinalize)(struct event_callback *, void *);\n        } evcb_cb_union;\n        void *evcb_arg;\n};\n\n/*\n    引用方式: #include <event.h>\n    ev_evcallback: 回调函数相关标志与数据(详见结构体event_callback注释)\n    ev_timeout_pos: 详见ev_timeout_pos段\n    ev_fd: 与事件处理器关联的句柄; 对于I/O事件处理器: 文件描述符值 || 对于信号事件处理器: 信号值\n    ev_base: 事件处理器从属的event_base实例\n    ev_: 详见ev_段\n    ev_events: 事件类型; 取值可以是event_new中介绍的各种事件类型的按位或(除了互斥的事件类型，如读写事件与信号事件不能同时设置)\n    ev_res: 记录当前激活事件的类型\n    ev_timeout: 指定定时器的超时值(仅对定时器有效)\n*/\n\nstruct event {\n        struct event_callback ev_evcallback;\n        /* for managing timeouts */\n        union {\n                TAILQ_ENTRY(event) ev_next_with_common_timeout;\n                int min_heap_idx;\n        } ev_timeout_pos;\n        evutil_socket_t ev_fd;\n        struct event_base *ev_base;\n        union {\n                /* used for io events */\n                struct {\n                        LIST_ENTRY (event) ev_io_next;\n                        struct timeval ev_timeout;\n                } ev_io;\n                /* used by signal events */\n                struct {\n                        LIST_ENTRY (event) ev_signal_next;\n                        short ev_ncalls;\n                        /* Allows deletes in callback */\n                        short *ev_pncalls;\n                } ev_signal;\n        } ev_;\n        short ev_events;\n        short ev_res;           /* result passed to event callback */\n        struct timeval ev_timeout;\n};\n```\n\n以下是一些数据结构的详解。\n\n### evcb_active_next\n\n所有被激活的事件处理器通过evcb_active_next成员串联成一个尾队列，即活动事件队列。\n\n活动事件队列不止一个，不同优先级(evcb_pri成员)的事件处理器被激活后将被插入不同的活动事件队列中。\n\n在事件循环中，Reactor将按优先级由高到低遍历所有活动事件队列，并依次处理其中的事件处理器。\n\n### evcb_flags\n\n事件标志。有如下可选值。\n\n* EVLIST_TIMEOUT。事件处理器从属于通用定时器队列/时间堆；\n* EVLIST_INSERTED。事件处理器从属于注册事件队列；\n* EVLIST_SIGNAL。此标志未使用；\n* EVLIST_ACTIVE。事件处理器从属于活动事件队列；\n* EVLIST_INTERNAL。用于内部使用；\n* EVLIST_INIT。事件处理器已被初始化；\n* EVLIST_ACTIVE_LATER。\n* EVLIST_FINALIZING。\n* EVLIST_ALL。定义所有标志；\n\n### evcb_closure\n\n指定event_base执行事件处理器的回调函数时的行为。有如下可选值。\n\n* EV_CLOSURE_EVENT。默认行为，调用evcb_callback回调函数；\n* EV_CLOSURE_EVENT_SIGNAL。执行信号事件处理器的回调函数时，调用ev_signal.ev_ncalls次回调函数；\n* EV_CLOSURE_EVENT_PERSIST。执行完回调函数后，再次将事件处理器加入注册事件队列；\n* EV_CLOSURE_CB_SELF。调用evcb_selfcb回调函数；\n* EV_CLOSURE_CB_FINALIZE。正在完成的回调，使用evcb_cbfinalize回调函数；\n* EV_CLOSURE_EVENT_FINALIZE。正在完成的回调，使用evcb_evfinalize回调函数；\n* EV_CLOSURE_EVENT_FINALIZE_FREE。正在完成的回调，且之后事件处理器将被释放；使用evcb_evfinalize回调函数；\n\n### ev_timeout_pos\n\n定时器通常由时间堆来管理，但一些情况下使用简单的链表来管理效率更高。2.0版本的libevent引入了所谓\"通用定时器\"的概念，这些定时器存储在尾队列中，记为通用定时器队列。\n\n其中ev_next_with_common_timeout成员指定通用定时器情况下该定时器在通用定时器队列中的位置；min_heap_idx成员指定其他定时器情况下该定时器在时间堆中的位置。\n\n一个定时器是否为通用定时器取决于其超时值大小，通过event.c中的is_common_timeout函数判断。\n\n### ev_\n\n所有具有相同文件描述符的I/O事件处理器通过ev_io.ev_io_next成员串联成一个尾队列，即I/O事件队列；所有具有相同信号值的信号事件处理器通过ev_signal.ev_signal_next成员串联成一个尾队列，即信号事件队列。\n\nev_signal.ev_ncalls成员指定信号事件发生后，Reactor需要执行多少次该事件对应的事件处理器中的回调函数。ev_signal.ev_pncalls成员要么指向ev_signal.ev_ncalls，要么为空。\n","tags":["网络编程"],"categories":["course"]},{"title":"第八章第三节 libevent源码组织结构","url":"/course/np-ch8-par3.html","content":"\n* 头文件目录include/event2。该目录自Libevent朱版本升级之2.0之后引入；其中的头文件是提供给应用程序使用的。如event.h提供核心函数、http.h提供HTTP协议相关服务、rpc.h提供远程调用支持。\n\n\n* 源码根目录下的头文件。这些头文件分为两类：一类是对include/event2目录下部分头文件的封装；一类供libevent内部使用，这类头文件都具有`*-internal.h`形式。\n\n\n* 通用数据结构目录cpmpat/sys。该目录下仅有一个头文件queue.h。该文件封装了跨平台的基础数据结构：单向链表、双向链表、队列、尾队列、循环队列。\n\n\n* sample目录。示例程序。\n\n\n* test目录。测试程序。\n\n\n* WIN32-Code目录。Windows平台上的专用代码。\n\n\n* event.c。实现libevent的整体框架。主要是对event与event_base对象的相关操作。\n\n\n* devpoll.c、kqueue.c、evport.c、select.c、win32select.c、poll.c与epoll.c。分别封装了/dev/poll、kqueue、event ports、POSIX select、Windows select、poll、epoll这些I/O复用机制。这些文件的主要内容相似，都是针对结构体eventop所定义的接口函数的实现。\n\n\n* signal.c。提供对信号的支持。其内容也是针对eventop所定义的接口函数的具体实现。\n\n\n* evmap.c。维护句柄与事件处理器之间的映射关系。\n\n\n* event_tagging.c。提供向缓冲区添加标记数据以及从缓冲区中读取标记数据的函数。\n\n\n* event_iocp.c。提供对Windows IOCP的支持。\n\n\n* `buffer*.c`。提供对网络I/O缓冲的控制。包含输入输出数据过滤、传输速率限制、使用SSL协议、零拷贝文件传输。\n\n\n* `evthread*.c`。提供对多线程的支持。\n\n\n* listener.c文件。封装对监听socket的操作，包括监听连接与接收连接。\n\n\n* logs.c文件。libevent的日志系统。\n\n\n* evutil.c、evutil_rand.c、strlcpy.c与arc4random.c文件。提供一些基本操作，如生成随机数、获取socket地址信息、读取文件、设置socket属性等。\n\n\n* evdns.c、http.c与evrpc.c。分别提供对DNS协议、HTTP协议、RPC协议的支持。\n","tags":["网络编程"],"categories":["course"]},{"title":"第八章第二节 初识libevent","url":"/course/np-ch8-par2.html","content":"\n## libevent简介\n\n[Libevent官方网站](https://libevent.org/)\n\n高性能分布式内存对象缓存软件memcached、Google Chromium Linux版等均使用Libevent作为I/O框架库。\n\nlibevent具有的特点：(1)跨平台；(2)统一事件源；(3)线程安全；(4)基于Reactor模式的实现。\n\n基于centos7(建议)安装libevent-2.1.8版本。安装步骤如下。\n\n```bash\ninstall_build_essential(){\n    yum install -y make \n    yum install -y automake\n    yum install -y gcc\n    yum install -y gcc-c++\n    yum install -y kernel-devel\n    yum install -y libtool\n}\n\ninstall_libevent(){\n    tar -zxvf libevent-2.1.8-stable.tar.gz\n    mv libevent-2.1.8-stable /usr/local/lib/libevent-2_1_8-stable\n    /usr/local/lib/libevent-2_1_8-stable/autogen.sh\n    /usr/local/lib/libevent-2_1_8-stable/configure\n    make -I /usr/local/lib/libevent-2_1_8-stable/\n    make install -I /usr/local/lib/libevent-2_1_8-stable/\n    make clean -I /usr/local/lib/libevent-2_1_8-stable/\n    cp /usr/local/lib/libevent-2.1.so.6 /usr/lib64/\n}\n\ninstall_build_essential\ninstall_libevent\n```\n\n注：对于使用了libevent框架库的源代码，使用gcc编译时要加上-levent选项。\n\n## libevent主要函数\n\n### event_init\n\n创建event_base对象；一个event_base对象可视为一个Reactor实例；\n\n### ev*_new系列函数\n创建相应事件的事件处理器；evsignal_new创建信号事件处理器；evtimer_new创建定时事件处理器；ev*_new系列函数定义在libevent源码的include/event2/event.h文件中。\n\n```c\n#define evsignal_new(b, x, cb, arg)                             \\\n         event_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))\n\n #define evtimer_new(b, cb, arg)        event_new((b), -1, 0, (cb), (arg))\n```\n\n由此可知，ev*_new系列函数统一调用event_new函数，而event_new函数即用来创建通用事件处理器。event_new函数定义如下。\n\n```c\n/*\n    引用方式: #include <event.h>\n    base: 创建的事件处理器从属的Reactor\n    fd: 与该事件处理器关联的句柄; 对I/O事件: 文件描述符 || 对信号事件: 信号值 || 对定时事件: -1\n    events: 指定事件类型; EV_TIMEOUT: 定时事件 || EV_READ: 可读事件 || EV_WRITE: 可写事件 || EV_SIGNAL: 信号事件 || EV_PERSIST: 永久事件 || EV_ET: 边沿触发事件\n    cb: 回调函数\n    arg: 传递给cb函数的参数\n    返回值: event对象(即事件处理器)\n*/\nstruct event * event_new(struct event_base * base, int fd, short events, event_callback_fn cb, void * arg);\n```\n\n事件由多路分发器管理，事件处理器则由事件队列管理。事件队列有多种：event_base中的注册事件队列、活动事件队列、通用定时器队列、evmap中的I/O事件队列、信号事件队列。\n\n### event_add函数\n\n将事件处理器添加到注册事件队列中，并将该事件处理器对应的事件添加到事件多路分发器中。\n\n### event_base_dispatch函数\n\n执行事件循环。\n\n### event*_free系列函数\n\nevent_free释放event对象；event_base_free释放event_base对象。\n","tags":["网络编程"],"categories":["course"]},{"title":"第八章第一节 I/O框架库概述","url":"/course/np-ch8-par1.html","content":"\n## 前言\n\n前面三章详细地介绍了Linux服务器程序必须处理的三类事件：I/O事件、信号、定时事件；在处理这三类事件时网络程序要考虑如下三个问题。\n\n* 统一事件源。\n* 可移植性。不同的操作系统具有不同的I/O复用方式；Solaris采用/dev/poll文件、FreeBSD采用kqueue机制、Linux采用epoll系列系统调用；\n* 并发。在多进程/线程环境下，网络程序需要考虑各执行实体如何协同处理客户连接、信号与定时器；\n\n开源社区提供了诸多优秀的I/O框架库——ACE、ASIO与Libevent。下面介绍相对轻量级的Libevent框架库。\n\n## I/O框架库概述\n\nI/O框架库一库函数的形式，封装了较为底层的系统调用，想应用程序提供一组更便于使用的接口。这些库函数经受住了真实网络环境下的高压测试，以及时间的考验。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 37.png pic37 %}</div>\n\n&nbsp;\n\n### 句柄Handle\n\nI/O框架库处理的对象(I/O事件，信号与定时事件)统一称为事件源。一个事件源绑定一个句柄；例如，在Linux环境下，I/O事件对应的句柄是文件描述符，信号事件对应的句柄是信号值。\n\n### 事件多路分发器\n\nI/O框架库将系统支持的各种I/O复用系统调用封装成统一的接口——事件多路分发器EventDemultiplexer。事件多路分发器的demultiplex方法是等待事件的核心函数，其内部调用的是select、poll、epoll_wait等函数。\n\n此外，事件多路分发器还需要实现register_event与remove_event方法，以便应用程序向事件多路分发器添加事件与删除事件。\n\n### (具体)事件处理器\n\n事件处理器执行事件对应的业务逻辑，它通常包含一个或多个handle_event回调函数。I/O框架库提供的事件处理器只是一个接口，应用程序需要继承该接口来实现具体的事件处理器，即具体事件处理器。\n\n此外，事件处理器还提供get_handle方法，它返回与该事件处理器关联的句柄。\n\n### Reactor\n\nReactor是I/O框架库的核心。它提供如下几个方法。\n\n* handle_events。handle_events方法执行事件循环，重复如下过程：等待事件，然后依次处理所有就绪事件对应的事件处理器；\n* register_handler。register_handler方法调用事件多路分发器的register_event方法来向事件多路分发器中注册一个事件；\n* remove_handler。remove_handler方法调用事件多路分发器的remove_event方法来删除事件多路分发器中的一个事件；\n\n## 小结\n\nI/O框架库的工作时序图如下。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 38.png pic38 %}</div>\n","tags":["网络编程"],"categories":["course"]},{"title":"第七章第二节 时间轮与时间堆","url":"/course/np-ch7-par2.html","content":"\n## 时间轮\n\n一层的简单时间轮如下图所示。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 35.png pic35 %}</div>\n\n&nbsp;\n\n实线指针指向轮子上的一个槽，，它以恒定的速度顺时针转动，每隔si时间转动一槽。记时间轮的槽数为N，则指针运转一周的时间为`N·si`。每个槽指向一个定时器链表，每个链表上的定时器的定时时间在模`N·si`下一致。\n\n因此，如果需要添加一个(相对)定时时间为ti的定时器，而此时指针指向槽cs，则该定时器将被插入槽`(cs+(ti/si)) mod N`对应的链表中。\n\n时间轮采用了哈希表的思想，将定时器散列到不同的链表上，使得不同链表上的定时器数量均很少，从而定时器的插入操作更快。\n\n可以看出，si值越小，定时精度越高；N值越大，执行效率越高。\n\n### 分层时间轮\n\n在设计时间轮时，如果遇到不同周期触发的定时事件，只使用一个时间轮的话会导致很多槽对应的定时器链表为空，从而降低时间轮的效率，更好的办法是采用分层时间轮。\n\n分层时间轮是这样一种思想：(1)凡是任务列表中应该被执行的，全部取出来执行；(2)每个时间粒度对应一个时间轮，多个时间轮之间进行级联协作。\n\n**下面举例说明**\n\n任务一：每天2点；任务二：每周二8点；任务三：每月12日10点；各任务的时间粒度分别为天、周、月，因此设计三个时间轮——天轮、周轮、月轮；如下图所示。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 36.png pic36 %}</div>\n\n&nbsp;\n\n初始添加任务时，将任务一添加到天轮、任务二添加到周轮、任务三添加到月轮；\n\n那么，当周轮的指针转到2时，将任务二复制到天轮，天轮接管该任务，当指针转到8时执行(执行后要删除该任务)；当月轮的指针转到12时，将任务三复制到天轮，天轮接管该任务，当指针转到10时执行(执行后要删除该任务)；\n\n## 时间堆\n\n时间堆的思路是：将所有定时器中定时最近的定时器的超时值作为超时时间。一旦超时，必然是超时时间最小的定时器到期，从而处理该定时器的超时事件。\n\n然后，再从剩余的定时器中找出定时最近的定时器，将其超时值作为超时时间；最小堆正是对这种定时方案的最佳工具。\n\n最小堆是一种完全二叉树，因此可使用数组来组织；对于节点i，其左右子节点分别为2i+1、2i+2，其父节点为[(i-1)/2]。\n\n**参考链接**\n\n[分层时间轮](https://blog.csdn.net/xinzhongtianxia/article/details/86221241)\n","tags":["网络编程"],"categories":["course"]},{"title":"第七章第一节 定时器基础","url":"/course/np-ch7-par1.html","content":"\n## 前言\n\n服务器程序通常管理着众多的定时事件，服务器程序需要有效地组织这些事件，使之能在预期的时间点被触发且不影响服务器的主要逻辑。\n\n为此，服务器程序将每个定时事件封装成定时器，并使用某种容器类数据结构(如链表、排序链表、时间轮)将所有的定时器串联起来以实现对定时事件的统一管理。\n\nLinux提供了三种定时方法：(1)socket选项SO_RCVTIMEO与SO_SNDTIMEO；(2)SIGALRM信号；(3)I/O复用系统调用的超时参数。\n\n## SO_RCVTIMEO与SO_SNDTIMEO选项\n\n其中，SO_RCVTIMEO选项仅对recv、recvmsg、accept这些数据接收系统调用有效；SO_SNDTIMEO选项仅对send、sendmsg、connect这些数据发送系统调用有效。\n\n所有这些数据发送/接收系统调用(除connect)超时后的行为是：返回-1并设置errno为EAGAIN或EWOULDBLOCK；connect超时后的行为是：返回-1并设置errno为EINPROGRESS。\n\n## SIGALRM信号\n\n由alarm/setitimer函数设置的实时闹钟一旦超时，将触发SIGALRM信号。从而可以利用SIGALRM信号的信号处理函数来处理定时任务。若要处理多个定时任务，则要在程序中不断触发SIGALRM信号，然后在SIGALRM的信号处理函数中执行到期的任务。\n\n通常，SIGALRM信号按照固定周期T触发，因此，如果在每次SIGALRM信号触发后去处理到期的事件，那么该事件的实际处理时间与理想处理时间(即事件到期后立即处理)会存在误差，而这个误差不会超过T。可见定时周期T也反映了定时处理的精度。\n\n## I/O复用系统调用的超时参数\n\n三组I/O复用系统调用的超时参数也能用于处理定时事件。由于I/O事件的到来也会导致I/O复用系统调用返回，而此时超时时间可能并未到期，因此程序需要不断更新定时参数以反映剩余的时间。\n","tags":["网络编程"],"categories":["course"]},{"title":"第六章第四节 网络编程相关信号","url":"/course/np-ch6-par4.html","content":"\n## SIGHUP\n\n当挂起进程的控制终端时，SIGHUP信号将被触发。对于没有控制终端的网络后台程序而言，它们通常利用SIGHUP信号来强制服务器重读配置文件。\n\n以xinetd为例，xinetd程序在接收到SIGHUP信号之后将调用hard_reconfig函数；它循环读取/etc/xinetd.d目录下所有的子配置文件，并检测其变化。\n\n具体来说，若某个正在运行的子服务的配置文件被修改以停止服务，则xinetd主进程将向该子服务进程发送SIGTERM信号来结束该子服务；若某个正在运行的子服务的配置文件被修改以开启服务，则xinetd主进程将开启新的socket并将其绑定到该子服务对应的端口上。\n\n## SIGPIPE\n\n默认情况下，向一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号。由于程序接收到SIGPIPE信号的默认行为是结束进程，因此必须在程序中捕获并处理SIGPIPE信号，即使只是忽略它。\n\n首先，程序应该禁止写操作触发SIGPIPE信号(send函数的flag设置为MSG_NOSIGNAL)，然后再使用send函数反馈的errno的值是否为EPIPE来判断管道或者socket连接的读端是否已经关闭。\n\n此外，程序还可以通过I/O复用系统调用来检测管道或socket连接的读端是否已经关闭。如使用poll系统调用监听时，当管道的读端关闭时，写端文件描述符上的POLLHUP事件将被触发；当socket连接被对方关闭时，socket上的POLLRDHUP事件将被触发。\n\n## SIGURG\n\n在Linux环境下，内核通知应用程序带外数据到达主要有两种方法：(1)使用I/O复用技术，select系统调用在接收带外数据时将返回，并向应用程序报告socket上的异常事件；(2)使用SIGURG信号。\n","tags":["网络编程"],"categories":["course"]},{"title":"第六章第三节 信号集","url":"/course/np-ch6-par3.html","content":"\n## 信号集函数\n\n__sigset_t类型定义如下。\n\n```c\n/*\n    引用方式: #include <bits/sigset.h>\n*/\ntypedef struct{\n    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];\n}__sigset_t;\n```\n\n__sigset_t实际是一个长整型数组，其中每个元素的每一位表示一个信号。Linux提供了一组函数来设置、修改、删除与查询信号集。\n\n```c\n/*\n    引用方式: #include <signal.h>\n    sigemptyset: 清空信号集\n    sigfillset: 在信号集中设置所有信号\n    sigaddset: 将信号signo添加到信号集中\n    sigdelset: 将信号signo从信号集中删除\n    sigismember: 测试signo是否在信号集中\n*/\nint sigemptyset(__sigset_t * set);\n\nint sigfillset(__sigset_t * set);\n\nint sigaddset(__sigset_t * set, int signo);\n\nint sigdelset(__sigset_t * set, int signo);\n\nint sigismember(const __sigset_t * set, int signo);\n```\n\n## 进程信号掩码\n\n若要单独设置进程的信号掩码，使用sigprocmask函数(也能查看进程的信号掩码)；\n\n```c\n/*\n    引用方式: #include <signal.h>\n    how: 指定设置进程信号掩码的方式(详见下表)\n    set: 指定新的信号掩码\n    oset: 存放进程原有信号掩码\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint sigprocmask(int how, const __sigset_t * set, __sigset_t * oset);\n```\n\n<div style=\"width:70%;margin:auto\">{% asset_img 34.png pic34 %}</div>\n\n## 被挂起的信号\n\n若其他进程向本进程发送一个被本进程屏蔽的信号，则操作系统将该信号设置为本进程的一个被挂起的信号。当本进程取消对被挂起信号的屏蔽后，它会立即被本进程接收，使用sigpending函数获得本进程当前被挂起的信号集。\n\n```c\n/*\n    引用方式: #include <signal.h>\n    set: 存放被挂起的信号集(即使某个信号向进程发送了多次，sigpending也只能反应一次, 相应的信号处理函数也只会触发一次)\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint sigpending(__sigset_t * set);\n```\n\n注：编写网络程序时，不能设想新创建的进程/线程具有与父进程完全相同的信号特征；如fork调用产生的子进程将继承父进程的信号掩码，但子进程的挂起信号集为空！\n\n## 统一事件源\n\n信号作为一种异步事件，使得信号处理函数与网络程序的主循环是两条不同的执行路线。为避免信号在信号处理函数执行过程中被屏蔽太久，一种典型的解决方案是：将信号的主要处理逻辑放到网络程序的主循环中，被触发的信号处理函数只是简单地通知主循环程序接收的信号；主循环程序再根据接收到的信号值执行信号对应的逻辑代码。\n\n信号处理函数通常使用管道将信号通知给主循环，主循环使用I/O复用系统调用进行监听管道读端文件的可读事件。\n\n由于这种处理方式使得信号事件能够和其他I/O事件一样被处理，因此称为统一事件源。\n","tags":["网络编程"],"categories":["course"]},{"title":"第六章第二节 信号函数","url":"/course/np-ch6-par2.html","content":"\n## signal系统调用\n\n使用signal函数为一个信号设置处理函数。\n\n```c\n/*\n    引用方式: #include <signal.h>\n    sig: 指定要捕获的信号类型\n    _handler: 指定信号sig的处理函数\n    返回_sighandler_t类型的函数指针或sig信号对应的默认处理函数指针SIG_DEF: 成功 || 返回SIG_ERR并设置errno: 失败\n*/\n_sighandler_t signal(int sig, _sighandler_t _handler);\n```\n\n## sigaction系统调用\n\n设置信号处理函数的更健壮的接口是sigaction系统调用。\n\n```c\n/*\n    引用方式: #include <signal.h>\n    sig: 指定要捕获的信号类型\n    act: 指定新的信号处理方式\n    oact: 存入之前信号的处理方式\n*/\nint sigaction(int sig, const struct sigaction * act, struct sigaction * oact);\n```\n\nsigaction结构体描述信号处理的细节，其定义如下。\n\n```c\nstruct sigaction{\n    union{\n        __sighandler_t sa_handler;\n        void (*sa_sigaction) (int, siginfo_t *, void *);\n    }__sigaction_handler;\n    __sigset_t sa_mask;\n    int sa_flags;\n    void (*sa_restorer) (void);\n};\n```\n\n* sa_handler。指定信号处理函数；\n* sa_mask。信号集类型参数(详见下一节)；设置进程的信号掩码(在进程原有信号掩码的基础上增加)，以指定哪些信号不能发送给本进程；\n* sa_flags。设置程序收到信号时的行为；可选值如下表所示。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 33.png pic33 %}</div>\n","tags":["网络编程"],"categories":["course"]},{"title":"第六章第一节 Linux信号概述","url":"/course/np-ch6-par1.html","content":"\n信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。Linux信号可在如下情形产生。\n\n* 对于前台进程，用户可通过输入特殊的终端字符来向其发送信号；\n* 系统异常(浮点异常，非法内存段访问等)；\n* 系统状态变化(如alarm定时器到期将引起SIGALRM信号)；\n* 运行kill命令或调用kill函数；\n\n## 发送信号\n\n在Linux系统中，一个进程向其他进程发送信号的API为kill函数。\n\n```c\n/*\n    引用方式: #include <signal.h>\n    返回0: 成功 || 返回-1并设置errno: 失败; EINVAL: 无效的信号 || EPERM: 该进程没有权限发信号给任何一个目标进程 || ESRCH: 目标进程或进程组不存在\n*/\nint kill(pid_t pid, int sig);\n```\n\n目标进程由pid参数指定，它可能的取值及其含义如下表。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 29.png pic29 %}</div>\n\n&nbsp;\n\nLinux定义的信号值都大于0，如果sig取值为0，则kill函数不发送任何信号，但将sig设置为0可以用来检测目标进程或进程组是否存在。不过这种检测方式不可靠：(1)由于进程PID的回绕，可能导致被检测的PID不是我们期望的进程的PID；(2)这种检测方法不是原子操作。\n\n## 信号处理方式\n\n目标进程需要定义相应的信号处理函数以便在接收到信号后作出相应的处理。信号处理函数的原型如下。\n\n```c\n/*\n    引用方式: #include <signal.h>\n    int参数: 指定信号类型\n*/\ntypedef void (* __sighandle_t)(int);\n```\n\n信号处理函数必须可重入，因此信号处理函数严禁调用不安全的函数。\n\nbits/signum.h还定义了信号的两种其他处理方式：SIG_IGN(忽略目标信号)与SIG_DFL(信号的默认处理方式)。信号的默认处理方式有几种：Term(结束进程)、Ign(忽略信号)、Core(结束进程并生成核心转储文件)、Stop(暂停进程)与Cont(继续进程)。\n\n## Linux信号\n\nLinux的可用信号都定义在bits/signum.h中，其中包括标准信号与POSIX实时信号。Linux标准信号如下表。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 30.png pic30 %}</div>\n\n<div style=\"width:80%;margin:auto\">{% asset_img 31.png pic31 %}</div>\n\n<div style=\"width:80%;margin:auto\">{% asset_img 32.png pic32 %}</div>\n\n&nbsp;\n\n**重点关注**：SIGHUP(控制终端挂起)、SIGPIPE(向读端被关闭的管道或socket连接中写数据)、SIGURG(socket连接上接收到紧急数据)、SIGALRM(由alarm、settimer设置的实时闹钟超时引起)、SIGCHLD(子进程状态发生变化，退出或暂停)。\n\n## 关于中断系统调用\n\n若程序在执行处于阻塞状态的系统调用时接收到信号，并且我们为信号设置了信号处理函数，则默认情况下系统调用将被中断，并将errno设置为EINTR。程序可以使用sigaction函数为信号设置SA_RESTART标志自动重启被中断的系统调用。\n\n对于默认行为是暂停进程的信号(SIGSTOP、SIGTTIN)，若程序未设置相应的信号处理函数，这些信号仍然可以中断一些系统调用(connect、epoll_wait)。这是Linux所特有的。\n","tags":["网络编程"],"categories":["course"]},{"title":"第五章第六节 超级服务xinetd","url":"/course/np-ch5-par6.html","content":"\nLinux因特网服务inetd是超级服务，它同时管理多个子服务，即监听多个端口。现在的Linux系统使用其升级版本xinetd，相对于inetd增加了一些控制选项，并提高了安全性。\n\n## xinetd配置文件\n\n主配置文件：/etc/xinetd.conf，各服务的子配置文件：/etc/xinetd.d/目录的相应子目录下；主配置文件包含通用选项、这些选项被所有的子配置文件继承。不过子配置文件可以覆盖这些选项，如下是telnet服务的配置文件内容示例。\n\n```bash\nservice telnet\n{\n        disable         = no\n        user            = root\n        id              = daytime-stream\n        wait            = no\n        socket_type     = stream\n        server          = /usr/sbin/in.telnetd\n        log_on_failure  += USERID\n}\n```\n\n其中，wait指定服务是采用单线程(yes)还是多线程(no)，单线程表示xinetd只接收第一次连接，此后将由子服务进程来接收新连接；多线程表示xinetd一直负责接收连接，而子服务进程仅处理连接socket上的数据读写。\n\nlog_on_failure指定当服务不能启动时输出日志的参数。\n\n## xinetd工作流程\n\n以上述xinetd配置为例，xinetd的工作流程如下所示。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 28.png pic28 %}</div>\n\n&nbsp;\n","tags":["网络编程"],"categories":["course"]},{"title":"第五章第五节 I/O复用高级应用","url":"/course/np-ch5-par5.html","content":"\n## 非阻塞connect\n\nconnect出错时会出现的一种errno值：EINPROGRESS；这种错误发生在对非阻塞的socket调用connect，而连接又没有立即建立时。\n\n此时，网络程序可以调用select、poll函数来监听这个连接失败的socket上的可写事件。当I/O复用函数返回后，再利用getsockopt来读取并清除该socket的错误；若错误的值为0，表示连接成功；否则，连接失败。\n\n## 聊天室\n\n一些网络服务如ssh需要同时处理网络连接与用户输入，这可以使用I/O复用来实现。\n\n对于聊天室服务，由两部分组成：客户端与服务器；客户端负责：(1)从标准输入终端读入用户数据，并将用户数据发送到服务器；(2)将服务器发送过来的数据打印到标准输出终端；服务器则负责接收用户数据，并将该数据发送给除数据发送者之外的所有在线客户端。\n\n### 客户端\n\n客户端使用poll同时监听用户输入与网络连接，并利用splice函数将用户输入内容直接定向到网络连接然后将其发送(数据零拷贝，提高程序执行效率)。\n\n### 服务器\n\n服务器使用poll同时管理监听socket与连接socket。\n\n`计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决`\n\n## 同时处理TCP与UDP服务\n\n创建一个流socket(TCP服务)与数据包socket(UDP服务)，均绑定到某一端口。使用I/O复用技术，就能同时监听该端口的TCP服务与UDP服务。\n","tags":["网络编程"],"categories":["course"]},{"title":"第五章第四节 三组I/O复用函数的比较","url":"/course/np-ch5-par4.html","content":"\n## 事件集\n\nselect的事件集由3个fd_set数组指定；fd_set数组在调用select时传入，select调用返回后被内核修改。\n\npoll的事件集由pollfd结构体数组指定，它绑定了文件描述符与事件；pollfd结构体的event成员传入网络程序关注的事件，poll调用返回后修改pollfd结构体的revent成员。\n\nepoll的事件通过epoll_ctl函数进行添加、修改与删除，epoll_wait调用返回的事件存入event数组。\n\n## 最大支持文件描述符数\n\npoll与epoll_wait函数最多可监听65535个文件描述符；而select最多可监听1024个文件描述符。\n\n## 工作模式\n\nselect与poll只能工作在相对低效的LT模式；而epoll则可以工作在ET高效模式，且epoll还支持EPOLLONESHOT事件，该事件可进一步减少可读/可写/异常事件被触发的次数。\n\n## 具体实现\n\nselect与poll均采用轮询的实现方式，每次调用都要扫描整个注册文件描述符集合；\n\n而epoll_wait采用回调的方式，内核检测到就绪的文件描述符后触发回调函数，回调函数将该文件描述符上对应事件插入内核就绪事件队列，内核最后在合适的时机将该就绪事件队列中的内容拷贝到用户空间。\n\n然而，在活动连接较多时，epoll_wait将会频繁触发回调函数，此时epoll_wait的效率不一定比select/poll高。可见epoll_wait适用于连接数量多，但活动连接少的情形。\n\n## 小结\n\n这3组I/O复用系统调用的区别如下表总结。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 27.png pic27 %}</div>\n","tags":["网络编程"],"categories":["course"]},{"title":"第五章第三节 epoll系列系统调用","url":"/course/np-ch5-par3.html","content":"\n## 内核事件表\n\nepoll是Linux特有的I/O复用函数，epoll使用一组函数来完成任务。epoll将用户关心的文件描述符上的事件放在内核的事件表中，此时epoll需要使用一个额外的文件描述符来唯一标识内核中的这个事件表。该文件描述符由epoll_create函数来创建。\n\n```c\n/*\n    引用方式: #include <sys/epoll.h>\n    size: 告知内核事件表需要多大\n    返回文件描述符: 成功 || 返回-1并设置errno: 失败\n*/\nint epoll_create(int size);\n```\n\n此函数的返回文件描述符用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表。\n\n下面的函数来操作epoll的内核事件表。\n\n```c\n/*\n    引用方式: #include <sys/epoll.h>\n    op: 指定操作类型; EPOLL_CTL_ADD(向事件表中注册fd上的事件) || EPOLL_CTL_MOD(修改fd上的注册事件) || EPOLL_CTL_DEL(删除fd上的注册事件)\n    fd: 要操作的文件描述符\n    event: 指定事件\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event * event);\n```\n\n其中，epoll_event结构体定义如下。\n\n```c\nstruct epoll_event{\n  uint32_t events;\n  epoll_data_t data;\n};\n```\n\n* events成员指定事件类型；epoll支持的事件类型与poll基本相同，表示epoll事件类型的宏是在poll对应的宏前面加\"E\"，如epoll的可读事件类型的宏为EPOLLIN。此外，epoll有两个额外事件类型：EPOLLET与EPOLLONESHOT(它们对epoll的高效运作非常关键，将在之后详细介绍)。\n* data存储用户数据；epoll_data_t结构体的定义如下。\n\n```c\ntypedef union epoll_data{\n  void *ptr;\n  int fd;\n  uint32_t u32;\n  uint64_t u64;\n} epoll_data_t;\n```\n\nepoll_data_t结构体是一个联合体。如果使用fd，则指定事件所从属的文件描述符；如果使用ptr，则指定与fd有关的用户数据。若要同时使用ptr与fd，可考虑在ptr指定的用户数据内包含fd。\n\n## epoll_wait函数\n\nepoll_wait函数在一段超时时间内等待一组文件描述符上的事件。\n\n```c\n/*\n    引用方式: #include <sys/epoll.h>\n    events: 用于存放内核事件表中的就绪事件\n    maxevents: 指定监听事件的数目最大值\n    timeout: 以毫秒为单位的超时值, timeout=-1: epoll_wait调用一直阻塞直到某个事件发生 || timeout=0: epoll_wait调用立即返回\n    返回就绪文件描述符总数: 成功 || 返回-1并设置errno: 失败\n*/\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n```\n\n由于epoll在内核中维护一个事件表，每次epoll_wait调用都直接从内核事件表中取得用户注册的事件，而无需反复从用户空间读入这些事件；同时epoll_wait函数仅将事件就绪的文件描述符存入events数组中，从而网络程序索引就绪的文件描述符的时间复杂度为O(1)。\n\n## LT与ET模式\n\nepoll对文件描述符的操作有两种模式：LT(电平触发)模式与ET(边沿触发)模式。\n\nLT模式是默认的工作模式，LT模式下的epoll相当于一个效率较高的poll。\n\n注：很多时候网络程序调用完select/poll/epoll_wait都会处理就绪的文件描述符，这时使用select/poll的网络程序需要遍历所有的文件描述符再进行相应的判断操作(对于select：使用FD_ISSET函数；对于poll，将`(fds+i)->revents`与POLLIN按位与)，而epoll_wait可以直接遍历就绪的文件描述符。\n\n网络程序向epoll内核事件表注册一个文件描述符上的EPOLLET事件后，epoll将以ET模式来操作该文件描述符。ET模式是epoll的高效工作模式。\n\n### LT模式\n\n对于采用LT模式的文件描述符，当epoll_wait函数检测到该文件描述符上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件；当应用程序下次调用epoll_wait时，epoll_wait还会再次向应用程序通知此事件，直到此事件被处理。\n\n### ET模式\n\nET模式只支持非阻塞的socket文件。\n\n注：如果文件描述符是阻塞的，那么读或写操作将会因为没有后续事件而一直处于阻塞状态\n\n当epoll_wait函数检测到该文件描述符上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件！\n\n注：在这个套接字中新的事件到来之前，网络程序都无法再从epoll_wait中获取该事件。因此这次必须处理完该事件。\n\nET模式在很多程度上降低了一个epoll事件被重复触发的次数，因此效率要高于LT模式。\n\n## EPOLLONESHOT事件\n\n若希望一个socket连接在任一时刻最多被一个线程处理，可向socket文件描述符注册EPOLLONESHOT事件。\n\n对于注册了EPOLLONESHOT事件的socket文件描述符，操作系统最多触发该文件描述符上注册的一个可读/可写/异常事件，且只触发一次，除非网络程序使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件。因此，一个线程处理完注册了EPOLLONESHOT事件的socket文件描述符后，需要重置该文件描述符上注册的EPOLLONESHOT事件。\n","tags":["网络编程"],"categories":["course"]},{"title":"第五章第二节 poll系统调用","url":"/course/np-ch5-par2.html","content":"\npoll系统调用与select系统调用类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。\n\n```c\n/*\n    引用方式: #include <poll.h>\n    fds: pollfd结构体数组, 指定程序感兴趣的所有文件描述符上发生的可读/可写/异常事件\n    nfds: 指定fds的大小\n    timeout: 以毫秒为单位的超时值, timeout=-1: poll调用一直阻塞直到某个事件发生 || timeout=0: poll调用立即返回\n    返回就绪文件描述符总数: 成功 || 返回-1并设置errno: 失败\n*/\nint poll(struct pollfd * fds, nfds_t nfds, int timeout);\n```\n\n其中，pollfd结构体的定义如下。\n\n```c\nstruct pollfd{\n    int fd;\n    short int events;\n    short int revents;\n};\n```\n\n其中，fd指定文件描述符，events成员告知poll需要监听fd上哪些事件，它是一系列事件的按位或。\n\n<div style=\"width:72%;margin:auto\">{% asset_img 25.png pic25 %}</div>\n\n<div style=\"width:72%;margin:auto\">{% asset_img 26.png pic26 %}</div>\n\n&nbsp;\n\nrevents成员由内核修改，以通知应用程序fd上实际发生了哪些事件。\n\n自Linux2.6.17内核之后，GNU为poll系统调用增加了一个POLLRDHUP事件，它在socket接收到对方关闭连接的请求后触发，从而区分socket上接收到的数据是有效数据还是对方关闭连接的请求。使用POLLRDHUP事件需要在代码最开始处定义`_GNU_SOURCE`。\n","tags":["网络编程"],"categories":["course"]},{"title":"第五章第一节 select系统调用","url":"/course/np-ch5-par1.html","content":"\n## 前言\n\nI/O复用使得程序同时监听多个文件描述符。通常，网络程序在下列情形下需要使用I/O复用技术。\n\n* 客户端要同时处理多个socket；\n* 客户端要同时处理用户输入与网络连接；\n* TCP服务器要同时处理监听socket与连接socket；\n* 服务器要同时处理TCP请求与UDP请求；\n* 服务器要同时监听多个端口，或处理多个服务；\n\nI/O复用虽然同时监听多个文件描述符，但它本身是阻塞的。\n\n## select系统调用\n\n在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写与异常等事件。select系统调用原型如下。\n\n```c\n/*\n    引用方式: #include <sys/select.h>\n    nfds: 被监听的文件描述符总数\n    rfds: 调用select时指定网络程序关注可读事件的文件描述符; select返回时内核将其修改以通知网络程序可读事件就绪的文件描述符\n    wfds: 调用select时指定网络程序关注可写事件的文件描述符; select返回时内核将其修改以通知网络程序可写事件就绪的文件描述符\n    efds: 调用select时指定网络程序关注异常事件的文件描述符; select返回时内核将其修改以通知网络程序异常事件就绪的文件描述符\n    timeout: 调用select函数前设置超时时间 => select返回后由内核设置select函数的超时时间\n    返回就绪文件描述符总数: 成功 || 返回-1并设置errno: 失败\n*/\nint select(int nfds, fd_set * rfds, fd_set * wfds, fd_set * efds, struct timeval * timeout);\n```\n\n其中，fd_set结构体定义如下。\n\n```c\ntypedef struct{\n    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];\n} fd_set;\n```\n\nfd_set是一个__fd_mask数组，数组中每个元素的每一位标记一个文件描述符，因此select能同时处理的文件描述符的总量不能超过1024。可使用如下宏来访问fd_set结构体的位。\n\n```c\n/*\n    #include <sys/select.h>\n    FD_ZERO: 清除fdset所有位\n    FD_SET: 设置fdset的位fd\n    FD_CLR: 清除fdset的位fd\n    FD_ISSET: 测试fdset的fd位是否被设置\n*/\nFD_ZERO(fd_set * fdset);\n\nFD_SET(int fd, fd_set * fdset);\n\nFD_CLR(int fd, fd_set * fdset);\n\nint FD_ISSET(int fd, fd_set * fdset);\n```\n\n此外，timeval结构体定义如下。\n\n```c\nstruct timeval{\n    __time_t tv_sec;/* 秒数 */\n    __suseconds_t tv_usec;/* 微秒数 */\n};\n```\n\n注意：在select调用失败时，timeout的值是不确定的。\n\nselect给我们提供了一个微妙级的定时方式，若向timeout变量的tv_sec成员与tv_usec成员传递0，则select将立即返回。若timeout设置为NULL，则select将一直阻塞直到某个文件描述符就绪。\n\n若程序在select等待期间接收到信号，则select立即返回-1，并设置errno为EINTR。\n\n由于内核修改了3个fd_set，因此网络程序下次调用select之前需要重置这3个fd_set。\n\n### 文件描述符就绪条件\n\n网络编程中，如下情况socket可读。\n\n* socket内核接收缓冲区中的字节数大于等于其低水位标记SO_RCVLOWAT，此时程序可无阻塞地读这个socket，读操作返回的字节数大于0；\n* socket通信的对方关闭连接，对socket的读操作返回0；\n* 监听socket上有新的连接请求；\n* socket上有未处理的错误，调用getsockopt来读取错误；\n\n如下情况socket可写。\n\n* socket内核发送缓冲区中的空闲字节数大于等于其低水位标记SO_SNDLOWAT，此时程序可无阻塞地写这个socket，写操作返回的字节数大于0；\n* socket写操作被关闭(对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号)；\n* socket使用非阻塞connect连接成功或失败(超时)后；\n* socket上有未处理的错误，调用getsockopt来清除错误；\n\nsocket能处理的异常情况只有一种：socket上接收了带外数据。\n\n### 处理带外数据\n\nsocket接收到普通数据与带外数据都将使select返回，但socket处于不同的就绪状态：前者处于可读状态、后者处于异常状态。\n","tags":["网络编程"],"categories":["course"]},{"title":"第四章第五节 有限状态机与其他建议","url":"/course/np-ch4-par5.html","content":"\n## 有限状态机\n\n有限状态机是逻辑单元内部的一种高效编程方法。\n\n以\"HTTP请求的读取与分析\"来说明有限状态机的使用。\n\n### 背景\n\n很多网络协议的头部都是固定格式再加上位于末尾的选项字段，通过头部中的长度字段就可以完全地解析头部数据；但是，HTTP协议的头部长度变化非常大，并且头部中没有长度字段，这时就需要借助有限状态机来解析HTTP报文。解析程序使用两个有限状态机(主状态机与从属状态机)来完成HTTP报文的解析工作。\n\n### 从属状态机\n\n从属状态机的工作是解析一行的内容，从属状态机的状态转移图如下所示。\n\n<div style=\"width:48%;margin:auto\">{% asset_img 23.png pic23 %}</div>\n\n&nbsp;\n\n### 主状态机\n\n主状态机调用从属状态机与两个解析器来解析HTTP报文，主状态机的状态转移图如下所示。\n\n<div style=\"width:36%;margin:auto\">{% asset_img 24.png pic24 %}</div>\n\n&nbsp;\n\n## 提高服务器性能的几条建议\n\n### 池\n\n以空间换时间，“浪费”服务器的硬件资源以换取其运行效率。池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。服务器进入运行状态后，如果它需要相应的资源，就直接从池中获取，无需动态分配。\n\n常见的池有内存池、进程池、线程池、连接池。其中，连接池用于服务器或服务器机群的内部永久连接。比如，服务器预先与数据库程序建立的连接放到连接池中，当服务器的逻辑单元需要访问数据库时，它可以直接从连接池中取得一个连接的实体来使用。完成数据库的访问之后，再归还该连接。\n\n### 数据复制\n\n高性能服务器要避免不必要的数据复制，尤其当数据复制发生在用户空间与内核空间之间时。比如内核可直接处理从socket或文件读入的数据时，则应用程序无需将这些数据从内核缓冲区复制到应用程序缓冲区。\n\n此外，用户空间之间的数据复制也可以避免：使用共享内存而避免使用管道/消息队列。\n\n### 上下文切换与锁\n\n进程/线程切换要耗费大量CPU时间，最好不要为每个客户连接都创建一个工作线程；高效的半同步/半异步工作模式要比半同步/半异步工作模式的效率高。多线程服务器的一个优点是不同线程可运行在不同CPU上，当线程数目小于CPU数目时，就不存在上下文切换的问题。\n\n服务器如果有更好的选择，应避免使用锁。\n","tags":["网络编程"],"categories":["course"]},{"title":"第四章第四节 高效并发模式","url":"/course/np-ch4-par4.html","content":"\n并发模式是指I/O处理单元与多个逻辑单元之间协调完成任务的方法。\n\n## 半同步/半异步模式\n\n在并发模式中，\"同步\"指程序完全按照代码序列的顺序执行，\"异步\"指程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。\n\n在半同步/半异步模式中，同步线程用于处理客户逻辑，异步线程用于处理I/O事件。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中；请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。\n\n半同步/半异步工作流程图如下。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 19.png pic19 %}</div>\n\n&nbsp;\n\n综合考虑两种事件模式与多种I/O模型，半同步/半异步模式就存在多种变体。\n\n### 半同步/半反应堆\n\n半同步/半反应堆模式图如下，采用Reactor模式。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 20.png pic20 %}</div>\n\n&nbsp;\n\n只有一个异步线程，即主线程；主线程负责监听所有socket上的事件，若监听socket上有可读事件发生(即新的连接请求到来)，主线程将其接受从而得到新的连接socket，再向epoll内核事件表中注册该socket上的读写事件。\n\n若连接socket上有读写事件发生(即有新的客户请求到来或有数据发送到客户端)，主线程就将该连接socket插入请求队列；所有工作线程都睡眠在请求队列上，当有任务到来时，它们通过竞争获得任务的接管权；这种竞争机制使得只有空闲的工作线程才有机会来处理新任务。\n\n半同步/半反应堆具有如下缺点：\n\n* 由于主线程与工作线程共享请求队列，因此在主线程向请求队列中添加任务或工作线程从请求队列中取出任务时都需要对请求队列进行加锁保护，从而浪费CPU时间；\n* 每个工作线程在同一时间只能处理一个客户请求。在客户数量很多时将使得服务器的响应速度变慢；而增加工作线程导致的线程切换又会耗费大量的CPU时间；\n\n### 高效的半同步/半异步模式\n\n为避免半同步/半反应堆的缺点，如下的高效半同步/半异步模式让每个工作线程都能同时处理多个客户连接。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 21.png pic21 %}</div>\n\n&nbsp;\n\n其中，主线程只管监听socket，而连接socket的工作由工作线程来完成。当有新的连接到来时，主线程就将其接受并将新返回的连接socket分配给某个工作线程，此后该socket上的所有I/O操作均由工作线程来完成，直到客户端关闭连接。\n\n主线程向工作线程分配socket最简单的方式为主线程向它与工作线程之间的管道中写数据；工作线程检测到管道中有数据可读时，就分析是否为一个新的客户连接请求，如果是就将此新的socket上的读写事件注册到自己的epoll内核事件表中。\n\n因此，这种高效的半同步/半异步模式中，所有的线程都工作在异步模式。\n\n## 领导者/追随者模式\n\n领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分配并处理事件的一种模式。\n\n在任意时刻，服务器都只有一个领导者线程，它负责监听I/O事件；其他线程均为追随者，它们忙于处理I/O事件或休眠在线程池中等待成为新的领导者。\n\n当前领导者检测到I/O事件后从线程池中推选出新的领导者线程，然后它去处理I/O事件；以此来实现并发。\n\n要实现领导者/追随者模式需要如下组件：句柄集(HandleSet)，线程集(ThreadSet)，事件处理器(EventHandle)以及具体的事件处理器(ConcreteEventHandle)。\n\n### 句柄集\n\n句柄(Handle)表示I/O资源，句柄集管理众多句柄，它使用wait_for_event方法来监听这些句柄上的I/O事件，并将其中的就绪事件通知给领导者线程。领导者调用绑定到Handle上的事件处理器来处理事件。Handle与事件处理器的绑定是通过调用句柄集中的register_handle方法实现的。\n\n### 线程集\n\n线程集是所有工作线程的管理者。它负责各线程之间的同步，以及新领导者线程的推选。线程集中的线程必处于如下三种状态之一：\n\n* Leader：领导者线程，负责等待句柄集上的I/O事件；\n* Processing：线程正在处理事件；领导者检测到I/O事件后，可以转移到Processing状态来处理该事件，并调用promote_new_leader方法推选新的领导者，也可以指定其他追随者来处理事件，此时领导者地位不变；处于processing状态的线程处理完事件之后，若当前线程集中没有领导者，该线程将成为领导者，否则成为追随者；\n* Follower：线程当前处于追随者身份，通过调用线程集的join方法等待成为新的领导者，也可能被当前的领导者指定来处理新的任务；\n\n注意到领导者线程推选出新的领导者和追随者等待成为新领导者这两个操作都将修改线程集，因此线程集提供一个成员Synchronizer来同步这两个操作，以避免竞态条件。\n\n### 事件处理器与具体的事件处理器\n\n事件处理器通常包含一个或多个回调函数handle_event，这些回调函数用于处理事件对应的业务逻辑。事件处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器中的回调函数。具体的事件处理器是事件处理器的派生类，它需要重新实现基类的handle_event方法，以处理特定的任务。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 22.png pic22 %}</div>\n\n&nbsp;\n\n领导者线程自己监听I/O事件并处理客户请求，因此领导者/追随者模式不需要在线程之间传递任何额外的数据，也无需像半同步/半反应堆模式那样在线程之间同步对请求队列的访问。\n\n但是领导者/追随者模式只支持一个事件源集合，无法让每个工作线程独立地管理多个客户连接。","tags":["网络编程"],"categories":["course"]},{"title":"第四章第三节 高效事件处理模式","url":"/course/np-ch4-par3.html","content":"\n## Reactor模式\n\n主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，检测到事件后立即将该事件通知工作线程(逻辑单元)；读写数据、接受新的连接、处理客户请求均在工作线程中完成。\n\n以epoll_wait为例，说明使用同步I/O模型实现的Reactor模式。\n\n* 主线程向epool内核事件表中注册socket读就绪事件；\n* 主线程调用eploo_wait等待socket上有数据可读；\n* 当socket上有数据可读时，epoll_wait通知主线程。主线程将socket可读事件放入请求队列；\n* 睡眠在请求队列上的某个工作线程被唤醒，它从socket中读取数据，并处理客户请求，再向epoll内核事件表中注册该socket上的写就绪事件；\n* 主线程调用eploo_wait等待socket可写；\n* 当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列；\n* 睡眠在请求队列上的某个工作线程被唤醒，它往socket中写入服务器处理客户请求的结果；\n\nReactor模式工作流程图如下。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n## Proactor模式\n\nProactor模式将所有I/O操作都交给主线程与内核来处理，工作线程仅仅负责业务逻辑。\n\n以aio_read与aio_write为例，说明使用异步I/O模型实现的Proactor模式。\n\n* 主线程调用aio_read函数向内核注册socket读完成事件，并告知内核读缓冲区的位置，以及读操作完成时如何通知应用程序(下面以信号为例，详情参考sigevent)；\n* 主线程继续处理其他逻辑；\n* 当socket中的数据被读入用户缓冲区时，内核将向应用程序发送一个信号，以通知应用程序数据已经可用；\n* 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket写完成事件，并告知内核写缓冲区的位置，以及写操作完成时如何通知应用程序；\n* 主线程继续处理其他逻辑；\n* 当用户缓冲区中的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕；\n* 应用程序预先定义好的信号处理函数选择一个工作线程来完成善后处理；\n\nProactor模式工作流程图如下。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n## 模拟Proactor模式\n\n主线程执行数据读写操作，读写完成后，主线程向工作线程通知这一完成事件。从工作线程的角度看，他们直接获得了数据读写的结果，只需要对读写的结果进行逻辑处理。\n\n以epoll_wait为例，使用同步I/O模型模拟Proactor模式。\n\n* 主线程向epoll事件表中注册socket读就绪事件；\n* 主线程调用epoll_wait等待socket上有数据可读；\n* 当socket上有数据可读时，epoll_wait通知主线程；主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列；\n* 主线程调用epoll_wait等待socket可写；\n* 当socket可写时，epoll_wait通知主线程；主线程向socket写入服务器处理客户请求的结果；\n\n使用同步I/O模型模拟Proactor模式的流程图如下。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 18.png pic18 %}</div>","tags":["网络编程"],"categories":["course"]},{"title":"第四章第二节 服务器编程框架与I/O模型","url":"/course/np-ch4-par2.html","content":"\n## 服务器编程框架\n\n服务器的基本框架如下图。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n各个模块的功能描述如下表。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n<div style=\"width:70%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\n请求队列通常被实现为池的一部分。对于服务器机群而言，请求队列是各台服务器之间预先建立的、静态的、永久的TCP连接。这种TCP连接能够提高服务器之间交换数据的效率，因为它避免了动态建立TCP连接而导致的额外系统开销。\n\n## I/O模型\n\n(非)阻塞的文件描述符为(非)阻塞I/O。socket的基础API中，可能被阻塞的系统调用包括accept、send、recv、connect。\n\n针对非阻塞I/O执行的系统调用总是立即返回，而不论事件是否已经发生。若事件没有立即发生，系统调用返回-1，这与出错情况一样。因此，需要根据errno来区分这两种情况。对accept、send、recv而言，事件未发生时errno通常被设置为EAGAIN或EWOULDBLOCK；对connect而言，errno则被设置为EINPROGRESS。\n\n**显然，只有在事件已经发生的情况下操作非阻塞I/O，才能提高程序的效率**。因此，非阻塞I/O通常要与其他I/O通知机制一起使用，如I/O复用与SIGIO信号。\n\n### I/O复用\n\nI/O复用是最常使用的I/O通知机制。应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数将其中就绪的事件通知给应用程序。\n\nLinux上常用的I/O复用函数有select、poll、epoll_wait；\n\n**I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力**。\n\n### SIGIO信号\n\nSIGIO信号也可以用来报告I/O事件。为目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号。于是，当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发，我们也就可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作。\n\n**阻塞I/O、I/O复用与信号驱动I/O都是I/O同步模型。I/O的读写操作均发生在I/O事件之后，由应用程序来完成**。\n\n### 异步I/O\n\n异步I/O的读写操作总是立即返回(不论I/O是否阻塞)，真正的读写操作已经由内核接管。\n\n**同步I/O向应用程序通知的是I/O就绪事件，而异步I/O向应用程序通知的是I/O完成事件**。\n\n### 小结\n\n上面讨论的几种I/O模型的差异如下表。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 15.png pic15 %}</div>","tags":["网络编程"],"categories":["course"]},{"title":"第四章第一节 服务器模型","url":"/course/np-ch4-par1.html","content":"\n## C/S模型\n\n服务器启动后，首先创建一个或多个监听socket，并调用bind函数将其绑定到服务器感兴趣的端口，再调用listen函数等待客户连接。\n\n服务器稳定运行之后，客户端就可以调用connect函数向服务器发起连接；而客户连接请求是随机到达的异步事件，需要某种I/O模型来监听这一事件。\n\n服务器使用的是I/O复用技术之一select系统调用。当监听到连接请求后，服务器调用accept函数接收它，并分配一个逻辑单元为新的连接服务。逻辑单元可以是新创建的子进程、子线程或其他。\n\n逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。客户端收到请求之后，可以继续发送请求，也可以关闭连接。\n\n如下图是TCP服务器与TCP客户端的一般工作流程。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 10.png pic10 %}</div>\n\n&nbsp;\n\n## P2P模型\n\nP2P模型使每台主机在消耗服务的同时也给别的主机提供服务。为了使主机之间便于发现，实际使用的P2P模型通常带有一个专门的发现服务器。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 11.png pic11 %}</div>","tags":["网络编程"],"categories":["course"]},{"title":"第三章第四节 服务器程序配置","url":"/course/np-ch3-par4.html","content":"\n## 系统资源限制\n\n运行的程序必定会受到系统资源的限制，如物理设备的限制(CPU数量、内存数量等)、系统策略限制(CPU时间)、以及具体实现的限制(文件名的最大长度)。\n\n```c\n/*\n    引用方式: #include <sys/resource.h>\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint getrlimit(int re, struct rlimit * rlim);\n\nint retrlimit(int re, const struct rlimit * rlim);\n```\n\n其中结构体rlimit的定义如下。\n\n```c\nstruct rlimit{\n    rlim_t rlim_cur;//rlim_t可以看作int\n    rlim_t rlim_max;\n}\n```\n\nrlim_cur指定资源的软限制，rlim_max指定资源的硬限制。软限制是一个建议性的、最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其运行。而硬限制一般是软限制的上限，普通程序可以减小硬限制，只有以root身份运行的程序才能增加硬限制。\n\nre参数指定资源限制类型，比较重要的资源限制类型见下表。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n&nbsp;\n\n## 改变工作目录与根目录\n\n获取进程当前目录的函数为getcwd。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    buf: 存储进程当前工作目录的绝对路径名\n    size: 指定buf地址处内存的大小\n    返回指向目标存储区的指针: 成功 || 返回NULL并设置errno\n*/\nchar * getcwd(char * buf, size_t size);\n```\n\n* 若buf=NULL且size=0。则getcwd会在内部使用malloc动态分配内存，并将进程的当前目录存储在其中，然后返回动态分配的内存地址。注意要自己释放这段内存。\n* 若当前工作目录的绝对路径名加一个字符串结束符'\\0'的长度大于size，则getcwd返回NULL，并设置errno为ERANGE。\n\n改变进程工作目录的函数为chdir。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    path: 指定要切换的目标目录\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint chdir(const char * path);\n```\n\n改变进程根目录的函数为chroot。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    path: 指定要切换到的目标根目录\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint chroot(const char * path);\n```\n\nchroot并不改变进程的当前目录，因此调用chroot后，还是需要使用chdir(\"/\")来将工作目录切换到新的根目录。\n\n只有特权进程才能改变根目录。\n\n改变进程根目录之后，可能无法访问类似/dev的文件，但是进程原先打开的文件描述符依然有效。因此可以使用调用chroot函数之前的文件描述符来访问调用chroot函数之后无法访问的文件。\n\n## 服务器程序后台化\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    nochdir: 指定是否改变工作目录(0代表设置工作目录为根目录)\n    noclose为0: 标准输入, 标准输出, 标准错误输出都被重定向到/dev/null; 否则仍然使用原来的设备\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint daemon(int nochdir, int noclose);\n```","tags":["网络编程"],"categories":["course"]},{"title":"第三章第三节 进程间关系","url":"/course/np-ch3-par3.html","content":"\n## 进程组\n\nLinux下每个进程都隶属于一个进程组，其进程组ID——PGID；使用getpgid函数可获取指定进程的PGID。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    返回进程pid所属进程组的PGID: 成功 || 返回-1并设置errno: 失败\n*/\npid_t getpgid(pid_t pid);\n```\n\n每个进程组都有一个首领进程，其PGID与PID相同；进程组将一直存在，直到其中所有进程均退出，或加入其他进程组。\n\n使用setpgid可设置PGID。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint setpgid(pid_t pid, pid_t pgid);\n```\n\n* 若pid=pgid。进程pid为进程组pgid的首领；\n* 若pid=0。设置当前进程的PGID为pgid；\n* 若pgid=0。设置pid为进程pid的PGID；\n\n一个进程只能设置自己或其子进程的PGID；而当子进程调用exec系列函数后，我们也不能再在父进程中对它设置PGID。\n\n## 会话\n\n一些有关联的进程组将形成一个会话session。下面的函数用于创建一个会话。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    返回新的进程组的PGID: 成功 || 返回-1并设置errno: 失败\n*/\npid_t setsid(void);\n```\n\n进程组的首领进程不能调用setsid，否则会产生一个错误。对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果。\n\n* 调用进程成为会话的首领，此时该进程是新会话的唯一成员；\n* 新建一个进程组，其PGID就是调用进程的PID，调用进程成为这个进程组的首领；\n* 调用进程将甩开终端；\n\n一个会话的会话ID被认为是会话首领所在进程组的PGID。使用getsid函数得到会话ID。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n*/\npid_t getsid(pid_t pid);\n```","tags":["网络编程"],"categories":["course"]},{"title":"第三章第二节 用户信息","url":"/course/np-ch3-par2.html","content":"\n## 各种ID\n\n真实用户ID——UID；有效用户ID——EUID；真实组ID——GID；有效组ID——EGID。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n*/\nuid_t getuid();\n\nuid_t geteuid();\n\ngid_t getgid();\n\ngid_t getegid();\n\nint setuid(uid_t uid);\n\nint seteuid(uid_t uid);\n\nint setgid(gid_t gid);\n\nint setegid(gid_t gid);\n```\n\nEUID的存在是为了方便资源访问，它使得运行程序的用户拥有该有效用户的权限。有效用户为root的进程为特权进程。","tags":["网络编程"],"categories":["course"]},{"title":"第三章第一节 日志","url":"/course/np-ch3-par1.html","content":"\n## Linux系统日志\n\nLinux现在提供守护进程rsyslogd来处理系统日志。rsyslogd守护进程既能接收用户进程输出的日志，也能接收内核日志。\n\n用户进程通过调用syslog函数生成系统日志；syslog函数将日志输出到一个UNIX本地域socket类型(AF_UNIX)的文件/dev/log；rsyslogd则监听/dev/log文件以获取用户进程的日志输出。\n\n内核日志由printk等函数打印至内核的环状缓存(ring buffer)中；环状缓存中的内容直接映射到/proc/kmsg文件中；rsyslogd通过读取/proc/kmsg文件获得内核日志。\n\nrsyslogd在接收到用户进程或内核输入的日志后，会将他们输出至某些特定的日志文件；默认情况下，调试信息保存在/var/log/debug，普通信息保存在/var/log/messages，内核消息则保存在/var/log/kernel.log；\n\nLinux系统的日志体系如下图。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n&nbsp;\n\n### rsyslogd的配置文件\n\nrsyslogd的主配置文件为/etc/rsyslog.conf，其中主要可以设置的项包括：内核日志输入路径、是否接收UDP日志及其监听端口、日志文件的权限、包含哪些子配置文件(如/etc/rsyslog.d/*.conf)；而rsyslogd的子配置文件则指定各类日志的目标存储文件。\n\n## syslog函数\n\n应用程序可使用syslog函数与rsyslogd守护进程通信。\n\n```c\n/*\n    引用方式: #include <syslog.h>\n    priority: 设施值与日志级别的按位或\n        设施值: 默认为LOG_USER\n        日志级别\n            0: 系统不可用\n            1: 报警, 需立即采取行动\n            2: 非常严重的情况\n            3: 错误\n            4: 警告\n            5: 通知\n            6: 信息\n            7: 调试\n    mes: 日志信息\n*/\nvoid syslog(int priority, const char * mes);\n```\n\nopenlog函数可进一步改变syslog的默认输出方式，进一步结构化日志内容。\n\n```c\n/*\n    引用方式: #include <syslog.h>\n    ident: 此处字符串会被添加到日志消息的日期与时间之后(通常为程序名)\n    logopt: 对后续syslog的行为进行配置, 取如下值的按位或\n        LOG_PID        0x01    在日志消息中包含程序PID\n        LOG_CONS       0x02    若消息不能记录到日志文件, 则打印至终端\n        LOG_ODELAY     0x04    延迟打开日志功能直到第一次调用syslog\n        LOG_NDELAY     0x08    不延迟打开日志功能\n    fac: 修改syslog函数中的默认设施值\n*/\nvoid openlog(const char * ident, int logout, int fac);\n```\n\n### 日志的过滤\n\n在程序开发过程中，可能需要输出很多调试信息；而程序发布后，我们需要将这些调试信息关闭；这通过设置日志掩码来实现：使日志级别大于日志掩码的日志信息被系统忽略。setlogmask函数用于设置syslog的日志掩码。\n\n```c\n/*\n    引用方式: #include <syslog.h>\n    mask: 日志掩码值\n    函数始终会成功, 返回调用进程先前的日志掩码值\n*/\nint setlogmask(int mask);\n```\n\n### 关闭日志功能\n\n使用closelog函数关闭日志功能。\n\n```c\n/*\n    引用方式: #include <syslog.h>\n*/\nvoid closelog();\n```","tags":["网络编程"],"categories":["course"]},{"title":"Ubuntu18.04给手机开热点","url":"/config/coming-to-Redmi.html","content":"\n在电脑连上网线时，是可以给手机开热点的。下面详细介绍配置过程。\n\n打开终端，进入root用户；输入如下命令。\n\n```bash\nnm-connection-editor\n```\n\n就会看到下图。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\n点击左下角的'+'号，选择Wi-Fi。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\n然后对此连接做如下配置(没有展示的就算使用默认配置)。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n<div style=\"width:45%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n<div style=\"width:45%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n然后打开设置->Wi-Fi，再点击右上角的选择链接打开隐藏的网络。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n<div style=\"width:45%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n然后在手机上就能看到热点，不过热点的名字不是上面Wi-Fi的名字，而是Ubuntu系统的用户名；输入密码即可连接到此Wi-Fi。","tags":["Ubuntu"],"categories":["config"]},{"title":"第二章第三节 控制I/O行为与属性函数","url":"/course/np-ch2-par3.html","content":"\n## fcntl函数\n\nfcntl函数提供对文件描述符的各种控制操作。\n\n```c\n/*\n    引用方式: #include <fcntl.h>\n    cmd: 指定执行哪种类型的操作\n    返回值根据操作与arg的不同而不同, 若失败返回-1并设置errno\n*/\nint fcntl(int fd, int cmd,...);\n```\n\n根据操作类型的不同，fcntl函数可能还需要第三个可选参数arg。fcntl函数支持的常用操作及其参数见下表。\n\n<div style=\"width:62%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n<div style=\"width:62%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n在网络编程中，fcntl函数通常用来将一个文件描述符设置为非阻塞的。基本框架如下。\n\n```c\nint setnonblocking( int fd ){\n    int old_option, new_option;\n    if((old_option=fcntl( fd, F_GETFL ))<0){\n        printf(\"fcntl error: %s\\n\", strerror(errno));\n        return -1;\n    }\n    new_option = old_option | O_NONBLOCK;\n    if((fcntl( fd, F_SETFL, new_option ))<0){\n        printf(\"fcntl error: %s\\n\", strerror(errno));\n        return -1;\n    }\n    return old_option;\n}\n```","tags":["网络编程"],"categories":["course"]},{"title":"第二章第二节 读写数据函数","url":"/course/np-ch2-par2.html","content":"\n## readv与writev函数\n\nreadv函数将数据从文件描述符读到分散的内存块，即分散读；writev函数将多块分散的内存数据一并写入文件描述符，即集中写。\n\n```c\n/*\n    引用方式: #include <sys/uio.h>\n    cnt: vec数组的长度\n    返回读出/写入的字节数: 成功 || 返回-1并设置errno: 失败\n*/\nsszize_t readv(int fd, const struct iovec * vec, int cnt);\n\nsszize_t writev(int fd, const struct iovec * vec, int cnt);\n```\n\n根据HTTP响应报文格式，状态行、多个头部字段、1个空行与文档内容，文档内容通常与前面的内容是分开的；因此，可以使用writev函数将它们同时写出。\n\n## sendfile函数\n\nsendfile函数在两个文件描述符之间直接传递数据(完全在内核中操作)，从而避免了内核缓冲区与用户缓冲区之间的数据拷贝，效率很高，这称为零拷贝。\n\n```c\n/*\n    引用方式: #include <sys/sendfile.h>\n    offset: 指定从读入文件流的哪个位置开始读; 为空则从读入文件流默认的起始位置开始\n    cnt: 指定传输的字节数\n    返回传输的字节数: 成功 || 返回-1并设置errno: 失败\n*/\nssize_t sendfile(int out, int fd, off_t * offset, size_t cnt);\n```\n\n`man 2 sendfile`明确指出：fd必须是支持mmap函数的文件描述符，必须指向真实的文件，不能是socket或管道；而out必须是一个socket。\n\n## mmap与munmap函数\n\nmmap函数用于申请一段内存空间，这段内存可以用于进程间通信，也可以用于映射文件。munmap释放由mmap创建的内存空间。\n\n```c\n/*\n    引用方式: #include <sys/mman.h>\n    start: 指定分配的内存的起始地址; 若设置为NULL则由系统自动分配\n    prot: 设置内存段的访问权限; PROT_READ: 可读 || PROT_WRITE: 可写 ||PROT_EXEC: 可执行 || PROT_NONE: 内存不可访问; prot可取几个值的按位或\n    flags: 控制内存被修改后程序的行为, 详见下表\n    fd: 被映射文件的文件描述符(一般由open获得)\n    返回目标内存区域的指针: 成功 || 返回MAP_FAILED((void *)-1)并设置errno: 失败\n*/\nvoid * mmap(void * start, size_t len, int prot, int flags, int fd, off_t offset);\n```\n\n<div style=\"width:62%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\nflags参数取某些值的按位或(除了MAR_SHARED与MAR_PRIVATE互斥外)。\n\n```c\n/*\n    引用方式: #include <sys/mman.h>\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint munmap(void * start, size_t len);\n```\n\n## splice函数\n\nsplice函数用于在两个文件描述符之间移动数据，也是零拷贝操作。\n\n```c\n/*\n    引用方式: #include <fcntl.h>\n    in: 待输入数据的文件描述符\n    off_in: 在in不是一个管道文件描述符时, 指定从输入数据流的何处偏移开始读取数据, 置NULL表示从数据流的当前偏移开始读入\n    out: 接收管道输出数据的文件描述符\n    off_out: 在out不是一个管道文件描述符时, 指定从输出数据流的何处偏移开始接收数据, 置NULL表示从数据流的当前偏移开始接收\n    len: 传输数据的长度上限\n    flags: 控制数据如何移动, 详见下表\n    返回传输字节长度(可能为0): 成功 || 返回-1并设置errno: 失败\n*/\nssize_t splice(int in, loff_t * off_in, int out, loff_t * off_out, size_t len, unsigned int flags);\n```\n\n文件描述符in与out必须至少有一个是管道文件描述符。\n\n<div style=\"width:62%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n## tee函数\n\ntee函数在两个管道文件描述符之间复制数据，也是零拷贝操作。它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操作。\n\n```c\n/*\n    引用方式: #include <fcntl.h>\n    返回传输字节长度(可能为0): 成功 || 返回-1并设置errno: 失败\n*/\nssize_t tee(int in, int out, size_t len, unsigned int flags);\n```","tags":["网络编程"],"categories":["course"]},{"title":"第二章第一节 创建文件描述符函数","url":"/course/np-ch2-par1.html","content":"\n## pipe函数\n\npipe函数创建一个管道，以实现进程间通信。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    fd: 存放管道两端的文件描述符; fd[0]只能从管道读数据, fd[1]只能向管道写数据\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint pipe(int fd[2]);\n```\n\n因此，若要实现进程间双向数据传输，则要使用两个管道。默认情况下，这两个文件描述符都是阻塞的；即若使用read系统调用来读一个空的管道，则read会被阻塞；同理，使用write系统调用来写一个满的管道也会陷入阻塞。\n\nfd[1]的引用计数归0，则使用read读该管道将返回0；fd[0]的引用计数归0，则使用write写该管道将失败，并触发SIGPIPE信号。\n\n管道容量大小默认为65536字节，可使用fcntl函数修改管道容量。\n\n此外，socket基础API提供socketpair函数创建双向管道。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    domain: 指定底层协议族; 此时只能是AF_UNIX\n    type: 指定服务类型; SOCK_STREAM: 流服务 || SOCK_UGRAM: 数据报服务;\n    protocol: 在前面两个参数的基础上更具体的选择一个协议, 一般设置为0, 表示使用默认协议\n    fd: 存放管道两端的文件描述符\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint socketpair(int domain, int type, int protocol, int fd[2]);\n```\n\n## dup函数与dup2函数\n\n`dup*`函数可复制文件描述符。从而实现输入/输出的重定向。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    bottom: 返回的第一个不小于bottom文件描述符\n    返回新创建的文件描述符, 它与fd指向同一文件/管道/网络连接(dup返回的文件描述符总是取当前可用的最小整数值)\n*/\nint dup(int fd);\n\nint dup2(int fd, int bottom);\n```\n\n简要说明代码6-1输出重定向的原理。关闭标准输出文件描述符STDOUT_FILENO(值为1)，然后复制socket文件描述符connfd。由于dup总是返回操作系统中最小的可用文件描述符，因此dup函数返回1。因此，printf实际上会打印到socket文件描述符connfd中。\n\n**以上就是CGI服务器的基本工作原理**","tags":["网络编程"],"categories":["course"]},{"title":"第一章第五节 网络信息API","url":"/course/np-ch1-par5.html","content":"\n## 域名解析\n\nLinux提供gethostbyname函数对域名进行解析。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    doname: 域名\n    返回hostent结构体指针: 成功 || 返回NULL并设置h_errno: 失败\n*/\nstruct hostent * gethostbyname(const char * doname);\n```\n\n其中，结构体hostent定义如下。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    h_name: 主机名\n    h_aliases: 主机别名数组(别名不止一个)\n    h_addrtype: 地址类型\n    h_length: 地址长度(字节)\n    h_addr_list: IP地址数组(网络字节序)\n*/\nstruct hostent{\n  char *h_name;\n  char **h_aliases;\n  int h_addrtype;\n  int h_length;\n  char **h_addr_list;\n};\n```\n\n如果想通过IP地址查到主机信息，使用gethostbyaddr函数。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    addr: 目标主机的IP地址(结构体in_addr或结构体in6_addr的指针)\n    len: IP地址长度\n    type: IP地址类型; AF_INET || AF_INET6\n    返回hostent结构体指针: 成功 || 返回NULL并设置h_errno: 失败\n*/\nstruct hostent * gethostbyaddr(const void * addr, size_t len, int type);\n```\n\n上述两个函数不可重入。\n\n## 服务解析\n\ngetservbyname函数根据服务名称获取某个服务的完整信息。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    name: 服务名称\n    proto: 服务类型; \"tcp\"表示流服务 || \"udp\"表示数据报服务 || NULL: 获取所有类型的服务\n    返回servent结构体指针: 成功 || 返回NULL: 失败\n*/\nstruct servent * getservbyname(const char * name, const char * proto);\n```\n\n其中，结构体servent的定义如下。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    s_name: 服务名称\n    s_aliases: 服务别名数组\n    s_port: 端口号\n    s_proto: 服务类型\n*/\nstruct servent{\n  char *s_name;\n  char **s_aliases;\n  int s_port;\n  char *s_proto;\n};\n```\n\n也可以通过端口获得服务的完整信息，使用getservbyport函数。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    port: 端口号\n    proto: 服务类型; \"tcp\"表示流服务 || \"udp\"表示数据报服务 || NULL: 获取所有类型的服务\n*/\nstruct servent * getservbyport(int port, const char * proto);\n```\n\n上述两个函数不可重入。Linux提供了这些函数可重入版本，在函数名尾部加上_r；\n\n## getaddrinfo\n\ngetaddrinfo函数既能通过主机名获得IP地址，也能通过服务名获得端口号。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    name: 主机名 || 字符串表示的IP地址\n    service: 服务名 || 端口号\n    hints: 对输出进行一些控制; 默认设置为NULL\n    result: result指向一个链表, 用于存储输出结果\n    返回0: 成功 || 返回错误码: 调用const char * gai_strerror(int ret); 查看具体错误信息\n*/\nint getaddrinfo(const char * name, const char * service, const struct addrinfo * hints, struct addrinfo * * result);\n```\n\n其中，结构体addrinfo的定义如下。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    ai_flags: 详见下表\n    ai_family: 地址族\n    ai_socktype: 服务类型; SOCK_STREAM || SOCK_DGRAM\n    ai_protocol: 一般设置为0, 表示使用默认协议\n    ai_addrlen: socket地址ai_addr的长度\n    ai_addr: socket地址\n    ai_canonname: 主机别名\n    ai_next: 指向下一个结构体addrinfo\n*/\nstruct addrinfo\n{\n  int ai_flags;\n  int ai_family;\n  int ai_socktype;\n  int ai_protocol;\n  socklen_t ai_addrlen;\n  struct sockaddr *ai_addr;\n  char *ai_canonname;\n  struct addrinfo *ai_next;\n};\n```\n\n<div style=\"width:65%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\ngetaddrinfo将隐式分配堆内存，使用配对函数freeaddrinfo来释放这段内存。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n*/\nvoid freeaddrinfo(struct addrinfo * result);\n```\n\n## getnameinfo\n\ngetnameinfo能通过socket地址同时获得以字符串表示的主机名与服务名。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    host: 存放主机名的地址\n    hostlen: host这段内存的长度\n    serv: 存放服务名\n    servlen: serv这段内存的长度\n    flags: 详见下表\n    返回0: 成功 || 返回错误码: 调用const char * gai_strerror(int ret); 查看具体错误信息\n*/\nint getnameinfo(const struct sockadrr * addr, socklen_t addrlen, char * host, socklen_t hostlen, char * serv, socklen_t servlen, int flags);\n```\n\n<div style=\"width:62%;margin:auto\">{% asset_img 3.png pic3 %}</div>","tags":["网络编程"],"categories":["course"]},{"title":"第一章第四节 socket选项","url":"/course/np-ch1-par4.html","content":"\n## socket选项简介\n\n下面两个函数专门用来读取与设置socket文件描述符属性。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    level: 指定协议类型\n    opt_name: 指定选项\n    opt_val: 存放选项的值的地址\n    len: 存放选项的值的地址的长度\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint getsockopt(int sockfd, int level, int opt_name, void * opt_val, socklen_t * len);\n\nint setsockopt(int sockfd, int level, int opt_name, const void * opt_val, socklen_t len);\n```\n\n如下表是一些常用的socket选项。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\n对服务器来说，有些socket选项只能在调用listen函数前针对监听socket设置才有效。对于这些监听socket，只能由accept函数返回。而此时接受的连接至少已经完成TCP三次握手的前两次步骤，但有些选项需要在TCP同步报文段中设置，因此这些选项必须在调用listen函数前针对监听socket设置，然后连接的socket将其继承，这些选项包括SO_DEBUG | SO_DONTROUTE | SO_KEEPALIVE | SO_LINGER | SO_OOBINLINE | SO_RCVBUF | SO_RCVLOWAT | SO_SNDBUF | SO_SNDLOWAT |TCP_MAXSEG | TCP_NODELAY。\n\n而对于客户端来说，这些socket选项应该在调用connect函数之前设置。\n\n下面讨论几个重要的socket选项。\n\n## SO_REUSEADDR选项\n\n服务器设置socket的SO_REUSEADDR选项来强制使用被处于TIME_WAIT状态的连接占用的socket地址。此外，设置内核参数/proc/sys/net/ipv4/tcp_tw_reuse来快速回收被关闭的socket地址\n\n## SO_RCVBUF与SO_SNDBUF\n\nSO_RCVBUF与SO_SNDBUF选项分别表示TCP接收缓冲区与发送缓冲区的大小。而事实上，操作系统会将设置的缓冲区大小加倍再作为缓冲区大小，而且不得小于某个最小值(TCP接收缓冲区最小值为256字节，发送缓冲区最小值为2048字节)。此外，可以设置/proc/sys/net/ipv4/tcp_rmem与/proc/sys/net/ipv4/tcp_wmem来使TCP接收/发送缓冲区没有大小限制。\n\n## SO_RCVLOWAT与SO_SNDLOWAT\n\n当TCP接收缓冲区中可读数据的总数大于其低水位标记SO_RCVLOWAT时，I/O复用系统调用将通知应用程序可从对应的socket上读取数据。\n\n当TCP发送缓冲区中空闲空间的大小大于其低水位标记SO_SNDLOWAT时，I/O复用系统调用将通知应用程序可向对应的socket上写入数据。\n\nSO_RCVLOWAT与SO_SNDLOWAT均默认为1字节。\n\n## SO_LINGER选项\n\nSO_LINGER选项控制close函数在关闭TCP连接时的行为。默认情况下，close函数关闭socket后，close立即返回，TCP模块负责将socket对应的TCP发送缓冲区中残留的数据发送给对方。\n\n设置SO_LINGER选项时，需要在setsockopt函数中传递一个linger结构体。定义如下。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    l_onoff: 开启(非0)还是关闭(0)该选项\n    l_linger: 滞留时间\n*/\nstruct linger{\n    int l_onoff;\n    int l_linger;\n};\n```\n\n根据l_onoff与l_linger的值，close函数有3种处理方式。\n\n* l_onoff为0。close采用默认处理方式；\n* l_onoff为1，l_linger为0。close函数立即返回，TCP模块丢弃被关闭的socket对应的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文；可见这给服务器提供了异常终止连接的方法；\n* l_onoff为1，l_linger大于0。若socket是非阻塞的，close将立即返回；若socket是阻塞的，则close将等待l_linger时间，若在这期间TCP模块发送完发送缓冲区残留的数据并收到对方的确认，close返回0，否则返回-1并设置errno为EWOULDBLOCK。","tags":["网络编程"],"categories":["course"]},{"title":"第一章第三节 socket信息交互API","url":"/course/np-ch1-par3.html","content":"\n## 数据读写\n\n### TCP数据读写\n\nsocket编程接口提供了专门用于socket数据读写的函数，它们增加对数据读写的控制。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    buf: 读/写缓冲区的地址\n    len: 读/写缓冲区的大小\n    flags: 为数据收发提供相应控制\n        MSG_CONFIRM: 指示数据链路层协议持续监听对方的回应, 直到得到回复; 仅能用于SOCK_DGRAM/SOCK_RAW类型的socket; 只能用于send函数\n        MSG_DONTROUTE: 不查看路由表, 直接将数据发送给本地局域网内的主机; 只能用于send函数\n        MSG_DONTWAIT: 对该socket的此次操作是非阻塞的\n        MSG_MORE: 告知内核应用程序还有更多数据要发送, 内核将超时等待新的数据写入TCP发送缓冲区后一并发送; 只能用于send函数\n        MSG_WAITALL: 读操作仅在读取到指定数量的字节后才返回; 只能用于recv函数\n        MSG_PEEK: 窥探读缓存的数据, 此次读操作不会导致这些数据被清除; 只能用于recv函数\n        MSG_OOB: 发送或接收紧急数据\n        MSG_NOSIGNAL: 向读端关闭的管道或socket连接中写数据时不引发SIGPIPE信号\n    返回实际读取/写入的数据: 成功 || 返回-1并设置errno: 失败\n*/\nssize_t recv(int sockfd, void * buf, size_t len, int flags);\n\nssize_t send(int sockfd, const void * buf, size_t len, int flags);\n```\n\n### UDP数据读写\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    buf: 读/写缓冲区的地址\n    len: 读/写缓冲区的大小\n    flags: 为数据收发提供相应控制, 选项与意义与send/recv的flags相同\n    addr: 发送/接收端的socket地址\n    addr_len: 发送/接收端的socket地址长度\n    返回实际读取/写入的数据: 成功 || 返回-1并设置errno: 失败\n*/\nssize_t recvfrom(int sockfd, void * buf, size_t len, int flags, struct sockaddr * addr, socklen_t * addr_len);\n\nssize_t sendto(int sockfd, const void * buf, size_t len, int flags, const struct sockaddr * addr, socklen_t addr_len);\n```\n\n若将参数addr与addr_len，则recvfrom/sendto也可用于面向连接的socket数据读写。\n\n### 通用数据读写\n\nsocket编程接口提供一对通用的数据读写系统调用。既可用于TCP流数据，又可以用于UDP数据报。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    返回实际读取/写入的数据: 成功 || 返回-1并设置errno: 失败\n*/\nssize_t recvmsg(int sockfd, struct msghdr * msg, int flags);\n\nssize_t sendmsg(int sockfd, struct msghdr * msg, int flags);\n```\n\n其中，结构体msghdr的定义如下。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    msg_name: socket地址(同样对于TCPL连接, 此项设置为NULL)\n    msg_iov: 分散的内存块\n    msg_namelen: 分散的内存块的数量\n    msg_control: 辅助数据的起始地址\n    msg_controllen: 辅助数据的大小\n    msg_flags: 复制函数中的flags参数, 并在调用过程中更新\n*/\nstruct msghdr\n  {\n    void *msg_name;\n    socklen_t msg_namelen;\n    struct iovec *msg_iov;\n    size_t msg_iovlen;\n    void *msg_control;\n    size_t msg_controllen;\n    int msg_flags;\n  };\n```\n\n其中，结构体iovec的定义如下。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    iov_base: 内存起始地址\n    iov_len: 这段内存长度\n*/\nstruct iovec\n  {\n    void *iov_base;\n    size_t iov_len;\n  };\n```\n\n## 接收带外标记\n\n在recv函数的flags中设置MSG_OOB选项可以接收带外数据，但是实际应用中程序无法预期带外数据何时到来；因此，Linux提供sockatmark函数来判断sockfd是否处于带外标记，即下一个被读取的数据是否为带外数据；如果是，sockatmark函数返回1。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n*/\nint sockatmark(int sockfd);\n```\n\n## 地址信息函数\n\n想知道一个连接socket的本端socket地址与远端socket地址，Linux提供如下两个函数。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    sockfd: 要查询本端socket地址/远端socket地址的连接socket\n    addr: 存放查询结果的地址\n    len: 存放查询结果的长度\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint getsockname(int sockfd, struct sockaddr * addr, socklen_t len);\n\nint getpeername(int sockfd, struct sockaddr * addr, socklen_t len);\n```","tags":["网络编程"],"categories":["course"]},{"title":"第一章第二节 socket基础API","url":"/course/np-ch1-par2.html","content":"\n## 创建socket\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    domain: 指定底层协议族; PF_INET: IPv4 || PF_INET6: IPv6\n    type: 指定服务类型; SOCK_STREAM: 流服务 || SOCK_UGRAM: 数据报服务; 对TCP/IP协议族来说，分别表示传输层使用TCP/UDP协议\n    protocol: 在前面两个参数的基础上更具体的选择一个协议, 一般设置为0, 表示使用默认协议\n    返回socket文件描述符: 成功 || 返回-1: 失败\n*/\nint socket (int domain, int type, int protocol);\n```\n\n## 命名socket\n\n创建socket时，只给出了地址族，但是并未指定使用的具体socket地址，将一个socket与socket地址绑定称为socket命名。命名socket通常用在服务器端，这样客户端才知道该怎么连接该socket。而客户端通常不需要命名socket，采用匿名方式，即使用操作系统自动分配的socket地址。命名socket使用bind函数。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    len: socket地址长度, 使用sizeof(address)即可, address是socket地址\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint bind (int fd, const struct sockaddr * addr, socklen_t len);\n```\n\n常见的errno有两种：EACCES(被绑定的地址是受保护地址，仅超级用户可以访问。如普通用户将socket绑定到0-1023端口)与EADDRINUSE(被绑定的端口正在使用，如将socket绑定到处于TIME_WAIT状态的socket地址)。\n\n## 监听socket\n\nsocket被命名后，还不能马上接受客户连接，需要使用listen函数来创建一个监听队列以存放待处理的客户连接。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    backlog: 内核监听队列的最大长度, 典型值为5\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint listen (int sockfd, int backlog);\n```\n\n在Ubuntu18.04上测试，连接socket的连接最多可以有(backlog+1)个。\n\n## 接受连接\n\naccept函数从listen监听队列中接受一个连接。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    返回新的连接socket: 成功 || 返回-1并设置errno: 失败\n*/\nint accept (int sockfd, struct sockaddr * addr, socklen_t len);\n```\n\n通过实验可知：accept只是从监听队列中取出连接，而不论连接处于哪种状态，更不关心网络状况的变化。\n\n## 发起连接\n\n客户端需要使用connect函数来主动连接服务器端的socket。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    serv_addr: 要连接的socket地址\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint connect (int local_sockfd, const struct sockaddr * serv_addr, socklen_t len);\n```\n\n常见的errno有两种：ECONNREFUSED(目标端口不存在)与ETIMEDOUT(连接超时)。\n\n## 关闭连接\n\nsocket也是文件，因此页可以通过close函数关闭。事实上，close并非总是立即关闭一个连接，而是将socket的引用计数减1；只有当socket为0时，才真的关闭连接。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint close(int fd);\n```\n\n如果要立即终止连接，使用shutdown函数，它是专门为网络编程设计的。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    howto: 指定shutdown关闭连接的方式;\n        SHUT_RD: sockfd不可再被读, sockfd接收缓冲区中的数据全部被丢弃;\n        SHUT_WR: sockfd不可再被写, sockfd发送缓冲区中的数据会在真正关闭前全部发送出去, 连接处于半关闭状态;\n        SHUT_RDWR: 同时关闭sockfd的读与写;\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint shutdown(int sockfd, int howto);\n```","tags":["网络编程"],"categories":["course"]},{"title":"第一章第一节 socket地址API","url":"/course/np-ch1-par1.html","content":"\n## 通用socket地址\n\n表示socket地址的结构体sockaddr。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    sa_family: 地址族类型变量. AF_UNIX/PF_UNIX表示UNIX本地域协议族 || AF_INET/PF_INET表示TCP/IPv4协议族 || AF_INET6/PF_INET6表示TCP/IPv6协议族\n    sa_data: 存放socket地址值. sa_data表示路径名(AF_UNIX类型) || sa_data包含2字节的端口号与4字节IPv4地址(AF_INET类型) || sa_data包含2字节端口号, 4字节流标识, 16字节IPv6地址, 4字节范围ID共26字节(AF_INTE6类型)\n*/\nstruct sockaddr\n  {\n    sa_family_t sa_family;\n    char sa_data[14];\n  };\n```\n\n14字节的sa_data无法容纳所有协议族的地址值；因此，Linux定义了如下新的通用socket地址结构体sockaddr_storage。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n*/\nstruct sockaddr_storage\n  {\n    sa_family_t ss_family;\n    char __ss_padding[(128 - (sizeof (unsigned short int)) - sizeof (unsigned long int))];\n    unsigned long int __ss_align;\n  };\n```\n\n## 专用socket地址\n\n上述通用socket结构体不易操作，Linux专门提供如下专用socket地址结构体。\n\n```c\n/*\n    引用方式: #include <sys/un.h>\n    UNIX本地域协议族\n*/\nstruct sockaddr_un\n  {\n    sa_family_t sun_family;\n    char sun_path[108];\n  };\n/*\n    引用方式: #include <netinet/in.h>\n    TCP/IPv4协议族\n    sin_port: 使用网络字节序\n*/\nstruct sockaddr_in\n  {\n    sa_family_t sin_family;\n    in_port_t sin_port;\n    struct in_addr sin_addr;\n\n    unsigned char sin_zero[sizeof (struct sockaddr) -\n      (sizeof (unsigned short int)) -\n      sizeof (in_port_t) -\n      sizeof (struct in_addr)];\n  };\n\nstruct in_addr\n  {\n    in_addr_t s_addr;// IPv4地址; 使用网络字节序\n  };\n/*\n    引用方式: #include <netinet/in.h>\n    TCP/IPv6协议族\n    sin_port6: 使用网络字节序\n*/\nstruct sockaddr_in6\n  {\n    sa_family_t sin6_family;\n    in_port_t sin6_port;\n    uint32_t sin6_flowinfo;\n    struct in6_addr sin6_addr;\n    uint32_t sin6_scope_id;\n  };\n\nstruct in6_addr\n  {\n    union\n      {\n uint8_t __u6_addr8[16];\n uint16_t __u6_addr16[8];\n uint32_t __u6_addr32[4];\n      } __in6_u;// IPv6地址; 使用网络字节序\n  };\n```\n\n所有专用socket地址类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr。\n\n## IP地址转换\n\n点分十进制字符串转结构体in_addr。\n\n```c\n/*\n    引用方式: #include <arpa/inet.h>\n    inp: 转换的结构体存放地址\n    返回1: 成功 || 返回0: 失败\n*/\nint inet_aton(const char * cp, struct in_addr * inp);\n```\n\n结构体in_addr转点分十进制字符串。\n\n```c\n/*\n    引用方式: #include <arpa/inet.h>\n*/\nchar * inet_ntoa(struct in_addr in);\n```\n\n**上述两个函数不可重入**\n\n还有同时适用于IPv4与IPv6地址转换的一对函数。\n\n点分十进制字符串(IPv4地址)或冒号分16进制字符串(IPv6)转对应结构体，即结构体in_addr或结构体in6_addr；由`__af`参数指定协议族，一般取宏AF_INET或AF_INET6。\n\n```c\n/*\n    引用方式: #include <arpa/inet.h>\n    af: 指定地址族; AF_INET: IPv4 || AF_INET6: IPv6\n    buf: 转换的结构体存放地址\n*/\nint inet_pton (int __af, const char * cp, void * buf);\n```\n\n结构体in_addr或结构体in6_addr转换为对应的字符串表示。\n\n```c\n/*\n    引用方式: #include <arpa/inet.h>\n    af: 指定地址族; AF_INET: IPv4 || AF_INET6: IPv6\n    buf: 字符串存储地址\n    len一般取两个宏INET_ADDRSTRLEN与INET6_ADDRSTRLEN; \n    返回目标存储地址: 成功 || 返回NULL并设置erno: 失败\n*/\nconst char * inet_ntop (int af, const void * cp, char * buf, socklen_t len);\n```","tags":["网络编程"],"categories":["course"]},{"title":"Answers for chapter one","url":"/course/sp-ch11.html","content":"\n## Answers\n\n(1)程序为什么要被编译器编译之后才能运行？\n\n解：程序的源代码属于高级语言，而能让计算机理解执行的只有机器语言；因此，编译器的编译就是做将高级语言转换为机器语言的工作的。\n\n&nbsp;\n\n(2)编译器是如何将C语言程序转化成可执行的机器码的？\n\n解：经4个步骤：预处理、编译、汇编、链接。详见[编译与链接](https://chu-kangming.gitee.io/course/sp-ch2.html)\n\n&nbsp;\n\n(3)可执行文件中有哪些内容，它们是如何组织的？\n\n解：一个动态链接的可执行文件具有如下的段。\n\n```bash\nSections:\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .interp       0000001c  0000000000000238  0000000000000238  00000238  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  1 .note.ABI-tag 00000020  0000000000000254  0000000000000254  00000254  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  2 .note.gnu.build-id 00000024  0000000000000274  0000000000000274  00000274  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  3 .gnu.hash     0000001c  0000000000000298  0000000000000298  00000298  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  4 .dynsym       000000a8  00000000000002b8  00000000000002b8  000002b8  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  5 .dynstr       00000084  0000000000000360  0000000000000360  00000360  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  6 .gnu.version  0000000e  00000000000003e4  00000000000003e4  000003e4  2**1\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  7 .gnu.version_r 00000020  00000000000003f8  00000000000003f8  000003f8  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  8 .rela.dyn     000000c0  0000000000000418  0000000000000418  00000418  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  9 .rela.plt     00000018  00000000000004d8  00000000000004d8  000004d8  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n 10 .init         00000017  00000000000004f0  00000000000004f0  000004f0  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n 11 .plt          00000020  0000000000000510  0000000000000510  00000510  2**4\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n 12 .plt.got      00000008  0000000000000530  0000000000000530  00000530  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n 13 .text         000001f2  0000000000000540  0000000000000540  00000540  2**4\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n 14 .fini         00000009  0000000000000734  0000000000000734  00000734  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n 15 .rodata       0000001e  0000000000000740  0000000000000740  00000740  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n 16 .eh_frame_hdr 00000044  0000000000000760  0000000000000760  00000760  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n 17 .eh_frame     00000128  00000000000007a8  00000000000007a8  000007a8  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n 18 .init_array   00000008  0000000000200db8  0000000000200db8  00000db8  2**3\n                  CONTENTS, ALLOC, LOAD, DATA\n 19 .fini_array   00000008  0000000000200dc0  0000000000200dc0  00000dc0  2**3\n                  CONTENTS, ALLOC, LOAD, DATA\n 20 .dynamic      000001f0  0000000000200dc8  0000000000200dc8  00000dc8  2**3\n                  CONTENTS, ALLOC, LOAD, DATA\n 21 .got          00000048  0000000000200fb8  0000000000200fb8  00000fb8  2**3\n                  CONTENTS, ALLOC, LOAD, DATA\n 22 .data         00000014  0000000000201000  0000000000201000  00001000  2**3\n                  CONTENTS, ALLOC, LOAD, DATA\n 23 .bss          0000000c  0000000000201014  0000000000201014  00001014  2**2\n                  ALLOC\n 24 .comment      00000029  0000000000000000  0000000000000000  00001014  2**0\n                  CONTENTS, READONLY\n```\n\n可执行文件主要包含\n\n* .text代码段(存放执行指令)；\n* .data数据段(已初始化的全局变量与局部静态变量)；\n* .rodata只读数据段(存放只读数据)；\n* .bss段(未初始化的全局变量与局部静态变量)；\n* .interp段(指出程序所需动态链接器版本)；\n* .dynamic段(动态链接的基本信息)；\n* .dynsym段(保存动态链接的共享模块间符号的导入导出关系)；\n* .dynstr段(保存.dynsym段中符号的名称)；\n* .got段(全局偏移表)；\n* .rela.dyn段(用来修正.got段中全局变量和.data段中符号的地址)；\n* .plt段(程序链接表，用于实现延迟绑定)；\n* .rela.plt段(用来修正.got段中外部函数的地址)；\n* .init段(程序初始化)、fini段(程序退出清理)；\n\n&nbsp;\n\n(4)解释`#include<stdio.h>`的作用，C语言库是什么？要如何实现？\n\n解：包含处理标准输入输出的C语言标准库。C语言库是支撑C语言程序可以正常运行的代码集合。\n\n&nbsp;\n\n(5)不同的编译器、硬件平台以及操作系统，编译同一源代码的结果是否相同？为什么？\n\n解：不相同。不同的编译器在编译过程中所做的优化不同，不同的硬件平台所支持的汇编指令集不同，不同的操作系统对C语言标准库中函数的具体实现不同；因此，即使编译同一源代码，所得结果也不会相同。\n\n&nbsp;\n\n(7)一个程序在没有操作系统的机器上如何才能运行？\n\n解：略。\n\n&nbsp;\n\n(8)printf函数是如何实现的？\n\n解：要实现printf函数有两点，一个是使用write系统调用向屏幕写数据、一个是支持变长参数；在printf函数内部定义va_list类型的变量ap，先用宏函数va_start将其初始化\n\n```c\nva_start(ap, lastarg);//lastarg为printf函数的最后一个具名参数\n```\n\n接下来，可以通过va_arg宏函数来获取下一个不定参数；\n\n```c\ntype next=va_arg(ap, type);//type为下一个不定参数的类型\n```\n\n在调用完write系统调用之后，用宏函数va_end来清理现场。\n\n&nbsp;\n\n(9)程序在运行时，它在内存中的组成？\n\n解：程序在运行时，它在内存中的组成包括Linux内核、堆栈、动态装载库、数据段、代码段以及保留部分。这些部分的组织如下图。\n\n<div style=\"width:35%;margin:auto\">{% asset_img 13.png pic13 %}</div>","tags":["系统编程"],"categories":["course"]},{"title":"第十章 系统调用","url":"/course/sp-ch10.html","content":"\n## 系统调用简介\n\nLinux系统在x86架构下的系统调用由int 0x80中断完成，各通用寄存器用于传递参数，其中eax寄存器存储系统调用的调用号，常用的调用号如下表。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n<div style=\"width:64%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n&nbsp;\n\n可使用`man 2 read`查看read系统调用的详细说明。\n\n但是，不同操作系统之间系统调用不兼容，为此，运行库对这些系统调用封装成统一的接口，使得相同的代码在不同操作系统下都可以被编译并产生一致的效果。\n\n## 系统调用原理\n\n以基于int的Linux经典系统调用为例。如下是调用fork系统调用的示意图。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 18.png pic18 %}</div>\n\n&nbsp;\n\n### 触发中断\n\nfork函数是对系统调用fork的封装，由如下宏代码定义。\n\n```c\n_syscall0(pid_t, fork);\n```\n\n其中，`_syscall0`是一个宏函数，用于定义一个没有参数的系统调用的封装。i386版本的`_syscall0`定义如下。\n\n```c\n#define _syscall0(type, name)\\\ntype name(void)\\\n{\\\nlong __res;\\\n__asm__ volatile (\"int $0x80\"\\ \n    : \"=a\" (__res)\\\n    : \"0\" (__NR_##name));\\\n__syscall_return(type,__res);\\\n}\n```\n\n对于`_syscall0(type, name)`，上述宏会展开为如下代码。\n\n```c\npid_t fork(void)\n{\nlong __res;\n__asm__ volatile (\"int $0x80\"\n    : \"=a\" (__res)\n    : \"0\" (__NR_fork));\n__syscall_return(type,__res);\n}\n```\n\n其中，`__NR_fork`是一个宏，表示fork系统调用的调用号；0指示编译器选择与输出相同的寄存器来传递参数，而=a表示将返回值存放在eax寄存器，于是eax寄存器也用来传递参数`__NR_fork`，而中断服务程序正好从eax处取得系统调用号。\n\n而如果调用的系统调用需要传递参数(x86架构下Linux支持的系统调用参数个数最多6个)，分别使用6个寄存器(ebx、ecx、edx、esi、edi、ebp)来传送。\n\n当CPU执行到int $0x80时，会保存现场以便恢复，然后将特权状态从用户态切换到内核态，然后CPU查找中断向量表第0x80号元素。\n\n### 切换堆栈\n\nint指令执行的第一步就是切换堆栈(进程拥有内核栈与用户栈)，由于中断会让进程从用户态进入内核态，因此进程的当前栈也应该从用户栈切换为内核栈。具体的切换方法为：\n\n* 将寄存器esp、ss压入内核栈；\n* 将内核栈顶地址存入esp寄存器，将内核栈所在页的地址存入ss寄存器；\n\n切换堆栈之后，int指令执行的下一步是将eflags、cs、eip寄存器压入内核栈。与之对应的，当进程从内核态返回用户态时，使用iret指令，它会从内核栈中弹出ss、esp、eflags、cs、eip的值。","tags":["系统编程"],"categories":["course"]},{"title":"第九章 运行库","url":"/course/sp-ch9.html","content":"\n## 入口函数\n\n一个程序完整的运行过程应该如下。\n\n* 操作系统创建进程后，将控制权交给程序的入口处，入口处是运行库中的入口函数；\n* 入口函数对运行库与程序运行环境进行初始化，包括堆、I/O、线程、全局变量构造等；\n* 入口函数在完成初始化之后调用main函数，开始执行程序主体部分；\n* main函数返回后，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭I/O等；\n\n## C&C++运行库\n\n### C语言运行库\n\n一个C语言运行库大致包含如下功能。\n\n* 启动与退出：包括入口函数与入口函数所依赖的函数；\n* 标准函数：由C语言标准规定的C语言标准库所包含的函数实现；\n* I/O：I/O功能的封装与实现；\n* 堆：堆的封装与实现；\n* 语言实现：语言中一些特殊功能的实现；\n* 调试：实现调试功能的代码；\n\n其中，以C语言标准库占主要部分。\n\n### C语言标准库\n\nANSI C的标准库由24个C头文件组成，包含数学函数、字符/字符串处理、I/O等基本方面。\n\n* 标准输入输出(stdio.h)；\n* 文件操作(stdio.h)；\n* 字符操作(ctype.h)；\n* 字符串操作(string.h)；\n* 数学函数(math.h)；\n* 资源管理(stdlib.h)；\n* 格式转换(stdlib.h)；\n* 时间与日期(time.h)；\n* 断言(assert.h)；\n* 各种类型的常数(limits.h、float.h)；\n\n除此之外，C语言标准库还有实现了一些扩展功能。\n\n* 变长参数(stdarg.h)；\n* 非局部跳转(setjmp.h)；\n\n比如标准库中的printf函数就是变长参数。\n\n关于非局部跳转，如下是一个示例。\n\n```c\n#include <stdio.h>\n#include <setjmp.h>\n\njmp_buf b;\n\nvoid f(){\n    longjmp(b,1);\n}\n\nint main()\n{\n    if(setjmp(b)){\n        printf(\"World!\\n\");\n    }\n    else{\n        printf(\"Hello, \");\n        f();\n    }\n}\n```\n\n程序的输出结果是\n\n```bash\nHello, World!\n```\n\n### glibc与GCC\n\n**glibc简介**\n\nglibc的发布版本由两部分组成——头文件(/usr/include/stdio.h、/usr/include/stdlib.h等)与二进制文件(动态标准库/lib/x86_64-linux-gnu/libc.so.6、静态标准库/usr/lib/x86_64-linux-gnu/libc.a)，除了这些标准库以外，glibc还有几个辅助程序运行的运行库/usr/lib/x86_64-linux-gnu/crt1.o、/usr/lib/x86_64-linux-gnu/crti.o、/usr/lib/x86_64-linux-gnu/crtn.o。\n\n程序的入口函数_start就包含于crt1.o，而crti.o与crtn.o是分别用来辅助.init段与.finit段中指令的执行。crt1.o为了支持.init段与.finit段，它会向`__libc_start_main`传递两个函数指针`__libc_csu_init`与`__libc_csu_fini`，这两个函数指针指向函数`_init()`与`_finit()`。事实上，最终的输出文件的.init段与.finit段分别包含的就是`_init()`与`_finit()`，其中crti.o与crtn.o中的代码作为这两个函数的开始与结尾部分。\n\n.init段与.finit段正好在main函数执行前后被执行，正好可以用来实现C++全局构造与析构。.init段与.finit段中分别有对一个执行所有构造/析构函数的函数的调用。具体执行所有构造/析构函数的工作由编译器完成。于是就要介绍下面的**GCC平台相关目标文件**。\n\n**GCC平台相关目标文件**\n\n在静态链接生成ELF可执行文件时用到如下GCC平台相关目标文件(均在/usr/lib/gcc目录下)。\n\n* x86_64-linux-gnu/7/crtbeginT.o；具体实现C++全局构造。\n* x86_64-linux-gnu/7/crtend.o；具体实现C++析构；\n* x86_64-linux-gnu/7/libgcc.a；抹除不同平台的差异性，支持GCC的跨平台特性；对应的动态链接版本为libgcc_s.so。\n* x86_64-linux-gnu/7/libgcc_eh.a；支持C++的异常处理；\n\n综上，.init段与.finit段只是提供了一个在main函数执行前后执行的机制，具体的C++全局构造与析构分别由crtbeginT.o与crtend.o实现。在\"C++全局构造与析构\"这一节介绍。\n\n\n## 运行库与多线程\n\n&nbsp;\n\n## C++全局构造与析构\n\n### _GLOBAL__I_Hw\n\n对每个编译单元(cpp文件)，GCC编译器会遍历其中所有的全局对象，生成一个特殊函数`_GLOBAL__I_Hw`(对所在编译单元的所有全局对象进行初始化)，然后将此函数的地址放在目标文件的.ctors段。\n\n这样，在链接器链接这些目标文件时，根据\"相同段合并原则\"，链接器会把所有目标文件的.ctors段合并为输出文件的.ctors段；同样地，crtbeginT.o的.ctors段放在输出文件的.ctors段的开头，它并没有指向哪个`_GLOBAL__I_Hw`，链接器会将后面构造函数的个数存放到这个位置，链接器将.ctors段的起始地址定义成符号`__CTOR_LIST__`；crtbeginT.o的.ctors段放在输出文件的.ctors段的结尾，这个段的值为0，链接器将.ctors段的结尾地址定义为符号`__CTOR_END__`。\n\n### C++全局构造\n\n如下是全局构造的调用链。\n\n```bash\n_start->__libc_start_main->__libc_csu_init->_init->_do_global_ctors_aux\n```\n\n在`_do_global_ctors_aux`函数中具体实现了C++全局构造，关键代码如下。\n\n```c\nvoid __do_global_ctors_aux(void){\n    /* Call constructor functions */\n    unsigned long nptrs=(unsigned long)__CTOR_LIST__[0];\n    unsigned long i;\n    for(i=nptrs;i>=1;i--)\n        __CTOR_LIST__[i]();\n}\n```\n\n### 析构\n\n全局对象的析构与构造的工作类似，如.init变成.finit、`_do_global_ctors_aux`变成`_do_global_dtor_aux`、`__CTOR_LIST__`对应`__DTOR_LIST__`；但是注意，析构函数的调用顺序与构造函数的调用顺序相反。","tags":["系统编程"],"categories":["course"]},{"title":"第八章 内存","url":"/course/sp-ch8.html","content":"\n## 程序的内存布局\n\n结合上一章介绍的动态链接，再来看看进程的32位内存地址空间的布局。\n\n<div style=\"width:35%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n&nbsp;\n\n## 栈与调用惯例\n\n### 栈\n\n栈用于维护函数调用的上下文，栈通常从用户空间最高地址开始，栈从高地址向低地址增长。\n\n在x86架构下，esp寄存器始终指向栈顶。栈保存了每个函数调用所需要维护的信息，维护的每个函数调用的信息称为一个活动记录。ebp寄存器指向当前活动记录的一个固定位置。如下是一个典型的活动记录示意图。\n\n<div style=\"width:35%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\nebp寄存器始终指向当前活动记录的old EBP，ebp-4是函数的返回地址、ebp-8、ebp-12等等是函数的参数的地址。\n\nx86架构下标准的函数从进入到退出序列如下。\n\n```assembly\npush ebp\nmov ebp, esp\nsub esp, x\npush reg1\n...\npush regn\n[Function instructions]\npop regn\n...\npop reg1\nmov esp, ebp\npop ebp\nret\n```\n\n### 调用惯例\n\n函数调用者传递的参数需要被函数正确地理解，如使用寄存器还是栈传参、参数压栈顺序为从左到右还是从右到左。为此，函数的调用方与与其自身需要有一个明确的约定，只有双方同时遵守同样的约定，函数才能正确的执行。这样的约定称为**调用惯例**。\n\n调用惯例通常会规定如下几个方面的内容。\n\n* 参数的传递顺序与方式；\n* 栈的维护方式；被压入栈中的参数被函数弹出还是被函数调用者弹出；\n* 名字修饰策略；如在函数名前下划线；\n\nC语言默认使用cdecl调用惯例：从右到左的顺序压参数入栈、栈由函数调用者维护、函数名修饰为在函数名前加下划线。\n\n### 函数返回值的传递\n\n一般来说，函数将其返回值存入eax寄存器，函数调用者访问eax寄存器获取调用的函数的返回值。但是在x86架构下，eax只有4个字节，如果返回值多余4个字节，但是没有超过8个字节，则使用eax与edx联合返回；那么，如果返回值特别长，远远大于8字节，该怎么传递返回值。\n\n解决办法是(被调用)函数在栈上为返回值开辟一段空间，然后将返回值复制到栈上，然后返回返回值的地址，调用者再根据返回的地址复制返回值到其内部的变量。此时，一个大尺寸的返回值会被复制两次，因此在程序编写过程中极其不建议返回大尺寸的值。\n\n## 堆与内存管理\n\n### 堆\n\n用来容纳应用程序动态分配的内存区域，程序使用malloc或new分配的内存就来自堆。进程申请内存空间需要使用系统调用，而如果程序对堆的操作比较频繁，那么就要频繁地调用开销很大的系统调用，为此，进程会向操作系统申请一块适当大小的内存作为堆空间，然后由进程自行管理这块内存空间，具体来说，是由程序的运行库向操作系统申请堆空间并管理堆空间的分配。\n\n### Linux进程堆管理\n\nLinux系统提供了两种堆空间的申请方式，即两个系统调用：brk与mmap；brk的功能是设置进程数据段的结束地址Program break；\n\n<div style=\"width:56%;margin:auto\">{% asset_img 15.png pic15 %}</div>\n\n&nbsp;\n\nProgram break向高地址移动，扩大的内存空间作为堆空间。mmap的功能是向操作系统申请一段虚拟地址空间。\n\n### 堆分配算法\n\n堆分配问题其实就是如何管理一大块连续的内存空间，可以按照需求分配、释放其中的空间。\n\n**空闲链表**：将堆中的空闲空间使用双向链表组织起来；当用户请求空间时，遍历整个链表，直到找到合适大小的空闲块并将其拆分。当用户释放空间时将其加入链表或链表的某个空闲块中。这种堆分配算法实现简单，但是不稳定。\n\n**位图**：将整个堆空间划分为大量的块，当用户请求内存时，算法会分配整数个块给用户，分配的第一个块称为头，其余的称为主体；可以使用一个数组来记录块的分配情况——空闲/主体/头，因此每2比特就可以表示一个块的状态。因此叫做位图。位图具有速度块、稳定性好的特点；但是容易产生内碎片。\n\n**对象池**：由于在某些情况下，用户会频繁地申请几个较为固定长度的内存，针对这种情况，堆分配算法可以将这些固定长度的内存作为单位，每次用户申请这些固定长度的内存时只需要找到一个对应长度的单位即可。对象池的管理可以使用空闲链表，也可以使用位图。\n\n实际应用的堆分配算法是上述多种分配算法的组合。","tags":["系统编程"],"categories":["course"]},{"title":"第七章 Linux共享库的组织","url":"/course/sp-ch7.html","content":"\n## 共享库版本\n\n### 共享库的兼容性\n\n在共享库升级时有如下4种修改会导致C语言的共享库二进制接口发生改变。\n\n* 导出函数的行为发生改变；\n* 导出函数被删除；\n* 导出数据的结构发生变化；\n* 导出函数的接口发生变化，如函数的返回值、参数变化；\n\n### 共享库版本命名\n\n共享库升级导致的不兼容是不可避免的，为此，只有对共享库进行版本命名：x.y.z；其中x为主版本号，y为次版本号，z为发布版本号；主版本号表示共享库的重大升级，不同主版本号的共享库之间不兼容；次版本号表示共享库的增量升级，主版本号相同时，次版本号高的共享库可兼容次版本号低的共享库。发布版本号表示库中错误的修正、函数性能的提升等，既不添加新的接口，也不对接口进行修改；相同主、次版本号的共享库完全兼容。\n\n### SO-NAME\n\n在ELF文件中用SO-NAME来命名一个依赖的共享库，具体做法为去掉共享库名称中的次、发布版本号；如ELF依赖共享库libfoo.so.2.6.1，则这个共享库对应的SO-NAME为libfoo.so.2。在Linux系统中，系统会为每个共享库在其所在目录创建一个以其SO-NAME为名的软链接指向其自身。通过软链接可以定向到相同主版本号中最新版本的共享库。这是因为在Linux系统安装或更新一个共享库时，会运行ldconfig工具，该工具会遍历所有的默认共享库目录，如/lib、/usr/lib，并更新所有的软链接，将其指向最新版本的共享库。\n\n### 链接名\n\n需要链接一个libXXX.so.x.y.z的共享库，只需要在GCC编译时加上-lXXX选项即可！其中，XXX也被称为链接名。\n\n## 符号版本\n\n如果一个ELF可执行文件所依赖的共享库的次版本号高于系统中该共享库的次版本号(主版本号相等)，SO-NAME机制也解决不了此时有可能发生的不兼容问题。为此，现在的操作系统使用一种更加精巧的机制——符号版本。\n\n符号版本的基本思路是：对共享库中每个导入&导出的符号关联一个版本号，每次共享库升级时，给那些新添加/修改的符号关联升级后的共享库版本命名。\n\n## 共享库系统路径\n\n目前包括Linux在内的大部分开源操作系统都遵守FHS标准，这个标准规定了一个系统中的系统文件该如何存放，以及每个目录的组织与作用，共享库作为系统中重要的文件，也是如此。FHS规定：一个系统中主要有两个存放共享库的位置——/lib与/usr/lib，以及一个存放第三方程序共享库的位置/usr/local/lib。\n\n* /lib。存放系统中最关键的共享库，如动态链接器、C语言运行库、数学库等，这些库主要被/bin与/sbin下的程序用到，以及系统启动所需；\n* /usr/lib。存放开发时会用到的共享库；\n* /usr/local/lib。存放第三方应用程序所需的共享库；\n\n## 共享库的查找\n\n一个动态链接的可执行文件所依赖的共享库的路径保存在.dynamic段中，由DT_NEED类型的项表示；保存的路径可以是绝对路径或相对路径，考虑到程序的可移植性，一般使用相对路径。\n\n为加快共享库的查找速度，ldconfig会建立SO-NAME缓存存放在/etc/ld.so.cache，/etc/ld.so.cache的特殊结构极其利于查找。若动态链接器未在/etc/ld.so.cache找到共享库，才会去遍历/lib与/usr/lib这两个目录。如果仍然没有找到，则会返回错误信息。\n\n## 环境变量\n\n* LD_LIBRARY_PATH。临时改变某个应用程序的共享库查找路径；因此更准确地说，动态链接器最先去LD_LIBRARY_PATH指定的路径下查找共享库；\n* LD_PRELOAD。指定预先装载的共享库或目标文件，LD_PRELOAD指定的文件会在动态链接器按照既定规则搜索共享库进行装载之前被装载，无论程序是否依赖它们。\n* LD_DEBUG。设置该环境变量之后，动态链接器会在运行时打印各种有用的信息。\n\n<div style=\"width:32%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n<div style=\"width:35%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n## 共享库的创建与安装\n\n### 创建共享库\n\n在GCC编译时，加上`-shared`与`-fPIC`两个选项，就可以输出共享库；此外，还可以加上`-WI`选项，该选项可以将指定的参数传递给链接器，如`-WI, -soname, my_soname`就是将`-soname my_soname`传递给链接器，用来指定生成的共享库的SO-NAME。如下是一个GCC编译出共享库的例子。\n\n```bash\ngcc -shared -fPIC -Wl,-soname,libfoo.so.1 -o libfoo.so.1.0.0 libfoo1.c libfoo2.c -lbar1 -lbar2\n```\n\n在链接器输出可执行文件时，只会将那些在链接时被其他共享模块引用到的符号放到动态符号表，则动态加载模块在被加载时无法引用主模块在链接时未被其他共享模块引用的符号，即**反向引用**失败。为避免上述问题，ld链接器提供了-export-dynamic参数，该参数指定ld链接器在输出可执行文件时将所有全局符号导出到全局符号表。\n\n### 清除符号信息\n\nstrip工具可清除共享库/可执行文件的所有符号与调试信息。\n\n### 安装共享库\n\n安装共享库最简便的方法是将其复制到某个标准的共享库目录，再运行ldconfig。需要root权限。\n\n### 共享库构造与析构函数\n\nGCC提供了为共享库定义构造/析构函数的方法：在函数声明时加上`__attribute__((constructor))`或`__attribute__((destructor))`修饰。同时，GCC还支持为构造/析构函数指定优先级，如`__attribute__((constructor(5)))`，对于构造函数，优先级越小越先于其他构造函数执行，而对于析构函数与之相反。\n\n### 共享库脚本\n\n事实上，共享库除了是ELF共享对象文件外，还可以是链接脚本，例如将C运行库与数学库结合起来的共享库libfoo.so文件的内容可以是\n\n```bash\nGROUP( /lib/libc.so.6 /lib/libm.so.2)\n```","tags":["系统编程"],"categories":["course"]},{"title":"第六章第二节 动态链接的实现与显式运行时链接","url":"/course/sp-ch6-par2.html","content":"\n## 动态链接的实现\n\n### 动态链接器自举\n\n动态链接器是一个特殊的共享对象！首先，动态链接器本身不能依赖于其他任何共享对象；其次，共享对象本身所需要的全局&静态变量&函数地址的重定位工作由它自身完成。为了完成第二个目标，动态链接器必须使用一段非常精巧的代码，这段启动代码便称为**自举**。\n\n自举代码在动态链接器入口处，自举代码首先找到自身的GOT，而GOT的第一项为.dynamic段，自举代码便可以通过.dynamic段的信息获得动态链接器本身的重定位表与符号表等，从而得到动态链接器本身的重定位入口，将重定位表中所有项重定位。从这一步开始，动态链接器的代码中才能使用自己的全局&静态变量以及调用函数。\n\n### 装载共享对象\n\n动态链接器完成自举之后，动态链接器将可执行文件与自身的符号表合并到一个符号表中——全局符号表。然后链接器根据.dynamic段的内容开始寻找可执行文件所依赖的共享对象，如果依赖的共享对象还依赖其他共享对象，同样将其装载到进程的地址空间。具体的装载算法可使用深度优先或广度优先。\n\n在装载共享对象时存在一个**全局符号介入**的问题，当一个符号需要被加入到全局符号表中时，如果相同的符号名已经存在，则后加入的符号会被忽略。\n\n由于编译器在编译时将模块内部的函数当作模块外部函数处理，因此，若希望加快函数调用速度，可以对函数加上static修饰，将函数作为编译单元私有函数，使用第一种地址引用方式。\n\n### 重定位与初始化\n\n有了全局符号表，链接器遍历可执行文件与每个共享对象的重定位表，将GOT&PLT中每个需要重定位的位置进行修正。重定位的操作与静态链接的重定位操作相同。重定位之后，如果共享对象有.init段，则动态链接器会执行.init段中的代码；相应地，共享对象还会有.finit段，当进程退出时会执行.finit段中的代码。接下来，动态链接器将控制权交给可执行文件。\n\n动态链接器作为共享对象，也可以作为可执行文件运行。动态链接器是静态链接的。\n\n## 显式运行时链接\n\n显式运行时链接是一种比动态链接更加灵活的模块加载方式，它让程序在运行时自己控制加载指定的模块，并在不需要某模块时将其卸载。此时的模块称为动态装载库，它与共享对象并无差别。\n\n动态链接由动态链接器完成，而显式运行时链接需要由程序来完成，因此动态链接器提供了一系列API来支持程序完成动态装载库的装载。\n\n* dlopen：打开一个动态库，并将其加载到进程的地址空间；\n* dlsym：找到动态装载库的符号，并返回符号的值；\n* dlerror：每次调用dlopen、dlsym、dlclose之后，都需要调用dlerror来判断上一次调用是否成功；\n* dlclose：卸载加载的模块，事实上，操作系统会为每个模块维护一个计数器，每有一个进程调用dlopen加载该模块，该模块对应的计数器加1；每有一个进程调用dlclose卸载该模块，该模块对应的计数器减1；只有当模块对应的计数器为0时才会真的被卸载，动态链接器首先执行.finit段中的代码，然后从进程的全局符号表中删除该模块中的符号，取消进程地址空间与模块的映射关系，最后关闭模块文件。","tags":["系统编程"],"categories":["course"]},{"title":"第六章第一节 动态链接基础","url":"/course/sp-ch6-par1.html","content":"\n## 动态链接的意义\n\n**静态链接的不足**：浪费计算机内存与磁盘空间(许多公用库函数在内存&可执行文件中有多份，这是没有必要的)；极大降低程序开发的效率(一旦程序中有任一模块更新，整个程序就要重新链接，然后发布给用户)。\n\n为了避免这些不足，出现了动态链接——将程序需要的模块相互分割开，等运行时再进行链接。使得程序具有可扩展性，在运行时可以动态地选择加载各种程序模块。\n\nELF动态链接文件以.so为扩展名，在Windows系统中动态链接库以.dll为扩展名。\n\n## 地址无关代码\n\n显然，动态链接必然要求共享对象在被装载前无法得知其装载地址。与链接时重定位不同，由于指令是多个进程之间共享的，共享对象映射到每个进程的地址空间中的虚拟地址是不同的，从而指令中对绝对地址的引用也是不同的，这就导致指令部分无法在多进程之间共享。\n\n解决办法是将指令中会因装载地址改变而改变的部分分离出来，与数据部分放在一起。于是多个进程可以共享指令部分，而数据部分每个进程都有一个副本。这就是地址无关代码。\n\n那么编译器如何编写地址无关的代码，先考虑在源代码中有哪些地址引用方式。按照是否跨模块与指令引用OR数据访问分成如下。\n\n* 模块内部的函数调用、跳转；\n* 模块内部的数据访问；\n* 模块外部的函数调用、跳转；\n* 模块外部的数据访问；\n\n**对于第一种地址引用方式** 被调用函数与调用指令的相对位置固定，可使用相对地址调用或基于寄存器的相对调用，对于这种指令无需重定位。\n\n**对于第二种地址引用方式** 被访问变量与访问指令的相对位置固定，但是，现代的计算机体系结构中没有相对于当前指令地址的寻址数据方式，因此在ELF文件中用如下巧妙的方式来得到当前指令地址；\n\n在需要知道当前指令地址的指令前调用`__i686.get_pc_thunk.cx`函数如下所示；\n\n```assembly\n00000494 <__i686.get_pc_thunk.cx>:\n 494:   8b 0c 24               mov (%esp), %ecx\n 497:   c3                     ret\n```\n\n这时因为CPU执行call指令时会将下一指令的地址压栈，而esp寄存器始终指向栈顶，因此`__i686.get_pc_thunk.cx`函数的作用就是将需要知道的指令地址存入ecx寄存器。之后加上偏移得到数据的绝对地址即可访问变量。\n\n**对于第四种地址引用方式** 被访问变量所在模块的装载地址在装载前不确定，因此被访问变量的绝对地址在装载前也不确定。为保证代码的地址无关性，ELF在数据段建立一个指向这些变量的指针数组——全局偏移表GOT，代码通过GOT中对应项间接访问变量。链接器在装载模块时会查找每个变量所在地址，并填充.got表中各项。而访问.got表中对应项即第二种地址引用方式。\n\n**对于第三种地址引用方式** 为加快程序的启动速度，ELF对于模块外部的函数采用**延迟绑定**——当函数第一次被调用时将其绑定。ELF将GOT拆分为.got与.got.plt两个表，分别保存全局变量的地址与外部函数的地址；其中，.got.plt的前三项分别为.dynamic段的地址、本模块的ID、_dl_runtime_resolve函数的地址，之后就是外部函数的地址。不同的是，链接器在装载模块时并不会将外部函数进行绑定。\n\n使用readelf查看所有段的信息。\n\n```bash\nobjdump -s -d Lib.so\n```\n\n### 延迟绑定的实现\n\n为了实现延迟绑定，ELF在间接访问外部函数的过程中增加了一次间接跳转，调用外部函数gfun时先跳转到外部函数在.plt表中对应项gfun@plt，gfun@plt的实现如下。\n\n```assembly\ngfun@plt:\njmp *(gfun@got) #gfun@got为gfun在.got表中对应项，即gfun的地址，为实现延迟绑定，gfun@got最初存放的是下面push n指令的地址\npush n #n为gfun这个符号在重定位表.rel.plt中的下标\njmp PLT0\n```\n\n其中，PLT0为.plt表中第一项，它的实现为\n\n```assembly\npush *(GOT+4) #GOT为.got.plt表的地址，而根据.got.plt表的前三项内容可知，该指令是将本模块的ID压栈\njmp *(GOT+8) #同理，该指令跳转到_dl_runtime_resolve函数处执行，该函数用来绑定gfun函数，前面的压栈是模拟函数的参数进栈\nnopl #.plt表中每一项为16字节\n```\n\n要使gcc编译时产生地址无关代码，加上-fPIC选项即可。要想判断一个so文件是否是地址无关代码，可使用如下命令。\n\n```bash\nreadelf -d lib.so | grep TEXTREL\n```\n\n### 共享对象的全局变量\n\n由于共享对象的全局变量可能在模块外部修改，因此编译器在编译共享对象时，默认将模块内部的全局变量当作模块外部的全局变量。采用上述第四种地址引用方式访问全局变量。共享对象被装载时，对其中的全局变量var：若var在可执行文件中被分配了空间，则var在GOT中的地址指向可执行文件中的var(若var在共享对象中被初始化，还需要将初始化的值复制到可执行文件的var)；否则，var在GOT中的地址指向共享对象内的var。\n\n## 动态链接相关结构\n\n### .interp段\n\n.interp段中保存可执行文件所需动态链接器的路径。通常为/lib64/ld-linux-x86-64.so.2，这是一个软链接，从而动态链接器更新版本时只需要将/lib64/ld-linux-x86-64.so.2指向新的动态链接器，而不用改动可执行文件的.interp段。\n\n### .dynamic段\n\n.dynamic段保存动态链接器所需的基本信息(依赖的共享对象、动态链接符号表地址、动态链接重定位表地址，共享对象初始化代码地址等)。.dynamic段就是一个结构体数组，结构体定义如下。\n\n```c\ntypedef struct{\n    Elf32_Sword d_tag;\n    union{\n        Elf32_Word d_val;\n        Elf32_Addr d_ptr;\n    }d_un;\n}Elf32_Dyn;\n```\n\nd_tag代表后面的d_un的含义，常见的d_tag类型及其含义如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n&nbsp;\n\n使用readelf工具可查看.dynamic段的内容。\n\n```bash\nreadelf -d Lib.so\n```\n\n### 动态符号表\n\n保存动态链接的共享模块间符号的导入导出关系。动态符号表在可执行文件中为.dynsym段。\n\n### 动态链接重定位表\n\n.rel.dyn段修正的地址位于.got段与数据段，.rel.plt修正的地址位于.got.plt(也存在.got未被拆分的情况，此时.rel.plt修正的符号也位于.got)。使用readelf工具可查看可执行文件的重定位表。\n\n```bash\nreadelf -r Lib.so\n```\n\n其中有如下三种类型的重定位入口：R_386_RELATIVE、R_386_GLOB_DAT、R_386_JUMP_SLOT。R_386_GLOB_DAT与R_386_JUMP_SLOT。被修正位置只需要直接填入符号的地址即可；R_386_RELATIVE入口的重定位方式为基址重置，这是由于编译器在编译共享对象时，为其分配的地址空间从0开始，假设一个静态变量的地址为B，则对此静态变量的地址重定位时，再加上共享对象的装载地址A，即A+B。\n\n### 进程堆栈初始化\n\n同样地，操作系统在将控制权交给动态链接器之前，会在进程的堆栈中保存动态链接器所需信息，以辅助信息结构体数组的形式存放，结构体定义如下。\n\n```c\ntypedef struct{\n    uint32_t a_type;\n    union{\n        uint32_t a_val;\n    }a_un;\n}Elf32_auxv_t;\n```\n\n该结构体定义与.dynamic段的结构体定义类似，a_type为类型值，a_val为数值，常见的类型及其含义如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n<div style=\"width:60%;margin:auto\">{% asset_img 10.png pic10 %}</div>\n\n&nbsp;\n\n辅助信息数组存放在环境变量指针之后。","tags":["系统编程"],"categories":["course"]},{"title":"第五章 可执行文件的装载与进程","url":"/course/sp-ch5.html","content":"\n## 可执行文件的装载\n\n### 进程的建立\n\n* 创建虚拟地址空间。事实上只需要分配一个页目录表。其中的内容等到发生缺页中断再填写。\n* 读取可执行文件头，建立虚拟地址空间与可执行文件的映射关系。以便在发生缺页中断时定位到该缺页在可执行文件中的位置。\n* 将可执行文件入口地址写入CPU指令寄存器，CPU开始运行。\n\n## 进程的虚拟空间分布\n\n### Segment & Section\n\n在操作系统装载可执行文件时，对每个段只区分其权限(可读可执行、可读可写、只读)。为了提高内存的利用效率，可将相同权限的段合并，这时用Segment表示相同权限的段的合并。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\nSegment的信息保存在ELF可执行文件的程序头表中。\n\n### 堆与栈\n\n常见的进程的虚拟地址空间如下。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n&nbsp;\n\n堆与栈共用同一内存区域，统称堆栈。堆从区域底部向上增长，栈从区域顶部向下增长，可用如下程序验证。\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nunsigned int stack_inc_dir(unsigned int * pid){\n\tunsigned int id=0x42;\n\tif(pid){\n\t\tid++;\n\t\tprintf(\"Stack increase from %p to %p\\n\", pid, & id);\n\t\treturn id;\n\t}\n\telse\n\t\treturn stack_inc_dir(& id);\n}\n\nunsigned int heap_inc_dir(){\n\tunsigned int * ip1, * ip2;\n\tif(!(ip1=(unsigned int *)malloc(16))||\n\t\t\t!(ip2=(unsigned int *)malloc(64)))\n\t\treturn -1;\n\tprintf(\"Heap increase from %p to %p\\n\", ip1, ip2);\n\treturn 0;\n}\n\nint main()\n{\n\treturn stack_inc_dir(NULL)|heap_inc_dir();\n}\n//gcc stack_heap.c -o stack_heap\n```\n\n### 多段共享\n\n由于页是(虚拟地址与物理地址)映射的最小单位。因此每一段的起始地址都要是4K的整数倍，这样会产生大量的内部碎片，从而极大降低了内存的利用效率。为此，Unix让各段相接部分共享同一物理页面，具体做法如下例。\n\nELF文件的起始虚拟地址为0x08048000，第一个虚拟内存区域VMA0的长度为0x709e5，因此第一个虚拟内存区域VMA0的结束地址为0x080b89e5。VMA0并未将以0x080b8000为起始地址的虚拟页对应的物理页面用完，于是VMA0要与下一段共享以0x080b8000为起始地址的虚拟页对应的物理页面。又因为段的起始地址必须是4字节的倍数，因此下一段从下一虚拟页的0x9e8偏移处开始，即0x080b99e8。\n\n### 进程栈的初始化\n\n进程在刚开始启动时，需要知道一些进程运行的环境参数，常见的做法是操作系统在进程启动前将这些信息保存到进程的虚拟地址空间的堆栈上。在bash上以`prog 123`命令运行的进程的栈的初始化状态如下图所示。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n栈顶指针esp指向栈顶(堆栈区域的最低地址)，首4字节存放命令行参数的数目。接下来的两个4字节为指向两个参数的指针，然后一个值为0的4字节，作为分隔标记。接下来的两个4字节存放环境变量的指针。然后一个值为0的4字节，作为分隔标记。然后是命令行参数与环境变量。\n\n## ELF可执行文件的装载\n\n宏观层面来说，Linux调用exec来装载可执行文件到内存。而exec调用sys_execve，sys_execve进行一些参数的检查复制后，调用do_execve，do_execve首先查找被执行的文件，如果找到，则读取其前128字节(这是因为Linux支持的可执行文件不止一种，因此需要通过文件最开始的128字节来判断文件格式)，对于ELF可执行文件，do_execve确定其文件格式后，调用load_elf_binary来装载ELF可执行文件。load_elf_binary处理流程如下。\n\n* 检查ELF可执行文件格式的有效性。\n* 寻找动态链接的`.interp`段，设置动态链接器路径。\n* 根据程序头表建立虚拟地址空间与可执行文件的映射。\n* 初始化进程的运行环境。\n* 修改系统调用的返回地址为ELF可执行文件的入口地址(对于静态链接的ELF文件，程序入口地址为ELF文件头中e_entry所指地址；对于动态链接的ELF文件，程序入口地址为动态链接器地址)。","tags":["系统编程"],"categories":["course"]},{"title":"第四章 静态链接","url":"/course/sp-ch4.html","content":"\n## 空间与地址分配\n\n链接器获得所有输入目标文件的段长度，将每种段合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。\n\n## 符号解析与重定位\n\n链接器将目标文件合并后，根据合并文件中的段的数据、重定位信息进行符号解析与重定位，调整代码中的地址。\n\n### 重定位\n\n目标文件中每个需要重定位的段都有一个对应的重定位段。例如，如果代码段需要重定位，则目标文件中会有一个.rela.text段，重定位表是所有重定位段的统称。使用objdump工具来查看目标文件的重定位表。\n\n```bash\nobjdump -r simple_section.o\n```\n\n重定位表的每一项的结构定义如下。\n\n```c\ntypedef struct {\n    Elf32_Addr r_offset;\n    Elf32_Word r_info;\n}\n```\n\n* r_offset。重定位入口的偏移。对于可重定位文件来说，r_offset为该重定位入口所用修正的位置的第一个字节相对于段起始的偏移。对于可执行文件或共享对象来说，r_offset是该重定位入口所要修正的位置的第一个字节的虚拟地址。\n* r_info。重定位入口的类型与符号。低8位表示重定位入口的类型，高24位表示重定位入口的符号在符号表中的下标。\n\n### 指令修正方式\n\n重定位入口的类型有两种：绝对近址32位寻址与相对近址32位寻址，不同的重定位入口类型的指令修正方式也不同。记\n\nA为保存在修正位置的值\n\nP为被修正的位置\n\nS为符号的实际地址\n\n则绝对近址32位寻址的修正方法为S+A，相对近址32位寻址的修正方法为S+A-P。\n\n## BFD库\n\n不同的软硬件平台导致了不同的目标文件格式不同，为了使编译器能够统一地处理这些目标文件，BFD库提供一个统一的接口来处理不同的目标文件格式。","tags":["系统编程"],"categories":["course"]},{"title":"第三章 目标文件","url":"/course/sp-ch3.html","content":"\n## 目标文件的格式\n\n不仅是目标文件(.o与.obj)按照可执行文件(.elf与.exe)格式存储，动态链接库(.so与.dll)与静态链接库(.a与.lib)也按照可执行文件格式存储。对于静态链接库，稍有不同的是它将多个目标文件拼在一起，再加上一些索引形成一个文件。ELF文件标准将系统中采用的ELF格式的文件分为如下4类。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n<div style=\"width:70%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\n在Ubuntu上可使用file命令查看一个文件的格式。\n\n## 目标文件的内容\n\n可执行文件主要有.text代码段(存放执行指令)，.data数据段(已初始化的全局变量与局部静态变量)，.bss段(未初始化的全局变量与局部静态变量)。.bss段为未初始化的全局变量与局部静态变量预留位置，在文件中不占据空间。\n\nQ：分段的好处？\n\nA：安全性(数据段可读，代码段可执行)，共享(当系统运行程序的多个副本，内存中只需要保存一份程序的指令部分，即代码段)，良好的局部性。\n\n### 整体结构\n\n使用objdump工具来查看目标文件的结构与内容。\n\n```bash\n# -c参数指定只编译，不链接\ngcc -c simple_section.c\n# -h参数指定只打印各个段的基本信息\nobjdump -h simple_section.o\n```\n\n其中simple_section.c内容如下。\n\n```c\n#include <stdio.h>\n\nunsigned int global_init_var=84;\n\nunsigned int global_uninit_var;\n\nint func(unsigned int);\n\nint func(unsigned int N){\n\tunsigned int X,Y;\n\tX=N;\n\tY=N+1;\n\twhile(X){\n\t\tY+=X;\n\t\tX--;\n\t}\n\treturn Y;\n}\n\nint main(char * * argv, int argc){\n\tunsigned int ret;\n\tret=func(global_init_var);\n\tprintf(\"func(global_init_var)=%d\\n\", ret);\n\treturn 0;\n}\n```\n\n分析结果如下。\n\n```bash\nsimple_section.o:     file format elf64-x86-64\n\nSections:\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .text         00000069  0000000000000000  0000000000000000  00000040  2**0\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE\n  1 .data         00000004  0000000000000000  0000000000000000  000000ac  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  2 .bss          00000000  0000000000000000  0000000000000000  000000b0  2**0\n                  ALLOC\n  3 .rodata       0000001a  0000000000000000  0000000000000000  000000b0  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  4 .comment      0000002a  0000000000000000  0000000000000000  000000ca  2**0\n                  CONTENTS, READONLY\n  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000f4  2**0\n                  CONTENTS, READONLY\n  6 .eh_frame     00000058  0000000000000000  0000000000000000  000000f8  2**3\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA\n```\n\n可以看到simple_section.o有如下段：.text、.data、.bss、.rodata、.comment、.note.GNU-stack、.eh_frame。各段的分布大致如下。\n\n```bash\n      |        |\n      |--------|0xf4\n      |        |\n0x2a  |.comment|\n      |        |\n      |        |\n      |--------|0xca\n      |        |\n0x1a  |.rodata |\n      |        |\n      |--------|0xb0\n0x04  |.data   |\n      |------- |0xac\n      |------- |0xa9\n      |        |\n      |        |\n0x69  |        |\n      |.text   |\n      |        |\n      |        |\n      |--------|0x40\n```\n\n此外，readelf工具可对ELF格式文件进行分析。\n\n### 代码段\n\n使用objdump也可以查看代码段。\n\n```bash\n#-s 参数指定以16进制打印数据，-d 参数将指令部分反汇编\nobjdump -s -d simple_section.o\n```\n\n### 只读数据段\n\n在.rodata段中存放只读数据，一般是程序中的字符串常量与const修饰的变量。\n\n### 数据段\n\n数据段信息如下。\n\n```bash\nContents of section .data:\n 0000 54000000                             T...            \n```\n\n从这里可以看出：x86架构的CPU使用的小端字节序(高位字节存放在高地址，低位字节存放在低地址)，与之对应的还有大端字节序(网络设备传输字节使用大端字节序，高位字节存放在低地址，最先传输)。\n\n### 其他段\n\n其他段的说明如下。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\nGCC提供扩展机制使程序编写者可指定变量所处段：`__attribute__((section(\"name\")))`。\n\n## ELF文件结构\n\n<div style=\"width:35%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n### 文件头\n\n使用readelf工具来查看ELF的文件头。\n\n```bash\nreadelf -h simple_section.o\n```\n\n### 段表\n\n段表描述ELF文件各个段的信息，包括每个段的名称、长度、偏移、读写权限等。\n\n用readelf工具来查看段表的内容。\n\n```bash\nreadelf -S simple_section.o\n```\n\n段表中的元素是`段描述符`，第一个元素为NULL，无效的段描述符。\n\n### 重定位表\n\n链接器在链接目标文件时，需要对来自其他模块的变量或函数进行重定位。需要重定位的变量或函数以及重定位所需的信息保存在重定位表中。\n\n### 字符串表\n\n由于字符串的长度不固定，为了用固定的长度表示字符串，常见的做法为：将字符串集中存放到一个字符串表，然后使用字符串在表中偏移来引用字符串。\n\n## 符号\n\n在链接时，函数与变量统称为符号，函数名或变量名即为符号名。目标文件中都有一个符号表，记录了目标文件中所有符号及其相关信息(符号名、符号值、符号大小、符号类型与绑定信息、符号所在段)。链接器重点关注每个目标文件中的定义全局符号与被引用的全局符号。\n\n### 符号表结构\n\n符号表在目标文件中通常作为一个段——.symtab，使用readelf工具来查看目标文件的符号表。\n\n```bash\nreadelf -s simple_section.o\n```\n\n### 特殊符号\n\n链接器在链接目标文件时会定义很多特殊符号，虽然未在源代码中定义，但是可以直接声明并引用它们。这就是特殊符号。如下例。\n\n```c\n#include <stdio.h>\n\nextern char __executable_start[];\nextern char etext[], _etext[], __etext[];\nextern char edata[], _edata[];\nextern char end[], _end[];\n\nint main()\n{\n\tprintf(\"Executable start %X\\n\", __executable_start);\n\tprintf(\"Text end %X %X %X\\n\", etext, _etext, __etext);\n\tprintf(\"Data end %X %X\\n\", edata, _edata);\n\tprintf(\"Executable end %X %X\\n\", end, _end);\n\treturn 0;\n}\n```\n\n### 符号修饰与函数签名\n\n为了防止符号名冲突，Unix下C语言规定：源代码中所有全局变量与函数经过编译后在符号名前加\"_\"。C++为支持重载，编译器增加了符号修饰机制。修饰后的名称因函数名、参数类型、所在类与名称空间等性质的不同而不同。\n\n### extern \"C\"\n\nC++编译器会将`extern \"C\"`的大括号内部的代码当作C语言处理。相应地，若C++源代码中要包含C语言库，就存在符号修饰不一致的问题，为解决这个问题，借助宏`__cplusplus`，C++编译器在编译C++源代码时会定义这个宏，于是可以通过这个宏是否被定义判断当前编译的语言是C语言还是C++。而如果是C++，则包含C语言库的语句要用`extern \"C\"`括号包含。\n\n### 弱符号与强符号\n\n对C语言与C++，编译器默认函数与初始化了的全局变量为强符号，未初始化的全局变量为弱符号。使用`__attribute__((weak))`在GCC编译时将强符号修饰为弱符号。\n\n在链接时，强符号不允许被多次定义；若一个符号在某个目标文件中是强符号，而在其他文件中是弱符号，链接器选择链接强符号；若一个符号在所有目标文件中均为弱符号，链接器选择链接占用空间最大的那个。\n\n**弱引用与强引用**：对一个强引用的符号，若链接器在链接时找不到该符号的定义，则会报符号未定义错误，而对于弱引用符号，则不会报错。使用`__attribute__((weakref))`可将对一个函数的引用声明为弱引用。","tags":["系统编程"],"categories":["course"]},{"title":"第二章 编译与链接","url":"/course/sp-ch2.html","content":"\n## 预处理\n\n预处理主要处理源代码文件中以`#`开头的预处理指令，预处理的工作如下：\n\n* 删除所有`#define`，展开所有宏定义；\n* 处理所有条件预处理指令(如`#if`、`#endif`、`#elif`、`#else`、`#endif`)；\n* 处理`#include`预处理指令，将被包含的文件插入预处理指令的位置。\n* 删除所有的注释；\n* 添加行号与文件名标识；\n* 保留所有`#pragma`编译器指令；\n\ngcc使用如下命令进行预处理。\n\n```bash\ngcc -E hello.c -o hello.i\n```\n\n## 编译\n\n* 词法分析：使用一种类似于有限自动机的算法将源代码的字符序列分割为一系列的记号。在Ubuntu上有一个flex的程序可实现词法分析。\n* 语法分析：使用上下文无关语法对词法扫描的记号进行语法分析，生成语法树。在Ubuntu是有一个bison的程序可实现语法分析。\n* 语义分析：静态语义分析包括声明、类型的匹配与转换。\n* 中间优化：源代码优化器将语法树转换成中间代码，然后对中间代码进行优化。中间代码使得编译器被分成前端与后端，前端负责产生与机器无关的中间代码，后端将中间代码转换成目标机器代码。这样，跨平台的编译器只需要一个前端，而针对不同的目标机器设计不同的后端。\n* 目标代码生成与优化：后端包括代码生成器与目标代码优化器。\n\n经过上述步骤得到的目标代码还有一个问题没有解决——定义在其他模块的变量与函数的地址怎么确定？这需要借助链接器！\n\n## 汇编\n\n将汇编代码转换为机器语言。\n\n## 链接\n\n链接包括地址与空间分配、符号绑定与重定位(链接器在链接时修正跨模块函数、变量的地址)。","tags":["系统编程"],"categories":["course"]},{"title":"第一章 前言","url":"/course/sp-ch1.html","content":"\n## Questions\n\n(1)程序为什么要被编译器编译之后才能运行？\n\n(2)编译器是如何将C语言程序转化成可执行的机器码的？\n\n(3)可执行文件中有哪些内容，它们是如何组织的？\n\n(4)解释`#include<stdio.h>`的作用，C语言库是什么？要如何实现？\n\n(5)不同的编译器、硬件平台以及操作系统，编译同一源代码的结果是否相同？为什么？\n\n(6)一个程序是如何运行的？(如何装载、从哪里执行、到哪里结束、结束之后又会发生什么)\n\n(7)一个程序在没有操作系统的机器上如何才能运行？\n\n(8)printf函数是如何实现的？\n\n(9)程序在运行时，它在内存中的组成？\n\n在学习完《程序员的自我修养》之后，对上述问题的[回答](http://localhost:4000/course/sp-ch11.html)。\n\n## 线程\n\n### 线程基础\n\n**可抢占线程与不可抢占线程**：线程在时间片用尽之后，被操作系统剥夺继续执行的权利而进入就绪状态，这个过程称为抢占。在早期的操作系统中，线程是不可抢占的，只有运行的线程主动发出放弃执行的命令，才能让其他就绪态线程获得CPU。\n\n### 线程安全\n\n**信号量、互斥量、临界区**：信号量可以跨进程使用，允许一个或多个线程访问共享资源，可以被任意线程申请与释放；互斥量可以跨进程使用，资源在任何时刻最多被一个线程占用，但是只有获取了互斥量的线程可以释放互斥量；临界区作用于进程内部，临界区中的资源在任何时刻最多被一个线程占用。\n\n**可重入**：一个函数在未执行完的情况下，由于外部因素或内部调用，又一次进入自身执行。一个函数称为可重入的，即该函数被重入后不会产生任何不良后果。需满足如下条件：\n\n* 不使用任何(局部)静态或全局的非const变量；\n* 不返回任何(局部)静态或全局的非const变量的指针；\n* 仅依赖于调用方提供的参数；\n* 不依赖任何单个资源的锁；\n* 不调用任何不可重入的函数；\n\n**过度优化**：编译器在优化时，为了提高效率而交换两条互不相关的指令的执行顺序。CPU的动态调度技术，在执行程序时为提高效率而交换两条指令的执行顺序。\n\n为解决这些优化而导致的多线程错误。在代码中加入volatile关键字阻止过度优化，它可以做到两件事：(1)阻止编译器为了提高运行速度将一个变量缓存到寄存器而不写回；(2)阻止编译器调整volatile变量的指令顺序。\n\nCPU提供barrier指令，一条barrier指令指令阻止CPU将该指令之前的指令交换到barrier，反之亦然。","tags":["系统编程"],"categories":["course"]},{"title":"第五章 常见网络攻击","url":"/course/cn-ch5.html","content":"\n[第一节 ARP欺骗与泛洪](https://chu-kangming.gitee.io/course/cn-ch5-par1.html)\n\n[第二节 拒绝服务攻击](https://chu-kangming.gitee.io/course/cn-ch5-par2.html)\n\n[第三节 XSS攻击](https://www.cnblogs.com/tugenhua0707/p/10909284.html)","tags":["计算机网络"],"categories":["course"]},{"title":"第五章第二节 拒绝服务攻击","url":"/course/cn-ch5-par2.html","content":"\n## 拒绝服务攻击简介\n\n拒绝服务是一种耗尽CPU、内存、带宽、磁盘资源等系统资源，来阻止或削弱对网络、系统或应用程序的授权使用的行为。\n\n拒绝服务攻击使用到洪泛法、源地址欺骗、SYN欺骗等方法。下面介绍经典的拒绝服务攻击。\n\n## 洪泛攻击\n\n洪泛攻击利用大量的恶意数据包来充斥整个网络，由于这种网络阻塞，在到达目标服务器的路径上很多数据包被丢弃，合法的流量很难在\n\n洪泛攻击中存活下来，使得服务器对网络上连接请求的响应能力急剧下降。可使用ICMP、UDP、TCP SYN数据包进行洪泛攻击。\n\n### 分布式拒绝服务攻击\n\n攻击者首先入侵多台主机使其被控制，然后控制这些主机一起发送恶意数据包。\n\n### 反射攻击\n\n反射攻击，是利用网络服务系统中的正常功能，向网络服务系统发送请求(源地址为目标系统的IP地址)让其对目标系统进行响应，网络服务系统向目标系统返回大量的响应数据包来占用目标系统大量资源，从而完成攻击。反射攻击一般要求利用的网络服务能够由较少数据的请求产生较大数据的响应，如Chargen,NDS,SNMP或ISAKMP服务等。\n\n## TCP SYN Flood\n\n### 攻击原理\n\n与洪泛攻击不同(攻击带宽)，还有一类拒绝服务攻击，它是通过大量占用系统资源来导致服务器无法对其他正常的网络请求作出响应。著名的就是TCP SYN Flood。其攻击原理如下。\n\n由TCP三次握手的步骤，客户端首先发送SYN请求，服务器返回SYN+ACK响应，而如果SYN请求是伪造的，报文中的源IP并未发起TCP请求，于是当服务器返回SYN+ACK响应返回给源IP主机时，此主机不会作出回应。而服务器如果没有收到回应，会重试3-5次并等待一个SYN Time。\n\n攻击者只需发送一定量的伪造SYN请求至目标主机，就可以使服务器消耗大量系统资源来保留TCP半连接，当服务器的TCP连接表被占完，就会使得服务器无暇顾及合法的TCP请求连接。\n\n### 防御策略\n\n**Cookie源认证**：当服务器收到第一个SYN请求报文时，让Dos防护系统来响应，同样返回一个SYN+ACK响应(但这不是TCP组件响应的，而是Dos防护系统)，若SYN请求报文不是伪造的，请求主机会返回ACK字段为seq+1的ACK报文，而如果SYN报文是伪造的，所谓的请求主机并不会返回ACK字段为seq+1的ACK报文。\n\n**首包丢弃**：根据TCP可靠重传特性，服务器在首次收到SYN请求报文后，并不作回应，如果是正常请求，源主机在一段时间内没有收到SYN+ACK响应时会再次发送SYN请求。","tags":["计算机网络"],"categories":["course"]},{"title":"第五章第一节 ARP欺骗与泛洪","url":"/course/cn-ch5-par1.html","content":"\n## 常见ARP攻击\n\n(1)ARP欺骗；攻击者发送伪造的ARP应答报文来恶意修改网关或网络中其他主机的ARP表项，造成用户或网络的报文转发异常。\n\n(2)ARP泛洪；攻击者向网络中发送大量目的IP地址无法解析的ARP请求报文，造成网络设备上ARP表项溢出，无法缓存正常用户的ARP表项。\n\n## 防御策略\n\n### 防御ARP欺骗\n\n设备收到ARP应答报文后，对其MAC头部的源、目的MAC地址与ARP报文数据段中的源、目的MAC地址进行一致性检查，若不一致，则丢弃此ARP报文。\n\n### 防御ARP泛洪\n\n禁止接口学习ARP表项的功能或配置ARP表项严格学习(只学习自己请求的ARP应答报文、限制接口可以学习的ARP表项的总数目、或限制一定时间内可以学习的ARP表项的数目，即限速，等等)\n\n<div style=\"width:100%;margin:auto\">{% asset_img 56.png pic56 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第四章 应用层","url":"/course/cn-ch4.html","content":"\n[第一节 域名系统DNS](https://chu-kangming.gitee.io/course/cn-ch4-par1.html)\n\n[第二节 文件传送协议](https://chu-kangming.gitee.io/course/cn-ch4-par2.html)\n\n[第三节 万维网](https://chu-kangming.gitee.io/course/cn-ch4-par3.html)\n\n[第四节 动态主机配置协议](https://chu-kangming.gitee.io/course/cn-ch4-par4.html)","tags":["计算机网络"],"categories":["course"]},{"title":"第四章第四节 动态主机配置协议","url":"/course/cn-ch4-par4.html","content":"\n连接到互联网中的计算机需要配置一些信息比如IP地址、子网掩码、默认路由器的IP地址、域名服务器的IP地址等。互联网广泛采用动态主机配置协议DHCP，它提供一种机制——即插即用连网。\n\nDHCP基于UDP。需要IP地址的主机在启动时向DHCP服务器广播DHCP发现报文(目的IP为255.255.255.255，源IP为0.0.0.0)，只有DHCP服务器才会回复此广播报文，DHCP服务器先在其数据库中查找此计算机的配置信息，若无，则从IP地址池中取一个地址分配给该计算机。\n\n事实上，并非每个网络上都有一个DHCP服务器，如果没有，则会有一个DHCP代理，当它收到DHCP发现报文后，转发给DHCP服务器并等待其回复，然后将回复报文返回客户主机。\n\nDHCP分配给主机的IP地址只是临时的，DHCP客户使用68端口、服务器使用69端口。DHCP协议工作过程如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 53.png pic53 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第四章第三节 万维网","url":"/course/cn-ch4-par3.html","content":"\n## 统一资源定位符URL\n\nURL一般格式为：<协议>://<主机>:<端口>/<路径>。\n\n## 超文本传送协议HTTP\n\nHTTP协议基于TCP协议。HTTP协议的端口号为80。HTTP是无连接的、无状态的。\n\n### HTTP的操作过程\n\n如下是一个建立HTTP请求到收到HTTP响应的过程示意图。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 46.png pic46 %}</div>\n\n&nbsp;\n\n可以看到，整个从建立HTTP请求到收到HTTP响应所花的时间=2RTT+服务器处理时间。而HTTP1.0规定服务器发送完响应消息后，要主动执行断开操作，而HTML文档与图片被视为独立的对象，因此要获取一个有多个图片的网页的全部内容时就需要多次HTTP请求与释放，这使得获取数据的效率很低。于是，HTTP1.1采用持续连接，即服务器在发送响应后的一段时间仍然保持这条连接。\n\n### 代理服务器\n\n代理服务器可减轻网络上的负载。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 47.png pic47 %}</div>\n\n&nbsp;\n\n### HTTP报文结构\n\nHTTP有两类报文：HTTP请求报文与HTTP响应报文。区别在于开始行不同。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 48.png pic48 %}</div>\n\n&nbsp;\n\nHTTP请求报文中的一些方法如下。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 49.png pic49 %}</div>\n\n&nbsp;\n\nHTTP请求报文中的一些首部字段如下。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 50.png pic50 %}</div>\n\n&nbsp;\n\nHTTP响应报文中的一些首部字段如下。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 51.png pic51 %}</div>\n\n&nbsp;\n\n实体中用到的一些字段如下。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 52.png pic52 %}</div>\n\n&nbsp;\n\n状态码是一个3位数，分为5大类。\n\n1XX表示通知信息；2XX表示成功；3XX表示重定向；4XX表示客户的差错；5XX表示服务器的差错。\n\n### Cookie\n\n当用户A浏览某个使用Cookie的网站时，网站的服务器为A产生一个唯一的识别码，并以此为索引在服务器后端数据库中产生一个项目。\n\n接着在给A的响应报文中添加一个Set-cookie的首部行(如Set-cookie: 31d4d96e407aad42)；\n\n当A收到响应后，其浏览器就在它管理的特定Cookie文件中添加一行，其中包括服务器的主机名及其给出的识别码；\n\n当A继续浏览网站时，每发送一个HTTP请求报文，浏览器均会从Cookie文件中取出此网站的识别码，并放到HTTP请求报文的首部行(Cookie: 31d4d96e407aad42)。\n\n于是，这个网站就能跟踪用户A在该网站的活动。\n\n## HTTPS\n\n### TLS握手\n\nHTTPS相对于HTTP，在建立TCP连接后，还需要进行TLS握手来协商出加密的参数。TLS握手示意图如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 54.png pic54 %}</div>\n\n&nbsp;\n\n(1)客户端向服务器发送Hello报文，其中包含客户端生成的随机数C、客户端的TLS版本号、支持的密码套件列表以及扩展列表。\n\n(2)服务器回复ACK报文；服务器向客户端发送Hello报文(选择了用来协商密钥的非对称加密算法后，自己计算出一对公私钥)，其中包含服务器生成的随机数S、对TLS版本号的确认、选择使用的密码套件(非对称加密算法与对称加密算法)、本服务器的证书，公钥与私钥的签名。\n\n(3)客户端回复ACK报文；然后验证证书与签名，确认无误后，自己计算出一对公私钥，并发送自己的公钥给服务器；客户端根据C、S与协商出来的密钥pre_master计算出主密钥master_secret，这将用来派生出对称加密密钥。同时，服务器按照相同的方式计算出主密钥master_secret。\n\n(4)此时客户端与服务器都能知道所有派生出的密钥，注意双方对称加密的密钥是不同的，这主要是为了进一步提高安全性，但是双方都可以解密出对方加密的密文。\n\n(5)客户端发送Change Cipher spec报文表明之后使用对称加密进行通信，并且发送对所有握手数据的摘要的加密密文(Finish报文)供服务器验证。\n\n(6)服务器回复ACK报文；不等服务器向客户端发送Change Cipher spec报文与Finish报文，客户端就开始向服务器发送加密的HTTP请求报文，这就是False start。\n\n(7)服务器回复ACK报文；服务器向客户端发送Change Cipher spec报文与Finish报文。\n\n(8)客户端回复ACK报文；之后双方进入HTTP加密通信。\n\n### HTTPS优化\n\n通常所说\"HTTPS连接慢\"就是指刚开始建立时相对于HTTP增加了TLS握手。而在对称加密通信过程中，对称加密算法的软硬件优化已经做得很好。对于HTTPS，有如下方面可以优化。\n\n* HSTS重定向技术。启用HSTS后，保证浏览器始终连接到网站的HTTPS加密版本，省去301跳转的出现，缩短访问时间。\n* TLS握手优化。使用ECDHE椭圆曲线密码套件，可以节约带宽与计算量，还能实现False start。\n* 会话标识符复用。\n  * 服务器为每次会话生成并记录一个ID号，发送给客户端；\n  * 若客户端重新发起连接，则要向服务器发送此ID号；\n  * 服务器收到客户端发来的ID号，查找自己的会话记录，匹配ID后，双方就可以重新使用之前协商好的密钥进行加密通信；\n* 开启OSCP装订。服务器主动获取OSCP查询结果与证书一起发送给客户端，客户端可直接验证证书，省去浏览器的在线验证过程；\n* 完全前向加密。采用ECDHE算法，每次握手都会生成一对临时的公私钥，每次通信的密钥对均不同，即使之前的密钥被泄露，目前进行的加密通信也是安全的。\n\n参考链接\n\n* [TLS握手](https://www.cnblogs.com/wxcx/p/12775311.html)\n* [HTTPS](https://blog.csdn.net/qq_35642036/article/details/82788421)","tags":["计算机网络"],"categories":["course"]},{"title":"第四章第二节 文件传送协议","url":"/course/cn-ch4-par2.html","content":"\n## FTP概述\n\n文件传送协议FTP提供交互式访问，允许客户指明文件的类型与格式，并允许文件具有存取权限，它屏蔽了各计算机系统的细节，适于异构网络中任意计算机之间的文件传输。\n\nFTP协议规定：若要存取文件，则必须在本地获得一个文件副本；若要修改文件，只能对文件的副本进行修改，修改完再将文件的副本复制回去。\n\nFTP与数据库系统不同的是：FTP由操作系统的文件系统提供对共享文件的透明存取。\n\n## FTP的工作原理\n\nFTP使用客户服务器方式，一个FTP服务器进程可同时为多个客户进程提供服务。FTP服务器进程由两类组成：主进程(负责接受新的请求)与从属进程(负责处理单个请求)。主进程的工作步骤如下：\n\n* 打开计算机的21端口；\n* 等待客户进程发起连接请求；\n* 启动一个从属进程处理客户进程发来的请求，然后自己回到(2)；\n\n在进行文件传输时，FTP的客户与服务器之间要建立两条并行的TCP连接——控制连接与数据连接，控制连接用来传输建立连接的信息，数据连接用来传输数据。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 45.png pic45 %}</div>\n\n## 简单文件传送协议TFTP\n\nTFTP协议基于UDP，因此有它自己的差错改正措施，它只支持文件传输而不支持文件交互。TFTP的工作类似停止等待协议；发送完一个文件块就等待对方的确认，确认时需指明确认的块编号，若在规定时间内没有收到确认，需要重新发送文件块，接收方若在规定时间内没有收到下一文件块，也会重新发送确认。\n\nTFTP每次传送的文件块为512字节(最后一次可能少于512字节)，若文件的长度恰为512字节的整数倍，则文件传送完毕后还需要发送一个只有头部而无数据的报文，表明文件传送完毕。","tags":["计算机网络"],"categories":["course"]},{"title":"第四章第一节 域名系统DNS","url":"/course/cn-ch4-par1.html","content":"\n## 域名系统概述\n\n域名系统DNS用来将计算机的域名解析为计算机的IP地址。DNS报文格式如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 58.png pic58 %}</div>\n\n&nbsp;\n\n* 16位标识字段用于标记一对DNS查询与应答；\n* 16位标志字段用于协商具体的通信方式与反馈通信状态，该字段细节如下图；\n  * QR：查询/应答标志。0表示查询，1表示应答；\n  * opcode：定义查询与应答的类型。0表示标准查询，1表示反向查询(由IP地址获取主机域名)，2表示请求服务器状态；\n  * AA：授权应答标志。仅由应答报文使用，1表示域名服务器是授权服务器；\n  * TC：截断标志。仅当DNS报文使用UDP协议时使用。由于UDP数据报有长度限制，因此过长的DNS报文将被截断。1表示DNS报文超过512字节并被截断；\n  * RD：递归查询标志。1表示执行递归查询，0表示执行迭代查询；\n  * RA：允许递归标志。仅由应答报文使用，1表示DNS服务器支持递归查询；\n  * zero：未使用；\n  * rcode：4位返回码。0：无错误，3：域名不存在；\n\n<div style=\"width:60%;margin:auto\">{% asset_img 59.png pic59 %}</div>\n\n&nbsp;\n\n* 之后4个字段分别指出DNS报文最后4个字段的资源记录数目。\n* 查询问题格式如下。\n  * 查询名：以一定格式封装要查询的主机域名；\n  * 查询类型：如何执行查询操作。类型A(值为1)：获取目标主机的IP地址，类型CNAME(值为5)：获得目标主机别名，类型PTR(值为12)：方向查询；\n  * 查询类：通常为1，指获取因特网地址；\n\n<div style=\"width:60%;margin:auto\">{% asset_img 60.png pic60 %}</div>\n\n&nbsp;\n\n\n\n* 其他三个字段都使用资源记录格式。其格式如下图。\n  * 32位域名、16位类型、16位类与对应查询问题的查询名、查询类型、查询类内容一致；\n  * 32位生存时间：该查询记录的结果可被客户端缓存多长时间，以秒为单位；\n\n<div style=\"width:60%;margin:auto\">{% asset_img 61.png pic61 %}</div>\n\n&nbsp;\n\n## 互联网的域名结构\n\n互联网的域名命名采用层次结构。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 44.png pic44 %}</div>\n\n## 域名服务器\n\n一个DNS服务器所负责管辖的范围称为区。这个DNS服务器就是这个区的权限域名服务器，它保存区中所有主机的域名到IP地址的映射。区包含于一个域。\n\n互联网中的DNS服务器同样以层次结构组织。\n\n* 根域名服务器。本地域名服务器在遇到自己无法解析的域名时，统一求助根域名服务器；\n* 顶级域名服务器。管理在顶级域名下注册的所有二级域名。\n* 权限域名服务器。\n* 本地域名服务器。一台主机发出DNS查询请求时，查询报文首先发送到本地域名服务器。\n\n可使用host命令访问DNS服务器。\n\n```bash\nhost -t A www.baidu.com\n```\n\n### 域名解析\n\n**递归查询**：若主机请求解析的域名在本地域名服务器中不存在，则本地域名服务器以DNS客户的身份，向根域名服务器发送查询请求。\n\n**迭代查询**：根域名服务器收到本地域名服务器的查询请求后，要么给出要查询的IP地址，要么给出下一个查询请求对象的IP地址。本地域名服务器就这样进行迭代查询直到得知域名的IP地址或查询失败。\n\n本地域名服务器将查询结果(IP地址或查询失败)返回给主机，并且将查询结果缓存，以便下次查询此域名能够快速响应。","tags":["计算机网络"],"categories":["course"]},{"title":"第三章 传输层","url":"/course/cn-ch3.html","content":"\n[第一节 传输层协议概述](https://chu-kangming.gitee.io/course/cn-ch3-par1.html)\n\n[第二节 用户数据报协议UDP](https://chu-kangming.gitee.io/course/cn-ch3-par2.html)\n\n[第三节 传输控制协议TCP概述](https://chu-kangming.gitee.io/course/cn-ch3-par3.html)\n\n[第四节 可靠传输的工作原理](https://chu-kangming.gitee.io/course/cn-ch3-par4.html)\n\n[第五节 TCP流量与拥塞控制](https://chu-kangming.gitee.io/course/cn-ch3-par5.html)\n\n[第六节 TCP的传输连接管理](https://chu-kangming.gitee.io/course/cn-ch3-par6.html)","tags":["计算机网络"],"categories":["course"]},{"title":"第三章第六节 TCP的传输连接管理","url":"/course/cn-ch3-par6.html","content":"\n## 三次握手\n\n<div style=\"width:56%;margin:auto\">{% asset_img 41.png pic41 %}</div>\n\n&nbsp;\n\nQ：为什么需要第三次握手?\n\nA：TCP作为可靠传输，收到报文后都要向发送方回复ACK回执。根据这个机制，TCP建立连接应该需要4次握手：\n\n(1)客户端向服务器端发送请求连接的SYN报文；\n\n(2)服务器端向客户端回复确认接收的ACK报文；\n\n(3)服务器端向客户端发送允许连接的SYN报文；\n\n(4)客户端向服务器端回复确认接收的ACK报文；\n\n然而，第(2)次握手与第(3)次握手可以合并到一个报文中，于是形成了熟知的三次握手。\n\n## 四次挥手\n\n<div style=\"width:60%;margin:auto\">{% asset_img 42.png pic42 %}</div>\n\n&nbsp;\n\nQ：为什么第(2)次挥手与第(3)次挥手不能合并?\n\nA：服务器端收到客户端请求释放连接的报文后，可能还需要处理一些工作，因此只能先发送确认收到报文，然后等工作处理完之后，向客户端发送允许释放连接的报文，客户端收到此报文后回复确认收到的报文后即可释放此TCP连接，服务器端收到客户端确认收到的回复报文后，释放此TCP连接，进入LISTEN状态。\n\n&nbsp;\n\nQ：为什么在TCP释放连接时发起方返回ACK报文后还要等待2MSL时间?\n\nA：MSL为报文最大生存时间，它是任何报文在网络上存在的最长时间。若释放连接的发起方返回的ACK报文未被另一方接收，则另一方会在超时后重传允许释放连接报文，释放连接的发起方就会在返回ACK报文后的2MSL时间内收到这个重传的报文，然后重新发送ACK报文。而如果直接退出，那么释放连接的发起方就不会重新发送ACK报文，另一方将无法按照正常的步骤进入CLOSED状态。\n\n此外，经过2MSL时间后，此次TCP连接中传送的所有报文均在网络中消失，可以使通信双方下一次建立的TCP连接与此次TCP连接完全地分离开，即不会出现此次TCP连接中传送的报文出现在下一次建立的TCP连接中的情况。\n\n## 复位报文\n\n在一些特殊情况下，TCP连接的一端会向另一端发送携带RST标志的报文，即复位报文，以通知对方关闭连接或重新打开连接。有如下3种产生复位报文的情况。\n\n* 访问了不存在的端口；当客户端访问一个不存在的端口，目标主机将向它发送一个复位报文；\n* 异常终止连接；TCP提供了异常终止一个连接的方法——向对方发送一个复位报文，一旦发送了复位报文，TCP发送缓冲区中的数据都将被丢弃；\n* 处理半打开连接；TCP连接一方关闭或异常终止了TCP连接，但是对方没有收到结束/复位报文，于是对方仍然维持着TCP连接，这种状态称为半连接；如果对方这时发送报文，就会收到复位报文；\n\n## TCP的有限状态机\n\n<div style=\"width:56%;margin:auto\">{% asset_img 43.png pic43 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第三章第五节 TCP流量与拥塞控制","url":"/course/cn-ch3-par5.html","content":"\n## 流量控制\n\n利用滑动窗口实现流量控制\n\n<div style=\"width:56%;margin:auto\">{% asset_img 39.png pic39 %}</div>\n\n## TCP拥塞控制\n\n### TCP拥塞控制的手段\n\n* 慢开始。TCP连接刚刚建立时，由小到大逐渐增大发送窗口。\n* 拥塞避免。当拥塞窗口增大到一定程度时，将其增速放缓。\n* 快重传。收到数据后立即发送已按顺序收到的报文的确认。若发送方连续收到3个重复确认，则要对确认报文之后的报文进行重传。\n* 快恢复。调整慢开始门限为拥塞窗口大小/2，拥塞窗口大小为慢开始门限，然后执行拥塞避免算法。\n\n### TCP拥塞控制流程\n\nTCP使用上述四种手段实现拥塞控制的流程图如下。\n\n<div style=\"width:68%;margin:auto\">{% asset_img 40.png pic40 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第三章第四节 可靠传输的工作原理及其TCP实现","url":"/course/cn-ch3-par4.html","content":"\n## 可靠传输的工作原理\n\n### 停止等待协议\n\n顾名思义，在发送分组后等待确认收到，之后再发送下一分组。如果设定时间内没有收到确认，则将此分组重传。因此TCP在发送完一个分组后，必须保留此分组的副本直到收到确认。由于没有收到确认有两种可能：(1)发送分组丢失或出错；(2)对方收到分组，且确认无误，但是发送的确认丢失；(3)由于网络阻塞，收到确认迟到了；不管是哪种可能，发送方都会重传分组。对于(1)，接收方会接收分组并发送确认；而对于(2)，接收方直接丢弃这个重复分组，但是仍然发送确认分组。对于(3)，发送方收到重复的确认后直接丢弃。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 37.png pic37 %}</div>\n\n&nbsp;\n\n然而，停止等待协议的信道利用率极其低，下面介绍连续ARQ协议与滑动窗口协议。\n\n### 连续ARQ协议\n\n**发送**：位于窗口内的分组可以全部发送出去而不用等待前一组的接收确认。\n\n**累积确认**：接收方不需要对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送接收确认，这就代表到这个分组为止的所有分组均已收到。\n\n**窗口滑动**：发送方收到确认后，将窗口滑动到确认分组的下一分组。\n\n连续ARQ协议工作例子如下。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 38.png pic38 %}</div>\n\n## TCP可靠传输的实现\n\n### 以字节为单位的滑动窗口\n\n&nbsp;\n\n### 超时重传时间的选择\n\nTCP采用一种自适应算法，它记录一个报文段发出的时间，以及收到相应确认的时间。这两者之差为该报文段的往返时间RTT，TCP保留一个加权平均往返时间RTTS<-(1-a)×RTTS+a×RTT。a建议为1/8。超时重传时间RTO=RTTS+4×RTTD，RTTD为RTT偏差的加权平均值。而重传的报文，其往返时间无法准确计算，于是Karn提出：重传报文的RTT不加入RTTS的计算，而这种方法又不能及时应对网络阻塞的变化(如果网络阻塞，导致RTT变大，而重传报文的RTT不加入RTTS的计算，于是超时重传时间得不到及时更新)，于是Karn算法修正为报文段每重传一次，就将超时重传时间增加一倍。","tags":["计算机网络"],"categories":["course"]},{"title":"第三章第三节 传输控制协议TCP概述","url":"/course/cn-ch3-par3.html","content":"\n## TCP主要特点\n\n* TCP是面向连接的传输层协议，即应用程序在使用TCP协议前，必须先建立TCP连接；\n* TCP连接只能是一对一；\n* TCP提供可靠交付。通过TCP协议传送的数据，可无差错、不丢失、不重复、按序到达；\n* TCP提供全双工通信。运行通信双方的应用进程在(建立连接之后，释放连接以前的)任何时候都可以发送数据，通信双方既是发送方也是接收方，TCP连接的两端都设有发送缓存与接收缓存；\n* 面向字节流。TCP将应用程序交付下来的数据仅仅看作一连串无结构的字节流。\n\n## TCP连接\n\nTCP连接有两个端点，这个端点就是套接字socket，可使用`IP:Port`唯一区分。\n\nsocket是操作系统提供的网络编程接口，因为数据链路层、网络层、传输层协议均在内核中实现，而应用层基本上在用户空间，因此操作系统必须提供一组系统调用使应用层可以使用数据链路层、网络层、传输层提供的服务。\n\nsocket主要提供两种功能：(1)将应用程序数据从用户缓冲区复制到TCP/UDP内核发送缓冲区、或从TCP/UDP内核接收缓冲区复制数据到用户缓冲区；(2)应用程序可通过socket提供的接口修改内核中各层协议的控制信息，从而精确地调整底层通信的行为。\n\n## TCP头部\n\nTCP头部格式如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 36.png pic36 %}</div>\n\n&nbsp;\n\n* 确认号。若确认号为N，则表明从起始序号到N-1的TCP字节流已经按顺序收到。\n* 数据偏移。以4字节为单位，即若数据偏移为5，则TCP头部长20字节。\n* 确认ACK。仅当确认ACK为1时确认号字段才有效，TCP规定：在连接建立后，所有传送的报文段都必须将ACK置1。\n* 复位RST。RST为1表明TCP连接出现严重差错，必须立即释放连接。\n* SYN位。在连接建立时用来同步序号，SYN=1且ACK=0用来请求连接，SYN=1且ACK=1表明接受连接；SYN位置1标志建立连接阶段的报文。\n* FIN位。FIN位置1表明向对方提出终止连接。\n* 窗口。用来告知通信另一方，自本报文段头部的确认号算起，允许其发送的数据量(以字节为单位)。\n* 选项。长度可变，包括最大报文段长度、窗口扩大选项、时间戳、选择确认等。","tags":["计算机网络"],"categories":["course"]},{"title":"第三章第二节 用户数据报协议UDP","url":"/course/cn-ch3-par2.html","content":"\n## UDP概述\n\nUDP只在IP协议上增加了复用/分用与差错检测功能。UDP具有无连接、尽最大努力交付、面向报文(应用层交给UDP多长的报文，UDP就照样发送)、无拥塞控制(即使网络出现拥塞，源主机发送数据的速率不变)、支持一/多对一/多、头部开销小的特点。\n\n## UDP头部\n\nUDP头部格式如下图。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 35.png pic35 %}</div>\n\n&nbsp;\n\n若接收方UDP发现收到的报文目的端口号不正确，则丢弃该报文，并且向源主机发送ICMP端口不可达差错报文。UDP的校验和是将首部与数据部分一起校验。","tags":["计算机网络"],"categories":["course"]},{"title":"第三章第一节 传输层协议概述","url":"/course/cn-ch3-par1.html","content":"\n## 进程间通信\n\n传输层是向应用进程间提供端到端的逻辑通信。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 32.png pic32 %}</div>\n\n## 传输层两个主要协议\n\n传输层的两个主要协议：用户数据报协议UDP与传输控制协议TCP。下表是使用TCP或UDP的应用层协议。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 33.png pic33 %}</div>\n\n## 传输层的端口\n\n标志本计算机应用层的各个进程与传输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。传输层的端口号分为下面两类。\n\n**服务端使用的端口号**：分为熟知端口号与登记端口号。熟知端口号(0-1023)可在`www.iana.org`查到。如下表是一些常用的熟知端口号。\n\n<div style=\"width:72%;margin:auto\">{% asset_img 34.png pic34 %}</div>\n\n&nbsp;\n\n登记端口号(1024-49151)被没有熟知端口号的应用程序使用，使用前需在IANA登记。\n\n**客户端使用的端口号**：仅在客户进程运行时才动态选择(49152-65535)。","tags":["计算机网络"],"categories":["course"]},{"title":"第二章 网络层","url":"/course/cn-ch2.html","content":"\n[第一节 网际协议IP](https://chu-kangming.gitee.io/course/cn-ch2-par1.html)\n\n[第二节 划分子网与构造超网](https://chu-kangming.gitee.io/course/cn-ch2-par2.html)\n\n[第三节 网际控制报文协议ICMP](https://chu-kangming.gitee.io/course/cn-ch2-par3.html)\n\n[第四节 互联网的路由选择协议](https://chu-kangming.gitee.io/course/cn-ch2-par4.html)\n\n[第五节 IPv6](https://chu-kangming.gitee.io/course/cn-ch2-par5.html)\n\n[第六节 IP多播](https://chu-kangming.gitee.io/course/cn-ch2-par6.html)\n\n[第七节 VPN与NAT](https://chu-kangming.gitee.io/course/cn-ch2-par7.html)\n\n[第八节 多协议标记交换MPLS](https://chu-kangming.gitee.io/course/cn-ch2-par8.html)","tags":["计算机网络"],"categories":["course"]},{"title":"超椭圆曲线(九)超椭圆曲线密码系统的实现","url":"/crypto/Hyper-ch9.html","content":"\nDiffie-Hellman密钥交换[10]是一个协议，两个实体$A$和$B$可以通过公共通道上的一系列传输，就一个秘密的加密密钥达成一致。方法如下。$A$和$B$首先选择一个(乘式写)有限Abel群$G$和某个元素$\\alpha\\in G$。然后$A$选择一个随机整数$a$且将$\\alpha^{a}$传输给$B$，$B$反过来选择一个随机整数$b$且将$\\alpha^{b}$传输给$A$。这样$A,B$均能确定$\\alpha^{ab}$，作为他们的共享密钥。\n\n窃听者$C$监控$A$与$B$之间的传输将会得到$G,\\alpha,\\alpha^{a},\\alpha^{b}$，选择参数$G$和$\\alpha$，使$C$确定$\\alpha^{ab}$在计算上是不可行的。事实上，若$C$可以计算$a$或者$b$，则$C$可以确定$\\alpha^{ab}$。给定$\\alpha,\\beta=\\alpha^{a}$确定$a$的问题称为离散对数问题。当限制在$[0,order(\\alpha)-1]$范围内$a$是唯一的，称为以$\\alpha$为底，$\\beta$的对数。确定$\\alpha^{ab}$与计算$G$上的离散对数问题是否等价还没有定论，在其他安全依赖于离散对数问题的加密协议中，有ElGamal公钥加密和数字签名方案[12]，以及最近采用的美国数字签名标准[29]。\n\n最好的算法以解决离散对数问题在任意$G$组指数平方根攻击(见McCurley[24]),有一个运行时间的平方根成比例最大的质数因子$l$, $l$是$\\alpha$的阶。因此，如果选择$G$和$\\alpha$，使$l$有一个大的素数因子，那么这些攻击就可以避免。\n\n令$F_{q}$代表阶为$q$的有限域，再令$q=p^{m}$其中$p$是$F_{q}$的特征，Diffie与Hellman最初提议$G=F_{q}^{*}$，$F_{q}$的乘法群，作为实现Diffie-Hellman密钥交换协议的候选。有一些已知的随机次指数时间算法可用于计算$F_{q}$中的对数。关于$q$为质数的情形，请参见Coppersmith，Odlyzko和Schroeppel [9]和Gordon [17]，对于$p=2$的情况，请参见Odlyzko [30]，有关一般情况，请参见Adleman和DeMarrais [1]。这些算法是对上一段中提到的通用算法的渐进改进。 出于加密目的，我们对相应离散对数问题的次指数算法未知的群感兴趣。另外，为了有效和实际地实施，群操作应该相对容易地应用。 对于这样的群，在有限域上定义的超椭圆曲线的雅可比行列式就是一种可能性。\n\n为了使用超椭圆曲线实现离散对数密码系统，必须选择合适的曲线$C$和有限域$K$。 所选曲线和域的理想属性包括：\n\n* 底层有限域K中的算术应该有效地实现； 特征2的有限域似乎是最有吸引力的选择；\n* $C$的行列式$J(K)$的阶，表示为$\\sharp J(K)$，应该能被大素数整除。给定当前的计算技术，一个安全的要求为$\\sharp J(K)$可被至少45位的十进制素数$r$整除。另外，为了避免约化攻击Frey and Ruck [13]，它将$J(K)$中的离散对数问题简化为扩展域$K=F_{q}$中的离散对数问题。对所有的$F_{q^{k}}$中的离散对数可解的小整数$k$，$r$应无法整除$q^{k}-1$($1\\leq k\\leq 2000/(\\log_{2}q)$满足)。\n\n接下来描述一种用于选择超椭圆曲线并计算$\\sharp J(K)$的技术。令$J$为定义在$F_{q}$上的超椭圆曲线$C$的雅可比行列式，由方程$v^{2}+h(u)v=f(u)$给定，令$F_{q^{n}}$代表$F_{q}$的$n$次扩展，且令$N_{n}$代表有限Abel群$J(F_{q^{n}})$的阶，$C$上的$F_{q^{n}}$-有理点的个数定义为$M_{n}$。与$C$关联的是zeta函数，定义如下：\n\n**定义53**(zeta函数)令$J$为定义在$F_{q}$上的超椭圆曲线$C$的雅可比行列式，再令$M_{r}=\\sharp C(F_{q^{r}}),r\\geq 1$，$C$的zeta函数是幂级数：\n$$\nZ_{C}(t)=exp\\left(\\sum_{r\\geq 1}M_{r}\\frac {r} {t^{r}}\\right)\n$$\n以下是有关zeta函数的一些众所周知的事实(例如，参见[23])。\n\n**定理54**(zeta函数的性质)令$C$为定义在$F_{q}$上类为$g$的超椭圆曲线，令$Z_{C}(t)$为$C$的zeta函数。\n\n$\\textrm{(i)}\\ Z_{C}(t)\\in Z(t)$。更确切地说，我们有：\n$$\nZ_{C}(t)=\\frac {P(t)} {(1-t)(1-qt)}\\tag{9}\n$$\n其中$P(t)$为次数为$2g$的整系数多项式；此外，$P(t)$有如下形式：\n$$\nP(t)=1+a_{1}t+\\cdots+a_{g}t^{g}+qa_{g-1}t^{g+1}+q^{2}a_{g-2}t^{g+2}+\\cdots+q^{g-1}a_{1}t^{2g-1}+q^{g}t^{2g}\\tag{10}\n$$\n$\\textrm{(ii)}\\ P(t)$分解为：\n$$\nP(t)=\\prod_{i=1}^{g}(1-\\alpha_{i}t)(1-\\bar\\alpha_{i}t)\\tag{11}\n$$\n\n其中每个$\\alpha_{i}=\\sqrt{q}$，$\\bar\\alpha_{i}$为$\\alpha_{i}$的共轭。\n\n$\\textrm{(iii)}\\ N_{n}=\\sharp J(F_{q^{n}})$满足：\n$$\nN_{n}=\\prod_{i=1}^{g}|1-\\alpha_{i}^{n}|^{2}\\tag{12}\n$$\n为了计算$N_{n}$，由它满足$\\textrm{(i)}$确定$P(t)$的系数$a_{1},\\cdots,a_{g}$，从而确定$P(t)$；$\\textrm{(ii)}$分解$P(t)$因此可以确定$\\alpha_{i}$；$\\textrm{(iii)}$通过等式$(12)$计算$N_{n}$。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 31.png pic31 %}</div>\n\n&nbsp;\n\n**推论55** 令$C$为定义在$F_{q}$上类为$g$的超椭圆曲线，令$N_{n}=\\sharp J(F_{q^{n}})$，则$(q^{n/2}-1)^{2g}\\leq N_{n}\\leq (q^{n/2}+1)^{2g}$；从而$N_{n}\\approx q^{ng}$。\n\n[原文链接](http://www.math.uwaterloo.ca/~ajmeneze/publications/hyperelliptic.pdf)\n\n翻译不当之处还请批评指正，另外文中有些证明等我看明白了再翻译...","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(八)约化因数相加","url":"/crypto/Hyper-ch8.html","content":"\n令$C$是定义在有限域$K$上属性为$g$的一个超椭圆曲线，令$J$是$C$的雅克比行列式，令$P(x,y)\\in C$，令$\\sigma$是$\\bar K$到$K$的一个自同构，则$P^{\\sigma}=(x^{\\sigma},y^{\\sigma})$同样是$C$上的一个点。\n\n**定义48**(因数的定义域)若一个因数$D=\\sum m_{P}P$有$D^{\\sigma}=\\sum m_{P}P^{\\sigma}$能对任意$\\bar K$到$K$的自同构$\\sigma$均与$D$相等。\n\n注意到如果$D$定义在$K$上，这并不代表$D$的支撑集中的每个点均为$K$有理点，一个主因数定义在$K$上当且仅当它是一个有$K$中系数的有理函数的因数，$J$中所有除数类的集合$J(K)$有一个定义在$K$上的代表，是$J$的一个子群。$J(K)$的每个元素都有一个唯一的表示形式，即约化因数$div(a, b)$，其中$a,b\\in K[u],deg(a)\\leq g,deg(b)<deg(a)$，因此$J(K)$事实上是一个有限Abel群。本节介绍一种在该组中元素相加的有效算法。\n\n令$D_{1}=\\textrm{div}(a_{1},b_{1}),D_{2}=\\textrm{div}(a_{2},b_{2})$为两个在$K$上定义的约化因数(则$a_{1},b_{1},a_{2},b_{2}\\in K[u]$)。算法1寻找一个半约化因数$D=\\textrm{div}(a,b),a,b\\in K[u]$使得$D\\sim D_{1}+D_{2}$。算法2将$D$约化为等价的约化因数$D^{'}$。\n\n算法1,2由Koblitz [20]实现，其推广了Cantor[5]的早期算法—假定$h(u)=0$且$char(K)\\neq 2$。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 21.png pic21 %}</div>\n\n&nbsp;\n\n**定理49**(算法1的有效性)令$D_{1}=\\textrm{div}(a_{1},b_{1}),D_{2}=\\textrm{div}(a_{2},b_{2})$为两个半约化因数，令$a,b$如式$(4),(5)$定义，则$D=\\textrm{div}(a,b)$是一个半约化因数且$D\\sim D_{1}+D_{2}$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 22.png pic22 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 23.png pic23 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 24.png pic24 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 25.png pic25 %}</div>\n\n算法2：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 26.png pic26 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:56%;margin:auto\">{% asset_img 27.png pic27 %}</div>\n\n&nbsp;\n\n**定理51**(算法2的有效性)令$D=\\textrm{div}(a,b)$是一个半约化因数，则由算法2返回的因数$D^{'}=\\textrm{div}(a^{'},b^{'})$是约化的且$D^{'}\\sim D$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 28.png pic28 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 31.png pic31 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 30.png pic30 %}</div>\n\n&nbsp;\n\n注意，算法1和算法2中的所有计算都发生在域$K$本身(而不是$K$的任何适当扩展)。在算法1中，若$deg(a_{1})\\leq g,deg(a_{2})\\leq g$则$deg(a)\\leq 2g$。此时，算法2对步骤1的迭代次数最多为$[g/2]$。","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(七)约化因数","url":"/crypto/Hyper-ch7.html","content":"\n本节定义了约化因数的概念，并证明了商群的每个陪集$\\bf{J=D^{0}/P}$只有一个约化因数，因此，我们可以用它的约化因数来识别每个陪集。\n\n**定义44**(约化因数)令$D=\\sum m_{i}P_{i}-(\\sum m_{i})\\infty$是一个半约化因数，若$\\sum m_{i}\\leq g$($g$是$C$的属性)，则$D$称为一个约化因数。\n\n**定义45**(因数的范数)令$D=\\sum_{P\\in C}m_{P}P$是一个因数，$D$的范数定义为：$|D|=\\sum_{P\\in C\\setminus {\\infty}}m_{P}$。\n\n注意到给定一个因数$D\\in \\bf{D^{0}}$，在引理39的证明中所描述的操作会产生一个半约化因数$D_{1}$使得$D_{1}\\sim D$且$D_{1}\\leq D$。\n\n**引理46** 令$R\\in \\bar K(C)^{*}$，若$R$没有有限的极点，则$R$是一个多形式函数。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 18.png pic18 %}</div>\n\n&nbsp;\n\n**定理47 **对任一因数$D\\in \\bf{D^{0}}$存在一个唯一的约化因数$D_{1}$使得$D_{1}\\sim D$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 19.png pic19 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 20.png pic20 %}</div>","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(六)半约化因数的表示","url":"/crypto/Hyper-ch6.html","content":"\n本节描述雅可比矩阵半约化因子的多项式表示。它引出了一个有效的算法来添加雅可比矩阵的元素。\n\n**引理40** 令$P(x,y)$是$C$上一个平凡点，再令$R\\in \\bar K(C)$是一个在$P$处没有极点的有理函数，则对任意的$k\\geq 0$，存在唯一的元素$c_{0},\\cdots,c_{k}\\in\\bar K$与$R_{k}\\in \\bar K(C)$使得$R=\\sum_{i=0}^{k} c_{i}(u-x)^{i}+(u-x)^{k+1}R_{k}$，其中$R_{k}$在$P$处没有极点。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\n**引理41** 令$P(x,y)$是$C$上一个平凡点，则对任一$k\\geq 1$，存在唯一的多项式$b_{k}(u)\\in \\bar K[u]$使得：\n\n$\\textrm{(i)}\\ deg_{u} b_{k}<k$；\n\n$\\textrm{(ii)}\\ b_{k}(x)=y$且$b_{k}^{2}(u)+b_{k}(u)h(u)\\equiv f(u)\\ \\textrm{mod}\\ (u-x)^{k}$；\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 15.png pic15 %}</div>\n\n&nbsp;\n\n下面的定理说明了半约化因数如何可以表示为两个多项式函数的因数的最大公约数。\n\n**定理42** 令$D=\\sum m_{i}P_{i}-(\\sum m_{i})\\infty$是一个半约化因数，其中$P_{i}(x_{i},y_{i})$，令$a(u)=\\prod (u-x_{i})^{m_{i}}$。令$b(u)$是唯一满足如下条件的多项式：\n$\\textrm{(i)}\\ deg(b)<deg(a)$；\n\n$\\textrm{(ii)}$对所有$m_{i}\\neq 0$的$i$都有$b(x_{i})=y_{i}$；\n\n$\\textrm{(iii)}\\ a(u)|[b^{2}(u)+b(u)h(u)-f(u)]$，则$D=\\textrm{gcd}(div(a(u)),div(b(u)-v))$。\n\n注：$\\textrm{gcd}(div(a(u)),div(b(u)-v))$通常缩写为$div(a(u),b(u)-v)$或者，更简单：$div(a,b)$。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n&nbsp;\n\n注意到零因数表示为$div(1,0)$，下一个结果来自定理42的证明。\n\n**引理43** 令$a(u),b(u)\\in \\bar K[u]$使得$deg(b)<deg(a)$，若$a|(b^{2}+bh-f)$则$div(a,b)$是半约化的。","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(五)因数","url":"/crypto/Hyper-ch5.html","content":"\n本节介绍因数的基本性质及超椭圆曲线的雅可比矩阵。\n\n**定义31**(因数 , 次数 , 阶数)因数D是C中的点的形式和：$D=\\sum_{P\\in C}m_{P}P ,m_{P}\\in Z$，其中只有有限的$m_{P}$是非零的。D的次数，记为$degD$，是$\\sum_{P\\in C}m_{P}$。$D$在$P$处的阶数$m_{P}$，记$ord_{P}(D)=m_{P}$。\n所有因数的集合记为D，在加法规则下形成一个可加群：$\\sum_{P\\in C}m_{P}P+\\sum_{P\\in C}n_{P}P=\\sum_{P\\in C}(m_{P}+n_{P})P$。\n所有次数为$0$的因数组成的集合，记为$\\bf{D^{0}}$，是$D$的子群。\n\n**定义32**(因数的公约数)令$D_{1}=\\sum_{P\\in C}m_{P}P , D_{2}=\\sum_{P\\in C}n_{P}P$为两个因子，$D_{1}$与$D_{2}$的最大公约数定义为：$gcd(D_{1},D_{2})=\\sum_{P\\in C}\\textrm{min}(m_{P},n_{P})P-(\\sum_{P\\in C}\\textrm{min}(m_{P},n_{P}))\\infty$(注意到$gcd(D_{1},D_{2})\\in \\bf{D^{0}}$)。\n\n**定义33**(有理函数的因数)令$R\\in \\bar K(C)^{*}$。$R$的因数是$div(R)=\\sum_{P\\in C}(ord_{P}R)P$，注意到若$R=G/H$则$div(R)=div(G)-div(H)$。定理29表明有理函数的因数确实是一个有限形式和并且次数为0。\n\n**例34**若$P(x,y)$是$C$上的一个平凡点，则$div(u-x)=P+\\bar P-2\\infty$，若$P(x,y)$是$C$上的一个特殊点，则$div(u-x)=2P-2\\infty$。\n\n**引理35**令$G\\in \\bar K[C]^{*} , div(G)=\\sum_{P\\in C}m_{P}P$，则$div(\\bar G)=\\sum_{P\\in C}m_{P}\\bar P$。\n\n证明：由引理28易得。\n\n若$R_{1} , R_{2}\\in \\bar K(C)^{*}$则由引理25可得$div(R_{1}R_{2})=div(R_{1})+div(R_{2})$。\n\n**定义36**若对某些有理函数$R\\in \\bar K(C)^{*}$，$D=div(R)$，则因数$D\\in \\bf{D^{0}}$称为主因数。所有主因数组成的集合，记为$\\bf{P}$，是$\\bf{D^{0}}$的子群；商群$J=\\bf{D^{0}/P}$称为曲线$C$的雅可比矩阵。若$D_{1} , D_{2}\\in \\bf{D^{0}}$，当$D_{1}-D_{2}\\in \\bf{P}$时我们记为$D_{1}\\sim D_{2}$，$D_{1}$与$D_{2}$被称为等价因数。\n\n**定义37**(因数的支持)令$D=\\sum_{P\\in C}m_{P}P$是一个因数，$D$的支持是集合$\\textrm{supp}(D)=\\{P\\in C|m_{P}\\neq 0\\}$。\n\n**定义38**(半约化因数)半约化因数是形如$D=\\sum m_{i}P_{i}-(\\sum m_{i})\\infty$，其中每个$m_{i}\\geq 0$且$P_{i}$均为有限点使得当$P_{i}\\in \\textrm{supp}(D)$则$\\bar P_{i}\\notin \\textrm{supp}(D)$，除非$P_{i}=\\bar P_{i}$，此时$m_{i}=1$。\n\n**引理39**对每个因数$D\\in\\bf{D^{0}}$存在一个半约化因数$D_{1}(D_{1}\\in\\bf{D^{0}})$使得$D\\sim D_{1}$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(四)零点与极点","url":"/crypto/Hyper-ch4.html","content":"\n本节介绍单值化参数的概念，以及有理函数的零点和极点的阶数。\n\n**定义18**(零点，极点)令$R\\in \\bar K(C)^{*},P\\in C$。若$R(P)=0$则记为$R$在$P$有一个零点。若$R$在$P$处没有定义则记为$R$在$P$处有一个极点，此时我们记为$R(P)=\\infty$。\n\n**引理19**令$G\\in \\bar K(C)^{*},P\\in C$，若$G(P)=0$，则$\\bar G(\\bar P)=0$。\n\n证明：套定义算就行，过程略。\n\n定理23中使用引理20、21和22，证明了单值化参数的存在性。\n\n**引理20** 令$P(x,y)$是$C$上一个点。假定$G(u,v)=a(u)-b(u)v\\in \\bar K[C]^{*}$在$P$处有一个零点，且$x$不是$a(u),b(u)$的根。则$\\bar G(P)=0$当且仅当$P$是一个特殊点。\n\n证明：式子一列就看出来了。\n\n**引理21** 令$P(x,y)$是$C$上一个平凡点，$G=a(u)-b(u)v\\in \\bar K(C)^{*}$。若$G(P)=0$，且$x$不是$a(u),b(u)$的根。则$G$能被写为$(u-x)^{s}S$的形式，其中$s$是$(u-x)$能够整除$N(G)$的最高次数。$S\\in \\bar K(C)$在$P$处既无零点也无极点。\n\n证明：$G=N(G)/\\bar G$，由引理20，$\\bar G(P)\\neq 0\\Rightarrow N(G)(x)=0$，因此$N(G)$可被表示为$(u-x)^{s}d(u)$的形式。再令$S=d(u)/\\bar G$，则$G$能被写为$(u-x)^{s}S$的形式。由$s$的定义可知$S(P)\\neq 0$且$S(P)\\neq \\infty$。\n\n**引理22** 令$P(x,y)$是一个在$C$上的特殊点。则$(u-x)$可被写为$(v-y)^{2}\\cdot S(u,v)$，其中$S(u,v)\\in \\bar K(C)$在$P$处既无零点也无极点。\n\n证明：记$H(u,v)=(v-y)^{2} , s(u)=H(u,y)$，显然$s(x)=0 , s^{'}(u)=f^{'}(u)-h^{'}(u)y$，由于$C$是超椭圆曲线，无奇异点，而$P(x,y)$是特殊点，因此$2y+h(u)=0$，因此必有$f^{'}(x)-h^{'}(x)y\\neq 0$，即$s^{'}(x)\\neq 0$；综上，$(u-x)|H(u,v)$且$(u-x)^{2}\\nmid H(u,v)$，可得$S(x,y)\\neq 0,\\infty$。\n\n**引理23**(单值化参数的存在性)令$P\\in C$，则存在一个函数$U\\in\\bar K(C) , U(P)=0$使下列性质成立：对于每个多项式函数$G\\in \\bar K[C]^{*}$，存在整数$d$与函数$S\\in\\bar K(C)$，使得$S(P)\\neq 0,\\infty$且$G=U^{d}S$；此外，$d$与$U$的选择无关。$U$称为关于$P$的单值化参数。\n\n证明：太麻烦了，自己看吧！\n\n<div style=\"width:80%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n&nbsp;\n\n下面利用单值化参数的概念来定义多项式函数在某一点上的阶数。定义26给出了[20]的另一种定义，它更便于用于计算目的。引理27证明这两个定义实际上是等价的。\n\n**定义24**(多项式函数在一点的阶数的通常定义)令$G\\in \\bar K[C]^{*} , P\\in C , U\\in \\bar K(C)$是关于$P$的单值化参数，记$G=U^{d}S$，其中$S\\in \\bar K(C) , S(P)\\neq 0,\\infty$。$G$的阶在$P$处定义为$ord_{P}(G)=d$。\n\n**引理25** 令$G_{1} , G_{2}\\in \\bar K[C]^{*} , P\\in C$，记$ord_{P}(G_{1})=r_{1} , ord_{P}(G_{2})=r_{2}$。\n\n$\\textrm{(i)}\\ ord_{P}(G_{1}G_{2})=ord_{P}(G_{1})+ord_{P}(G_{2})$\n\n$\\textrm{(ii)}$若$G_{1}\\neq -G_{2}$。若$r_{1}\\neq r_{2}$，则$ord_{P}(G_{1}+G_{2})=\\textrm{min}(r_{1},r_{2})$，若$r_{1}=r_{2}$则$ord_{P}(G_{1}+G_{2})\\geq\\textrm{min}(r_{1},r_{2})$\n\n证明：由定义24易证！\n\n**定义26**(多项式函数在一点的阶数的另一种定义) $G=a-bv\\in \\bar K[C]^{*} , P\\in C$，$G$在$P$处的定义记为$ord_{P}(G)$，定义如下：\n\n$\\textrm{(i)}$若$P(x,y)$是有限点，则令$r$为$u-x$能够同时整除$a(u),b(u)$的最高次数，记$G(u,v)=(u-x)^{r}[a_{0}(u)-b_{0}(u)v]$，若$a_{0}(x)-b_{0}(x)y\\neq 0$，则令$s=0$；否则，令$s$为$u-x$能整除$N(a_{0}(u)-b_{0}(u)v)=a_{0}^{2}+a_{0}b_{0}h-b_{0}f$。若$P$是一个平凡点，则定义$ord_{P}(G)=r+s$，若$P$是一个特殊点，则定义$ord_{P}(G)=2r+s$。\n\n$\\textrm{(ii)}$若$P=\\infty$，则$ord_{P}(G)=-max[2deg(a),2g+1+2deg(b)]$。\n\n**引理27** 定义24与定义26等价。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 10.png pic10 %}</div>\n\n&nbsp;\n\n**引理28** 令$G\\in \\bar K[C]^{*} , P\\in C$。则$ord_{P}(G)=ord_{\\bar P}(\\bar G)$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\n**定理29**$G\\in \\bar K[C]^{*}$。则$G$存在有限个零点与极点；此外，$\\sum _{P\\in C}ord_{P}(G)=0$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n**定义30**(有理函数在一点上的阶数)令$R=G/H\\in \\bar K(C)^{*} , P\\in C$，$R$在$P$处的阶数定义为$ord_{P}(R)=ord_{P}(G)-ord_{P}(H)$。\n\n不难证明ordP (R)不依赖于G和H的选择，引理25和定理29对于非零有理函数也成立。","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(三)多项式与有理函数","url":"/crypto/Hyper-ch3.html","content":"\n本节介绍多项式和有理函数的基本性质，这些性质是将它们视为超椭圆曲线上的函数而产生的。\n\n**定义8**(坐标环，多项式函数)$K$上$C$的坐标环，定义为$K[C]$，是商环\n$$\nK[C]=K[u,v]/(v^{2}+h(u)v-f(u))\n$$\n其中$(v^{2}+h(u)v-f(u))$定义为由多项式$v^{2}+h(u)v-f(u)$生成的$K[u,v]$的理想。类似地，$\\bar K$上$C$的坐标环定义为\n$$\n\\bar K[C]=\\bar K[u,v]/(v^{2}+h(u)v-f(u))\n$$\n$\\bar K[C]$的一个元素称为$C$上的多项式函数。\n\n**引理9** $\\bar K$上的多项式$r(u,v)=v^{2}+h(u)v-f(u)$不可约，从而$\\bar K[C]$是一个整环。\n\n证明：\n\n若$r(u,v)$在$\\bar K$可约，那么它将被分解为$(v-a(u))(v-b(u)),a,b\\in \\bar K[u]$。然而，此时$deg(a\\cdot b)=deg(f)=2g+1,deg(a+b)=deg(h)=g$，这是不可能的！\n\n注意到对每个$G(u,v)\\in \\bar K[C]$，我们可以重复地用$f(u)-h(u)v$替换$v^{2}$直到最终得到如下表示：\n$$\nG(u,v)=a(u)-b(u)v,a(u),b(u)\\in \\bar K[u]\n$$\n显然这种表示是唯一的。\n\n**定义10**(共轭)令$G(u,v)=a(u)-b(u)v$是$\\bar K[C]$的一个多项式函数。$G(u,v)$的共轭被定义为$\\bar G(u,v)=a(u)+b(u)[v+h(u)]$。\n\n**定义11**(范数)令$G(u,v)=a(u)-b(u)v$是$\\bar K[C]$的一个多项式函数。$G$的范数为多项式函数$N(G)=G\\cdot \\bar G$。\n\n范数函数在把关于双变量多项式函数的问题转化为关于单变量多项式的简单问题时非常有用。\n\n**引理12**(范数的性质)令$G,H\\in \\bar K[C]$为多项式函数。\n\n$\\textrm{(i)}\\ N(G)$是$\\bar K[u]$的一个多项式；\n\n$\\textrm{(ii)}\\ N(\\bar G)=N(G)$；\n\n$\\textrm{(iii)}\\ N(GH)=N(G)N(H)$；\n\n证明：$N(G)=a^{2}(u)-b^{2}(u)f(u)+a(u)b(u)h(u)$...基本就是套定义，没有什么思路的难度。\n\n**定义13**(函数域，有理函数)$K$上$C$的函数域$K(C)$是$K[C]$的分数域。同理，$\\bar K$上$C$的函数域$\\bar K(C)$是$\\bar K[C]$的分数域。$\\bar K(C)$的元素被称为$C$上的有理函数。\n\n注意到$\\bar K[C]$是$\\bar K(C)$的子环，即每个多项式函数也是有理函数。\n\n**定义14**(有理函数在有限点处的值)令$R\\in \\bar K(C),P\\in C,P\\neq \\infty$。如果存在多项式函数$G,H\\in \\bar K[C]$，使得$R=G/H$且$H(P)\\neq 0$，则称$R$在$P$处有定义。如果没有这样的$G,H\\in \\bar K[C]$存在，则$R$在$P$处没有定义。如果$R$在$P$处有定义，则$R$在$P$处的值定义为$R(P)=G(P)/H(P)$。\n\n显然值$R(P)$是定义明确的，即它不取决于$G,H$的选择，下面的定义介绍了多项式函数的次数的概念。\n\n**定义15**(多项式函数的次数)令$G(u,v)=a(u)-b(u)v$为$\\bar K[C]$中非零多项式函数，$G$的次数定义为：\n$$\ndeg(G)=max[2deg(a),2g+1+2deg(b)]\n$$\n**引理16**(次数的性质)令$G,H\\in \\bar K[C]$。\n\n$\\textrm{(i)}\\ deg(G)=deg(N(G))$；\n\n$\\textrm{(ii)}\\ deg(GH)=deg(G)+deg(H)$；\n\n$\\textrm{(iii)}\\ deg(G)=deg(\\bar G)$；\n\n证明：\n\n$\\textrm{(i)}N(G)=a^{2}-b^{2}f+abh,deg(N(G))=max[deg(G),deg(a)+deg(b)+g]$，因此只需证$deg(a)+deg(b)+g$必小于$2deg(a)$与$2g+1+2deg(b)$其中一个。\n\n$\\textrm{(ii)}$结合$\\textrm{(i)}$与引理$12\\ \\textrm{(iii)}$的结论，$deg(GH)=deg(N(GH))=deg(N(G)N(H))=deg(N(G))+deg(N(H))=deg(G)+deg(H)$\n\n$\\textrm{(iii)}$结合$\\textrm{(i)}$与引理$12\\ \\textrm{(ii)}$的结论...\n\n**定义17**(有理函数在$\\infty$处的值)令$R=G/H\\in \\bar K(C)$是一个有理函数。\n\n$\\textrm{(i)}$若$deg(G)<deg(H)$则$R$在$\\infty$处的值被定义为$R(\\infty)=0$；\n\n$\\textrm{(ii)}$若$deg(G)>deg(H)$则$R$在$\\infty$处的无定义；\n\n$\\textrm{(iii)}$若$deg(G)=deg(H)$则$R(\\infty)$被定义为$G$与$H$的首项系数的比值。","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(二)基本定义与属性","url":"/crypto/Hyper-ch2.html","content":"\n**定义1(超椭圆曲线)**设$K$是一个域，$\\bar K$是$K$的代数闭包。$K$上类为$g$的超椭圆曲线定义为如下等式：\n$$\nC: v^{2}+h(u)v=f(u)\\ \\textrm{in}\\ K[u,v] \\tag{1}\n$$\n其中$h(u)\\in K[u]$是次数不超过$g$的多项式，$f(u)\\in K[u]$是次数为$2g+1$的首项系数为$1$多项式，并且不存在解$(u,v)\\in \\bar K\\times\\bar K$同时满足方程$v^{2}+h(u)v=f(u)\\ \\textrm{in}\\ K[u,v]$与两个偏微分方程$2v+h(u)=0,h^{'}(u)v-f^{'}(u)=0$。\n\n所谓$C$上的奇异点是一个解$(u,v)\\in \\bar K\\times\\bar K$同时满足上述三个方程。定义$1$表明超椭圆曲线没有任何奇异点。\n\n对于本文的其余部分，假设域$K$和曲线$C$已经固定。\n\n\n\n**引理1** 令$C$是$K$上如式$(1)$定义的超椭圆曲线；\n\n$(\\textrm{i})$ 若$h(u)=0$，则$char(K)\\neq 2$；\n\n$(\\textrm{ii})$ 若$char(K)\\neq 2$，则变量替换$u\\rightarrow u,v\\rightarrow (v-h(u)/2)$将$C$转换为形式$v^{2}=f(u)$，其中$f$的次数为$2g+1$；\n\n$(\\textrm{iii})$ 令$C$是形如$(1)$的等式且$h(u)=0,char(K)\\neq 2$，则$C$是超椭圆曲线当且仅当$f(u)$在$\\bar K$上没有重根；\n\n证明：\n\n$(\\textrm{i})$假设$char(K)=2$，则任意的$x\\in K , 2x=0$，因此要成为曲线$C$上的奇异点只需要满足如下两个等式即可：\n$$\n\\begin{cases}\nv^{2}=f(u)\\\\\n\\\\\nf^{'}(u)=0\n\\end{cases}\n$$\n\n先求满足$f^{'}(u)=0$的根$u_{0}$，再求满足$v^{2}=f(u_{0})$的根$v_{0}$，从而得到曲线$C$的奇异点$(u_{1},v_{0})$；这与$C$是超椭圆曲线矛盾。\n\n$(\\textrm{ii})$经变量替换，$C$的形式为：$(v-\\frac {h(u)} {2})^{2}=f(u)\\Rightarrow v^{2}=f(u)-\\frac {h^{2}(u)} {4}$，而$deg(h)\\leq g\\Rightarrow deg(f(u)-\\frac {h^{2}(u)} {4})=2g+1$。\n\n$(\\textrm{iii}) 当h(u)=0,char(K)\\neq 2$时，$C$有奇异点等价于存在$(u,v)\\in \\bar K\\times\\bar K$，满足：\n$$\n\\begin{cases}\nv^{2}=f(u)\\\\\n\\\\\n2v=0\\\\\n\\\\\nf^{'}(u)=0\n\\end{cases}\n$$\n等价于：\n$$\n\\begin{cases}\nf(u)=0\\\\\n\\\\\nf^{'}(u)=0\\\\\n\\\\\nv=0\n\\end{cases}\n$$\n因此，$C$有奇异点等价于存在$u\\in \\bar K$，满足：\n$$\n\\begin{cases}\nf(u)=0\\\\\n\\\\\nf^{'}(u)=0\n\\end{cases}\n$$\n即$f$有重根；因此，$C$是超椭圆曲线等价于$f$无重根。\n\n**定义3**(有理点，无限点，有限点)设$L$是$K$的扩展域。$C$上$L$有理点的集合，记为$C(L)$，是满足曲线$C$的等式$(1)$的所有点$P(x,y)\\in L\\times L$连同一个在无穷远处的特殊点(记为$\\infty$)，点集$C(\\bar K)$简单地被$C$定义，$C$上异于$\\infty$的点称为有限点。\n\n\n\n**例4**(实数域上的超椭圆曲线)如下是实数域上的超椭圆曲线的三个例子，每条曲线类$g=2$且$h(u)=0$。\n\n$(\\textrm{i})\\ C_{1}:\\ v^{2}=u^{5}+u^{4}+4u^{3}+4u^{2}+3u+3=(u+1)(u^{2}+1)(u^{2}+3)$，$C_{1}$在实平面的图像如图$1$所示；\n\n<div style=\"width:80%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\n$(\\textrm{ii})\\ C_{2}:\\ v^{2}=u^{5}+u^{4}-u^{2}-u=u(u-1)(u+1)(u^{2}+u+1)$，$C_{2}$在实平面的图像如图$2$所示；\n\n<div style=\"width:80%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\n$(\\textrm{iii})\\ C_{3}:\\ v^{2}=u^{5}-5u^{3}-u^{2}+4u=u(u-1)(u+1)(u-2)(u+2)$，$C_{3}$在实平面的图像如图$3$所示；\n\n<div style=\"width:80%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\n\n\n**定义5**(相反点、特殊点和平凡点)令$P(x,y)$是曲线$C$上的一个有限点。$P$的相反点是$\\bar P(x,-y-h(x))$。(注意到$\\bar P$确实在$C$上。)我们同样定义$\\infty$的相反点$\\bar \\infty=\\infty$为他的本身。若一个有限点$P$满足$P=\\bar P$，则该点被称为特殊的；否则，该点被称为平凡的。\n\n\n\n**例6**($Z_{7}$上的超椭圆曲线)考虑有限域$Z_{7}$上的曲线$C:v^{2}+uv=u^{5}+5u^{4}+6u^{2}+u+3$。这里，$h(u)=u,f(u)=u^{5}+5u^{4}+6u^{2}+u+3$且$g=2$，可以证明$C$没有奇异点(除了$\\infty$)，因此$C$确实是一个超椭圆曲线。$C$上的$Z_{7}$有理点为$C(Z_{7})={\\infty,(1,1),(1,5),(2,2),(2,3),(5,3),(5,6),(6,4)}$，点$(6,4)$是一个特殊点。\n\n\n\n**例7**($F_{2^{5}}$上的超椭圆曲线)考虑有限域$F_{2^{5}}=F_{2}[x]/(x^{5}+x^{2}+1)$，并且令$\\alpha$是本原多项式$x^{5}+x^{2}+1$在$F_{2^{5}}$的根。$\\alpha$的指数如表$1$所示。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n考虑有限域$F_{2^{5}}$上类$g=2$曲线$C: v^{2}+(u^{2}+u)v=u^{5}+u^{3}+1$，这里$h(u)=u^{2}+u,f(u)=u^{5}+u^{3}+1$，可以证明$C$没有奇异点(除了$\\infty$)，因此$C$实际上是一个超椭圆曲线。$C(F_{2^{5}})$中的有限点如下：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n其中，点$(0,1),(1,1)$是特殊的。","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(一)简介","url":"/crypto/Hyper-ch1.html","content":"\n**前言**：本文对具有密码相关性的任意特征的有限域上的超椭圆曲线的一些理论作了初步的介绍。给出了在超椭圆曲线雅可比矩阵中求解的康托算法，并证明了该算法的正确性。\n\n\n超椭圆曲线是一类特殊的代数曲线，可以看作是椭圆曲线的推广。对每类$g\\geq1$的超椭圆曲线，当$g=1$时超椭圆曲线退化为椭圆曲线。一百多年来，人们对椭圆曲线进行了广泛的研究，并有大量的相关文献;例如，参见西尔弗曼[34,35]的著作。最初研究椭圆曲线主要是出于纯粹的审美原因，最近已成为几个重要应用领域的必要工具，包括编码理论(如Driencourt和Michon[11]和van der Geer [15])；伪随机数生成(如Kaliski [18]);数论算法(如Goldwasser and Kilian[16]和Lenstra [21]);和公开密钥密码学(见Koblitz [19]， Miller[27]和Menezes [25])。\n\n另一方面，超椭圆曲线理论还没有得到学术界足够的重视。在代数几何文献中出现的关于超椭圆曲线的大多数结果都是用非常一般的术语表达的。例如，在有关超椭圆曲线的论文中，一个常见的来源是芒福德的书[28]。然而，非专业人士很难将本书中的结果专门研究(更不用说发现)到超椭圆曲线的特殊情况。另一个困难是，这些书中的理论通常仅限于复数上的超椭圆曲线(如芒福德的书)，或特征不等于$2$的代数闭域。最近的Cassels和Flynn[6]的书是关于类为$2$曲线的广泛记述。(与他们的书相比，我们的方法绝对是“低级的”。)近年来，超椭圆曲线在代数几何以外的领域得到了应用。超椭圆曲线是Adleman和Huang关于证明[3]的质数的随机多项式时间算法的关键组成部分。在纠错码[4]、整数分解算法[22]和公钥密码[20]的设计中也考虑了超椭圆曲线。对于实现这些代码和密码系统，在特征为$2$的有限域上的超椭圆曲线是特别有趣的。\n\nCharlap和Robbins[7,8]对椭圆曲线进行了初步的介绍。目的是为有限域上计算椭圆曲线上的点的Schoof算法[33]的一些基本理论提供基本的自成证明。讨论仅限于不等于2或3的特征域。然而，在实际应用中，椭圆曲线和超椭圆曲线在两个特征域上特别具有吸引力。本文与Charlap和Robbins的思想相似，对具有密码相关性的任意特征有限域上的超椭圆曲线的一些理论作了初步的介绍。关于代数曲线理论的一般介绍，请参阅富尔顿的著作[14]。","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"第二章第八节 多协议标记交换MPLS","url":"/course/cn-ch2-par8.html","content":"\n## MPLS的工作原理\n\nMPLS工作原理图如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 30.png pic30 %}</div>\n\n&nbsp;\n\n一个标记仅仅在一对标记交换路由器LSR之间才有意义，MPLS数据包每经过一个LSR，LSR需要做两件事：更换标记与转发。划分为同一转发等价类的数据包被设置同样的标记，转发等价类也可用于负载均衡。\n\n## MPLS头部\n\nMPLS头部格式如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 31.png pic31 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第二章第六节 IP多播","url":"/course/cn-ch2-par6.html","content":"\n## 网际组管理协议IGMP\n\nIGMP协议基于IP协议。IGMP的工作大体分为两类。\n\n* 有主机要加入某一多播组时，主机向该多播组的多播地址发送一个IGMP报文，声明加入该组。本地的多播路由器收到IGMP报文后，需利用多播路由选择协议将这种组成员关系转发给互联网上的其他多播路由器；\n* 本地多播路由器需周期性探询本地局域网上的主机，以便知道这些主机是否仍然为组成员。只要有一台组内的主机响应，那么本地的多播路由器就认为该组活跃，否则，本地的多播路由器认为局域网中所有主机离开该组，不再将这个组的成员关系转发给其他多播路由器；\n\n为减少网络开销，IGMP协议具有以下特点。\n\n* 主机与多播路由器间的所有通信均为IP多播；\n* 多播路由器在探询组成员关系时，只需要对所有组发送一个请求信息的询问报文；\n* 同一组内每台主机都要监听响应，若本组的其他主机先发送了响应，则自己不用再发送响应；\n\n## 多播路由选择协议\n\n多播路由选择就是要找出以源主机为根节点的多播转发树，多播路由选择协议尚未标准化，下面介绍多播路由选择的3种方法。\n\n### 洪泛与剪除\n\n开始，路由器使用洪泛法转发多播数据报，每个路由器在收到一个数据包后，检查数据包是否是从源点经最短路径传送来的(计算从路由器到源点的最短路径，判断刚刚转发数据包的路由器是否为最短路径上的第一个路由器)。若是，则向所有其他方向转发此多播数据包，否则丢弃而不转发。如下是一个例子。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 25.png pic25 %}</div>\n\n&nbsp;\n\n若多播转发树上的某个路由器的下游树枝已无该多播组的成员，则将该路由器与其下游树枝一起剪除。\n\n### 隧道技术\n\n适用于多播组的位置在地理上分散的情形。在多播数据包进入单播网络时，将多播数据包封装上普通IP头部，到达多播网络后再去除普通IP头部。多播数据包如同在隧道中通过单播网络。\n\n### 基于核心的发现技术\n\n对每个多播组G指定一个核心路由器q，给出q的IP单播地址。q按照洪泛与剪除法创建G的转发树。发送到核心路由器的数据包会被沿途所有路由器检查内容，到达q后，若数据包是多播数据包，则q向G中所有成员转发数据包。若数据包是请求加入G，q就会将源路由器加入G，然后用隧道技术向刚刚加入的路由器转发每个多播数据报的副本。","tags":["计算机网络"],"categories":["course"]},{"title":"第二章第五节 IPv6","url":"/course/cn-ch2-par5.html","content":"\n## IPv6基本首部\n\nIPv6数据报大体分两部分：基本头部与有效载荷，有效载荷中可写入多个扩展头部(非必需)。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 21.png pic21 %}</div>\n\n&nbsp;\n\nIPv6基本头部格式如下。\n\n<div style=\"width:54%;margin:auto\">{% asset_img 22.png pic22 %}</div>\n\n&nbsp;\n\n其中，流标号是基于IPv6所提出的流概念，\"流\"是互联网上从某一源点到某一终点的一系列数据包，这个\"流\"经过的路由器都保证指明的服务质量。\n\n## IPv6地址\n\n每个地址占128位，采用冒号16进制记法。IPv6地址分类如下。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 23.png pic23 %}</div>\n\n## 从IPv4向IPv6过渡\n\n(1)双协议栈；(2)隧道技术：在IPv6数据报要进入IPv4网络时，将其封装为IPv4数据报。示意图如下。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 24.png pic24 %}</div>\n\n&nbsp;\n\n## ICMPv6\n\n与IPv4一样，IPv6也不保证数据的可靠交付，因此IPv6也需要使用类似ICMP的协议来反馈差错信息——ICMPv6，它还将地址解析协议ARP、网际组管理协议IGMP合并进自身。","tags":["计算机网络"],"categories":["course"]},{"title":"第二章第四节 互联网的路由选择协议","url":"/course/cn-ch2-par4.html","content":"\n## 基本概念\n\n理想的路由算法应具有如下特点：(1)算法必须正确、完整；(2)算法易于计算；(3)算法具有自适应性，即能适应通信量与网络拓扑的变化；(4)稳定性；(5)公平性；(6)算法应是最优的。实际的路由算法应尽可能接近理想的路由算法。\n\n### 分层的路由选择协议\n\n互联网采用分层次的路由选择协议，整个互联网被划分为许多较小的自治系统AS。于是，路由选择协议分为两类：(1)内部网关协议IGP：自治系统内部使用的路由选择协议，如RIP、OSPF协议；(2)外部网关协议：各自治系统间使用的路由选择协议，如BGP-4。\n\n## 内部网关协议RIP\n\n### 工作原理\n\nRIP协议要求网络中的每个路由器均维护一个从自身到所有其他网络的距离，即跳数。RIP协议有如下特点：\n\n* 只与相邻路由器交换信息。\n* 路由器无保留地交换信息。\n* 路由器按固定的时间间隔交换信息。\n\n路由表中的主要信息为：(1)到某个网络的最短距离；(2)下一跳的地址；路由器更新要做的就是刷新到各个网络的最短距离及其应该经过的下一跳地址。即RIP协议所使用的距离向量算法。\n\n### 距离向量算法\n\n对每一相邻路由器发来的RIP报文，路由器根据此报文更新路由表：\n\n(1)对地址为X的相邻路由器发来的RIP报文中的路由表，将路由表中的所有路由的下一跳项改为X、距离项的值加1；\n\n(2)对修改后的每一路由r：若路由器的路由表中没有到r中目的网络y的路由，则将此路由添加到路由器的路由表中。否则，记路由器的路由表中到目的网络y的路由为s，(i)若s的下一跳地址为X，则将r替换s；(ii)s的下一跳地址非X，若r的距离小于s的距离，则将r替换s。\n\n(3)若3分钟未收到相邻路由器的路由表，则将此相邻路由器标记为不可达。\n\n### RIP协议的报文格式\n\n<div style=\"width:56%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\n其中路由标记填入自治系统号ASN。RIP实现简单、开销小，存在的问题是传递故障信息的速度很慢，适用于小规模网络。\n\n## 内部网关协议OSPF\n\n### 工作原理\n\nOSPF为分布式链路状态协议，具有以下3个特点：\n\n* 采用洪泛法向所有相邻的路由器发送信息；\n* 发送的信息为与自身相邻的所有路由器的链路状态，链路状态包含费用、距离、时延、带宽等等；\n* 只有链路状态发生变化时，发生变化的路由器才使用洪泛法向所有相邻的路由器发送信息；\n\n各路由器之间频繁交换链路状态信息，最终所有的路由器都能建立一个链路状态数据库，即全网的拓扑结构图。每个路由器根据拓扑结构图使用Dijkstra算法计算到各路由器的路由。\n\n### 划分区域\n\nOSPF为适应大规模的自治系统，将其划分为若干个小范围——区域，每一区域有一个32位的标识符。此时再使用洪泛法发送信息时就只在区域内传递。为使得区域间能发送消息，OSPF会定义一个主干区域，其他区域均为边界区域。主干区域的标识符为0.0.0.0，它连接所有的边界区域，来自其他区域的信息先汇集到该区域的边界路由器，进入主干区域后流入目的区域。如下是一个例子。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 15.png pic15 %}</div>\n\n&nbsp;\n\n### OSPF协议报文格式\n\nOSPF使用IP数据报传递信息，OSPF分组使用如下图的24字节固定长度头部，如下图为OSPF协议报文格式。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n&nbsp;\n\nOSPF报文共有5种类型。其中路由器标识符标志发送此报文的路由器接口IP地址。OSPF具有以下特点：\n\n* OSPF允许管理员给每条路由指派不同的代价；\n* 若到目的网络存在多条代价相同的路由，OSPF可将通信量分配到多条路径，达到多路由间的负载均衡；\n* 所有使用OSPF协议的路由器在交换时都会进行鉴别，确保仅在可信赖的路由器间交换链路状态信息；\n* OSPF支持可变长度的子网划分与无分类的编址CIDR；\n* 由于网络中的链路状态经常变化，因此OSPF让每一个链路状态带有一个32位的序号，每次链路状态改变序号加1，且OSPF协议规定增长的速率不超过次/5s；\n\n### 5类OSPF报文\n\n* 问候报文。发现与维持相邻路由器的可达性；\n* 数据库描述报文。向相邻路由器发送自身链路状态数据库中所有链路状态项目的摘要信息；\n* 链路状态请求报文。向目的路由器请求其发送某些链路状态项目的详细信息；\n* 链路状态更新报文。使用洪泛法向全网更新链路状态；\n* 链路状态确认报文。对链路更新分组进行确认；\n\n除问候报文外，其余四类报文均用来进行链路状态数据库的同步。一个刚刚工作的路由器先通过问候报文得知有哪些路由器与之物理相邻。每个路由器向相邻路由器发送数据库描述报文，路由器再根据这些数据库描述报文向对应路由器发送链路状态请求报文。通过一系列交互，建立起全网同步的链路数据库。上述同步的示意图如下。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n## 外部网关协议BGP\n\n### 工作原理\n\n在配置BGP时，每个自治系统的管理员至少选择一个路由器作为\"BGP发言人\"，BGP发言人使用TCP连接交换路由信息。BGP发言人与自治系统AS之间的关系如下图。各BGP发言人之间交换的信息就是达到某个网络需经过的自治系统。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 18.png pic18 %}</div>\n\n&nbsp;\n\nBGP协议支持无分类域间路由选择CIDR，因此使用BGP协议的路由器的每条路由应包含目的网络前缀、下一跳IP地址、到达目的网络需经过的自治系统序列。若某个BGP发言人收到其他BGP发言人的路径通知，它需要检查自身是否在通知的路径中，若在，则不能采用此路径，避免形成回路。\n\n路由器运行稳定后，路由器只需要在自治系统发生变化时发送BGP报文。\n\n### 4类BGP报文\n\n* OPEN报文。与相邻的BGP发言人建立关系，初始化通信；\n* UPDATE报文。告知某一路由的信息(不能增加多条)，以及列出要撤销的多条路由；\n* KEEPALIVE报文。周期性地证实连接的连通性。\n* NOTIFICATION报文。发送检测到的差错。\n\n### BGP报文格式\n\n4类BGP报文具有同样的通用BGP头部，如下图所示。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 19.png pic19 %}</div>\n\n&nbsp;\n\nKEEPALIVE报文只有BGP头部，共19字节。OPEN报文主体有6个字段：版本、本自治系统号、保持时间、BGP标识符、可选参数长度、可选参数；UPDATE报文主体有5个字段：不可行路由长度、撤销路由列表、路径属性总长度、路径属性、网络层可达信息。NOTIFICATION报文有3个字段：差错代码、差错子代码、差错数据。\n\n## 路由器简介\n\n典型的路由器结构如下。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 20.png pic20 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第二章第三节 网际控制报文协议ICMP","url":"/course/cn-ch2-par3.html","content":"\n## 概述\n\n为更有效地转发IP数据报，在网络层使用网际控制报文协议ICMP。ICMP允许路由器或主机报告IP数据报的差错情况。ICMP报文格式如下：\n\n<div style=\"width:45%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\nICMP报文分两种：ICMP差错报告报文与ICMP询问报文。ICMP报文前4字节是包含3个字段(类型、代码、校验和)的固定格式，接下来4个字节的内容与ICMP的类型有关。最后的数据字段取决于ICMP的类型。下表给出常用的ICMP报文类型。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n下面具体介绍。\n\n## ICMP差错报告报文\n\nICMP差错报告报文主要有以下4种：\n\n* 终点不可达。路由器或主机无法交付数据报。\n* 时间超过。路由器收到生存时间为0的数据报，丢弃该数据报，并向数据报的源点发送时间超过ICMP报文。\n* 参数问题。路由器或目的主机收到的数据报头部有不正确字段，则丢弃该数据报，向源点发送参数问题报文。\n* 改变路由(重定向)。路由器将改变路由报文发送给主机，告知主机下次将报文发送给另外的路由器。\n\n对于需要进行差错报告的IP数据报，路由器或主机会将IP头部与IP数据字段的前8字节取出，作为ICMP报文的数据字段，再填写ICMP头部得到ICMP报文。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n&nbsp;\n\n对于以下几种情形，均不发送ICMP差错报文。\n\n* 对ICMP报文，它也是IP数据报，但是对于它的差错情况无需发送ICMP差错报文；\n* 一个IP数据包出错，路由器发送ICMP差错报文后，同属于这一数据报的数据包的差错情况不用再发ICMP差错报文；\n* 对具有多播地址或特殊地址(127.0.0.0、0.0.0.0)的数据报，均不发送ICMP差错报文；\n\n## ICMP询问报文\n\n(1)回送请求与回答；ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问，收到此报文的主机必须给查询方回复ICMP回送回答报文。这类报文用来测试目的站是否可达以及了解其相关状态。\n\n(2)时间戳请求与回答；ICMP时间戳请求报文向目的主机或路由器查询当前日期与时间，这类报文用于时钟同步与时间测量。\n\n## ICMP应用举例\n\nunix/Linux上的应用traceroute可以显示一个数据报从源点到终点的路径，此工具的原理如下。\n\ntraceroute从源主机向目的主机发送UDP数据报，第一个数据报P1的生存时间TTL设为1，那么当P1到达路径上第一个路由器R1时，R1将其接收，并将P1的TTL减1，于是TTL等于0，R1便将P1丢弃并向源主机发送一个ICMP时间超过差错报告报文，于是traceroute就得到了路径上的第一个路由器的IP地址；\n\n第二个数据报P2的生存时间TTL设为2从而得到路径上的第二个路由器的IP地址；以此类推，直到UDP数据报恰能到达目的主机，但是由于UDP报文中的目的端口不正确(不存在对应于该端口号的应用进程)，目的主机就会丢弃该报文，并向源主机发送ICMP终点不可达差错报告报文。","tags":["计算机网络"],"categories":["course"]},{"title":"第二章第二节 划分子网与构造超网","url":"/course/cn-ch2-par2.html","content":"\n## 划分子网\n\n基本思路如下：\n\n* 一个拥有多个物理网络的单位，将所属的物理网络划分为若干子网，但该单位对外仍表现为一个网络。\n* 从网络的主机号借用若干位作为子网号，两级IP地址在本单位内部变成三级IP地址{<网络号><子网号><主机号>}。\n* 发送给本单位某台主机的网络包到达本单位网络上的路由器后，路由器根据目的网络号与子网号找到目的子网，再将网络包发送给目的子网。\n\n## 子网掩码\n\n<div style=\"width:50%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n&nbsp;\n\n目的IP与子网掩码按位与得到子网地址。网络的默认子网掩码中1的位置与网络中主机IP地址的网络号字段对应。\n\n## 使用子网时的分组转发\n\n在划分子网的情形下，路由表的每条路由主要包含三项：目的网络地址、子网掩码、下一跳IP地址，分组转发算法也要做出相应改变。\n\n* 路由器从网络包的IP头部提取目的IP；将目的IP与各子网掩码按位与，若计算结果等于路由器所在子网地址，则路由器直接将网络包交付目的主机；否则，执行下一步。\n* 若路由器的路由表中有目的IP的特定路由，则路由器将网络包发给路由表所指明的下一跳路由器。否则，执行下一步。\n* 对路由表的每一行<目的网络地址, 子网掩码, 下一跳IP地址>，用其子网掩码与网络包的目的IP按位与，若计算结果等于其目的网络地址，则将数据传递给该路由的下一跳IP地址。否则，执行下一步。\n* 若路由器中有一个默认路由，则路由器将网络包发给路由表所指明的默认路由器。否则，执行下一步。\n* 报告分组转发出错。\n\n## 无分类编址CIDR\n\n### 网络前缀\n\n无分类域间路由选择。CIDR将32位的IP地址划分为前后两个部分，前面部分指明网络，后面部分指明主机。消除了传统的A类、B类、C类地址与划分子网概念。如下是一个CIDR地址划分的例子。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n&nbsp;\n\n### 最长前缀匹配\n\n根据上节的例子可以看到，在查找路由表时可能会得到不止一个匹配结果，此时应该选择匹配长度最长的路由。这称为最长前缀匹配。\n\n### 二叉线索查找路由\n\n为进行有效查找，无分类编址的路由表存放在二叉线索树中。在查找前，找出对应每个IP地址在表中的唯一前缀，接下来以这些前缀构造二叉线索，查找时，只要可以与唯一前缀匹配即可。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 10.png pic10 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第二章第一节 网际协议IP","url":"/course/cn-ch2-par1.html","content":"\n## 虚拟互连网络\n\n许多计算机网络通过路由器互连，参加互连的计算机网络都使用相同的网际协议IP，因此可以把互连以后的计算机网络看成如下图所示的一个虚拟互连网络。互连起来的各种物理网络的异构性是客观存在的，但是使用IP协议就可以使这些性能各异的网络在网络层看起来如同一个统一的网络。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\n## 分类的IP地址\n\n将IP地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，第一个字段称为网络号，第二个字段称为主机号。组成的IP地址在整个互联网范围内是唯一的。这种两级IP地址记为{<网络号><主机号>}。如下图是各种类型的IP地址：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n## IP地址与硬件地址\n\n(1)设计IP地址的目的。(有了MAC地址为什么还要IP地址)\n\n随着网络中设备的逐渐增多，人们发现路由(寻址数据包从发送端到接收端的路径)越来越困难。于是有人提出将网络划分成很多的子网，在路由时就可以将其他子网看成一个整体，路由器只需要考虑将数据包发送到接收端所在子网即可(剩下工作由子网内部解决)。这样找到的路由接近最优路由但大大减少了计算量。于是，需要有一种地域相关的地址，而IP地址就是！位于同一子网上的网络设备，其IP地址的前缀一致。从而在路由时通过IP地址找到较优路由。\n\n(2)设计MAC地址的目的。(有了IP地址为什么还要MAC地址)\n\nMAC地址是网卡地址，网卡才是真正能够做通讯的设备，IP只是上层的软件，负责将不同的网络连接在一起。\n\n&nbsp;\n\nIP地址用在网络层及以上，MAC地址用在数据链路层及以下。如下图，三个局域网用两个路由器连接起来，由于路由器R1、R2同时连接在两个局域网上，因此R1、R2都有两个MAC地址。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n## 地址解析协议ARP\n\n### ARP报文格式\n\n<div style=\"width:60%;margin:auto\">{% asset_img 55.jpg pic55 %}</div>\n\n&nbsp;\n\n* 硬件地址：表示ARP报文可在哪种类型的网络上传输，1表示以太网；\n* 上层协议类型：表示硬件地址要映射的地址协议类型。映射IP地址时为0x0800；\n* MAC地址长度：6；\n* IP协议地址长度：4；\n* 操作类型：1表示请求报文，2表示应答报文；\n\nARP报文加上MAC头部发送到网络上。\n\n### ARP工作原理\n\n根据IP地址，解析出同一局域网上设备的MAC地址。每台主机上都设置一个ARP高速缓存，存放着本局域网上各主机与路由器的IP地址到MAC地址的映射表。显然，如果主机查询的IP地址在主机的ARP高速缓存中存在，即可读取出IP地址对应的MAC地址，否则，按如下步骤找出IP地址对应的MAC地址。\n\n* 查询主机的ARP进程在本局域网上广播发送一个ARP请求分组用于查询IP地址对应的MAC地址；\n* 本局域网上所有主机运行的ARP进程都收到此ARP请求分组；\n* IP地址与请求分组中查询MAC地址的IP地址不一致的主机忽略此请求，否则，(IP地址与请求分组中查询MAC地址的IP地址一致的主机)向查询主机发送ARP响应分组，其中包含自身的MAC地址。同时在自身的ARP高速缓存中写入查询主机的IP : MAC映射；在Linux上可使用`arp -a`查看当前的ARP高速缓存。\n* 查询主机收到响应分组后，在其ARP缓存中添加这组IP : MAC映射；\n\n<div style=\"width:60%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n&nbsp;\n\n## IP数据报的格式\n\n<div style=\"width:60%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n* 首部长度。以4字节为单位，即若首部长度为5，则表示IP首部的长度为20字节；\n* 标识。IP软件维持一个计数器，每产生一个数据报，计数器加1，并将计数器的值赋给标识字段。这个标识并不是序号(IP是无连接的)，这是因为当数据报很长需要分组传输时，每个分组的数据包的标识字段都是一样的。相同标识字段的数据包意味着数据包来自同一数据报；\n* 总长度。整个IP数据包的长度，以字节为单位；该字段占16位，故IP数据包的长度最大为65535字节；\n* 标志。该字段最低位记为MF位，MF位为1表示该数据报还有分组，MF位为0表示这是数据报中最后一个分组；该字段中间位记为DF位，DF为0表示允许IP数据报分组，否则不允许IP数据报分组；\n* 片偏移。较长的数据报在分组后，某分组在原数据报中的相对位置，片偏移以8字节为偏移单位，即每个分组的长度必为8字节的整数倍；\n* 生存时间(TTL)。占8位，IP数据包每经过一个路由器，路由器就会将IP数据包的TTL减1，若IP数据包的TTL为0，则丢弃该IP数据包；\n* 协议。指明该IP数据报携带的数据使用的哪种协议，常见的TCP协议为6、UDP协议为17、IPv6协议为41；\n\n<div style=\"width:66%;margin:auto\">{% asset_img 57.png pic57 %}</div>\n\n&nbsp;\n\n\n\n## IP数据报的分组转发\n\n在路由表中，最主要的路由包含(目的IP地址, 下一跳IP地址)。网络包每次到达路由器，路由器都根据目的IP地址确定下一跳路由器的IP地址，然后将IP数据包送交数据链路层的网络接口，网络接口将下一跳的IP地址借助ARP协议转换为MAC地址，它将作为MAC头部的目的地址，然后路由器将网络包发送到下一跳路由器。归纳如下分组转发算法。\n\n* 路由器从网络包的IP头部提取目的IP；若目的IP与路由器在同一网络，则路由器直接将网络包交付目的主机；否则，执行下一步。\n* 若路由器的路由表中有目的IP的特定路由，则路由器将网络包发给路由表所指明的下一跳路由器。否则，执行下一步。\n* 若路由表有到达目的主机所在网络的路由，则路由器将网络包发给路由表所指明的下一跳路由器。否则，执行下一步。\n* 若路由器中有一个默认路由，则路由器将网络包发给路由表所指明的默认路由器。否则，执行下一步。\n* 报告分组转发出错。","tags":["计算机网络"],"categories":["course"]},{"title":"第一章 计算机网络体系结构","url":"/course/cn-ch1.html","content":"\n## 分层的好处\n\n分层的好处：(1)各层之间相互独立；(2)灵活；(3)易于实现与维护；(4)促进标准化。通常各层要完成以下功能：\n\n* 差错控制：保证相应层次对等方的通信可靠；\n* 流量控制：发送的数据要让接收端来得及接收；\n* 分段与重装：发送端将要发送的数据划分为一定长度的数据块，接收端要将接收的数据块还原；\n* 复用与分用：发送端的多个高层应用复用一条低层的连接，而接收端的低层将收到的信息分别交付高层的多个应用；\n* 连接建立与释放：通信开始前建立连接，通信结束断开连接；\n\n## 五层协议模型\n\n<div style=\"width:56%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\n**应用层**\n\n通过应用进程间的交互来完成特定网络应用。应用层协议定义应用进程间通信与交互的规则。如域名系统DNS、HTTP协议、SMTP电子邮件协议。\n\n**传输层**\n\n向两台主机中进程之间的通信提供通用的数据传输服务。传输层主要有TCP协议与UDP协议：\n\n* 传输控制协议TCP：提供面向连接、可靠的数据传输服务；\n* 用户数据报协议UDP：提供无连接的、尽最大努力的数据传输服务；\n\n**网络层**\n\n为分组交互网上的不同主机提供通信服务。网络层主要使用IP协议。\n\n## TCP/IP协议族\n\n将TCP/IP协议族按层次描述如下图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 2.png pic2 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第十九章 I/O子系统","url":"/course/os-ch19.html","content":"\n## I/O特点\n\nI/O设备有三种常见类型：字符设备(键盘、鼠标等)，块设备(磁盘驱动器、光驱等)，网络设备(无线网卡、蓝牙等)。不同类型的设备访问特征不同。\n\n* 字符设备：以字节为单位顺序访问，访问使用get()、put()函数；\n* 块设备：读写以一个数据块为单位，访问既可以使用get()、put()函数，也可以使用文件系统接口，或者将文件映射到内存；\n* 网络设备：交互复杂，接收格式化的网络报文，访问使用专门的网络报文收发接口——send/receive；\n\n## I/O结构\n\n如下是整个计算机系统的结构：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 77.png pic77 %}</div>\n\n&nbsp;\n\nI/O的结构层次如下：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 78.png pic78 %}</div>\n\n&nbsp;\n\n下面考虑一个完整的I/O请求的生命周期：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 79.png pic79 %}</div>\n\n## I/O数据传输\n\n访问设备的数据可通过CPU指令(in/out)实现，这种方式便于实现但是消耗CPU(时间与数据量成正比)。或者直接通过内存访问，只需要在传输数据的开始和结束使用CPU，传输数据过程不影响CPU，在高吞吐量的I/O设备中使用该方式。\n\n处理设备请求有两种方式：轮询与设备中断；设备中断效率高，设备中断的I/O处理流程如下：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 80.png pic80 %}</div>\n\n&nbsp;\n\n## Linux I/O子系统\n\nLinux I/O系统结构如下图所示：\n\n<div style=\"width:38%;margin:auto\">{% asset_img 81.png pic81 %}</div>","tags":["操作系统"],"categories":["course"]},{"title":"第十八章 文件系统实例","url":"/course/os-ch18.html","content":"\n## FAT文件系统\n\nFAT文件系统的结构如下：\n\n```basic\n---------------------------------------------------------------------------------------\n| 启动扇区 |   文件分配表   |  文件分配表副本  |  根目录项  |           其他文件           |\n---------------------------------------------------------------------------------------\n```\n\n## EXT4文件系统\n\n支持大容量存储，可快速恢复异常状态。\n\n### 大容量存储\n\n<div style=\"width:68%;margin:auto\">{% asset_img 68.png pic68 %}</div>\n\n&nbsp;\n\n索引块采用\"段机制\"，对于大文件(一般连续)，只需要一次访问。\n\n### 异常恢复\n\nEXT4文件系统框架示意图如下：\n\n<div style=\"width:40%;margin:auto\">{% asset_img 71.png pic71 %}</div>\n\n&nbsp;\n\n其中Group的结构如下图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 69.png pic69 %}</div>\n\n&nbsp;\n\n其中，Bitmaps标志每个文件数据块是否被占用，文件数据块有两种——索引数据块与存储数据块；\n\n当系统出现断电或者系统崩溃，有些在缓存中的数据还未写入文件，这时就出现缓存与文件的数据不一致。EXT4文件系统使用日志来恢复异常(现代的文件系统都是日志文件系统)。日志的组成如下：\n\n<div style=\"width:40%;margin:auto\">{% asset_img 70.png pic70 %}</div>\n\n其中，TxB与TxE分配标志一个日志的开始与结束，中间是日志的内容：\n\n* I[v2]：对更改的存储数据块对应的索引数据块的改变；\n* B[v2]：对更改的存储数据块对应的Bitmaps位的改变；\n* Db：更改的存储数据块；\n\n日志文件系统先将对应日志写入日志数据块，再将缓存数据写入文件。为保证TxE的正确性，先写入TxB、I[v2]、B[v2]，再写入TxE。\n\n为提高数据写入文件的速度，可采用批处理；此外，通过循环日志的方式，缩小日志数据的规模。\n\n为了进一步提高数据写入文件的速度，metadata日志省略了在日志数据块中写入Db，但此时要调整数据写入顺序：Db写入文件->metadata写入日志数据块->metadata写入文件系统。通过强制首先写入数据，保证指针永远不会指向垃圾数据。\n\n## ZFS文件系统\n\n### 概述\n\nZFS是一种新型的文件系统，它提供了简单的管理、事务语义、端到端数据完整性与极大的可扩展性。ZFS文件系统框架如下图：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 72.png pic72 %}</div>\n\n* ZPL：封装的处理文件的接口；\n* DMU：数据管理单元，提供基于对象的事务操作的支持；\n* ARC：(类似内存的)缓存与替换算法；\n* ZIO：对实际的I/O处理做抽象，向ARC层提供支持；\n* VDEV：虚拟设备，内置了各种RAID；\n\nZFS文件系统使用存储池作为存储设备。取消了文件卷，采用分配与回收机制，分配的空间易于调整；\n\n<div style=\"width:40%;margin:auto\">{% asset_img 73.png pic73 %}</div>\n\n&nbsp;\n\n### 数据完整性\n\n**写时复制**：对数据进行修改时，先复制数据的一个副本，在副本上修改完再写回数据的位置(提交)。\n\n读数据时，采用分层校验，即ZFS校验树，每级目录都有校验和；\n\n<div style=\"width:30%;margin:auto\">{% asset_img 74.png pic74 %}</div>\n\n&nbsp;\n\n在读数据时，如果数据未能通过校验，则读取数据副本，并将副本写入数据位置。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 75.png pic75 %}</div>\n\n&nbsp;\n\nZFS采用动态条带宽，不同对象校验数据块的的个数也不同，根据所需安全性来选择合适的校验数据块个数；\n\n<div style=\"width:30%;margin:auto\">{% asset_img 76.png pic76 %}</div>\n\n&nbsp;","tags":["操作系统"],"categories":["course"]},{"title":"第十七章 文件系统概念","url":"/course/os-ch17.html","content":"\n## 文件系统与文件\n\n文件系统是操作系统中管理持久性数据的子系统，提供数据存储与访问功能。文件是具有符号名，由字节序列构成的数据项集合。文件是文件系统的基本数据单位，文件名是文件的标识符号。\n\n**文件系统的功能**\n\n* 分配文件磁盘空间：管理文件数据块、管理空闲空间、分配存储区域；\n* 管理文件集合：文件定位、文件命名、文件系统结构——文件的组织；\n* 数据可靠与安全：安全(多层次保护数据安全)、可靠(持久保存数据，避免系统崩溃、媒体错误、攻击等等)；\n\n**文件属性**\n\n文件属性包括名称、类型、位置、大小、保护、创建者、创建时间、最近修改时间等等。\n\n**文件头**\n\n文件系统元数据中的文件信息。其中包括文件属性以及文件的存储位置与顺序。\n\n## 文件描述符\n\n操作系统维护的打开的文件的状态与信息。包括文件指针、文件打开次数、文件在磁盘上的位置、访问权限等等。\n\n## 目录 文件别名 文件系统种类\n\n目录是一种特殊的文件，用来表示其他文件的信息，目录的内容为文件索引表(每个索引项为<文件名, 指向文件的指针>)。\n\n**日志文件系统**：文件系统的所有修改，都会记录。\n\n## 虚拟文件系统\n\n对所有不同文件系统的抽象。主要实现以下四个功能：\n\n* 提供相同的文件与文件系统接口；\n* 管理所有文件和文件系统关联的数据结构；\n* 高效的查询；\n* 与特定文件系统模块的交互；\n\n### 文件系统基本数据结构\n\n* 文件卷控制块；一个文件系统有一个文件卷控制块，包含文件系统详细信息(块大小、空余块、计数/指针等)。\n* 文件控制块；一个文件有一个文件控制块，包含文件详细信息(访问权限、所有者、大小、数据块位置等)。\n* 目录项；一个文件有一个目录项，将目录项数据结构及树型布局编码成树型数据结构(指向文件控制块、父目录、子目录等)。\n\n整个文件系统的组织视图如下：\n\n<div style=\"width:42%;margin:auto\">{% asset_img 56.png pic56 %}</div>\n\n## 文件缓存与打开文件\n\n### 文件缓存\n\n在计算机系统中存在多处缓存：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 57.png pic57 %}</div>\n\n&nbsp;\n\n数据块有两种缓存方式：数据块缓存与页缓存(将数据块与内存页缓存起来)。\n\n* 数据块缓存：虚拟页对换与文件读写分开。最终合并为数据块缓存。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 58.png pic58 %}</div>\n\n&nbsp;\n\n* 页缓存：在虚拟地址空间中虚拟页面可映射到本地外存文件中。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 59.png pic59 %}</div>\n\n&nbsp;\n\n其中文件数据块被映射为页，文件的读/写操作被转换成对内存的访问。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 60.png pic60 %}</div>\n\n### 打开文件\n\n每个打开的文件都有一个文件描述符，记录文件的状态信息，包括目录项、当前文件指针、文件操作设置等；\n\n每个进程有一个打开文件表，记录进程单独打开的文件描述符；\n\n同时操作系统还有一个打开文件表，其中记录的文件描述符由多个进程共享；\n\n<div style=\"width:60%;margin:auto\">{% asset_img 61.png pic61 %}</div>\n\n&nbsp;\n\n一些文件系统提供文件锁，用于协调多进程的文件访问；文件系统有两个处理方式：强制与劝告。\n\n* 强制：根据锁的状态与访问请求确定是否拒绝访问；\n* 劝告：进程查看锁的状态，由进程决定下一步操作；\n\n## 文件分配\n\n本质为如何表示分配给一个文件数据块的位置与顺序。与内存分配类似，文件分配也有连续、链式、索引分配。所谓索引分配，就是用存储文件数据块的指针来表示分配给一个文件数据块的位置与顺序(这个存储文件数据块的指针的数据块称为索引数据块)。这3种分配方式各有优缺点，实际的文件分配方案会将这三种分配方式结合起来，下面介绍UFS文件系统的文件分配方案。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 62.png pic62 %}</div>\n\n&nbsp;\n\n文件头包含13个指针，前10个指针(直接)指向文件数据块、第11个指针指向索引块、第12个指针指向2级索引块、第13个指针指向3级索引块；对于小文件：这种文件分配退化为连续分配，对于大文件：这种文件分配就是多级索引分配。\n\n## 冗余磁盘阵列\n\n使用多磁盘可改善吞吐量(并行)，增加可靠性(冗余)。\n\n### RAID-0\n\n磁盘条带化技术。将数据分成多个子块，存储在独立的磁盘中。增加了读写的磁盘带宽，读写数据的性能提升。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 63.png pic63 %}</div>\n\n&nbsp;\n\n### RAID-1\n\n向两个磁盘写入，从任何一个读取。增加了可靠性与读数据的性能。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 64.png pic64 %}</div>\n\n&nbsp;\n\n### RAID-4\n\n带校验的磁盘条带化——数据块级别的磁盘条带化加专用奇偶校验磁盘。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 65.png pic65 %}</div>\n\n### RAID-5\n\n带分布式校验的磁盘条带化。减小了带校验和磁盘的读写压力。\n\n<div style=\"width:66%;margin:auto\">{% asset_img 66.png pic66 %}</div>\n\n&nbsp;\n\n此外，这些RAID技术还可以嵌套使用。比如RAID-0与RAID-1的嵌套：\n\n<div style=\"width:45%;margin:auto\">{% asset_img 67.png pic67 %}</div>","tags":["操作系统"],"categories":["course"]},{"title":"第十六章 进程通信","url":"/course/os-ch16.html","content":"\n## 进程通信基本概念\n\n进程通信，简称IPC，是进程进行通信与同步的机制；IPC提供2个基本操作——send(发送操作)与receive(接收操作)；进程通信的流程为：(1)在通信进程间建立通信链路，(2)通过send/receive交互消息；\n\n### 直接通信与间接通信\n\n**直接通信**：send(P,mes)<->receive(Q,mes)，进程在直接通信时必须指明发送/接收的对象是谁。\n\n**间接通信**：通过操作系统维护的消息队列(内核中)实现进程间消息的接收与发送。每个消息队列都有一个唯一的标识，只有共享了相同消息队列的进程才可以通信。\n\n### 阻塞通信与非阻塞通信\n\n阻塞通信\n\n* 发送：发送进程在发送消息后进入等待，直到接收进程成功接收。\n* 接收：接收进程在请求消息后进入等待，直到接收到消息。\n\n非阻塞通信\n\n* 发送：发送进程在发送完消息后不用等待，可继续进行其他操作。\n* 接收：接收进程在请求消息后如果没有收到消息不用等待，可继续进行其他操作。\n\n## 信号与管道\n\n### 信号\n\n进程间软件中断通知与处理机制。信号机制的实现如下图。\n\n<div style=\"width:42%;margin:auto\">{% asset_img 54.png pic54 %}</div>\n\n### 管道\n\n进程间基于内存文件的通信机制。是一种间接通信机制。\n\n* 创建管道：pipe(rgfd)；rgfd是两个文件描述符组成的数组，其中rgfd[0]是读文件描述符、rgfd[1]是写文件描述符。\n* 读管道：系统调用read(fd, buffer, n)\n* 写管道：系统调用write(fd, buffer, n)\n\n## 消息队列与共享内存\n\n### 消息队列\n\n操作系统维护的以字节序列为基本单位的间接通信机制。\n\n### 共享内存\n\n操作系统通过将同一物理内存区域映射到多个进程的地址空间来实现进程通信。需要额外的同步互斥机制。是进程间最快速的通信机制。\n\n## D-bus机制\n\n&nbsp;\n\n## Binder机制\n\n### 一次拷贝\n\n<div style=\"width:68%;margin:auto\">{% asset_img 55.png pic55 %}</div>\n\n当进程A向进程B拷贝数据时，首先将进程A的数据从用户空间拷贝到内核空间，再将内核空间中的数据所在内存区域映射到进程B的用户空间，这样使用一次拷贝即可传递进程A的数据到进程B，之所以没有使用共享内存是为了避免同步互斥的开销。","tags":["操作系统"],"categories":["course"]},{"title":"第十五章 死锁与并发错误检测","url":"/course/os-ch15.html","content":"\n## 死锁的概念\n\n多个进程各自占用部分资源，形成循环等待的现象。\n\n死锁的必要条件：\n\n* 互斥：任何时刻只能有一个进程使用该资源；\n* 持有并等待：进程占用着一个资源，并且还需要等待另外的资源；\n* 非抢占：资源只能由进程使用后自愿释放；\n* 出现了循环等待；\n\n## 死锁处理方法\n\n对死锁的处理采用\"纵深防御\"的思路——死锁预防、死锁避免、死锁检测与恢复；死锁通常由应用程序处理，操作系统层面不考虑死锁。\n\n### 死锁预防\n\n限制并发进程对资源的请求，使操作系统在任何时刻不满足死锁的必要条件；但资源的利用效率低。\n\n### 死锁避免\n\n**安全进程序列**：对一列进程$\\{\\rm{P_1}, \\cdots , \\rm{P_n}\\}$，$\\rm{P_i}$未来需要的资源量(声明所需资源的最大量减去已占用的资源量)<=当前可用资源量+所有$\\rm{P_j(j<i)}$的资源量对所有的$\\rm{i}$均成立，则这个进程序列称为安全进程序列。\n\n系统处于安全状态，即对所有占用资源的进程，存在一个安全进程序列。\n\n于是当进程请求资源时，操作系统判断分配资源之后是否还处于安全状态，如果是，则分配进程申请的资源。\n\n### 死锁检测\n\n检测操作系统是否出现死锁，根据占用资源的进程是否存在一个安全进程序列，如果不存在，操作系统就会出现死锁。","tags":["操作系统"],"categories":["course"]},{"title":"第十四章 信号量与管程","url":"/course/os-ch14.html","content":"\n## 信号量\n\n信号量是操作系统提供的一种协调共享资源访问的方法。信号量是一种抽象的数据类型，由一个整型变量与两个原子操作(P操作——申请资源，V操作——释放资源)组成：\n\n```c++\nclass Semaphore{\n    int sem;\n    WaitQuene q;//等待队列q\n}\n\nSemaphore::__init__(flag){\n    sem=flag;\n    q=NULL;\n}\n\nSemaphore::P(){\n    sem--;\n    if(sem<0){\n        q.add(current);//当前进程\n        block(current);\n    }\n}\n\nSemaphore::V(){\n    sem++;\n    if(sem<=0){\n        next=q.remove();\n        wakeup(next);\n    }\n}\n```\n\nP、V操作由操作系统实现，执行过程中不会被打断，从而保证其原子性。借助P、V操作的原子性，可以更简单地实现同步互斥。下面介绍信号量的使用。\n\n### 信号量的使用\n\n实现互斥的伪代码如下：\n\n```c++\nmutex= Semaphore(1);\n```\n\n对于需要互斥访问的临界区代码：\n\n```c++\nmutex->P(t);\n//Critical Section\nmutex->V();\n```\n\n注意：必须按照先P操作后V操作的顺序使用，且P操作与V操作必须成对使用。\n\n实现条件同步的伪代码如下：\n\n```c++\ncondition=Semaphore(0);\n```\n\n例如：必须等线程B执行完X，线程A才能执行N；这样使用信号量：\n\n对线程A：在N之前插入P操作，对线程B：在X后插入V操作，即：\n\n```c++\n//线程A\n----------------\n|     M        |\n----------------\ncondition->P();\n----------------\n|     N        |\n----------------\n//线程A\n\n//线程B\n----------------\n|     X        |\n----------------\ncondition->V();\n----------------\n|     Y        |\n----------------\n//线程B\n```\n\n### 用信号量解决生产者-消费者问题\n\n问题分析：\n\n* 任何时刻只能有一个线程操作缓冲区(互斥访问)；\n* 缓冲区空则消费者必须等待生产者(条件同步)；\n* 缓冲区满则生产者必须等待消费者(条件同步)；\n\n每个约束条件对应一个信号量：(二进制)信号量mutex、(资源)信号量fullBuffers与(资源)信号量emptyBuffers。将有界缓冲区定义为如下类，Deposit方法向有界缓冲区写入一个字节，Remove方法从有界缓冲区中移出一个字节。\n\n```c++\nclass BoundedBuffer{\n    Semaphore mutex;\n    Semaphore fullBuffers;\n    Semaphore emptyBuffers;\n    char data[n];//n为缓冲区大小\n}\n\nBounderBuffer::__init__(){\n    mutex=Semaphore(1);\n    fullBuffers=Semaphore(0);\n    emptyBuffers=Semaphore(n);\n}\n\nBounderBuffer::Deposit(c){\n    emptyBuffers->P();\n    mutex->P();\n    write(data, c);\n    mutex->V();\n    fullBuffers->V();\n}\n\nBounderBuffer::Remove(){\n    fullBuffers->P();\n    mutex->P();\n    move(data, c);\n    mutex->V();\n    emptyBuffers->V();\n}\n```\n\n从上面的运用中可以看出，使用信号量来解决同步互斥问题时要求P、V操作必须成对出现，编写容易出错。一旦没有考虑周全，就会导致死锁。\n\n## 管程\n\n管程是一种用于多线程互斥访问共享资源的程序结构。它采用面向对象的编程方法，将对共享资源的P、V操作成对地写入对共享资源的操作。与临界区不同的是，正在管程中的线程可以放弃对管程的互斥访问，等待事件出现时恢复(与临界区的不同点：线程在临界区中执行时，只能在临界区执行完后退出临界区)。\n\n利用管程来定义访问数据的方法，从而不用程序编写者考虑访问时的P、V操作。管程包括锁与条件变量(可选)：\n\n* 锁用于控制管程代码的互斥访问，因此在管程外会有一个等待队列；\n* 每个条件变量对应一种等待原因，都有一个等待队列(在管程内部)；另外，条件变量有两种操作——Wait操作与Signal操作；对条件变量的定义如下：\n\n```c++\nclass Condition{\n    int numWaiting;\n    WaitQuene q;\n}\n\nCondition::__init__(){\n    numWaiting=0;\n    q=NULL;\n}\n\nCondition::Wait(lock){\n    numWaiting++;\n    //自身阻塞在条件变量的等待队列中\n    q.add(current);\n    //释放管程的互斥访问\n    lock.Release();\n    //去唤醒其他线程\n    schedule();\n    //条件满足后重新获取锁\n    lock.Acquire();\n}\n\nCondition::Signal(){\n    if(numWaiting>0){\n        t=q.remove();//从q中选择一个进程将其唤醒\n        wakeup(t);\n        numWaiting--;\n    }\n}\n```\n\n### 用管程解决生产者-消费者问题\n\n```c++\nclass BoundedBuffer{\n    Lock lock;\n    int count;\n    Condition notFull, notEmpty;\n    char data[n];//n为缓冲区大小\n}\n\nBoundedBuffer::__init__(){\n    lock=Lock();\n    count=0;\n    notFull=Condition();\n    notEmpty=Condition();\n}\n\nBoundedBuffer::Deposit(c){\n    lock.Acquire();\n    //检查是否还有空闲区，如果缓存写满了就等待，直到notFull的条件满足。\n    while(count==n)\n        notFull.Wait(lock);\n    write(data, c);\n    count++;\n    notEmpty.Signal();\n    lock.Realease();\n}\n\nBoundedBuffer::Remove(c){\n    lock.Acquire();\n    //检查缓冲区是否有数据，如果缓冲区为空则等待，直到notEmpty的条件满足。\n    while(count==0)\n        notEmpty.Wait(lock);\n    move(data, c);\n    count--;\n    notFull.Signal();\n    lock->Release();\n}\n```\n\n### 条件变量释放后的处理\n\n根据条件变量释放后处理的不同，管程分为Hansen管程与Hoare管程；Hansen管程会等到当前线程执行完之后再去执行条件变量唤醒的线程，而Hoare管程会立即切换到条件变量唤醒的线程执行。在实际操作系统中，使用Hansen管程因为其效率更高、且易于实现。若操作系统使用了Hansen管程，等到被唤醒的线程被调度时可能所需条件又不满足，因此需要用while循环再次检查；但如果操作系统使用的是Hoare管程。那么CPU会立即执行被唤醒的线程，因此使用if控制流。\n\n### 用管程解决读者-写者问题\n\n读者-写者问题约束如下：\n\n* 同一时刻，允许多个读者同时读；\n* 读写互斥；\n* 写写互斥；\n\n定义两个基本方法——Read与Write，4个条件变量；\n\n```c++\nclass Database{\n    int AR;//active reader\n    int AW;//active writer\n    int WR;//waiting reader\n    int WW;//waiting writer\n    Lock lock;\n    Condition okToRead, okToWrite;\n    char * data;\n}\n\nDatabase::Read(){\n    while (AW+WW);//wait until no writers.\n    StartRead();\n    read(data);\n    //check out: wake up waiting writers.\n    DoneRead();\n}\n\nDatabase::StartRead(){\n    lock.Acquire();\n    while((AW+WW)>0){\n        WR++;\n        okToRead.wait(lock);\n        WR--;\n    }\n    AR++;\n    lock.Release();\n}\n\nDatabase::DoneRead(){\n    lock.Acquire();\n    AR--;\n    if(AR==0 && WW>0)\n        okToWrite.Signal();\n    lock.Release();\n}\n\nDatabase::Write(){\n    while (AR+WR);//wait until no reader.\n    StartWrite();\n    write(data);\n    //check out: wake up wating reader.\n    DoneWrite();\n}\n\nDatabase::StartWrite(){\n    lock.Acquire();\n    while((AW+AR)){\n        WW++;\n        okToWrite.wait(lock);\n        WW--;\n    }\n    AW++;\n    lock.Release();\n}\n\nDatabase::DoneWrite(){\n    lock.Acquire();\n    AW--;\n    if(WW>0)\n        okToWrite.Signal();\n    else if(WR>0)\n        okToRead.broadcast();//使所有在该条件上等待的进程都被释放并进入队列(读读不互斥)\n    lock.Release();\n}\n```","tags":["操作系统"],"categories":["course"]},{"title":"第十三章 同步互斥","url":"/course/os-ch13.html","content":"\n## 同步互斥的背景\n\n同步互斥是操作系统中协调进程协作与相互关系的一种机制。对于并发的进程，存在多个进程共享资源的情形，那么这时进程执行就会存在不确定性与不可重现性；然而，进程并发执行具有节约资源(共享)、高速等优点，因此为了使并发的进程能够正确运行，操作系统使用了同步互斥机制。\n\n### 原子操作\n\n一次不存在任何中断与失败的操作。\n\n操作系统需要利用同步互斥机制在并发执行的同时，保证一些操作是原子操作。\n\n实现同步互斥机制最简单有效的方案为利用两个原子操作实现一个锁：\n\n* Lock.Acquire()：在锁释放前请求锁的进程一直处于等待状态；如果多于一个进程都在等待同一个锁，在锁释放之后，只有一个进程能够获得锁。\n* Lock.Release()：解锁并唤醒一个等待中的进程。\n\n事实上，这就是用两个原子操作的锁放在一段需要是原子操作的代码两端，使这段代码的执行是原子操作。开头的锁操作称为进入临界区，代码后的解锁操作称为退出临界区。\n\n### 进程的交互关系\n\n根据进程相互感知程度的不同，进程之间的交互分为3种关系，如下表所示：\n\n|             相互感知的程度             |     交互关系     |             进程间的影响             |\n| :------------------------------------: | :--------------: | :----------------------------------: |\n|  相互不感知(完全不了解其他进程的存在)  |       独立       |         进程间的操作互不影响         |\n| 间接感知(双方与第三方交互，如共享资源) | 通过共享进行协作 |    进程的结果依赖于共享资源的状态    |\n|     直接感知(双方直接交互，如通信)     | 通过通信进行协作 | 进程的结果依赖于从其他进程获取的信息 |\n\n此时进程间会出现如下三种状态。\n\n* 互斥：一个进程占用资源，其他的进程不能使用该资源；\n* 死锁：多个进程各自占用部分资源，形成循环等待；\n* 饥饿：进程一直得不到资源。\n\n## 同步方法\n\n为了保证只有一个进程进入临界区执行，需要在进入临界区之前检查进程是否能够进入临界区，若可以进入，接下来设置相应\"进入临界区\"的标志。进程使用完资源之后，退出临界区，去除相应\"进入临界区\"的标志。\n\n综上，临界区的访问规则为空闲则入、忙则等待、有限等待与让权等待(可选)。\n\n### 禁用硬件中断\n\n没有中断，没有上下文切换，因此没有并发。\n\n* 硬件将中断处理延迟到中断被启用之后；\n* 现代计算机体系结构都提供指令来实现禁用中断；\n\n因此，进入临界区就是禁用所有中断并保存标志位；退出临界区就是启用所有中断并恢复标志位。禁用硬件中断可有效实现同步互斥，但是也有如下局限性：\n\n* 禁用中断后，进程无法被停止；会使整个操作系统暂停，导致其他进程处于饥饿状态；\n* 临界区执行时间可能很长；\n\n因此，禁用硬件中断的方法须小心使用。\n\n### 基于软件的同步\n\n复杂(需要两个进程间的共享数据项)，是一个忙等待(浪费CPU时间)。\n\n### 高级抽象的同步方法\n\n原子操作指令1：测试与置位指令(TS指令)——从内存单元读取值并返回，期间将内存单元置1；\n\n该指令的伪代码操作如下：\n\n```c\nbool TestAndSet(bool * target)\n{\n    bool * rv= target;\n    * target=true;\n    return rv;\n}\n```\n\n\n\n原子操作指令2：交换指令(exchange)，顾名思义，交互内存中的两个值。\n\n基于上述两个原子操作指令，来实现锁。\n\n**使用TS指令实现锁**：\n\n```c++\nclass Lock{\n    bool value;\n}\n\nLock::__init__(){\n    value=false;\n}\n\nLock::Acquire(){\n    while (TS(& value)){\n        //run\n    }\n}\n\nLock::Release(){\n    value=false;\n}\n```\n\n但是上述实现是一种忙等待，改进如下：\n\n```c++\n//增加一个等待队列\nclass Lock{\n    bool value;\n    WaitQuene q;\n}\n\nLock::__init__(){\n    value=false;\n    q=NULL;\n}\n\n//当进程申请不到资源时，进入等待队列，执行进程调度\nLock::Acquire(){\n    while (TS(& value)){\n        q.add(current);\n        schedule();\n    }\n}\n\n//当占用资源的进程使用完资源后，释放锁，并且将某个等待的进程从等待队列中移除并将其唤醒\nLock::Release(){\n    value=false;\n    current=q.remove();\n    wakeup(current);\n}\n```","tags":["操作系统"],"categories":["course"]},{"title":"第四步 Web服务器处理请求","url":"/course/cn-step4.html","content":"\n## 服务器程序的结构\n\n为保证服务器同时与多个客户端进行通信，服务器启动多个服务器程序一对一地与客户端交互。服务器程序的结构如下图所示：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 20.png pic20 %}</div>\n\n&nbsp;\n\n服务器程序分为两个模块：等待连接模块与通信模块；在服务器启动并完成初始化操作后，它就会运行等待连接模块；等待连接模块创建套接字，然后进入等待连接的暂停状态，直到客户端发起连接；等待连接模块恢复运行并接受连接，启动客户端通信模块，传递套接字的副本给通信模块；\n\n通信模块使用已连接的套接字与客户端通信。由于在服务器上，一个端口可能与多个客户端建立通信，因此会有多个套接字的端口号相同，于是不能只通过端口号来指定套接字(在客户端可以这样做)，还需要加上源IP，因为各个客户端的IP肯定是不同，每个套接字与客户端一一对应，这样就能准确指定套接字。\n\n## 服务器的接收操作\n\n数据经网卡、MAC层、IP层到达TCP层(对于HTTP消息来说)，TCP的数据收发详见第二章，只剩下TCP的断开操作还未介绍；TCP断开操作称为四次挥手，示意图如下：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 21.jpg pic21 %}</div>\n\n&nbsp;\n\nHTTP协议规定服务器返回响应消息后主动断开连接，于是服务器端执行TCP断开操作；服务器端发送FIN位置1的TCP头部(表面自己已经没有要发送的消息)，客户端收到后返回确认接收的TCP头部，客户端仍然可以给服务器端发送消息，等客户端处理完数据可以结束与服务器端的连接时，客户端发送FIN位置1的TCP头部，处于等待状态的服务器返回确认接收的TCP头部，到此TCP连接彻底断开。\n\n## 服务器解析请求消息并作出响应\n\nWeb服务器公开的目录并不是磁盘上的实际目录，而是如下图所示的虚拟目录：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 22.png pic22 %}</div>\n\n&nbsp;\n\nWeb服务器根据请求消息中的源IP、用户名&密码、客户端域名进行访问控制；只有满足条件的请求消息才会对请求消息作出响应。\n\n对于运行访问的请求消息，若URL指定HTML文件或图片，直接将文件内容作为响应消息返回客户端即可；若URL指定的是一个程序，则服务器要从消息中获取运行程序所需参数(方法为GET，参数在URL之后；方法为POST，参数在消息体中)并运行程序然后将输出结果作为响应消息返回客户端。\n\n接下来Web服务器将响应消息委托给协议栈发送给客户端。\n\n## 浏览器接收响应并显示内容\n\n&nbsp;","tags":["计算机网络"],"categories":["course"]},{"title":"第三步 服务器端的局域网","url":"/course/cn-step3.html","content":"\n## 防火墙的结构与原理\n\n防火墙的基本思路：只允许发往特定服务器的特定应用程序的网络包通过，屏蔽其他的网络包。其中最主流的方式为包过滤，它根据源IP与目的IP、源端口与目的端口、控制位等信息来判断是否允许网络包通过。\n\n## 负载均衡\n\n若对服务器的访问量上升，则需要多台服务器来分担负载，即分布式架构。要采用这种方法，需要一种机制将客户端发送的请求分发到不同的服务器上，最简单的方式是通过DNS服务器来分配——由于客户端访问Web服务器时需要先向DNS服务器查询Web服务器的IP地址，这时在DNS服务器中对Web服务器的域名填写多个IP地址，则每次查询时DNS服务器都会按顺序(循环地)返回不同的IP地址，即轮询。但是，DNS服务器不能确认某个IP地址对应的Web服务器是否正常工作，因此，如果某台Web服务器出现故障，DNS仍然会给客户端返回这台Web服务器的IP地址，那么客户端发送的请求就无法被处理。\n\n另外，由于一些操作需要发送多次HTTP请求，这就导致需要在一个Web服务器上完成这多个请求，然而轮询会把这些HTTP请求分发到不同的Web服务器上。\n\n为避免上述问题，需要使用名为负载均衡器的设备，对于相关HTTP请求消息，客户端发送HTTP请求消息时在表单里面加上表示关联的信息，或者对HTTP规格进行扩展，在HTTP头部字段加上用来判断相关性的信息。若请求消息相关，负载均衡器将不考虑Web服务器的负载而是必须将相关的请求发送到同一Web服务器。\n\n同样地，要使用负载均衡器，要将Web服务器域名对应的IP在DNS服务器中设置为负载均衡器的IP。\n\n## 缓存服务器\n\nWeb服务器需要检查网址与访问权限，还有一些在页面填充数据的操作，因此将页面返回客户端的时间较长；相对地，缓存服务器只需要将保存在磁盘上的数据读取出来发送给客户端即可。使用缓存服务器既减轻了Web服务器的负担，又缩短了请求响应的时间。\n\n### 缓存服务器的工作过程\n\n与负载均衡器相同，缓存服务器也需要代替Web服务器被注册到DNS服务器上；因此，对于使用了缓存服务器的Web服务器，客户端的请求会到达缓存服务器，缓存服务器接收请求消息，接收操作下一章介绍；然后，缓存服务器会检查请求消息的内容，判断请求的数据是否已经在缓存中；\n\n* 不在缓存中。缓存服务器在HTTP请求消息头部添加一个Via字段，表示这个消息经过缓存服务器转发，然后将消息转发给Web服务器(如果有多台Web服务器，可根据请求消息中URL的目录名来判断)，示意图如下：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n&nbsp;\n\n缓存服务器转发请求消息时，缓存服务器相当于客户端，会创建套接字并连接Web服务器的套接字，然后转发请求消息并接收Web服务器的响应消息，然后在响应消息中加上Via字段表示响应消息是经缓存服务器中转的；最后，响应消息会保存在缓存服务器中，并记录保存的时间。\n\n* 在缓存中。缓存服务器在HTTP请求头部添加一个If-Modified-Since字段(内容为缓存数据被保存的时间)并将请求转发给Web服务器，Web服务器比较请求数据最后的更新时间与缓存数据被保存的时间来判断Web服务器上的请求的数据与缓存服务器上保存的请求的数据是否一致。\n  * 若一致。缓存服务器将请求的数据返回给客户端，同样加上Via字段；示意图如下。\n  * 若不一致。Web服务器返回最新的请求数据，缓存服务器加上Via字段转发给客户端。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n&nbsp;\n\n这种在Web服务器端缓存数据的代理机制，称为反向代理。\n\n**透明代理**：缓存服务器在判断转发的目标Web服务器时，还可以查看请求消息头部，从而可以将消息转发给任一Web服务器。\n\n## 内容分发服务\n\n缓存服务器放在Web服务器端虽然可以减轻Web服务器的负载，但无法减少互联网中的流量。从这一点来看，将缓存服务器放在客户端更有效，但是Web服务器的运营者无法控制客户端的缓存服务器。于是出现了内容分发服务，一些专门从事相关服务的厂商来部署缓存服务器，并租借给Web服务器运营者。\n\n而互联网中有很多缓存服务器，需要找到离客户端最近的一个。\n\n* 一种方法是DNS服务器使用路由表的路由信息计算大致距离，并向客户端返回距离(收到客户端查询请求的DNS服务器)最近的缓存服务器的IP地址。这种计算比较粗略；\n\n<div style=\"width:80%;margin:auto\">{% asset_img 18.png pic18 %}</div>\n\n* 另一种方法是使用重定向服务器分配访问目标；当使用重定向告知客户端最近的缓存服务器时，首先需要将重定向服务器注册到DNS服务器上。于是，客户端会将HTTP请求消息发送到重定向服务器上。重定向服务器和刚才一种方法中的DNS服务器一样，收集了来自各个路由器的路由信息，并根据这些信息找到离客户端最近的缓存服务器，然后将缓存服务器的地址放到Location字段中返回响应。这样，客户端就会重新去访问指定的缓存服务器了。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 19.png pic19 %}</div>\n\n同时，每次客户端发送请求时缓存服务器都需要询问Web服务器缓存的数据是否一致，而更好的方法是每次Web服务器中数据发生改变时主动联系缓存服务器，使缓存服务器上的内容时刻保持最新。","tags":["计算机网络"],"categories":["course"]},{"title":"第十二章 CPU多核调度","url":"/course/os-ch12.html","content":"\n## CPU多核调度概述\n\n### 单队列多核调度\n\n* 缺乏可扩展性：多个CPU核均对一个就绪队列进行读写操作；\n* 缺乏缓存亲和性：CPU核对进程的缓存不能得到有效利用；\n\n如下图，4个CPU核对5个进程的调度：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 46.png pic46 %}</div>\n\n为了提高调度算法的缓存亲和性，尽量让进程在同一个CPU核上运行(在保持对该进程的缓存亲和性时，可能会牺牲其他进程的缓存亲和性)；如下图所示：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 47.png pic47 %}</div>\n\n### 多队列多核调度\n\n* 每个CPU核维护一个就绪队列，各CPU核之间的调度相互独立；\n* 会出现负载不均衡；\n\n如下图，开始给进程A、C分配CPU核0，给进程B、D分配CPU核1；\n\n<div style=\"width:64%;margin:auto\">{% asset_img 48.png pic48 %}</div>\n\n一段时间之后，进程C结束，进程A独占CPU核0；\n\n<div style=\"width:64%;margin:auto\">{% asset_img 49.png pic49 %}</div>\n\n一段时间之后，进程A结束，CPU核0处于空闲状态，而CPU核1还在运行着两个进程，此时就出现了负载不均衡；\n\n<div style=\"width:64%;margin:auto\">{% asset_img 50.png pic50 %}</div>\n\n为了解决出现的负载不均衡问题，就要将繁忙的CPU核上的进程迁移到空闲的CPU核上去；比如上幅图，可以将进程B移到CPU核0上，然后系统负载均衡；而对于进程A独占CPU核0的情形，调度就比较复杂，此时操作系统该如何决定发起迁移？\n\n一般采用一种叫做\"工作窃取\"的技术；让执行的进程数目少的CPU核\"不定期\"地查看其他CPU核的就绪队列，从那些长的就绪队列中\"拉取\"一个或多个进程，从而实现负载均衡。而这个查看的时刻一般选在CPU核的进程进行切换的时候。\n\n## O1调度器\n\nLinux系统中进程有140种优先级，使用长140的比特数组来记录优先级；每个(优先级)比特对应该优先级的FIFO进程队列(若一个优先级下有进程队列，则这个优先级对应的bit位置1)，其中run比特数组管理还未运行的就绪态进程，expired比特数组管理运行过的进程；给每个CPU核维护上述两个数组。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 51.png pic51 %}</div>\n\n对于调度时对数组进行的3种基本操作：访问(最高优先级就绪态进程)、(在expired比特数组对应的优先级队列中)插入(刚刚运行过的进程)、(在expired比特数组对应的优先级队列中)删除(刚刚运行过的进程)；分析这些操作的复杂度：\n\n* 访问：在切换进程时，会寻找最高优先级的就绪态进程，而这等价于寻找一个比特数组中为1的最高位比特，CPU可在O(1)时间内找出一个字节中为1的最高位比特；因此，随机访问的复杂度为O(1)；\n* 插入：在队尾插入，复杂度O(1)；如果插入前在expired数组的该优先级下没有进程队列，则将expired数组的该优先级对应的比特置1；\n* 删除：在队头删除，复杂度O(1)；如果删除后在run数组的该优先级下没有进程队列，则将run数组的该优先级对应的比特置0；如果run数组所有比特均为0，则交换run数组与expired数组；并且，每个CPU核不定期检查自己的负载，如果自己负载较其他CPU核轻，则\"拉取\"其他CPU核上的就绪态进程；\n\n## CFS调度\n\n完全公平的调度。通过进程消耗的CPU时间(标准化之后的虚拟CPU时间)来确定调度哪个进程；\n\n分配给进程的运行时间=调度周期×进程权重/所有进程权重之和；但是调度周期一直处于动态变化中，通过这个式子确定分配给进程的运行时间比较麻烦，因此引入虚拟运行时间vruntime=实际运行时间×1024/进程权重；这样既考虑到分配CPU运行时间较少的进程(对它给予一定补偿)，有考虑到高优先级的进程。\n\nLinux系统(每个CPU核)采用红黑树来维护进程的vruntime，需要调度时，从红黑树中选取vruntime最小的进程投入CPU中执行。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 52.png pic52 %}</div>\n\n为避免已经运行一段时间的进程在新的进程进入后出现\"饥饿\"现象=>不能将新进程的vruntime设置为0，而应该设置为红黑树中就绪态进程的最小vruntime。\n\n对于休眠了一段时间的进程，由于其他进程的vruntime一直增加而休眠进程的vruntime并未增加，因此在休眠进程被唤醒后可能会长时间抢占其他进程的CPU资源=>在休眠进程被唤醒后应该以红黑树中就绪态进程的最小vruntime为基准重新设置其vruntime值。\n\n在负载轻的CPU核\"拉取\"负载重的CPU核上的就绪态进程时，它的vruntime需要进行调整以\"适应新的环境\"=>记进程的vruntime为vrt，它所在CPU核的红黑树中就绪态进程的最小vruntime记为min_vrt_1，\"拉取\"此进程的CPU核的红黑树中就绪态进程的最小vruntime记为min_vrt_2，则此进程新的vruntime=vrt-min_vrt_1+min_vrt_2；\n\n由计算vruntime的式子可以看到，CPU的运行时间长了之后，各进程的实际运行时间也会很长，这是算出的vruntime值可能会产生溢出，考虑到vruntime的作用是作为调度的依据——选择最小vruntime的进程=>填在红黑树中的节点值实际上是每个进程的vrt-min_vrt；\n\n## BFS调度算法\n\nBFS调度算法是时间片轮转算法的变种。大致形式如下图：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 53.png pic53 %}</div>\n\nBFS算法在多核CPU的情形下使用单就绪队列(链表)，增加了队列互斥访问的开销，但减少了维护负载均衡的开销。\n\nBFS算法设定了103个优先级(100个静态的实时优先级与3个普通的优先级)，每个优先级维护一个就绪进程队列。每个CPU核计算进程的虚拟截止时间时，对于进程上一次执行的CPU核，会适当减小其虚拟截止时间。","tags":["操作系统"],"categories":["course"]},{"title":"第十一章 CPU调度","url":"/course/os-ch11.html","content":"\n## CPU调度概念\n\nCPU的调度要考虑以下几个问题：\n\n* 调度的时机；\n* 从就绪队列中挑选下一个占用CPU运行的进程；\n* 从多个可用CPU里面挑选就绪进程可使用的CPU资源。\n\n操作系统通过调度程序来完成CPU的调度，操作系统运行调度程序的条件：\n\n* 进程从运行状态切换到等待状态；\n* 进程退出；\n\n对非抢占系统：只有当进程主动放弃CPU时，操作系统才能运行调度程序；\n\n对抢占系统：如果分配给进程的时间片用完或者优先级更高的等待进程切换到就绪状态，那么在抢占系统中，操作系统就会运行调度程序；\n\n## 调度准则\n\n响应时间指标；\n\n* 减少响应时间：及时处理用户的输入请求，尽快将输出反馈给用户。\n* 减少平均响应时间的波动；\n\n吞吐量指标；\n\n* 增加吞吐量；\n* 减少等待时间；\n\n公平性指标；\n\n* 保证每个进程占用相同的CPU时间；\n* 保证每个进程的等待时间相同；\n\n## 调度算法\n\n### 先来先服务算法\n\n&nbsp;\n\n### 短进程优先算法\n\n&nbsp;\n\n### 最高响应比优先算法\n\n响应比R=(w+s)/s，其中w为等待时间、s为执行的时间，然后选择就绪队列中响应比R值最高的进程。该调度算法不可抢占、关注进程的等待时间从而防止执行时间长的进程出现长时间等待的情况(\"饥饿\")。\n\n### 时间片轮转算法\n\n时间片：分配CPU资源的基本时间单元；\n\n给每个进程分配一个时间片占用CPU，一个时间片结束之后，按照先来先服务算法切换到下一个就绪进程。该调度算法存在额外的上下文切换造成的开销，需要选择一个合适的时间片长度(一般是10ms，能够保证上下文切换的开销占CPU处理的1%)\n\n### 多级反馈队列算法\n\n由于没有一个调度算法能够满足所有的需求(有的希望响应迅速，有的希望处理时间短)；为解决这个问题，操作系统使用多个队列，不同需求的就绪进程放到不同的就绪队列，根据需求的不同选择合适的调度算法，各队列按照一定的比例分配CPU处理时间；\n\n进一步改进，让各个队列之间存在交流，这就是多级反馈队列。\n\n* 时间片大小随优先级的增加而增加；\n* 若进程在当前的时间片内没有完成，则降到下一(优先)级就绪队列；\n\n算法执行过程如下图所示：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 44.png pic44 %}</div>\n\n&nbsp;\n\n### 公平共享调度算法\n\n强调资源访问的公平，将用户与进程分组，更重要的用户的进程分配更长的运行时间；同时保证不重要的组无法垄断资源；未使用的资源安装比例分配，没有使用完所分配资源的组获得更高的优先级。\n\n## 进程切换中的调度\n\n调度程序在进程切换时被调用，具体的使用时机见下图：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 45.png pic45 %}</div>\n\n## 实时调度\n\n对于实时操作系统，它的正确性依赖于时间与功能两方面。实时操作系统的性能主要考虑时间约束的及时性，而速度与平均性能相对不重要。因此，实时操作系统要求时间约束的可预测性。\n\n时间约束分为硬时限与软时限；硬时限：错过任务时限会导致严重后果，必须验证操作系统在最坏情况下能够满足时限；软时限：通常能满足任务时限，若有时不能满足，则降低要求。\n\n关于实时调度的调度算法，有以下两个：速率单调调度算法与最早截止时间优先算法。\n\n速率单调调度算法：先执行周期最短的任务；\n\n最早截止时间优先算法：先执行截止时间最早的任务；\n\n## 多核CPU的进程分配\n\n对于多个处理器的CPU，有下面两种方式来分配进程：\n\n* 静态进程分配：进程从开始到结束都在一个固定的处理器上运行，每个处理器有自己的队列，此时调度的开销很小；\n* 动态进程分配：进程在执行过程中可分配到任一空闲处理器上运行，所有处理器共享一个就绪队列，由于进程会在不同的处理器间切换，因此调度开销较大，然而这种进程分配能够保证各处理机是负载均衡的。\n\n## 优先级反置\n\n低优先级的进程占着高优先级申请的资源使得高优先级的进程进入等待状态，而这时优先级处于前面两个优先级之间的进程抢占了低优先级的进程；这一现象称为优先级反置。解决优先级反置有下面两种处理方法：\n\n**优先级继承**：占用资源的低优先级进程在被抢占时继承申请资源的高优先级进程的优先级，并在释放资源后，优先级将为原来低的优先级；\n\n**优先级天花板协议**：占用资源进程的优先级与所有可能申请该资源的进程的最高优先级相同；","tags":["操作系统"],"categories":["course"]},{"title":"第十章 进程与线程控制","url":"/course/os-ch10.html","content":"\n## 进程创建\n\n对于unix类系统，创建进程采用fork()与exec()两个系统调用来完成；\n\n* fork()将一个进程复制为两个进程；被复制的进程称为父进程，复制得到的进程称为子进程；复制的信息包括父进程的管理结构，线性地址空间与除eax(eax置0)外所有寄存器的值；\n* exec()用新程序来重写当前进程；\n\nQ：在linux系统中，如果任何一个创建的进程都必须(在用户态)通过复制其他进程得到，那么第一个进程是怎么来的呢？\n\nA：第一个进程由操作系统的设计者写好，这个进程就是进程0。\n\n### 进程的地址空间\n\n在介绍fork创建进程之前，先说明Linux是怎么表示一个进程的——task_struct结构体，在Linux2.2.0的源码中，task_struct的定义如下。\n\n```c\nstruct task_struct {\n/* these are hardcoded - don't touch */\n\tvolatile long state;\t/* -1 unrunnable, 0 runnable, >0 stopped */\n\tunsigned long flags;\t/* per process flags, defined below */\n\tint sigpending;\n\tmm_segment_t addr_limit;\t/* thread address space:\n\t\t\t\t\t \t0-0xBFFFFFFF for user-thead\n\t\t\t\t\t\t0-0xFFFFFFFF for kernel-thread\n\t\t\t\t\t */\n\tstruct exec_domain *exec_domain;\n\tlong need_resched;\n/* various fields */\n\tlong counter;\n\tlong priority;\n\tcycles_t avg_slice;\n/* SMP and runqueue state */\n\tint has_cpu;\n\tint processor;\n\tint last_processor;\n\tint lock_depth;\t\t/* Lock depth. We can context switch in and out of holding a syscall kernel lock... */\t\n\tstruct task_struct *next_task, *prev_task;\n\tstruct task_struct *next_run,  *prev_run;\n/* task state */\n\tstruct linux_binfmt *binfmt;\n\tint exit_code, exit_signal;\n\tint pdeath_signal;  /*  The signal sent when the parent dies  */\n\t/* ??? */\n\tunsigned long personality;\n\tint dumpable:1;\n\tint did_exec:1;\n\tpid_t pid;\n\tpid_t pgrp;\n\tpid_t tty_old_pgrp;\n\tpid_t session;\n\t/* boolean value for session group leader */\n\tint leader;\n\t/* \n\t * pointers to (original) parent process, youngest child, younger sibling,\n\t * older sibling, respectively.  (p->father can be replaced with \n\t * p->p_pptr->pid)\n\t */\n\tstruct task_struct *p_opptr, *p_pptr, *p_cptr, *p_ysptr, *p_osptr;\n\t/* PID hash table linkage. */\n\tstruct task_struct *pidhash_next;\n\tstruct task_struct **pidhash_pprev;\n\t/* Pointer to task[] array linkage. */\n\tstruct task_struct **tarray_ptr;\n\tstruct wait_queue *wait_chldexit;\t/* for wait4() */\n\tstruct semaphore *vfork_sem;\t\t/* for vfork() */\n\tunsigned long policy, rt_priority;\n\tunsigned long it_real_value, it_prof_value, it_virt_value;\n\tunsigned long it_real_incr, it_prof_incr, it_virt_incr;\n\tstruct timer_list real_timer;\n\tstruct tms times;\n\tunsigned long start_time;\n\tlong per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS];\n/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */\n\tunsigned long min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;\n\tint swappable:1;\n\tunsigned long swap_address;\n\tunsigned long swap_cnt;\t\t/* number of pages to swap on next pass */\n/* process credentials */\n\tuid_t uid,euid,suid,fsuid;\n\tgid_t gid,egid,sgid,fsgid;\n\tint ngroups;\n\tgid_t\tgroups[NGROUPS];\n        kernel_cap_t   cap_effective, cap_inheritable, cap_permitted;\n\tstruct user_struct *user;\n/* limits */\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\tunsigned short used_math;\n\tchar comm[16];\n/* file system info */\n\tint link_count;\n\tstruct tty_struct *tty; /* NULL if no tty */\n/* ipc stuff */\n\tstruct sem_undo *semundo;\n\tstruct sem_queue *semsleeping;\n/* tss for this task */\n\tstruct thread_struct tss;\n/* filesystem information */\n\tstruct fs_struct *fs;\n/* open file information */\n\tstruct files_struct *files;\n/* memory management info */\n\tstruct mm_struct *mm;\n/* signal handlers */\n\tspinlock_t sigmask_lock;\t/* Protects signal and blocked */\n\tstruct signal_struct *sig;\n\tsigset_t signal, blocked;\n\tstruct signal_queue *sigqueue, **sigqueue_tail;\n\tunsigned long sas_ss_sp;\n\tsize_t sas_ss_size;\n};\n```\n\n其中，结构体mm_struct用来描述一个进程的虚拟地址空间。mm_struct的定义如下。\n\n```c\nstruct mm_struct {\n\tstruct vm_area_struct *mmap;\t\t/* list of VMAs */\n\tstruct vm_area_struct *mmap_avl;\t/* tree of VMAs */\n\tstruct vm_area_struct *mmap_cache;\t/* last find_vma result */\n\tpgd_t * pgd;\n\tatomic_t count;\n\tint map_count;\t\t\t\t/* number of VMAs */\n\tstruct semaphore mmap_sem;\n\tunsigned long context;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long start_brk, brk, start_stack;\n\tunsigned long arg_start, arg_end, env_start, env_end;\n\tunsigned long rss, total_vm, locked_vm;\n\tunsigned long def_flags;\n\tunsigned long cpu_vm_mask;\n\t/*\n\t * This is an architecture-specific pointer: the portable\n\t * part of Linux does not know about any segments.\n\t */\n\tvoid * segments;\n};\n```\n\n其中vm_area_struct用来描述一个虚拟内存区域VMA，一个进程的地址空间由多个虚拟内存区域组成，各虚拟内存区域由链表组织。操作系统将每个内存区域作为一个单独的内存对象管理，每个内存区域都有一致的属性(因此进程的代码段、数据段、bss段都分别用一个vm_area_struct描述)。vm_area_struct的定义如下。\n\n```c\nstruct vm_area_struct {\n\tstruct mm_struct * vm_mm;\t/* VM area parameters */\n\tunsigned long vm_start;\n\tunsigned long vm_end;\n\n\t/* linked list of VM areas per task, sorted by address */\n\tstruct vm_area_struct *vm_next;\n\n\tpgprot_t vm_page_prot;\n\tunsigned short vm_flags;\n\n\t/* AVL tree of VM areas per task, sorted by address */\n\tshort vm_avl_height;\n\tstruct vm_area_struct * vm_avl_left;\n\tstruct vm_area_struct * vm_avl_right;\n\n\t/* For areas with inode, the list inode->i_mmap, for shm areas,\n\t * the list of attaches, otherwise unused.\n\t */\n\tstruct vm_area_struct *vm_next_share;\n\tstruct vm_area_struct **vm_pprev_share;\n\n\tstruct vm_operations_struct * vm_ops;\n\tunsigned long vm_offset;\n\tstruct file * vm_file;\n\tunsigned long vm_pte;\t\t\t/* shared mem */\n};\n```\n\n最终，进程管理其进程空间的实现如下图所示。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 43.png pic43 %}</div>\n\n&nbsp;\n\n### fork与写时复制\n\n传统的fork直接将父进程所有资源复制给子进程，很多时候，操作系统创建一个进程是为了加载一个新的可执行文件，此时复制父进程资源是没有必要的。于是之后的fork采用写时复制技术：创建的子进程以只读方式共享父进程的地址空间(实现方式为仅复制父进程的页表而不复制对应物理内存区域中的内容)，如果父/子进程需要向地址空间写入数据，操作系统再去复制一份地址空间的内容供父/子进程修改。这时，如果fork之后立即执行了exec，则无需复制父进程的地址空间的内容。此外，之后的fork还明确子进程先执行。\n\n### vfork\n\nvfork创建的子进程相当于父进程的线程，它没有复制父进程的页表，直接共用父进程的地址空间，即子进程的task_struct直接复制父进程的task_struct的mm成员，注意到mm是一个mm_struct结构体指针，因此vfork是让子进程共用父进程的地址空间。此外，vfork明确子进程先执行。使用vfork创建子进程后，父进程一直处于阻塞状态，直到子进程退出或执行完exec。\n\n### 创建线程\n\n通过创建与父进程共享某些资源(具体见下表)的子进程，来创建线程。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 82.png pic82 %}</div>\n\n&nbsp;\n\n### 小结\n\n总结一下创建进程的完整过程；\n\n* 分配进程控制块数据结构；\n* 创建进程的内核堆栈；\n* 设置进程的地址空间(如果是创建线程则共享父进程的地址空间)；\n* 修改子进程的状态为不可中断等待状态(还未进行进程加载)；\n\n## 进程加载\n\n将刚刚分配子进程的地址空间重写，其中包括代码段、数据段、堆与栈等等；使用exec调用来实现；\n\n\n## 进程切换\n\n暂停当前运行进程(当前运行进程从运行态变为其他状态)，调度另一个进程(也有可能还是刚刚运行的进程)从就绪状态变成运行状态。\n\n进程切换前，保存被暂停进程的上下文(寄存器、CPU状态)；进程切换后，恢复被调度进程的上下文(寄存器、CPU状态)。\n\n如下是一个进程切换的例子：\n\n<div style=\"width:45%;margin:auto\">{% asset_img 40.png pic40 %}</div>\n\n&nbsp;\n\n\n\n为了对进程进行切换，操作系统将相同状态的PCB放置在同一队列。如下图所示：有就绪(进程)队列、等待(进程)队列以及僵尸队列(要退出的进程)。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 41.png pic41 %}</div>\n\n&nbsp;\n\n当并发的进程数目太多时，使用双向链表来组织PCB使得查找的时间过长，那么这时采用Hash表，Hash值相同PCB组成双向链表，再通过数组将这些双向链表组织起来。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 42.png pic42 %}</div>\n\n&nbsp;\n\n实现进程调度的函数为schedule。\n\n## 进程等待与退出\n\nwait系统调用用于父进程等待子进程的结束；子进程结束时通过exit()向父进程返回一个值，父进程通过wait()接受并处理返回值。\n\n* 当子进程存活时，如果父进程调用了wait，则父进程进入等待状态，等待子进程的返回结果。当子进程结束调用了exit()后，父进程被唤醒，将子进程exit()的返回值作为父进程wait()的返回值；\n* 如果父进程调用wait时已有结束的子进程，wait()立即返回这些已经结束的子进程调用exit()返回值中的一个；\n* 若无子进程存活，wait()立刻返回；\n\nexit被称为有序终止；\n\n* exit()返回的结果作为父进程下一步处理的参数；\n* 进程各种资源的回收(打开的文件，分配的内存空间以及大部分与进程相关的数据结构)；\n* 清理所有处于僵尸状态的子进程；\n* 检查父进程是否存活，若父进程存活，自身进入僵尸状态，等待父进程处理；否则，释放所有的数据结构，进程结束；","tags":["操作系统"],"categories":["course"]},{"title":"第九章 进程与线程","url":"/course/os-ch9.html","content":"\n## 进程的概念\n\n**进程**：具有一定独立功能的程序在一个数据集合上的一次动态执行过程；\n\n程序是有序代码的集合，进程是程序的执行。\n\n## 进程控制块\n\n**进程控制块(PCB)**：操作系统管理控制进程运行所用的信息集合。包含以下信息：\n\n* 调度进程与处理机使用情况；\n* 进程间通信相关的各种标识；\n* 指向进程映像存储空间的数据结构；\n* 进程使用的系统资源；\n* 数据结构连接信息；\n\n## 进程的状态\n\n进程的生命周期划分：创建、运行、等待、抢占、唤醒与结束；这些不同周期的转换如下图所示：\n\n<div style=\"width:32%;margin:auto\">{% asset_img 37.png pic37 %}</div>\n\n&nbsp;\n\n每种状态转换的条件见下表：\n\n| 箭头 |                             条件                             |\n| :--: | :----------------------------------------------------------: |\n| (1)  | 系统初始化；<br />用户请求创建一个新进程；<br />正在运行的进程调用了创建进程的系统调用； |\n| (2)  |                       获得CPU的调度；                        |\n| (3)  | 请求并等待系统服务，无法马上完成；<br />启动某种操作，无法马上完成；<br />需要的数据还未到达； |\n| (4)  |  高优先级进程就绪；<br />操作系统给进程分配的时间片已用完；  |\n| (5)  |               使进程进入等待状态的条件被满足；               |\n| (6)  | 正常退出；<br />错误退出(自愿的)；<br />致命错误(强制性)；<br />被其他进程杀死(强制性)； |\n\n## 进程挂起\n\n**进程挂起**：操作系统将进程从内存移到外存(以节省内存占用)；与之对应的，将进程从外存移入内存称为(进程)激活。\n\n在进程的状态中考虑进程挂起后，就多了就绪挂起与等待挂起两种状态；这时各种状态的转换如下图所示：\n\n<div style=\"width:40%;margin:auto\">{% asset_img 38.png pic38 %}</div>\n\n&nbsp;\n\n相比上一节的状态转换，增加的状态转换的条件见下表：\n\n| 箭头 |                             条件                             |\n| :--: | :----------------------------------------------------------: |\n| (7)  | 操作系统根据当前资源状况和性能要求将就绪态进程对换出去成为挂起就绪态； |\n| (8)  |    没有就绪进程或挂起进程的优先级高于就绪态进程的优先级；    |\n| (9)  |           在抢先式分时系统，高优先级挂起进程就绪；           |\n| (10) |                            同(5)                             |\n| (11) |  其他进程释放了足够内存，且本进程在挂起的进程中优先级最高；  |\n| (12) | 操作系统根据当前资源状况和性能要求将等待态进程对换出去成为挂起等待态； |\n\n&nbsp;\n\n最后，操作系统切换进程的示意图如下：\n\n<div style=\"width:45%;margin:auto\">{% asset_img 39.png pic39 %}</div>\n\n## 线程的概念\n\n线程是进程的一部分，描述指令流执行状态。它是进程中指令执行流的最小单元，是CPU调度的基本单位。\n\n线程=进程-共享资源(地址空间，文件等)\n\n对进程与线程作一个比较：\n\n|          进程          |                  线程                  |\n| :--------------------: | :------------------------------------: |\n|      资源分配单位      |              CPU调度单位               |\n| 拥有程序执行完整的资源 | 只独享指令流执行必要的资源(寄存器、栈) |\n\n### 用户线程\n\n用户自己实现，操作系统并不支持多线程。\n\n### 内核线程\n\n进程由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止与管理。","tags":["操作系统"],"categories":["course"]},{"title":"第八章 面向缓存的页置换算法","url":"/course/os-ch8.html","content":"\n## 访问频率置换算法(FBR)\n\n操作系统维护一个如下形式的栈来存放缓存数据：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 33.png pic33 %}</div>\n\n&nbsp;\n\n栈分为3个部分：新区域、中间区域与旧区域；每个缓存块都有一个引用计数，算法具体处理如下：\n\n* 访问的数据在栈中：缓存块被移到栈顶，若缓存块不在新区域，将其引用计数加1；\n* 访问的数据不在栈中：在访问完数据之后；栈的旧区域中引用计数最小的缓存块被移出；将访问的数据放到栈顶，其引用计数置1；\n\nFBR算法的问题：需要调整参数。\n\n## LRU-K 2Q页置换算法\n\n考虑一下在进程访问数据时，会有哪些模式的访问：\n\n* 顺序访问：数据块一个接一个被访问，不存在重复访问；\n* 循环访问：所有的数据块按照一定的间隔重复访问；\n* 时间密集访问：最近被访问的数据块是将来最可能被访问的；\n* 概率访问：所有数据块都有固定的概率被访问，且被访问的概率相互独立；\n\n### LRU-K页置换算法\n\nLRU-K算法是LRU算法的扩展；增加了一个数据访问历史记录队列，记录数据被访问的次数以及最近的访问时间戳。\n\n如果[数据]在离开历史记录队列之前被访问了K次，则需要将[数据]加入数据缓存队列：如果缓存队列的长度超过最大缓存长度，则先将缓存队列头部的数据删除，然后在缓存队列的队尾加上[数据]，然后[数据]的访问历史记录从历史记录队列中删除。\n\n若缓存队列的[数据]被访问，则将[数据]放到缓存队列的队尾。\n\n综上，LRU-K页置换算法的示意图如下：\n\n<div style=\"width:36%;margin:auto\">{% asset_img 34.png pic34 %}</div>\n\n&nbsp;\n\n其中，LRU-2是综合考虑各种访问模式后的最优选择。\n\n### LRU-2Q页置换算法\n\n进一步改进LRU-2页置换算法；使用两个缓存队列来维护缓存区，示意图如下：\n\n<div style=\"width:36%;margin:auto\">{% asset_img 35.png pic35 %}</div>\n\n&nbsp;\n\n数据块第一次被访问时，数据块缓存到FIFO队列的队尾(如果队列没有空闲空间，就删除队列头部的数据)，如果数据块在离开FIFO队列之前被再次访问，则将数据块移到LRU队列的队尾(同样地，如果队列没有空闲空间，就删除队列头部的数据)；若LRU队列的数据块被访问，则将数据块放到LRU队列的队尾。\n\n## LIRS页置换算法\n\n定义两个属性；R(i,t)：从最近一次访问数据块i之后到当前时刻t，被访问的不重复数据块数；IRR(i)：在最近两次访问数据块i之间，被访问的不重复数据块数。\n\n初始时，每个数据块的IRR=inf, R=0；\n\n有数据块(记为i)被访问后，每个数据块的IRR值与R值更新：\n\n* 被访问：IRR(i,t)=R(i,t-1), R(i, t)=0；\n* 未被访问：IRR(j)不变，R(j,t)=R(j,t-1)+1{最近一次访问数据块j之后到t-1时刻, 数据块i没有被访问过}，j!=i；\n\n**性质1**：每次访问数据块时，除了被访问的数据块，其他数据块的R值均单调不减。\n\nLIRS算法区分IRR值高的数据块与IRR值低的数据块，缓存区分为两个部分：常驻cache与暂驻cache；LIR块(低IRR值的数据块)放在常驻cache，HIR块(高IRR值的数据块)放在暂驻cache；\n\n我们可以看到，**R值其实就是IRR值的一个候选，一旦数据块被访问，它的R值就成为IRR值**；\n\n由于常驻cache与暂驻cache是根据数据块的IRR值进行区分，那么这两个cache的数据块也会因为其IRR值进行调整；因此，当一个HIR块i被访问后，若存在LIR块j，R(j,t)>size且R(j,t)>IIR(i)，则数据块i与数据块j的状态交换。即max{R(j,t)|j in LIR}>max{size, IIR(i)}。\n\nLIRS算法在各种访问模式下均有很好的表现，但是算法要维护两组值(R值与IRR值)使得算法的开销很大；因此，也就有了下面利用栈而不用显式计算R值与IRR值的方法。\n\n<div style=\"width:24%;margin:auto\">{% asset_img 36.png pic36 %}</div>\n\n&nbsp;\n\n维护两个栈：栈S与栈Q；\n\n栈S：LIR块(低IRR值的数据块)与IRR值小于LIR块的最大R值的HIR块(高IRR值的数据块)；\n\n栈Q：常驻cache中的HIR块；\n\n事实上，栈S存放着当前的LIR块与之后有可能成为LIR块的HIR块；下面介绍\"栈裁剪\"操作。\n\n\"栈裁剪\"操作：若栈S底部的LIR块被删除，则一直删除底部数据块直到遇到LIR块。\n\nQ：\"栈裁剪\"操作的合理性是什么?\n\nA：若栈S底部的LIR块被删除，则底部的HIR块将不会成为LIR块。\n\n在证明\"栈裁剪\"操作的合理性之前，注意到如下的性质：\n\n**性质2**：记S栈如下：\n\n```bash\n---------------------------------------\n                q_3 | q_2 | q_1 | q_0 |\n---------------------------------------\n```\n\n那么R(q_i, t)>R(q_i+1, t)，即R(q_i, t)>=R(q_i+1, t)+1。\n\n对栈底部的HIR块i，考虑它再次被访问后：IRR(i)=R(i,t-1)>max{R(j,t-1)|j in LIR} => IRR(i)>=max{R(j,t)|j in LIR}；从而状态交换的条件不成立，因此栈底部的HIR块不会成为LIR块；\n\n考虑访问各种数据块时算法的反应：\n\n```bash\n|\n|—— LIR块：LIR块移到栈顶，执行\"栈裁剪\"操作；\n|\n|—— HIR块\n     |\n     |—— 在S中：HIR块状态变为LIR并被移到S栈顶，S栈底LIR块状态变为HIR并从栈S中移到栈Q中，执行\"栈裁剪\"操作；\n     |\n     |—— 不在S中：HIR块移到Q栈顶；\n```","tags":["操作系统"],"categories":["course"]},{"title":"第七章 全局页面置换算法","url":"/course/os-ch7.html","content":"\n## 工作集置换算法\n\n**工作集**：一个进程当前正在使用的逻辑页面集合，可表示为二元函数W(t,delta)；t为当前执行时刻，delta为一个页面访问时间窗口，称为工作集窗口；W(t,delta)是时刻t前delta时间窗口内所有访问的页面所组成的集合，|W(t,delta)|就是时刻t前delta时间窗口内访问的页面的数目。\n\n**常驻集**：当前时刻，进程实际驻留在内存中的页面集合。\n\n缺页率与(工作集, 常驻集)的关系：\n\n* 常驻集包含工作集时，缺页率较小；\n* 工作集发生剧烈变动时，缺页率较高；\n* 进程常驻集大小到达一定数目后，缺页率不会明显下降；\n\n**工作集置换算法**：每次访问内存后，换出不在工作集中的页面；\n\n## 缺页率置换算法\n\n**缺页率**：缺页时间间隔的倒数。\n\n**缺页率置换算法**：通过(在发生缺页中断时)调节常驻集大小，使进程的缺页率保持在一个合理的范围内。具体来说，在发生缺页时计算相邻两次缺页的时间间隔delta；对于预先设定的T，若delta>T，操作系统将未被引用的内存页面换出内存，记这些页面的数目为nr，则操作系统收回进程的(nr-1)个未被引用的内存页面，并将缺失页写入剩下的那个未被引用的内存页面；若delta<=T，操作系统为进程申请一个内存页面来写入缺失页(相当于将缺失页增加到工作集中)。\n\n## 抖动与负载控制\n\n**抖动**：并发进程数目太多，使得分配给每个进程的内存页面太少而不能包含工作集；造成了大量缺页，从而操作系统需要频繁地进行置换，降低了CPU的工作效率，进程的运行速度变慢。\n\n操作系统通过调节并发进程数(MPL)来进行负载控制。\n\nCPU利用率与并发进程数的关系大致如下图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 32.png pic32 %}</div>\n\n&nbsp;\n\n而图中的Nmax不好确定，因此只能对Nmax作一个估计，使平均缺页间隔时间/缺页异常处理时间=1的并发进程数，这样可以近似地估计Nmax，从而使系统处于均衡的繁忙状态。","tags":["操作系统"],"categories":["course"]},{"title":"第六章 局部页面置换算法","url":"/course/os-ch6.html","content":"\n## 页面置换算法概述\n\n根据页面置换算法可借用的外界条件，将页面置换算法分为局部页面置换算法：置换页面的选择范围仅限于当前进程占用的内存页面，全局页面置换算法：置换页面的选择范围是所有可换出的内存页面(并不是所有的内存页面都可以换出内存，比如内核关键代码所在内存页面；因此对这些页面，会将其页表项的锁定位置1，从而操作系统在换出内存页面时就不会考虑这些页面)。\n\n## 局部页面置换算法\n\n下面介绍三种理论上的局部页面置换算法。\n\n* 最优算法：将未来最长时间不访问的页面换出内存；缺页次数最少，但是无法实现。用来评价其他置换算法的效率。\n\n* 先进先出算法：将在内存中驻留时间最长的页面进行置换。易于实现，但是效率很低；甚至会出现Belady现象。\n\n* 最近最久未使用算法：将内存中最长时间未被引用的页面进行置换。\n\n实际实现的算法在上述置换算法的基础上做一些折中，使得既易于实现，效率又不是太差。\n\n### 时钟置换算法\n\n* 各页面组成环形链表，指针指向最先调入的页面；\n* 若要访问的页面在内存中，则将页面对应页表项的A位置1；\n* 若要访问的页面不在内存中，从指针处开始顺序查找，对于访问过的页面，将页面对应页表项的A位置0；直到找到A位为0的页面(可以想一下此时A位为0与页面未被访问过的区别)，这就是可以置换的页面；\n\n如下是一个使用时钟置换算法进行内存分配的例子：\n\n{% asset_img 31.jpg pic31 %}\n\n&nbsp;\n\n### 改进的时钟置换算法\n\n由于置换修改过的内存页面需要将该页面的数据写到外存，然后再从外存中读取要换入的页面；这样缺页中断的处理时间几乎是置换未被修改的内存页面的两倍(指令执行的时间可以忽略不计，主要是读取数据的时间)；因此，为了提高缺页中断处理的效率，操作系统应该避免在缺页时置换修改过的内存页面，而是在另外合适的时机将修改过的内存页面的数据写入外存对应位置。\n\n因此有了改进的时钟置换算法，相比于经典的时钟置换算法，操作系统在内存页面分配，访问，置换时还要再对页表项的D位进行维护；\n\n### 最不常用置换算法\n\n发生缺页时，置换访问次数最少的内存页面；\n\n## Belady现象\n\n在给进程分配的内存页面数目增加之后，使用某个(局部)页面置换算法反而使得发生缺页的次数增加，这一现象称为Belady现象。而先进先出算法就具有Belady现象，下面举例说明。\n\n|   FIFO   |  1   |  2   |  3   |  4   |  1   |  2   |  5   |  1   |  2   |  3   |  4   |  5   |\n| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|   尾部   |  1   |  2   |  3   |  4   |  1   |  2   |  5   |  5   |  5   |  3   |  4   |  4   |\n|          |      |  1   |  2   |  3   |  4   |  1   |  2   |  2   |  2   |  5   |  3   |  3   |\n|   头部   |      |      |  1   |  2   |  3   |  4   |  1   |  1   |  1   |  2   |  5   |  5   |\n| 缺页状态 |  √   |  √   |  √   |  √   |  √   |  √   |  √   |      |      |  √   |  √   |      |      |\n\n\n\n此时缺页9次；如果分配4个内存页面：\n\n|   FIFO   |  1   |  2   |  3   |  4   |  1   |  2   |  5   |  1   |  2   |  3   |  4   |  5   |\n| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|   尾部   |  1   |  2   |  3   |  4   |  4   |  4   |  5   |  1   |  2   |  3   |  4   |  5   |\n|          |      |  1   |  2   |  3   |  3   |  3   |  4   |  5   |  1   |  2   |  3   |  4   |\n|          |      |      |  1   |  2   |  2   |  2   |  3   |  4   |  5   |  1   |  2   |  3   |\n|   头部   |      |      |      |  1   |  1   |  1   |  2   |  3   |  4   |  5   |  1   |  2   |\n| 缺页状态 |  √   |  √   |  √   |  √   |      |      |  √   |  √   |  √   |  √   |  √   |  √   |\n\n此时缺页10次，分配的内存页面增加，而缺页的次数增加。\n\n最优算法无Belady现象。\n","tags":["操作系统"],"categories":["course"]},{"title":"第五章 虚拟存储概念","url":"/course/os-ch5.html","content":"\n## 覆盖与交换技术\n\n**覆盖技术**：依据程序的逻辑结构，将程序划分为若干功能独立的模块，将不会同时执行的模块共享同一块内存区域。\n\n**交换技术**：将暂时不能运行的程序换到外存，再将外存中某一进程的数据读入内存。\n\n\n## 局部性原理\n\n程序在执行过程的一段较短时期内，所执行指令的地址与操作数的地址，分别局限于一定区域。具体来说：\n\n* 时间局部性；一条指令在执行后的较短时间内很可能会再次执行，某个内存地址在被访问后的较短时间内很可能会再次访问；\n* 空间局部性；相邻指令访问的内存地址很可能集中在一个较小的区域；\n* 分支局部性；一条跳转指令的两次执行，很可能会跳到相同的内存地址；\n\n局部性原理给虚拟存储技术提供了理论支持。\n\n## 虚拟存储概述\n\n* 在装载程序时，只将指令执行需要的部分页面或段装入内存；\n* 当指令执行时需要的指令或数据不在内存中时(即缺页或缺段)，处理器通知操作系统将相应的页面或者段读入内存；\n* 此外，操作系统还会时刻监控内存中页或段的使用情况，从而将暂时不用的页或段换到外存；\n\n要实现虚拟存储，需要硬件与操作系统的支持；\n\n对硬件：支持虚拟存储的页或段式地址转换机制；\n\n对操作系统：管理内存与外存间页或段的数据的写入；\n\n## 虚拟页式存储管理\n\n概括地说，虚拟页式存储管理就是在页式存储管理的基础上增加请求调页与页面置换。\n\n上一章指出了页表项的结构，但是对其中的控制位并未作解释；在这里我们指出这些控制位在虚拟页式存储管理中所起的作用。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 29.jpg pic29 %}</div>\n\n&nbsp;\n\n* P位：存在位；1表示该页在内存中，0表示该页在外存中；\n* A位：访问位；若该页被访问过，A位置1，否则A位置0；\n* D位：修改位；若该页被修改过，D位置1，否则D位置0；\n\n下面分析一些关键时刻，操作系统对这些控制位的处理。\n\n**装载**\n\n操作系统给应用程序分配足够的线性地址空间，而事实上，操作系统只是将应用程序此时执行必要的一部分页面装入内存中，那么这些页面对应页表项的P位置1，而没有装入内存的页面对应页表项的P位置0；\n\n**内存访问**\n\n操作系统会将访问过的内存页面对应的页表项的A位置1；如果指令对该页进行了修改，则需要将该页对应页表项的D位置1；\n\n**缺页**\n\n指令要访问的页面不在内存中，操作系统调用缺页中断服务例程将该页读入内存，并将该页对应页表项的P位置1；\n\n**页面换出内存**\n\n若页面对应页表项的D位为0，则只需要将P位置0即可；否则，操作系统要将内存中的该页写到外存中对应位置；\n\n## 缺页中断\n\n下面详细介绍缺页中断处理例程。发生缺页中断时，操作系统会找到外存中的对应页面，之后在内存中申请一个空闲页面，将外存中的页面装载到内存中，如果内存中此时没有空闲页面，那么需要根据页面置换算法将内存中的某些页面换出内存。具体的页面置换算法在下一章介绍。","tags":["操作系统"],"categories":["course"]},{"title":"第四章 物理内存管理：非连续内存分配","url":"/course/os-ch4.html","content":"\n## 背景\n\n如果使用连续内存分配，有时不一定有满足要求的一块连续的物理内存；此外，连续内存分配产生的内/外碎片也降低内存分配效率，并且分配了的内存空间无法动态调整。\n\n## 段式存储管理\n\n段的访问机制为[段选择符 : 段偏移量]，MMU通过段选择符索引段描述符表中的段描述符，以此获得段基址；在开启分页机制之前，段基址+段内偏移=物理地址，而在开启分页机制之后，段基址+段内偏移=线性地址；线性地址在下一节介绍。\n\n## 页式存储管理\n\n开启分页机制后，逻辑地址经上述转换得到的是线性地址，线性地址转换为物理地址的原理如下：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 1.jpg pic1 %}</div>\n\n&nbsp;\n\n转换过程中所用到的页表在下一节介绍。此外，页目录表是存放页表地址的页表。\n\n\n## 页表\n\n页表主要用来存放页框地址，MMU通过线性地址中的页表字段索引页表中的页表项，页表项的结构如下图所示：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 29.jpg pic29 %}</div>\n\n&nbsp;\n\n可以看出，页表项中除了记录对应页框的物理地址，还存放一些控制位(如存在位P)；\n\n但是在线性地址转物理地址的原理图中可以看到除了页表之外，还有页目录表，这就是下一节要介绍的多级页表。\n\n\n## 快表与多级页表\n\n### 快表\n\n为提高内存访问效率，会将访问过的页表项缓存到CPU的关联存储器中，这一区域称为快表，相比在页表中查找，在快表中查找会快很多(CPU的处理速度比内存中的访问速度快很多)；于是，在访问内存时，首先在快表中查找页表项，若快表中缓存了此页表项，直接从快表中读取此页表项然后去访问相应的物理地址即可，若快表中未缓存此页表项，接下来则需要通过页表查询页表项，并且将此页表项缓存到CPU的关联存储器中。\n\n### 多级页表\n\n通过间接引用，将线性地址分为若干级，在转换物理地址时，通过各级页表的索引(上一级索引的页表项中的页框地址作为下一级页表的地址)最终找到页表项。得到的页表项中的页框地址加上页内偏移就是要访问的物理内存地址。\n\n如下是两级页表寻址的示意图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 30.png pic30 %}</div>\n\n&nbsp;\n\n**页表自映射**：考虑一个非常特殊的页表项：页目录表对应的页表项。\n\n页表也是页，因此页目录表也是页表。因此，页目录表中必然有一个指向页目录表的页表项；如下图所示：\n\n<div style=\"width:36%;margin:auto\">{% asset_img 32.png pic32 %}</div>\n\n&nbsp;\n\n页目录表对应的页表项的线性地址记为B1|B2|B3；下面解释为何将B1、B2与B3标注在图所示位置。\n\n图中阴影页表项就是指向页目录表的页表项，而每个页表项占4个字节，因此4×B3应该标注在此；\n\n将页目录表看作一个页，而指向这个页的页目录项就是图中阴影页表项，因此4×B2应该标注在此；\n\n将页目录表看作一个页表，页目录表中指向这个页表的页目录项就是图中阴影页表项，因此B1应该标注在此；\n\n## 页映射机制\n\n&nbsp;\n\n## 开启页表机制\n\n&nbsp;\n","tags":["操作系统"],"categories":["course"]},{"title":"第二步 传输TCP/IP数据","url":"/course/cn-step2.html","content":"\n## 创建套接字\n\n### 协议栈的结构\n\n<div style=\"width:60%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n### 套接字：通信控制信息\n\n套接字记录着通信对象的IP地址与端口号、通信的状态等等；总之，套接字中记录了用于控制通信的各种信息，协议栈根据这些信息判断下一步操作。\n\n### socket的内部实现\n\n以下所示是更详细的收发数据示意图：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n## 连接服务器\n\n### 连接：通信双方交换控制信息\n\n所谓建立连接，就是为通信双方互相交换控制信息，在套接字中记录这些必要信息并准备数据收发的一系列操作。\n\n### 保存控制信息的头部\n\n在数据包的头部，存放着客户端与服务器相互联络所需的控制信息，这些信息在TCP协议中进行了定义，如下表所示。\n\n&nbsp;\n\n<div style=\"width:80%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n&nbsp;\n\n在连接阶段，通信双方只交换控制信息，此时网络包的结构如下图：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\n通信双方建立连接之后，通信双方开始互相发送数据，此时的网络包结构如下图：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 10.png pic10 %}</div>\n\n&nbsp;\n\n### 连接的具体操作\n\n|                           服务器端                           | 方向 |                            客户端                            |\n| :----------------------------------------------------------: | ---- | :----------------------------------------------------------: |\n|                                                              | <    | 创建TCP头部，其中包含表示开始数据收发操作的控制信息；<br /><br />对TCP头部进行初始化设置(源IP与目的IP、源端口与目的端口、SYN位置1、序号设置与窗口大小设置等等)；<br /><br />将TCP头部传给IP层并委托IP层发送给服务器端。 |\n| 服务器端接收到数据，经以太层、IP层解析之后到达TCP层；<br /><br />TCP层根据头部的目的端口号找到连接此请求的套接字，并向该套接字中写入相应的信息；套接字的状态改为正在连接；<br /><br />服务器端也是发送一个TCP头部给客户端(操作与客户端的操作相同，但是有些地方的设置要反过来，比如TCP头部的源IP与目的IP、源端口与目的端口之类)；此外，还要将ACK位置为1，表示已经接收到相应的网络包。 | >    |                                                              |\n|                                                              | <    | 客户端接收到数据，经以太层、IP层解析之后到达TCP层；<br />TCP层通过接收到的TCP头部的SYN位确认连接服务器的操作是否成功；若SYN位为1,(表示连接成功)，此时TCP模块会向套接字中写入服务器的IP地址，端口号等信息；并将套接字的状态设置为连接完毕；<br />同样地，客户端也需要将TCP头部的ACK位置1并将TCP头部传给IP层并委托IP层发送给服务器端。 |\n|    服务器收到客户端第二次发送的网络包，连接操作全部完成。    |      |                                                              |\n\n此后，套接字进入了随时可以收发数据的状态。到这里，也就是connect执行完毕。\n\n## 收发数据\n\n### 请求消息进入协议栈\n\n协议栈收到数据后，先将其存放在内部的发送缓冲区，继续等待应用程序后续的数据；协议栈是否发送数据有以下两个判断要素：\n\n* 缓存的数据包长度是否接近MSS(最大分段大小)。MSS=MTU-ip_head_len-tcp_head_len，MTU(最大传输单元)一般为1500；\n* 等待时间。即使数据包长度还未接近MSS，但是已经等待了一定时间，为避免造成发送延迟，也会将数据包发送出去；\n\n应用程序可以控制数据包发送的时机(长度优先或时间优先)，若应用程序未指定，则由协议栈自行决定。\n\n### 对长数据进行拆分\n\n当应用程序送入协议栈的数据长度大于MSS，数据以MSS个字节为单位进行分组，在每组数据前加上TCP头部后送入IP层，委托IP将数据发送。\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n### 网络包的接收确认\n\n每发送一个网络包，都需要进行确认操作。首先，在客户端(发送方)与服务器端(接收方)建立连接时，客户端(发送方)向服务器(接收方)发送的tcp头部使用一个32位的随机数作为序列号；在(发送方)TCP模块拆分数据时，每一数据块前所加的TCP头部的序列号为在上述序列号(32位的随机数)的基础上加上数据块的位置。服务器端(接收方)在收到网络包后，会计算ACK值(序列号+data_len+1)；\n\n&nbsp;\n\n服务器端(接收方)创建一个TCP头部(ACK的值为上述ACK的值，ACK位置1)，然后发送给客户端(发送方)；客户端(发送方)在没有收到某个数据包对应的ACK号之前，数据包会一直保存在发送缓冲区中，如果没有收到某个数据包对应的ACK号，TCP模块会重新发送此数据包。\n\n以下是TCP数据包传输的示意图(简便起见，没有考虑32随机数的初始序列号)。\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n&nbsp;\n\n同时，TCP的数据收发是双向的，即服务器端作为发送方、客户端作为接收方，也会为网络包的接收确认做上述操作。\n\n如下是TCP数据双向传输的示意图：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\n### ACK号等待时间\n\nTCP协议采用动态调整的策略来设置ACK号的等待时间。策略是：在TCP模块发送数据时持续测量ACK号的等待时间，若ACK号的返回变慢，则增大ACK号的等待时间，若ACK号的返回变快，则减小ACK号的等待时间。\n\n### 滑动窗口\n\n接收方告知发送方自己最多能接收的数据，然后发送方根据这个值对发送的数据量进行控制。以下是一个TCP滑动窗口的示例。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 15.png pic15 %}</div>\n\n&nbsp;\n\n### ACK与窗口信息的合并发送\n\nQ1：接收方何时要向发送方发送窗口的更新信息？\n\n答：应用程序从接收缓冲区取出数据后。\n\nQ2：接收方何时要向发送方发送ACK号？\n\n答：收到数据包确认无误后。\n\n为了提高网络的效率，可考虑将这两种信息放入同一tcp头部进行发送。这时，在等待过程中(一种情形是刚刚收到了tcp数据包并确认无误，等待应用程序从接收缓冲区取出数据；另一种情形是应用程序从接收缓冲区取出了数据，等待数据包的到来与确认)，窗口信息或ACK号会有多个值，此时只需要传递最终结果即可。","tags":["计算机网络"],"categories":["course"]},{"title":"AT&T汇编基础知识","url":"/course/ATwithT.html","content":"\n## 基本语法\n\nAT&T与Inter汇编主要有以下几个不同：\n\n* 寄存器的命名；\n```assembly\nAT&T：%eax                   Intel：eax\n```\n* 源操作数与目的操作数的顺序；AT&T赋值方向为从左向右。\n```assembly\nAT&T：movl %eax, %ebx         Intel：mov ebx, eax\n```\n* 常数与立即数的格式；\n```assembly\nAT&T：movl $12, %ebx          Intel：mov eax, 12\n```\n* 地址；\n```assembly\nAT&T：movl $0xd00d, %ebx      Intel：mov eax, 0xd00d\n```\n* 操作数长度标识；\n```assembly\nAT&T：movw %ax, %bx           Intel：mov bx, ax\n```\n* 寻址方式；\n```assembly\n#通用寻址\nAT&T：imm32(base, ip, scale)   Intel：[base+ip×scale+imm32]\n#直接寻址\nAT&T：foo                      Intel：[foo]\n#寄存器间接寻址\nAT&T：(%eax)                   Intel：[eax]\n```\n\n\n## GCC基本内联汇编\n\n基本内联汇编的格式为：`asm(\"statements\");`\n\n## GCC扩展内联汇编\n\nGCC扩展内联汇编的格式为：\n\n```assembly\nasm [volatile]( Assembler Template\n\t: Output Operands\n\t[ : Input Operands\n\t[ : Clobbers ]])\n```\n\n注：如果不希望汇编语句被gcc优化而改变位置，就需要在asm符号后添加volatile关键词；\n\n**样例**\n\n```assembly\n#define read_cr0() ({ \\\nunsigned int __dummy; \\\n__asm__( \\\n\t\"movl %%cr0, %0\\n\\t\" \\\n\t:\"=r\" (__dummy)); \\\n__dummy; \\\n})\n```\n\n**说明**\n\n* 在`__asm__`的括号内，第一行为汇编程序模板；其中`%0`以占位符作为汇编指令的操作数，GCC将这些占位符与C语言表达式按照出现的顺序相对应。即`%0`对应C语言表达式`__dummy`；\n* 第二行为输出部分；输出部分用来规定输出变量如何与寄存器结合的约束，输出部分可以有多个约束，互相以逗号分开，每个约束以\"=\"开头，接着用一个字母来表示操作数的类型，接着是关于变量结合的约束。在上例中，\"r\"代表任一通用寄存器，其他常用约束字母与含义见下表：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\n* 如果有输入部分；输入部分与输出部分相似，但是没有\"=\"；\n* 汇编程序模板为必选项，输入部分与输出部分为可选项；当存在输入部分而不存在输出部分时，需要保留\":\"(代表输出部分，即使输出部分不存在)，而当只存在修改部分时，需要保留\":::\"(代表输出部分、输入部分与修改部分)；\n\n**练习**\n\n扩展内联汇编代码：\n\n```c\nint count=1;\nint value=1;\nint buf[10];\nvoid main()\n{\n    asm(\n        \"cld \\n\\t\"\n        \"rep \\n\\t\"\n        \"stosl\"\n    :\n    : \"c\" (count), \"a\" (value) , \"D\" (buf)\n    );\n}\n```\n\n经过GCC编译之后得到的汇编代码为：\n\n```assembly\nmovl count,%ecx\nmovl value,%eax\nmovl buf,%edi\n#APP\ncld\nrep\nstosl\n#NO_APP\n```","tags":["操作系统","assembly"],"categories":["course"]},{"title":"第一步 浏览器生成消息","url":"/course/cn-step1.html","content":"\n## 生成HTTP请求消息\n\n### 浏览器解析URL\n\n* HTTP协议的URL格式：`http://[用户名(可省略)]:[密码(可省略)]@[Web服务器域名]:[端口号(可省略)][文件路径名]`，例如：\n\n  `http://user:password@www.glasscom.com:80/dir/file1.htm`\n\n* FTP协议的URL格式：`ftp://[用户名(可省略)]:[密码(可省略)]@[ftp服务器域名]:[端口号(可省略)][文件路径名]`，例如：\n\n  `ftp://user:password@ftp.glasscom.com:21/dir/file1.htm`\n\n* 计算机本地文件URL格式：`file://[计算机名(可省略)][文件路径名]`，例如：\n\n  `file://localhost/home/user/Desktop/wps-office-prometheus.desktop`\n\n* 发送电子邮件的URL格式：`mailto:[邮件地址]`，例如：\n\n  `mailto:tone@glasscom.com`\n\n浏览器根据开头就能确定是哪种协议，进而根据对应的协议格式对URL进行解析。\n\n例1：解析如下URL\n\n* `http://www.lab.glasscom.com/`：访问/目录下的index.html或default.html；\n* `http://www.lab.glasscom.com`：访问/目录下的index.html或default.html；\n* `http://www.lab.glasscom.com/what`：若/what是文件，则访问/目录下的what文件，若what是目录，则访问/what目录下的index.html或default.html；\n\n### 生成HTTP请求消息\n\nHTTP请求消息格式如下：\n\n&nbsp;\n\n<div style=\"width:64%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\nHTTP的主要方法及其含义如下图所示：\n\n&nbsp;\n\n<div style=\"width:80%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\nHTTP请求消息中主要的头字段有如下这些：\n\n&nbsp;\n\n<div style=\"width:80%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n## 向DNS服务器查询Web服务器的IP地址\n\n<div style=\"width:64%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n* 客户端将查询消息发送给最近的DNS服务器(地址填写在客户端的TCP/IP设置中)；若该DNS服务器的缓存中存放了`www.lab.glasscom.com`Web服务器的IP地址，则直接返回相应IP地址；\n* 如果该DNS服务器中没有存放`www.lab.glasscom.com`Web服务器的IP地址，就需要从根域向下查找(每台DNS服务器都会保存根域DNS服务器的IP地址，共13个)；\n* 该DNS服务器将查询消息发送给根域DNS服务器，根域DNS服务器根据域名结构判断出该域名属于com域，将com域DNS服务器的IP地址返回该DNS服务器，该DNS服务器再向com域DNS服务器发送查询消息；\n* 一直类似以上步骤，直到查询消息到达目标DNS服务器——com.glasscom.lab域DNS服务器；com.glasscom.lab域中如果存在`www.lab.glasscom.com`这个域名，则目标DNS服务器就会将其IP地址发送给离客户端最近的DNS服务器；否则，目标DNS服务器将\"不存在\"这一结果发送给离客户端最近的DNS服务器；\n* 离客户端最近的DNS服务器将查询结果返回给客户端，同时将此次查询结果缓存，以便下次客户端查询时能够快速响应(DNS服务器缓存的信息都会有一个有效期，过了有效期缓存的信息会被删除)；\n\n## 委托协议栈发送消息\n\n数据通过类似管道的结构来流动：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n收发数据大体分为4个阶段：\n\n* 创建套接字阶段；\n* 连接阶段(将管道连接到服务端的套接字上)；\n* 通信阶段(收发数据)；\n* 断开阶段(断开管道并删除套接字)；\n\n如下示意图：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n&nbsp;\n\n**创建套接字阶段**\n\n创建套接字通过调用socket程序组件完成，套接字创建完成后，协议栈(socket程序组件)返回关于此套接字的描述符。\n\n**连接阶段**\n\n连接目的服务器通过调用connect程序组件完成，connect程序组件需接收3个参数：对应套接字的描述符、目的服务器的IP地址与目的端口号(用来指定要连接的服务器端的套接字)。最终，客户端的套接字与服务器端的套接字连接。\n\n**通信阶段**\n\n调用write程序组件将请求消息从客户端的套接字传送到服务器端的套接字。当服务器端接收到请求消息后，将请求消息解析并执行相应的操作，然后向客户端返回响应消息。接收响应消息通过调用read程序组件完成，read程序组件需接收1个参数——接收到的响应消息在内存中的地址，这一内存区域称为接收缓冲区。\n\n**断开阶段**\n\nWeb服务器发送完响应消息后，会主动执行断开操作；断开操作传回客户端之后，客户端调用close程序组件断开连接、删除套接字。\n\n&nbsp;\n\n在HTTP1.0版本中，HTML文档与图片视为独立的对象，每获取一次数据，就要执行一轮创建套接字、连接、通信与断开的操作；因此，如果一个网页中包含多张图片，就必须重复多轮上述操作，因此在HTTP1.1版本中设计了可以在一次连接中收发多个请求与响应的方法，当所有数据都请求完成后，客户端的应用程序会主动执行断开操作。","tags":["计算机网络"],"categories":["course"]},{"title":"第三章 物理内存管理：连续内存分配","url":"/course/os-ch3.html","content":"\n## 计算机体系结构与内存层次\n\n### 计算机体系结构\n\n<div style=\"width:64%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n### 内存层次\n\n<div style=\"width:50%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n&nbsp;\n\n### 操作系统的内存管理方式\n\n**预备知识**\n\n* 物理地址：将内存当作一个数组，内存单元在数组中的索引就是该内存单元的物理地址；\n* 线性地址(虚拟地址)：操作系统提供的一种对内存的抽象；线性地址到物理地址的转换如下图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 1.jpg pic1 %}</div>\n\n&nbsp;\n\n注：寄存器CR3用于存放当前进程正在使用的页目录基地址\n\n* 逻辑地址：形式为[段描述符 : 段偏移量]；逻辑地址到线性地址的转换如下图：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 10.jpg pic10 %}</div>\n\n&nbsp;\n\n**正文**\n\n<div style=\"width:50%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n&nbsp;\n\n* 重定位：操作系统把用户程序指令中的相对地址变换成为所在存储中的绝对地址的操作；\n* 分段\n  * 段：段由三个参数定义：段基地址、段限长和段属性；段基地址、段限长以及段的保护属性存储在一个称为段描述符的结构体中。\n  * 分段机制：将虚拟地址空间中的虚拟内存组织成一些长度可变的称为段的内存块单元；\n* 分页：虚拟地址空间按照固定大小划分成称为页面的若干单元，在物理内存中对应的单元称为页框。\n* 虚拟存储：进程的地址空间中有的页映射到内存，有的页映射到外存。当程序需要访问外存中的数据时，进程产生缺页中断，然后操作系统将这部分数据装入内存之中，然后进程重新执行失败的指令。\n\n## 地址空间与地址生成\n\n### 地址空间的定义\n\n地址空间是一个进程用来寻址内存的一套地址集合；地址空间中的地址为线性地址。\n\n### 地址生成\n\n举例说明如下：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\n地址的生成有如下几种时机：\n\n* 编译时(地址已知)；\n* 加载时；使用重定位表，在加载时生成绝对地址；\n* 执行时；需硬件支持的地址转换；\n\n### 地址检查\n\n以指令`mov %eax, $0xfffa620e`执行时的地址检查为例。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n## 连续内存分配\n\n以下是在内存分配没有其他技术支持条件下的讨论。此时必须对进程分配连续的地址空间。\n\n### 内存碎片\n\n**外碎片**：由于每个进程的寿命不一致，导致有的进程先从内存中退出，有的进程后从内存中退出，从而在进程占用的内存区域之间出现空闲的内存区域，而该内存区域的长度小于所有进程要求的长度，使得该内存区域变得不可用。这样的空闲内存区域称为外碎片。\n\n**内碎片**：分配给进程区域内无法利用的内存。这是由于分配内存时只能分配2的整数次幂长度的内存区域。\n\n### 动态分配\n\n* 最先匹配：将空闲内存区域按照地址排序，将第一个长度大于进程要求长度的空闲内存区域分配给该进程；\n* 最佳匹配：将空闲内存区域按照长度排序(从小到大)，将第一个长度大于进程要求长度的空闲内存区域分配给该进程；\n* 最差匹配：将空闲内存区域按照长度排序(从大到小)，将第一个空闲内存区域分配给该进程；\n\n## 碎片整理\n\n通过调整进程占用的分区位置来减少或避免分区碎片。\n\n## 伙伴系统\n\n连续内存分配的实例。\n\n## SLUB分配器\n\n### 概述\n\n针对以下情形：\n\n* 一些内核所用到的结构体等对象远比页要小；\n* 并且这些对象会被频繁地申请与释放；\n* 有些对象仅仅初始化的时间就超过了申请到释放的时间；\n\n为满足这些对象申请内存的需求，需要创造页分配管理器之外的内存分配管理器——SLAB分配器，而SLUB分配器是在SLAB分配器的基础上进一步优化；使得效率更高，(分配器的)内存占用更低；下面介绍SLUB分配器的原理。\n\nSLUB将内存分组管理，每个组包含$2^{3},\\cdots,2^{11}$个字节，在4KB为一页的情形下，还有两个特殊的长度分组(96B，192B)，共11组；\n\n可以这样理解：SLUB相当于零售商，伙伴系统相当于厂家，SLUB从伙伴系统那里\"批发\"内存，然后SLUB再零售出去。\n\n整个SLUB系统结构图如下：\n\n{% asset_img 13.jpg pic13 %}\n\n&nbsp;\n\n整个系统的源头就是数组kmalloc_caches[12]，其中每个数组元素kmem_cache结构体相当于超市，每个超市出售一种特定长度的内存；每个超市有两个部门：仓库(kmem_cache_node)与营业厅(kmem_cache_cpu)，营业厅只保留一个slab(从kmem_cache获取的多个内存页)，营业厅在没有空闲object(特定长度的内存)的情况下会从仓库中换出有空闲object的slab；仓库中存放着被完全使用的slab(full链表存放)与被部分使用的slab(partial链表存放)。\n\n### 申请内存块\n\n**第一次申请内存块**\n\n给对象分配object，freelist指向下一空闲的object。\n\n{% asset_img 14.jpg pic14 %}\n\n&nbsp;\n\n**kmem_cache_cpu的slab有空闲的object时申请内存块**\n\n给对象分配object，freelist指向下一空闲的object。\n\n{% asset_img 15.jpg pic15 %}\n\n&nbsp;\n\n这里可能会问一个问题，为什么kmem_cache_cpu的slab中被占用的object是分开的，这是因为中间空闲的object被占用后释放了。\n\n**kmem_cache_cpu的slab无空闲的object时申请内存块，kmem_cache_node的partial链表有slab**\n\nkmem_cache_cpu的slab添加到kmem_cache_node的full链表，再将kmem_cache_cpu的slab换成kmem_cache_node的partial链表中的slab。然后给对象分配object，freelist指向下一空闲的object。\n\n{% asset_img 16.jpg pic16 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 17.jpg pic17 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 18.jpg pic18 %}\n\n&nbsp;\n\n**kmem_cache_cpu的slab无空闲的object时申请内存块，kmem_cache_node的partial链表无slab**\n\nkmem_cache_cpu的slab添加到kmem_cache_node的full链表，向伙伴系统申请slab并初始化slab，然后给对象分配object，freelist指向下一空闲的object；\n\n{% asset_img 19.jpg pic19 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 20.jpg pic20 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 21.jpg pic21 %}\n\n### 释放内存块\n\n**释放kmem_cache_cpu的slab上的object**\n\n将该object放入freelist链表即可。\n\n**释放kmem_cache_node上full链表上的object**\n\n先释放该object，那么该object所在slab的状态从full变成partial，因此需要将该object所在slab从full链表中移除，然后将其添加到partial链表。\n\n{% asset_img 22.jpg pic22 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 23.jpg pic23 %}\n\n&nbsp;\n\n**释放kmem_cache_node上partial链表(有多个object被分配)上的object**\n\n先释放该object，并将该object放入所在slab的freelist链表。\n\n{% asset_img 24.jpg pic24 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 25.jpg pic25 %}\n\n&nbsp;\n\n**释放kmem_cache_node上partial链表(只有一个object被分配)上的object**\n\n先释放该object，之后该object所在slab的状态变成empty，于是还要将该object所在slab也释放。\n\n{% asset_img 26.jpg pic26 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 27.jpg pic27 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 28.png pic28 %}\n\n&nbsp;\n\n**参考链接**\n\n[SLUB算法原理](https://blog.csdn.net/lukuen/article/details/6935068)\n\n[对各种地址更详细地解释](http://bbs.chinaunix.net/thread-2083672-1-1.html)","tags":["操作系统"],"categories":["course"]},{"title":"第二章 中断、异常与系统调用","url":"/course/os-ch2.html","content":"\n## 基本概念与原理\n\n<div style=\"width:36%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n**系统调用**：应用程序主动向操作系统发出的服务请求；异步响应。\n\n**异常**：非法指令或其他原因导致当前指令执行失败，(如内存出错)后的处理请求；同步响应。\n\n**中断**：来自硬件设备(外设，device)的处理请求。好处：避免CPU不停地去查询外设的状态，提高CPU的运行效率；异步或同步响应。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n## 中断处理机制\n\n* 建立中断服务例程；\n* 设置控制寄存器状态使CPU能够响应中断；\n* 处理中断；\n* 保存与恢复现场；\n\n### 设置CPU可响应中断\n\n* sstaus(硬件)：保存全局中断使能位；\n* sie(硬件)：指出CPU目前能处理或忽略的中断；\n* stvec(硬件)：中断入口地址；\n\n初始化如下：\n\n* 设置sie的TI使能STIE位；\n* 设置sstaus的使能中断SIE位；\n* 实现中断服务总控函数并设置stvec指向该函数的地址；\n\n### 建立中断服务例程\n\n* 初始化\n* 服务例程\n\n### 保存现场&恢复现场\n\n在调用中断服务例程之前，需要保存被中断的应用程序的上下文(也就是所有的寄存器)，具体来说，有如下寄存器：\n\n* x[0-31]：通用寄存器；\n* sstatus：系统状态寄存器；\n* 以及寄存器sepc、scause、stval；\n\n产生中断后，硬件设置如下：\n\n* sepc设置为产生中断后指令的地址；\n* pc设置为stvec(总控中断服务程序的地址)；\n* scause设置为中断的来源；\n* sstatus的SIE位置0以禁用中断；\n* stval保存中断相关的附加信息；\n\n## 系统调用\n\n<div style=\"width:80%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n&nbsp;\n\n* ecall指令与sret指令用于系统调用；\n* 系统调用存在着堆栈切换与特权级的切换，参数验证(内核无法信任应用程序)以及可能的切换页表、拷贝数据操作；\n\n**具体流程**\n\n* 应用发起请求；\n* 函数库发出系统调用请求(设置系统调用号，再执行ecall指令)；\n* 保存被中断的应用程序的上下文；\n* 硬件设置：\n  * sepc：保存请求后的指令地址；\n  * pc设置为stvec(总控中断服务程序的地址)；\n  * scause设置为ecall from u-mode；\n  * sstatus：SIE位置0以禁用中断；\n  * stval保存中断相关的附加信息；\n* 调用中断服务例程；\n* 恢复被中断的应用程序的上下文；\n* 应用继续执行；","tags":["操作系统"],"categories":["course"]},{"title":"第一章 操作系统与系统结构&程序设计语言","url":"/course/os-ch1.html","content":"\n## 从OS角度看计算机系统\n\n使用操作系统，在一个CPU上并发的执行多个程序的实例，我们称为进程。在多个进程相互执行时如何做到相互之间不互相影响，保证系统是安全的，这时需要对程序的执行进行**隔离**。这种隔离就需要计算机系统结构给予支持。而这里主要的隔离技术即**虚拟内存**与**特权模式(中断)**。\n\n### 隔离\n\n* 隔离以避免对整个系统的可用性、可靠性、安全产生影响；\n* 运行的程序通常是隔离的单元；\n* 技术1：地址空间。一个程序只能寻址自己的内存，任一程序若无许可，则不能访问不属于自己的内存。\n* 技术2：特权模式（中断机制）。防止应用程序访问设备与敏感的CPU寄存器。使用中断机制进行特权模式的切换。\n\n### 虚拟内存\n\n由操作系统提供的一种对物理内存的抽象。\n\n### 特权模式&中断\n\n* 内核模式(低特权级)\n* 用户模式(高特权级)\n\n\n## Lab1\n\n安装qemu-system\n\n```bash\napt install -y qemu-system\n```\n\n进入ucore/labcodes/lab1文件夹，使用`make`命令编译。\n\n使用qemu-system-x86启动ucore.img但是并不马上执行，以便我们用gdb对其进行远程调试。如无特别说明，以下命令都是在ucore/labcodes/lab1目录下执行。\n\n```bash\nqemu-system-i386 -S -s -hda bin/ucore.img -monitor stdio\n```\n\n再用以下内容替换~/.gdbinit文件\n\n```bash\nfile bin/kernel\ntarget remote :1234\nbreak kern_init\nset arch i8086\n```\n\n接下来运行gdb，效果如下图所示：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\n参考链接：\n\n[清华大学操作系统实验ucore](https://blog.csdn.net/ever_freedom/article/details/105563670)","tags":["操作系统"],"categories":["course"]},{"title":"攻防世界-密码学-Marijuana","url":"/crypto/xctf-Marijuana.html","content":"\n## 题目信息\n\n这个密码系统的开发者在开发过程中使用率很高，也可以说是非常高。 也许他的想法是错的，这个密码系统是非常容易攻破的。\n\n## 分析\n\nRSA的d很小，但是N有3个因子，使用wiener攻击没破解出来，想用boneh_durfee攻击却发现没法列方程，看了writeup才了解到wiener攻击的变种，[论文链接在此](https://web.math.pmf.unizg.hr/~duje/pdf/dujececc.pdf)；总的来说，记$\\{h_{i}/k_{i}\\}$是$e/N$的连分数收敛列，常规的wiener攻击中$d=k_{i}$，而在wiener攻击的变种中，$d=s\\cdot k_{i}+t\\cdot k_{i-1} , s,t \\in Z$，一般来说，$d$越大，$s,t$的取值范围也越大。\n\n## 解题\n\n解题的Python脚本如下：\n```Python\nfrom gmpy2 import is_square,sqrt\nfrom Crypto.Util.number import *\nfrom pwn import pwnlib\nfrom pwnlib.util.iters import mbruteforce\n\nclass Wiener(object):\n    def __init__(self,N,e,mode):\n        self.N=N\n        self.e=e\n        self.mode=mode\n        return\n\n    def next_frac(self):\n        hi_1,hi_2=1,0\n        ki_1,ki_2=0,1\n        a,b=self.e,self.N\n        r=1\n        while r:\n            p,r=divmod(a,b)\n            hi=p*hi_1+hi_2\n            ki=p*ki_1+ki_2\n            hi_1,hi_2=hi,hi_1\n            ki_1,ki_2=ki,ki_1\n            a,b=b,r\n            yield (hi,ki)\n\n    def two(self):\n        N,e=self.N,self.e\n        for frac in self.next_frac():\n            hi,ki=frac\n            if hi==0:\n                continue\n            # f=t^2-(N-(ki*e-1)/hi+1)*t+N ==> delta=[N-(ki*e-1)/hi+1]^2-4*N\n            t1=(ki*e-1)%hi\n            if not t1:\n                t1=N-(ki*e-1)//hi+1\n                delta=pow(t1,2)-4*N\n                if is_square(delta):\n                    t2=int(sqrt(delta))\n                    if not (t1-t2)%2:\n                        P=(t1-t2)//2\n                        Q=(t1+t2)//2\n                        return P,Q\n        return\n\n    def multi(self,rate):\n        N,e=self.N,self.e\n        pt=getRandomRange(2,N-1)\n        ct=pow(pt,e,N)\n        ki_1,ki_2=0,1\n        for frac in self.next_frac():\n            hi,ki=frac\n            ki_1,ki_2=ki,ki_1\n            if hi==0:\n                continue\n            check=lambda rs: pow(ct,int(rs[:rate],2)*ki_1+int(rs[rate:],2)*ki_2,N)==pt\n            rs=mbruteforce(check,'01',2*rate,method='fixed')\n            if rs:\n                return int(rs[:rate],2)*ki_1+int(rs[rate:],2)*ki_2\n        return\n\n    def attack(self):\n        if self.mode:\n            #when there is no solution, maybe you could take greater action, via increase rate.\n            return self.multi(4)\n        else:\n            return self.two()\n\ndef solve():\n    pubkey = (1696852658826990842058316561963467335977986730245296081842693913454799128341723605666024757923000936875008280288574503060506225324560725525210728761064310034604441130912702077320696660565727540525259413564999213382434231194132697630244074950529107794905761549606578049632101483460345878198682237227139704889943489709170676301481918176902970896183163611197618458670928730764124354693594769219086662173889094843054787693685403229558143793832013288487194871165461567L, 814161885590044357190593282132583612817366020133424034468187008267919006610450334193936389251944312061685926620628676079561886595567219325737685515818965422518820810326234612624290774570873983198113409686391355443155606621049101005048872030700143084978689888823664771959905075795440800042648923901406744546140059930315752131296763893979780940230041254506456283030727953969468933552050776243515721233426119581636614777596169466339421956338478341355508343072697451L, 171012227587318507773834753911094468358648971527111097308935888531930900156798659257578479378777764146070352809723708236353390208094909385240006920137781562826981091183813955039359863361624869703055918575613667858215532572602435432258750639197322091887713402631456113333645709142822182724397962837201266977523L, 96969753191136466007366303619618019752521508403657426306543836447071659732926802256183021740376016065813234292694535879838415771865207311953800116203362150588941093508091412441933752168889516206420588410478242229762908362637083786338280959547015086176046206126019992386890758970740552952647510652431386064722L)\n    n,e,a,g=pubkey\n    wiener=Wiener(n,e,1)\n    d=wiener.attack()\n    c1,c2=(1569733526826523065259704222721381245770313117205865099913421859731162526943498524936251685846967970606251353344665893442015804015671457823645874503670136308040791285744658847419176471348768113798503897694020110157476679833746227801224812046930570487233225157924912272791212802495997329083436189937249314855532400635293522270501567950040825794060896420481676398789310029592608176167251882124182145471818654414925639589921023176070657483148482403065241178276749773L, 139537660044872985880471632333334179976891152860359271230202507995985566816703080930428310461057387079799847266510420206696052591677854190150642820963140050439023069266243433278700748622126726137374130247097863526461696642750021196138340072411724739383716017406022211953417323065831672315854246554523225039827L)\n    k=pow(c1,d,n)\n    K=pow(g,k,a)\n    return long_to_bytes(c2*inverse(K,a)%a)\n\nif __name__=='__main__':\n    print solve()\n```\n程序运行结果如下：\n```Bash\n$ python solve.py \n[-] MBruteforcing: No matches found\n......\n[-] MBruteforcing: No matches found\n[+] MBruteforcing: Found key: \"01110110\"\nASIS{Wiener_at7ack_iN_mUlt1_Prim3_RSA_iZ_f34sible_t0O!}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-babyRSA1","url":"/crypto/xctf-Babyrsa1.html","content":"\n## 题目信息\n\n题目无描述。\n\n## 分析\n\n在伽罗华域上实现RSA还是第一次见，该题是典型的论文题，提出这个idea的paper[链接在此](http://www.diva-portal.se/smash/get/diva2:823505/FULLTEXT01.pdf)；\n\n记模数N的分解为$N=P\\cdot Q , s=(2^{deg(P)}-1)\\cdot (2^{deg(Q)}-1)$，其中$deg(\\cdot)$为多项式的次数；则$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ s$。\n\n## 解题\n\n解题的sage脚本如下：\n```Python\nfrom Crypto.Util.number import *\n\ndef solve():\n    p,q=N.factor()\n    p,q=p[0],q[0]\n    #s is the equivalent of phi from classic RSA\n    s=(pow(2,p.degree())-1)*(pow(2,q.degree())-1)\n    #therefore, d is the private key to decrypt\n    d=inverse_mod(e,s)\n    pp=pow(PR(pc),d,N)\n    return long_to_bytes(R(pp).integer_representation())\n\nif __name__=='__main__':\n    PR=PolynomialRing(GF(2),'x')\n    e=31337\n    N=PR('x^2048 + x^2046 + x^2043 + x^2040 + x^2036 + x^2035 + x^2034 + x^2033 + x^2031 + x^2029 + x^2025 + x^2024 + x^2022 + x^2019 + x^2018 + x^2017 + x^2012 + x^2007 + x^2006 + x^2004 + x^2000 + x^1999 + x^1998 + x^1997 + x^1993 + x^1992 + x^1991 + x^1986 + x^1982 + x^1981 + x^1979 + x^1978 + x^1977 + x^1975 + x^1970 + x^1964 + x^1963 + x^1962 + x^1961 + x^1960 + x^1959 + x^1958 + x^1955 + x^1954 + x^1952 + x^1951 + x^1949 + x^1947 + x^1942 + x^1939 + x^1938 + x^1936 + x^1934 + x^1933 + x^1932 + x^1930 + x^1928 + x^1927 + x^1923 + x^1922 + x^1919 + x^1918 + x^1915 + x^1914 + x^1913 + x^1912 + x^1911 + x^1910 + x^1908 + x^1903 + x^1902 + x^1900 + x^1899 + x^1897 + x^1893 + x^1891 + x^1890 + x^1886 + x^1881 + x^1880 + x^1879 + x^1878 + x^1875 + x^1874 + x^1873 + x^1872 + x^1871 + x^1870 + x^1869 + x^1865 + x^1863 + x^1862 + x^1860 + x^1856 + x^1855 + x^1853 + x^1852 + x^1845 + x^1841 + x^1839 + x^1837 + x^1836 + x^1835 + x^1833 + x^1832 + x^1829 + x^1828 + x^1827 + x^1826 + x^1824 + x^1823 + x^1822 + x^1821 + x^1820 + x^1819 + x^1818 + x^1817 + x^1813 + x^1812 + x^1810 + x^1809 + x^1808 + x^1807 + x^1803 + x^1799 + x^1797 + x^1796 + x^1794 + x^1792 + x^1790 + x^1786 + x^1783 + x^1782 + x^1779 + x^1778 + x^1776 + x^1775 + x^1774 + x^1772 + x^1767 + x^1766 + x^1765 + x^1764 + x^1763 + x^1762 + x^1759 + x^1757 + x^1756 + x^1754 + x^1753 + x^1752 + x^1750 + x^1749 + x^1741 + x^1734 + x^1730 + x^1729 + x^1726 + x^1725 + x^1723 + x^1722 + x^1721 + x^1716 + x^1714 + x^1713 + x^1712 + x^1710 + x^1709 + x^1706 + x^1705 + x^1703 + x^1702 + x^1700 + x^1698 + x^1693 + x^1692 + x^1691 + x^1690 + x^1683 + x^1682 + x^1681 + x^1680 + x^1679 + x^1677 + x^1672 + x^1670 + x^1669 + x^1666 + x^1663 + x^1662 + x^1661 + x^1659 + x^1655 + x^1653 + x^1651 + x^1649 + x^1648 + x^1647 + x^1646 + x^1644 + x^1643 + x^1642 + x^1640 + x^1639 + x^1638 + x^1634 + x^1633 + x^1628 + x^1620 + x^1619 + x^1618 + x^1616 + x^1614 + x^1611 + x^1610 + x^1608 + x^1605 + x^1604 + x^1603 + x^1599 + x^1597 + x^1595 + x^1594 + x^1590 + x^1588 + x^1587 + x^1585 + x^1583 + x^1580 + x^1579 + x^1577 + x^1574 + x^1573 + x^1572 + x^1568 + x^1566 + x^1565 + x^1563 + x^1562 + x^1560 + x^1555 + x^1554 + x^1552 + x^1550 + x^1549 + x^1548 + x^1545 + x^1544 + x^1542 + x^1540 + x^1538 + x^1537 + x^1536 + x^1535 + x^1534 + x^1533 + x^1532 + x^1531 + x^1528 + x^1526 + x^1525 + x^1523 + x^1522 + x^1521 + x^1519 + x^1517 + x^1515 + x^1510 + x^1509 + x^1506 + x^1504 + x^1502 + x^1499 + x^1498 + x^1497 + x^1488 + x^1483 + x^1480 + x^1477 + x^1472 + x^1471 + x^1469 + x^1468 + x^1467 + x^1466 + x^1464 + x^1462 + x^1457 + x^1456 + x^1455 + x^1454 + x^1453 + x^1452 + x^1448 + x^1446 + x^1444 + x^1443 + x^1442 + x^1441 + x^1440 + x^1436 + x^1435 + x^1431 + x^1428 + x^1425 + x^1424 + x^1422 + x^1420 + x^1415 + x^1414 + x^1411 + x^1410 + x^1408 + x^1406 + x^1405 + x^1403 + x^1402 + x^1399 + x^1397 + x^1396 + x^1395 + x^1394 + x^1393 + x^1391 + x^1388 + x^1385 + x^1377 + x^1376 + x^1372 + x^1371 + x^1370 + x^1369 + x^1367 + x^1363 + x^1361 + x^1357 + x^1355 + x^1354 + x^1349 + x^1343 + x^1339 + x^1338 + x^1337 + x^1336 + x^1335 + x^1332 + x^1329 + x^1327 + x^1326 + x^1324 + x^1321 + x^1315 + x^1314 + x^1312 + x^1310 + x^1309 + x^1305 + x^1304 + x^1303 + x^1302 + x^1299 + x^1298 + x^1296 + x^1295 + x^1293 + x^1291 + x^1290 + x^1289 + x^1284 + x^1283 + x^1282 + x^1281 + x^1280 + x^1278 + x^1277 + x^1276 + x^1275 + x^1272 + x^1270 + x^1269 + x^1268 + x^1267 + x^1259 + x^1257 + x^1254 + x^1252 + x^1251 + x^1249 + x^1247 + x^1246 + x^1244 + x^1240 + x^1238 + x^1233 + x^1232 + x^1229 + x^1222 + x^1219 + x^1217 + x^1211 + x^1209 + x^1208 + x^1205 + x^1204 + x^1203 + x^1202 + x^1200 + x^1197 + x^1196 + x^1195 + x^1193 + x^1192 + x^1189 + x^1187 + x^1186 + x^1185 + x^1184 + x^1183 + x^1182 + x^1181 + x^1177 + x^1176 + x^1173 + x^1170 + x^1167 + x^1166 + x^1162 + x^1161 + x^1160 + x^1159 + x^1158 + x^1156 + x^1155 + x^1154 + x^1153 + x^1151 + x^1146 + x^1143 + x^1141 + x^1139 + x^1138 + x^1137 + x^1135 + x^1131 + x^1129 + x^1128 + x^1125 + x^1124 + x^1122 + x^1116 + x^1115 + x^1114 + x^1112 + x^1111 + x^1107 + x^1106 + x^1105 + x^1104 + x^1103 + x^1102 + x^1098 + x^1097 + x^1095 + x^1094 + x^1092 + x^1088 + x^1087 + x^1085 + x^1077 + x^1076 + x^1075 + x^1072 + x^1069 + x^1068 + x^1061 + x^1060 + x^1059 + x^1057 + x^1055 + x^1054 + x^1053 + x^1050 + x^1047 + x^1046 + x^1044 + x^1043 + x^1042 + x^1036 + x^1029 + x^1025 + x^1024 + x^1023 + x^1022 + x^1019 + x^1016 + x^1013 + x^1012 + x^1010 + x^1008 + x^1007 + x^1006 + x^1004 + x^1000 + x^996 + x^995 + x^993 + x^992 + x^989 + x^985 + x^983 + x^978 + x^977 + x^975 + x^972 + x^971 + x^970 + x^969 + x^967 + x^963 + x^957 + x^956 + x^952 + x^950 + x^948 + x^945 + x^942 + x^941 + x^940 + x^938 + x^937 + x^936 + x^935 + x^932 + x^931 + x^930 + x^928 + x^927 + x^926 + x^923 + x^921 + x^918 + x^916 + x^914 + x^913 + x^909 + x^906 + x^905 + x^904 + x^902 + x^897 + x^895 + x^892 + x^889 + x^888 + x^887 + x^886 + x^885 + x^884 + x^882 + x^881 + x^879 + x^876 + x^870 + x^868 + x^867 + x^865 + x^862 + x^861 + x^859 + x^858 + x^856 + x^854 + x^848 + x^847 + x^846 + x^843 + x^839 + x^837 + x^836 + x^832 + x^831 + x^830 + x^829 + x^826 + x^823 + x^821 + x^820 + x^817 + x^815 + x^812 + x^809 + x^808 + x^805 + x^803 + x^802 + x^800 + x^799 + x^797 + x^795 + x^793 + x^792 + x^788 + x^786 + x^784 + x^780 + x^775 + x^774 + x^770 + x^768 + x^766 + x^764 + x^761 + x^760 + x^753 + x^752 + x^751 + x^750 + x^747 + x^744 + x^742 + x^741 + x^737 + x^734 + x^732 + x^728 + x^727 + x^724 + x^722 + x^721 + x^719 + x^717 + x^715 + x^714 + x^713 + x^710 + x^709 + x^705 + x^703 + x^701 + x^698 + x^697 + x^695 + x^690 + x^687 + x^685 + x^684 + x^682 + x^681 + x^680 + x^677 + x^676 + x^674 + x^673 + x^672 + x^671 + x^670 + x^669 + x^665 + x^663 + x^659 + x^652 + x^651 + x^650 + x^649 + x^648 + x^647 + x^646 + x^645 + x^642 + x^640 + x^638 + x^632 + x^631 + x^630 + x^629 + x^627 + x^626 + x^623 + x^622 + x^621 + x^620 + x^616 + x^615 + x^610 + x^605 + x^602 + x^601 + x^600 + x^599 + x^598 + x^596 + x^594 + x^593 + x^591 + x^583 + x^581 + x^579 + x^578 + x^577 + x^576 + x^575 + x^573 + x^572 + x^571 + x^570 + x^569 + x^565 + x^563 + x^562 + x^561 + x^559 + x^557 + x^555 + x^552 + x^551 + x^546 + x^544 + x^542 + x^541 + x^540 + x^539 + x^538 + x^537 + x^535 + x^533 + x^530 + x^527 + x^523 + x^522 + x^520 + x^519 + x^515 + x^513 + x^511 + x^509 + x^507 + x^505 + x^504 + x^503 + x^499 + x^497 + x^496 + x^495 + x^493 + x^492 + x^488 + x^486 + x^481 + x^480 + x^479 + x^478 + x^477 + x^472 + x^470 + x^468 + x^467 + x^464 + x^463 + x^460 + x^459 + x^455 + x^454 + x^453 + x^446 + x^445 + x^444 + x^443 + x^440 + x^438 + x^437 + x^432 + x^431 + x^428 + x^427 + x^426 + x^420 + x^419 + x^416 + x^415 + x^414 + x^413 + x^412 + x^411 + x^405 + x^404 + x^401 + x^396 + x^393 + x^392 + x^391 + x^388 + x^387 + x^383 + x^381 + x^380 + x^377 + x^376 + x^369 + x^364 + x^362 + x^358 + x^357 + x^356 + x^355 + x^353 + x^351 + x^349 + x^340 + x^339 + x^338 + x^337 + x^336 + x^335 + x^334 + x^332 + x^330 + x^328 + x^327 + x^326 + x^324 + x^320 + x^318 + x^316 + x^315 + x^309 + x^302 + x^298 + x^292 + x^291 + x^290 + x^289 + x^287 + x^286 + x^285 + x^284 + x^281 + x^279 + x^278 + x^276 + x^274 + x^273 + x^272 + x^271 + x^267 + x^266 + x^264 + x^263 + x^262 + x^260 + x^259 + x^256 + x^254 + x^253 + x^252 + x^251 + x^249 + x^248 + x^247 + x^245 + x^244 + x^241 + x^239 + x^235 + x^234 + x^233 + x^232 + x^231 + x^230 + x^226 + x^224 + x^221 + x^219 + x^218 + x^216 + x^215 + x^214 + x^209 + x^207 + x^206 + x^202 + x^201 + x^198 + x^197 + x^194 + x^193 + x^192 + x^191 + x^189 + x^188 + x^183 + x^182 + x^181 + x^180 + x^179 + x^178 + x^177 + x^175 + x^172 + x^169 + x^168 + x^166 + x^165 + x^164 + x^163 + x^158 + x^157 + x^153 + x^152 + x^149 + x^147 + x^146 + x^144 + x^140 + x^139 + x^136 + x^128 + x^127 + x^126 + x^124 + x^123 + x^122 + x^121 + x^116 + x^115 + x^113 + x^112 + x^109 + x^108 + x^107 + x^106 + x^104 + x^103 + x^102 + x^101 + x^100 + x^99 + x^97 + x^95 + x^94 + x^93 + x^92 + x^87 + x^84 + x^83 + x^82 + x^80 + x^79 + x^78 + x^76 + x^73 + x^70 + x^69 + x^68 + x^67 + x^66 + x^65 + x^63 + x^60 + x^59 + x^57 + x^55 + x^52 + x^51 + x^47 + x^46 + x^45 + x^43 + x^42 + x^40 + x^36 + x^35 + x^30 + x^29 + x^28 + x^27 + x^23 + x^20 + x^17 + x^14 + x^9 + x^7 + x^3 + 1')\n    R.<a> = GF(2^2049)\n    with open('flag.enc','rb') as f:\n        pc=R.fetch_int(bytes_to_long(f.read()))\n    print solve()\n```\n\n程序运行结果如下：\n```Bash\nsage solve.sage\n  ***   Warning: increasing stack size to 2000000.\nflag{P1ea5e_k33p_N_as_A_inTegeR~~~~~~}jIXXXX\n```\n注：后面XXXX代表不可打印明文。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-oneTimePad2","url":"/crypto/xctf-Onetimepad-2.html","content":"\n## 题目信息\n\n看名字也可以猜出来是oneTimePad的升级版。\n\n## 分析\n\nprocess1：GF(2^128)上的乘法操作；也是oneTimePad的唯一考点。\n\nnextrand：将process2视为$\\{(x_{1},x_{2},x_{3},x_{4})|x_{i}\\in GF(2^{128})\\}$上的乘法操作，则函数最后的tmp1就是$(A,B,0,1)^{N}$；而通过几次尝试，发现$(A,B,0,1)^{N}$有形式$(A^{N},A^{N-1}\\cdot B+\\cdots +A\\cdot B+B,0,1)$，即$(A^{N},B(A^{N}-1)\\cdot (A-1)^{-1},0,1)$而这可通过数学归纳法得到证明(证明很简单，此处略)。此外，$N$更新为$N^{2}$(乘法为GF(2^128)上的乘法操作)。从而得到密钥的更新迭代公式为：$k_{i+1}=k_{i}\\cdot A^{N}+B(A^{N}-1)\\cdot (A-1)^{-1}=(k_{i}+B\\cdot (A-1)^{-1})\\cdot A^{N}-B(A-1)^{-1}$，则$k_{i+1}+B\\cdot (A-1)^{-1}=(k_{i}+B\\cdot (A-1)^{-1})\\cdot A^{N}$，记$f(k)=k+B\\cdot (A-1)^{-1}$，则$A^{N}=f(k_{i+1})\\cdot f(k_{i})^{-1}$。128位的离散对数问题sage还是可以搞定的！\n\n而由于题目给了一定长度的明文，因此我们也就得到了一定数量的密钥(3个)，使用第2个和第3个密钥恢复出生成第3个密钥的$N$；得到$N$之后进行同样的操作来恢复出加密消息时的密钥流。\n\n注：我恢复的是生成第3个密钥的$N$，需要更新($N\\leftarrow N^{2}$)才能对接下来的密文(第4组起)解密！\n\n## 解题\n\n解题分为两步，第一步解出$N$，使用的sage脚本如下：\n```Python\nfrom binascii import unhexlify\nfrom Crypto.Util.number import *\n\ndef polify(N):\n    bN=list(bin(N)[2:])\n    bN.reverse()\n    return K(bN)\n\ndef unpolify(Poly):\n    bN=Poly.polynomial().list()\n    bN.reverse()\n    return long(''.join([str(it) for it in bN]),2)\n\nif __name__=='__main__':\n    K.<x>=GF(2L^128,modulus=x^128+x^7+x^2+x+1)\n    cipher='0da8e9e84a99d24d0f788c716ef9e99cc447c3cf12c716206dee92b9ce591dc0722d42462918621120ece68ac64e493a41ea3a70dd7fe2b1d116ac48f08dbf2b26bd63834fa5b4cb75e3c60d496760921b91df5e5e631e8e9e50c9d80350249c'\n    cipher=unhexlify(cipher)\n    cs=[bytes_to_long(cipher[ii:(ii+16)]) for ii in range(0,len(cipher),16)]\n    pre=\"One-Time Pad is used here. You won't know that the flag is flag{\"\n    ps=[bytes_to_long(pre[ii:ii+16]) for ii in range(0,len(pre)-16,16)]\n    ks=[p^^c for p,c in zip(ps,cs)]\n    f=lambda k,a,b: k+b*(a-1)^-1\n    A=0xc6a5777f4dc639d7d1a50d6521e79bfd\n    B=0x2e18716441db24baf79ff92393735345\n    KA,KB=polify(A),polify(B)\n    Kks=[polify(t) for t in ks]\n    tt=f(Kks[2],KA,KB)*f(Kks[1],KA,KB)^-1\n    N=discrete_log(tt,KA)\n    KN=polify(N)\n    print unpolify(pow(KN,2))\n```\n脚本运行结果如下：\n```Bash\n$ sage solve.sage\n139066609048774629292054833219983607544\n```\n注：我最后做了更新操作，因此直接对第四组起的密文解密即可。\n\n第二步，进行同样的操作来恢复出加密消息时的密钥流来解密密文，使用的Python脚本如下：\n```Python\nfrom binascii import unhexlify\nfrom Crypto.Util.number import *\nfrom oneTimePad2 import P,A,B\nfrom oneTimePad2 import process1,process2\n\ndef nextrand(rand):\n    global N, A, B\n    tmp1 = [1, 0, 0, 1]\n    tmp2 = [A, B, 0, 1]\n    s = N\n    N = process1(N, N)\n    while s:\n        if s % 2:\n            tmp1 = process2(tmp2, tmp1)\n        tmp2 = process2(tmp2, tmp2)\n        s = s / 2\n    return process1(rand, tmp1[0]) ^ tmp1[1]\n\ndef keygen():\n    key = bytes_to_long(pre)^bytes_to_long(cipher[0:16])\n    while True:\n        yield key\n        key = nextrand(key)\n\nif __name__=='__main__':\n    N=139066609048774629292054833219983607544\n    cipher='0da8e9e84a99d24d0f788c716ef9e99cc447c3cf12c716206dee92b9ce591dc0722d42462918621120ece68ac64e493a41ea3a70dd7fe2b1d116ac48f08dbf2b26bd63834fa5b4cb75e3c60d496760921b91df5e5e631e8e9e50c9d80350249c'\n    cipher=unhexlify(cipher[64:])\n    pre=\"on't know that t\"\n    res=''\n    for i, key in zip(range(0,64,16),keygen()):\n        res+= long_to_bytes(bytes_to_long(cipher[i:i+16])^key)\n    print res\n```\n注：为了复用P,A,B以及process1,process2，对oneTimePad2.py做了一定调整，P,A,B的定义放在全局，其他的除了函数定义全部放到`if __name__ == '__main__':`下。\n运行脚本结果如下：\n\n```Bash\n$ python solve.py\non't know that the flag is flag{LCG1sN3ver5aFe!!}.XXXX\n```\n注：后面的字符有不可打印字符因此用XXXX代替。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-root","url":"/crypto/xctf-Root.html","content":"\n## 题目信息\n\n附件是一个流量包。\n\n## 分析\n\n在流量包中找到RSA公钥，由于没有提供任何其他信息，且模数位数很高，只能寄希望于因子之差很小，即采用费马攻击。之后将私钥导入流量包即可找出flag。\n\n## 解题\n\n解题的Python脚本如下：\n```Python\nfrom gmpy2 import isqrt,square,is_square\nfrom Crypto.Util.number import *\nfrom Crypto.PublicKey import RSA\n\ndef fermat_factors(n):\n    assert n % 2 != 0\n    a = isqrt(n)\n    b2 = square(a) - n\n    while not is_square(b2):\n        a += 1\n        b2 = square(a) - n\n    factor1 = a + isqrt(b2)\n    factor2 = a - isqrt(b2)\n    return int(factor1), int(factor2)\n\ndef solve():\n    N=0x726f6f7400000000000000000000000000000000001b000000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001fffff7777777b00000000000000001ffffffffffffb00000000000000001ffffffffffb0000000000000000001ffffffffffb0000000000000000001ffffffffffffb00000000000000001fffff2222222b00000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb00000000000000265293c4422be3532638feeb2a635e865e5bccd4862d1491f8e46ed41afdab32ab1e913c296c45a723a371cc4ad218d273a494ac501a1c677576b84d3a1700b24e38f3d7c8090c952767f8a9da532eb4496a953fa2b2641f93af58321e491ad6b3e1f6600ea1757635a2d47562dff2f245bfc8ed511420931de246d56334d8897d6465b227f6c095ece1ad994c7551f08dbc21f8b40691ee51f5f72d052d9352062f90b0e7c52c2eb18196c2c985101af4eac67499396c6241ad4f2439ed11f87d67e73a239b865c45d65a61cf0f56082de831b97fb28ae8222a7195e0ec06c08281ffc16e7106e77e68b8c4510424beeb5582fe21cc345f53534682b75c368d73c9\n    E=31337\n    p,q=fermat_factors(N)\n    phi=(p-1)*(q-1)\n    assert GCD(E,phi)==1\n    d=inverse(E,phi)\n    rsakey=RSA.construct((N,E,d,p,q))\n    with open('key.pem','wb') as f:\n        f.write(rsakey.exportKey('PEM'))\n    return\n\nif __name__=='__main__':\n    solve()\n```\n之后将私钥导入流量包，如下图所示：\n\n{% asset_img 1.png pic1 %}\n\n然后返回，快捷键Ctrl-Alt-Shift-S来追踪SSL流，在明文的最后以'666c6167'开头，而它正好是flag的16进制编码。将这串字符进行16进制解码即得到flag。\n```Python\n>>> '666c61673a7768656e5f736f6c76696e675f70726f626c656d735f6469675f61745f7468655f726f6f74735f696e73746561645f6f665f6a7573745f6861636b696e675f61745f7468655f6c6561766573'.decode('hex')\n'flag:when_solving_problems_dig_at_the_roots_instead_of_just_hacking_at_the_leaves'\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-babyrsa","url":"/crypto/xctf-Babyrsa.html","content":"\n## 题目信息\n\n点击获取在线场景来得到在线场景。\n\n## 分析\n\n就是一个最常规的RSA Oracle，在CTF Wiki中[RSA部分](https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_chosen_plain_cipher/)有介绍。\n\n## 解题\n\n交互解题的Python脚本如下：\n```Python\nfrom pwn import pwnlib\nfrom pwnlib.tubes.remote import remote\nfrom time import sleep\nfrom Crypto.Util.number import *\n\ne=0x10001\nn=0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db\nc=0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0\n\ndef check(guess,err):\n    for m in range(guess-err,guess+err):\n        if pow(m,e,n)==c:\n            return m\n    return\n\ndef solve():\n    low,high=0,n\n    cnt=0\n    while high-low>4:\n        cnt+=1\n        tt=(pow(2,cnt*e,n)*c)%n\n        r=remote('111.200.241.244',44451)\n        re=r.recv()\n        r.sendline(hex(tt)[2:])\n        re=r.recv().strip('\\n')\n        r.close()\n        if re=='odd':\n            low=(low+high)//2\n        else:\n            high=(low+high)//2\n        print len(bin(high-low))-2\n        sleep(0.5)\n    m=check(low,150)\n    if not m:\n        print 'try again!'\n        return\n    return long_to_bytes(m)\n\nif __name__=='__main__':\n    print(solve())\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-beginners-luck","url":"/crypto/xctf-Beginners-Luck.html","content":"\n## 题目信息\n\n题目无描述。\n\n## 分析\n\n通过对加密脚本的分析可知需通过PNG文件格式与最后的填充破解出密钥，[PNG文件格式详细介绍在此](https://www.cnblogs.com/senior-engineer/p/9548347.html)；大致来说，每个PNG文件的开头都是一串固定的字节来表明其PNG文件格式，你并不需要确切知道这些字节是什么，只需要找一张可正常打开的PNG文件即可！然而，仅通过PNG文件头无法破解密钥的全部24字节，于是还需要借助加密前的填充操作，填充是一串长度相同的字节，且字节的值等于这串字节的长度，通过结合这两点，即可破解出key全部24个字节。\n\n## 解题\n\n如下是解题的Python脚本(找一张可正常打开的PNG文件，命名为sample.png于同目录下)：\n```Python\ndef solve():\n    with open('BITSCTFfullhd.png','rb') as f:\n        d=f.read()\n    with open('sample.png','rb') as f:\n        dd=f.read(24)\n    pre_k=bytes([s^t for s,t in zip(d[:24],dd)])\n    me=bytes([s^t for s,t in zip(pre_k,d[-24:])])\n    L=max(me,key=me.count)\n    end_k=bytes([s^t for s,t in zip(L.to_bytes(1,'little')*L,d[-L:])])\n    key=pre_k[:-L]+end_k\n    ld=len(d)\n    assert not ld%24\n    m=bytes([s^t for s,t in zip(d,key*(ld//24))])\n    with open('FLAG.png','wb') as f:\n        f.write(m[:-L])\n    return\n\nif __name__=='__main__':\n    solve()\n    print('done!')\n```\n程序运行后会在目录下生成FLAG.png，打开即可见flag。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-Handicraft_RSA","url":"/crypto/xctf-Handraft-rsa.html","content":"\n## 题目信息\n\n有人正在他老房子的地下室里开发自己的RSA系统。 证明他这个RSA系统只在他的地下室有效！\n\n## 分析\n\n很明显素数的生成有问题，生成的素数p，其p-1有很多小因子，使用RsaCtfTool即可破解出私钥！\n\n## 解题\n\n```Bash\n$ python3 RsaCtfTool.py -n 21702007965967851183912845012669844623756908507890324243024055496763943595946688940552416734878197459043831494232875785620294668737665396025897150541283087580428261036967329585399916163401369611036124501098728512558174430431806459204349427025717455575024289926516646738721697827263582054632714414433009171634156535642801472435174298248730890036345522414464312932752899972440365978028349224554681969090140541620264972373596402565696085035645624229615500129915303416150964709569033763686335344334340374467597281565279826664494938820964323794098815428802817709142950181265208976166531957235913949338642042322944000000001 -e 65537 --private\n\n[*] Testing key /tmp/tmpeooqiijv.\n[*] Performing boneh_durfee attack on /tmp/tmpeooqiijv.\n[*] Performing comfact_cn attack on /tmp/tmpeooqiijv.\n[*] Performing cube_root attack on /tmp/tmpeooqiijv.\n[*] Performing ecm attack on /tmp/tmpeooqiijv.\n[*] ECM Method can run forever and may never succeed, timeout set to 30sec. Hit Ctrl-C to bail out.\n^C[*] Performing ecm2 attack on /tmp/tmpeooqiijv.\n[*] ECM2 Method can run forever and may never succeed, timeout set to 30sec. Hit Ctrl-C to bail out.\n^C[*] Performing factordb attack on /tmp/tmpeooqiijv.\n\nResults for /tmp/tmpeooqiijv:\n\nPrivate key :\n-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEAq+m7iHurBa9G8ujEiTpZ71aHOVNhQXpd6jCQNhwMN3hD6JHk\nv0HSxmJwfGe0EnXDtjRraWmS6OYzT4+LSrXsz9IkWGzRlJ4lC7WHS8D3NWIWYHCP\n4TRt2N0TlWXWm9nFCrEXqQ3IWgYQpQvKzsdsetnIZJL1tf1wQzGE6rbkbvURlUBb\nzBSuidkmi0kY5Qxp2Jfb6OUI647zx2dPxJpDffSCNffVIDUYOvrgYxIhs5HmCF3X\nECC3VfaKtRceL5JM8R0qz5nVU2Ns8hPvSVP+7/i7G447cjW151si0joB7RpBplu4\n4Vk8TXXDAk0JZdW6KwJn7ITaX04AAAAAAAAAAQIDAQABAoIBAQCEWcr2FXeiRcIS\nit+cYp8QowYyPR4YAfRBsyejcM56+g0WBRQdprh14R2GuXQp7h5BrXOwUQY4ZdnE\n+9caKptpl/hBV222xFXzAMtrp+DqaVye3Kn4kJutJO7JywCBNhP72kFD9odzv02b\nM0vtDB1ZK0ebHoUqmjaOlJYm+a0+OgzRG/VY6PfVs0GWdsSPtbIcautHI/+5V8US\nyG2wRH78JmTobVCLxEmdpjnUNKTM1Vsg/VCatzbkpohrE1cEZHhk+ke9uhyPvIvt\nafOC442Y09eI0vaC24IfgyAVuhOfuU3uik+JT6Vz1x9/53vorAD//wAA//8AAP//\nAAD//wABAoGBAMaX7gnjTwV6mm9o004b07Hk5Ab3PR4oEzniNgtrpP8/3Ed1wpHg\nM54idlm6rYlcLh+XWU4Z7/4v5HaNjbPaRye2tGVfGi+gY+HcrRLbEHUJlhPKUozd\nN6nayALynp7Lso19xaOz6kV86oUw+TFSi1PRnHcV01mJTgAAAAAAAAABAoGBAN2b\nbaKYDQzqBypnO+t/6JQPIvHzY8gC34qdUv7ShqvKgX70QRcFY4BY2C+ZTln0y1jv\ntX3tCwq59dzh1CRpgAfwk5nR2IjA+JLU35vAGB1IVqWmVC/VZ46zOSwy07xCJEy4\nHQ0d+PqANk8Wv2pMFmZZZfDWsYDWAAAAAAAAAAABAoGAK2b69BhEperko6KiQ7jb\nLE7c8xTHu7aAdS8WJqrQ9aQMTWXULzNztITNntCoqpOF1QurzeDnTYNECBDpvjvf\nPzOz+0+slmoUSkGDZdKQpzOAJDUck4KpbqrM+a/ysLvN+xRYxG1Grwcc7h0E6R2k\nK55s9q3DchcK//8AAP//AAECgYAUPbgb28uFXHLfGqLMddhmfaNxegupHyoP3SLR\nh6UpV8vQLrsrQSC/fl3wqw4PBV71dp+bKuWRSz77t9zKnqBFGWJB8HrYsteBgdQS\nw87wDcVsR+70l4dn71LPiKzySxBJuZ9drVkqeD99pdRB/0UkgBHhl5qK7AD//wAA\n//8AAQKBgQCYIKsSiGhJxY9AGaWofVsVe2sgGPHpwj3l2Yv8/PoG5Fpxozy+mzqv\nlDHIzJjsDIhtDeZr2cTkT6ODNM8bswDC62QnG+VUAzltXeN7P/aQzrbEUcGg7zgd\nZzvOJdNjXP9dU/vKGBT9cjjJhvwowfqnDlUVrl12W3AE/jn6U/Xpfg==\n-----END RSA PRIVATE KEY-----\n```\n破解出私钥之后，循环解密多次直到找出flag。如下Python脚本：\n```Python\nfrom base64 import b64decode\nfrom Crypto.Util.number import *\n\ndef solve():\n    N=21702007965967851183912845012669844623756908507890324243024055496763943595946688940552416734878197459043831494232875785620294668737665396025897150541283087580428261036967329585399916163401369611036124501098728512558174430431806459204349427025717455575024289926516646738721697827263582054632714414433009171634156535642801472435174298248730890036345522414464312932752899972440365978028349224554681969090140541620264972373596402565696085035645624229615500129915303416150964709569033763686335344334340374467597281565279826664494938820964323794098815428802817709142950181265208976166531957235913949338642042322944000000001\n    d=16707734744082089987096183760536140050531071284398222525928539910115274945961673413424053379896538639181783084998088831705326266248972451538621553176990679827738650084993005694971585059194288779236578752505246610328862945930341561242587398577636666631640913502943335996493633579116896296237142465786006038646664937384294577512911411958573147328359278328601128101352047028079357406162063405979398633542591758429760763171350524080583743130797539259640940004907846945847664144924968938380506532950172261068535550048712875992662239788993590417593968724043704420879416184807161738395187599580068732017638891008132810473473\n    C=b64decode(b'eER0JNIcZYx/t+7lnRvv8s8zyMw8dYspZlne0MQUatQNcnDL/wnHtkAoNdCalQkpcbnZeAz4qeMX5GBmsO+BXyAKDueMA4uy3fw2k/dqFSsZFiB7I9M0oEkqUja52IMpkGDJ2eXGj9WHe4mqkniIayS42o4p9b0Qlz754qqRgkuaKzPWkZPKynULAtFXF39zm6dPI/jUA2BEo5WBoPzsCzwRmdr6QmJXTsau5BAQC5qdIkmCNq7+NLY1fjOmSEF/W+mdQvcwYPbe2zezroCiLiPNZnoABfmPbWAcASVU6M0YxvnXsh2YjkyLFf4cJSgroM3Aw4fVz3PPSsAQyCFKBA==')\n    f=open('mes','wb')\n    for _ in range(80):\n        C=long_to_bytes(pow(bytes_to_long(C),d,N))\n        f.write(C+b'\\n\\n')\n    return\n\nif __name__=='__main__':\n    solve()\n```\n在mes中第64行：\n\n```Bash\nthe flag is: ASIS{n0t_5O_e4sy___RSA___in_ASIS!!!}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"Paillier同态加密之解密的正确性","url":"/crypto/Correctness-of-decryption-of-Paillier-homomorphic-encryption.html","content":"\n## Paillier同态加密系统\n\n### 符号说明\n\n* p,q为大素数，$p\\neq q$；\n* $n=p\\cdot q$；\n* $\\lambda =(p-1)\\cdot (q-1)$；\n* $B_{\\alpha}=\\{e\\in Z_{n^{2}}^{\\ast}|ord(e)=\\alpha\\cdot n\\}$；\n* $B=\\bigcup_{\\alpha=1}^{\\lambda}B_{\\alpha}$；\n* 函数$L(x,n)=[(x-1)/n]$；\n\n### 密钥生成\n\n* 随机选择指定长度的大素数p,q；(p,q)为私钥；\n* $n=p\\cdot q$；随机选择$g\\in B$；(g,n)为公钥；\n\n### 加密\n\n* 明文m<n，随机选择r<n；\n* 密文$c=g^{m}\\cdot r^{n}\\ \\textrm{mod}\\ n^{2}$；\n\n### 解密\n* 密文$c<n^{2}$；\n* 明文$m=L(c^{\\lambda}\\ \\textrm{mod}\\ n^{2}, n)\\cdot L(g^{\\lambda}\\ \\textrm{mod}\\ n^{2}, n)^{-1}\\ \\textrm{mod}\\ n$；\n\n## 解密的正确性\n\n对于$g=1+n$的情形，网上已有很多证明解密正确性的推导，而我在这里是希望给出更一般的情形下解密正确性的证明；推导参考提出Paillier同态加密系统的这篇论文：《Public-Key Cryptosystems Based on Composite Degree Residuosity Classes》。\n\n**定义1**：定义映射$\\varepsilon_{g}: Z_{n}\\times Z_{n}^{\\ast}\\mapsto Z_{n^{2}}^{\\ast}$，$\\varepsilon_{g}(x,y)=g^{x}\\cdot y^{n}\\ \\textrm{mod}\\ n^{2}$。\n\n**引理1**：若$g$的阶$ord(g)$是$n$的非零整数倍，则$\\varepsilon_{g}$是双射。\n\n证明：由于$Z_{n}\\times Z_{n}^{\\ast}$与$Z_{n^{2}}^{\\ast}$的元素个数均为$n\\phi(n)$(参考《近世代数》(第三版)杨子胥 第149页 定理1)，因此只需证明$\\varepsilon_{g}$是单射；\n\n假设$\\varepsilon_{g}(x_{1},y_{1})=\\varepsilon_{g}(x_{2},y_{2})$；\n\n则$g^{x_{1}-x_{2}}\\cdot (y_{1}\\cdot y_{2}^{-1})^{n}\\equiv 1\\ \\textrm{mod}\\ n^{2}$；\n\n因此$g^{\\lambda(x_{1}-x_{2})}\\cdot (y_{1}\\cdot y_{2}^{-1})^{\\lambda\\cdot n}\\equiv g^{\\lambda(x_{1}-x_{2})}\\equiv 1\\ \\textrm{mod}\\ n^{2}$；\n\n从而$ord(g)|\\lambda(x_{1}-x_{2})$；\n\n又$n|ord(g)\\Rightarrow n|\\lambda(x_{1}-x_{2}) , (n,\\lambda)=1\\Rightarrow n|(x_{1}-x_{2})$；\n\n因此在$x_{1},x_{2}\\in Z_{n}$的意义下，$x_{1}=x_{2}$；\n\n那么$(y_{1}\\cdot y_{2}^{-1})^{n}\\equiv 1\\ \\textrm{mod}\\ n^{2}$，则$y_{1}\\cdot y_{2}^{-1}\\equiv 1\\ \\textrm{mod}\\ n$，理由如下：\n\n假设$x^{n}\\equiv 1\\ \\textrm{mod}\\ n^{2}$，则：\n$$\n\\begin{cases}\nx^{(p-1)\\cdot q+q}\\equiv 1\\ \\textrm{mod}\\ p\\\n\\\\\n\\\\\nx^{(q-1)\\cdot p+p}\\equiv 1\\ \\textrm{mod}\\ q\\\n\\end{cases}\n$$\n即：\n$$\n\\begin{cases}\nx^{q}\\equiv 1\\ \\textrm{mod}\\ p\\\n\\\\\n\\\\\nx^{p}\\equiv 1\\ \\textrm{mod}\\ q\\\n\\end{cases}\n$$\n又$(p,q-1)=1$，$(q,p-1)=1$，从而存在$s,t\\in Z$，使得$p\\cdot s\\equiv 1\\ \\textrm{mod}\\ q-1 , q\\cdot t\\equiv 1\\ \\textrm{mod}\\ p-1$，同理可得：\n$$\n\\begin{cases}\nx\\equiv 1\\ \\textrm{mod}\\ p\\\n\\\\\n\\\\\nx\\equiv 1\\ \\textrm{mod}\\ q\\\n\\end{cases}\n$$\n由中国剩余定理，$x$在模$n$意义下有唯一解，又1满足上述同余方程组，因此$x\\equiv 1\\ \\textrm{mod}\\ n$\n回到本引理的证明，则有$y_{1}\\cdot y_{2}^{-1}\\equiv 1\\ \\textrm{mod}\\ n$，即$y_{1}\\equiv y_{2}\\ \\textrm{mod}\\ n$；\n综上，$\\varepsilon_{g}$是单射，也是双射。\n\n**解密的正确性**\n\n由引理1，存在$(a,b)\\in Z_{n}\\times Z_{n}^{\\ast}$使得$g=(1+n)^{a}\\cdot b^{n}\\ \\textrm{mod}\\ n^{2}$，则：\n\n$g^{\\lambda}\\equiv (1+n)^{a\\cdot\\lambda}\\cdot b^{n\\cdot\\lambda}\\equiv (1+n)^{a\\cdot\\lambda}\\equiv 1+na\\lambda\\ \\textrm{mod}\\ n^{2}$\n\n同理，$c^{\\lambda}\\equiv (g^{m}\\cdot r^{n})^{\\lambda}\\equiv [(1+n)^{a}\\cdot b^{n}]^{m\\lambda}\\cdot r^{n\\lambda}\\equiv (1+n)^{a\\cdot m\\lambda}\\cdot b^{n\\cdot m\\lambda}\\cdot r^{n\\lambda}\\equiv (1+n)^{a\\cdot m\\lambda}\\equiv 1+mna\\lambda\\ \\textrm{mod}\\ n^{2}$\n\n因此，$L(c^{\\lambda})\\cdot [L(g^{\\lambda})]^{-1}\\equiv ma\\lambda\\cdot (a\\lambda)^{-1}\\equiv m\\ \\textrm{mod}\\ n$。","tags":["密码学知识","Paillier"],"categories":["crypto"]},{"title":"使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)","url":"/config/personal-blog.html","content":"**前言** 系统环境为Ubuntu18.04\n\n## 准备工作\n\n### 安装nodejs\n\n从[node官网](https://nodejs.org/en/download/)下载二进制包(最后下载低一点的版本，这样之后配置主题时成功率更高)并命名为nodejs，再进行如下操作：\n```Bash\n$ sudo mv nodejs /opt/\n$ sudo cp /opt/nodejs/bin/node /usr/local/bin/ && chmod +x /usr/local/bin/node\n```\n在/opt/nodejs/bin目录下还有npm、npx两个sh脚本，试过符号链接到/usr/local/bin/目录下但是运行不了，那就只能在运行它们时使用绝对路径精确指定了:(，将npm换淘宝源以便更快下载：\n```Bash\n$ /opt/nodejs/bin/npm config set registry https://registry.npm.taobao.org\n```\n\n### 安装hexo\n使用npm安装hexo：\n```Bash\n# 这种下载方式不会出错，遇到错误的都懂\n$ sudo /opt/nodejs/bin/npm install --unsafe-perm --verbose -g hexo\n```\n\n## 本地博客部署\n新建一个文件夹用来存放博客数据：\n```Bash\n$ mkdir hexo\n```\n在新建的博客文件夹hexo的父目录初始化hexo：\n```Bash\n$ hexo init hexo\n```\n输出警告“Failed to install dependencies”，继续执行下面命令即可；\n```Bash\n$ cd hexo\n$ /opt/nodejs/bin/npm install\n```\n使用hexo编译静态页面：\n```Bash\n$ hexo generate\n$ hexo server\n```\n然后在浏览器中进入`http://localhost:4000`，就可以看到编译好的静态页面。\n\n## 本地配置博客\n\n下载一个自己觉得好看的主题，比如jsimple；\n```Bash\n$ git clone https://github.com/tangkunyin/hexo-theme-jsimple themes/jsimple\n```\n然后将hexo/_config.yml文件中的`theme: landscape`更改为`theme: jsimple`\n手动安装主题所需依赖`hexo-generator-search`：\n```Bash\n/opt/nodejs/bin/npm install hexo-generator-search --save\n```\n还没到打开网页的时候，还要进行一些文件的配置：\n* scaffolds/post.md，用如下内容替换：\n```Bash\ntitle: {{ title }}\ndate: {{ date }}\nauthor: 托码思\navatar: /images/avatar.png\nauthorLink: https://www.tangkunyin.com\nauthorAbout: https://about.tangkunyin.com\nauthorDesc: 一个写代码的「伪文人」\ncategory:\ntags:\ncomments: true\n```\n**注**author、authorLink、authorAbout、authorDesc可以换成自己想写的内容，avatar的/images/favicon.png可以换成自己想换的图片；\n\n* scaffolds/page.md，用如下内容替换：\n```Bash\ntitle: {{ title }}\nauthor: 托码思\navatar: /images/avatar.png\nauthorLink: https://www.tangkunyin.com\nauthorAbout: https://about.tangkunyin.com\nauthorDesc: 一个写代码的「伪文人」\nlayout: {{ title }}\n```\n\n* _config.yml对应内容(原来有的如果不一样改成与下面一样，没有的添加进去)配置得与如下内容一样：\n```Bash\n# 语言配置\nlanguage:\n    - zh-cn\n\n# URL （注意 permalink 格式。其中timestamp是改了源码加上的，具体参见patch目录文件）\nurl: https://shuoit.net\nroot: /\npermalink: :category/:entitle-:timestamp.html\npermalink_defaults:\n  lang: en\n\n# 搜索配置\nsearch:\n  path: search.json\n  field: all\n  content: true\n  \n# 分类和标签别名\ndefault_category: 技术\ncategory_map:\n   技术: tech\n   人文: humanity\ntag_map:\n  hexo: hexo\n  生活: life\n\n# 便于动态配置导航，最新版把左导航写成配置方式了。注意uri前边的\"-\"，这里是object类型，内层包了数组\nleftPagesMenu:\n- uri: pageName    // 这个是创建layout为page类型的页面名称，简而言之，就是独立页面名称\n  title: navName\t  // 故名意思，导航名称，这在大屏幕时体现\n  faName: fa-wifi  // FontAwesome样式名称，最新主题使用了4.7.0，请参考http://fontawesome.io/icons/\n```\n**注** 其中主题配置文件里的menu项需要和category_map键值对一致。二者顺序可以不同，但是主题中的顺序决定网站导航栏菜单的顺序。\n\n然后重新编译静态页面(由于本文接下来会多次进行下述操作，因此提到\"重新编译静态页面\"就是进行下面操作)：\n```Bash\n$ hexo clean && hexo generate\n$ hexo server\n```\n然后在浏览器进入`http://localhost:4000`，可以看到主题已经应用；在终端按Crtl-C退出继续配置；\n\n## 完善页面\n\n### tag|category\n当我们打开这些页面时都显示`Cannot GET /categories/XXX`，因为这些页面还没创建！因此需要创建这些页面：\n```Bash\n# 经过测试，page category及其子页面可以不用生成，如果一个分类下存在文章，那么该分类页面可以正常显示，否则会出现GET: categorise/XXX错误\n$ hexo new page categories\n$ hexo new page tech -p categories/tech\n$ hexo new page humanity -p category/humanity\n#下面这些页面一定要生成\n$ hexo new page tags\n$ hexo new page help\n$ hexo new page about\n$ hexo new page links\n```\n\n重新编辑静态页面，标签(tag)、分类(category)已经没有问题了！\n\n### 数学公式\n\n卸载原Markdown渲染器，安装`hexo-renderer-kramed --save`这款Markdown渲染器：\n```Bash\n$ /opt/nodejs/bin/npm uninstall hexo-renderer-marked --save\n$ /opt/nodejs/bin/npm install hexo-renderer-kramed --save\n```\n安装了新的Markdown渲染器并没有完全解决公式渲染的问题！接下来修改node_modules/kramed/lib/rules/inline.js的内容—第11行与第20行，分别改为：\n```Bash\n# 第11行，原为escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,改为如下：\nescape: /^\\\\([`*\\[\\]()#$+\\-.!_>])/,\n# 第20行，原为em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,改为如下：\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n将主题配置文件_config.yml中的mathjax的enable设置为true，对于需要公式渲染的博客，在开头添加`mathjax: true`，重新编辑静态页面，可以看到该博客内的公式可以被无误渲染！\n\n### 小插曲\n\n正当我兴致冲冲重新编辑静态页面，去看看配置好的另一篇带有数学公式的博客时，神奇的事情发生了，博客页面出现的竟然是hello world！！！整个人发出无数wc，平静下来后在这篇博客的地址栏发现了端倪，地址是这样的：\n```Bash\nhttp://localhost:4000/tech/undefined-undefined.html\n```\n刚看到这个我也不明白是哪里出了问题，不断的研读两篇配置文件，终于找到了一点突破，我们还记得在前面，根据主题作者修改配置文件时有一个`permalink: :category/:entitle-:timestamp.html`，首先是我感觉这有点像地址的构造方式(原谅我还没学过前端，一点小聪明还望大佬勿喷)，category我知道是什么，它就在文章开头设置的，那么基本上就清楚了，地址是根据category、entitle与timestamp三者组合而成的，而我在博客开头压根没有设置什么timestamp，所以地址生成失败，统一生成了undefined-undefined，其实地址这么复杂我也用不到，就自己改成如下：\n```Bash\npermalink: :category/:title.html\npermalink_defaults:\n```\n重新编辑静态页面，终于没问题了！\n\n### 地图(sitemap)\n\n为保证博客可被baidu、Google检索，需安装`hexo-generator-sitemap`插件：\n```Bash\n$ /opt/nodejs/bin/npm install hexo-generator-sitemap --save\n```\n\n### 嵌入图片\n\npost_asset_folder设置为true，对于需要引用图片的博客，首先在与博客的同目录下新建一个与博客名相同的文件夹，想要引用的图片放入该文件夹中，以`{% asset_img 1.png pic1 %}`命令就可以嵌入图片！虽然在Typora中不能显示，但是编辑到博客中可以正常显示。\n\n### 其他\n\n还有一些site_name，头像，cover_title，cover_description等等自己改一下就行了。\n\n## 部署到Gitee\n\n在本地将博客配置得足够满意之后，还要将博客部署到Gitee上面，这样其他人也可以在互联网访问；\n\n### 申请Gitee pages\n\n这个主题必须要求博客是`根目录部署`，就是创建的项目名称与个人空间地址一致，重要的事情说三遍！！！网上大部分教程说的项目名称与用户名一致是因为他们申请Gitee账号后没有更改用户名，从而个人空间地址与用户名一致，因此他们的做法可以正确部署到根目录，但是如果你更改过用户名导致个人空间地址与用户名一致的话，那么这时你创建的项目名称应该与个人空间地址一致，否则就是错误的`根目录部署`！\n\n个人空间地址在：设置-->个人资料-->个人空间地址进行查看。\n\n项目创建好之后，新建一个blog分支；然后开启Gitee Page服务，服务部署到blog分支上，勾选强制使用HTTPS；然后就可以生成Page了，这时我们可以看到什么叫根目录部署了，以我的Gitee Pages服务的地址为例：`https://chu-kangming.gitee.io`；\n\n### 部署到Gitee Pages\n\n安装hexo-deployer-git组件：\n\n```Bash\n/opt/nodejs/bin/npm install hexo-deployer-git --save\n```\n\n我这里假定你电脑上面已经安装git，并且公钥已经添加到了Gitee；修改站点配置文件_config.yml的deploy：\n```Bash\ndeploy:\n  type: git\n  repo: ssh地址\n  branch: blog\n```\n\n使用命令`hexo d`就可以将本地的博客数据部署到Gitee上面，可以看到blog分支下已经有了博客数据，但是，但是你如果这个时候打开Gitee Pages服务的地址它还是404，或者和你本地的博客显示不一致，这时因为Gitee Pages还没有更新(Gitee Pages Pro可以自动更新，但是需要氪金)，你只能手动更新：\n\n{% asset_img 1.png pic1 %}\n\n点击上图的更新，等重新部署完成，再次打开Gitee Pages服务地址，可以看到博客的效果终于和本地的博客效果一致了！\n\n注意：\n* 比如我的search功能好像还有些问题，可以再`hexo d`一次然后再更新一次Gitee Pages，如果还不行可以稍等一会儿再看，毕竟没有氪金，更新起来不会很快，我等第二天早上再去博客时search功能就正常了；\n\n* 每次刷新浏览器时不要用Ctrl-R，一定要用Shift-F5强制刷新；\n\n**参考链接**\n\n[使用Gitee+Hexo搭建个人博客](https://xiuxiuing.gitee.io/blog/2018/08/08/giteepage/)\n\n[jsimple主题](https://github.com/tangkunyin/hexo-theme-jsimple)\n\n[hexo本地与部署不一致](https://blog.csdn.net/GAI159/article/details/105128186)\n\n[Hexo + Gitee采坑指北](https://www.luogu.com.cn/blog/jelly123/hexo-gitee-cai-keng-zhi-bei)\n\n[渲染公式](https://www.jianshu.com/p/7ab21c7f0674)\n\n[引用图片](https://segmentfault.com/q/1010000019625231)\n\n[sitemap](https://blog.csdn.net/formemorywithyou/article/details/96478453)\n\n","tags":["hexo","gitee","jsimple"],"categories":["config"]},{"title":"Ubuntu18.04安装ntl库","url":"/config/Ubuntu1804-installs-the-NTL-library.html","content":"## 安装\n\n首先去[官网](https://www.shoup.net/ntl)下载安装包，下列shell脚本与安装包放到同一目录，赋予此脚本执行权限。另外，我这里默认你的电脑上面已经安装gcc，g++，make。\n\n```Bash\n#apt install -y gcc\n#apt install -y g++\n#apt install -y make\napt install -y autoconf\n\napt install -y m4\napt install -y libgmp-dev\napt install -y libgf2x-dev\n\ntar zxvf ntl-11.4.3.tar.gz\n\nmv ntl-11.4.3 ntl\n \necho -e \"\\033[31m start install ntl \\033[0m\"\ncd ntl/src\n./configure NTL_GF2X_LIB=on\nmake && make check && make install\ncd - >> /dev/null\n \nrm -r ntl\n```\n## 测试\n\n新建一个rand.cpp（顾名思义，是输出随机数）\n\n```C++\n#include <NTL/ZZ.h>\n#include <time.h>\nNTL_CLIENT\nint main()\n{\n\tZZ a,b,c;\n\tSetSeed(to_ZZ(time(NULL)));\n\tRandomLen(a, 32);\n\tRandomLen(b, 32);\n\tc = a + b;\n\tcout << \"a=\" << a << \", b=\" << b << \", c=\" << c << \"\\n\";\n\treturn 0;\n}\n```\n按照官网的介绍，使用如下命令编译：\n```Bash\ng++ -g -O2 -std=c++11 -pthread -march=native rand.cpp -o rand -lntl -lgmp -lm\n```\n其中rand.cpp是c++文件，rand是编译后的可执行文件。程序运行效果如下：\n```Bash\n$ ./rand\na=2298665095, b=3622090486, c=5920755581\n```\n\n**参考链接**：\n[NTL库快速上手中文指南](https://blog.csdn.net/tzwh_86/article/details/9372411#commentBox)\n[A Tour of NTL](https://libntl.org/doc/tour.html)","tags":["Ubuntu","ntl"],"categories":["config"]},{"title":"git基础使用&gitee","url":"/program/The-basic-Git-use-with-Gitee.html","content":"## 在网站上初始化\n\n在[码云](https://gitee.com/)上创建项目基本是傻瓜式操作。创建一个名为git-test的私有项目以备后续使用。\n\n本文介绍在本地创建仓库、将仓库上传至服务器以及本地与服务器的交互。\n\n## 在本地创建仓库及相关操作\n\n```Bash\n# 初始化一个Git仓库，则执行命令的目录会作为一个仓库\nmkdir /home/gitee/git-test && cd /home/gitee/git-test\ngit init\n# 那么git-test文件夹将会作为一个仓库\n# 新建一个文件然后将文件添加到Git的暂存区\necho 'Life is beautiful' > README.md && git add \"README.md\"\n# 查看仓库当前文件提交状态(A：提交成功；AM：文件在添加到缓存之后又有改动)\ngit status -s\n# 从Git的暂存区提交版本到仓库，参数-m后为当次提交的备注信息\ngit commit -m \"1.0.0\"\n```\n\n## 本地与服务器的交互\n\n在本地与服务器交互之前，先配置ssh公钥；保证已经安装了ssh(apt install -y ssh)，使用ssh-keygen生成ssh公钥：\n```Bash\ngit config --global user.email 'gitee注册邮箱'\ngit config --global user.name 'gitee用户名'\nssh-keygen -t rsa\n```\n在~/.ssh目录下有一个id_rsa.pub文件，里面的文本以ssh-rsa开头，将这些文本全部复制，转到设置->安全设置->ssh公钥，随便写个标题，将id_rsa.pub中的文本全部复制到公钥下面的框内。\n\n关于项目的ssh地址如何获得，见下图：\n\n{% asset_img 1.png pic1 %}\n\n下面介绍一些本地与服务器的常用交互\n```Bash\n# 在不执行克隆操作时将一个远程仓库添加到本地的仓库\ngit remote add origin ssh地址\n# 如果不需要远程的更新，比如此时远程只是一般性的初始化内容，可使用-f选项进行强制推送(远程仓库默认名为origin)\ngit push origin master -f\n# 克隆服务器中的项目(即在1中新建的名为git-test的项目)到本地\ngit clone ssh地址\n## 文件修改(本地)\n# 修改文件README.md，在文件后面追加一行'local change'\n# 此时查看状态\ngit status -s\n#先将文件添加到Git的暂存区，然后提交\ngit add 'README.md' && git commit -m '1.0.1'\n# 用本地仓库内容更新远程仓库内容\ngit push ssh地址\n# 刷新网站，可以看到服务器上面的内容已经与本地一致\n\n## 文件添加(本地)\n# 创建一个输出hello,world的C文件并将其编译\necho -e '#include <stdio.h>\\n\\nint main()\\n{\\n\\tprintf(\"hello,world\\\\n\");\\n\\treturn 0;\\n}' > hello.c && gcc hello.c -o hello -g\n# 先将新增的文件添加到Git的暂存区\ngit add he*\n# 这里可以查看一下状态\ngit status -s\n# 从Git的暂存区提交版本到仓库\ngit commit -m '1.0.2'\n# 将更改同步到远程服务器\ngit push ssh地址\n# 可以看到网站上已经有新增的文件\n\n## 文件移动(本地)\n# 为增强项目文件的组织性，我将上述的两个新增文件移到一个文件夹中\nmkdir Hello && git mv he* Hello\n# 这里可以查看一下状态\ngit status -s\n# 将更改提交版本到仓库\ngit commit -m '1.0.3'\n# 将更改同步到远程服务器\ngit push ssh地址\n# 可以看到网站上原来新增的两个文件已经在新建的文件夹下\n\n## 文件删除(本地)\n# 如我要将hello这个可执行文件删除\ngit rm Hello/hello\n# 这里可以查看一下状态\ngit status -s\n# 将更改提交版本到仓库\ngit commit -m '1.0.4'\n# 将更改同步到远程服务器\ngit push ssh地址\n\n# 如果是在网站上对项目做出更改(文件修改、添加、移动与删除)，要将更改同步回本地(即拉取)，使用pull命令\ngit pull origin master\n```\n以上基本上包含了使用git常见问题的解决方案。","tags":["Git"],"categories":["program"]},{"title":"鲲鹏计算专场密码学部分详解","url":"/crypto/HUAWEICTF2021.html","content":"## 平平无奇的RSA\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/HUAWEI/task_task_gHXvFLV)\n\n### 分析\n\n题目由三个小问题组合而成，下面分别对他们进行分析。\n\n**Level 3**\n\n从脚本可得的信息如下：\n\n$N_{3}=p\\cdot q$，$\\phi$是$N_{3}$的欧拉函数；\n\n$s\\cdot sinv\\equiv 1\\ \\textrm{mod}\\ q$，再令$e=4s\\cdot sinv+3$(且要保证$(e,\\phi)=1$)；\n\n给你一组已知明-密文$km,kc$，即$kc\\equiv km^{e}\\ \\textrm{mod}\\ N_{3}$；\n\n那么分解$N_{3}$的步骤如下：\n\n$kc\\equiv km^{e}\\ \\textrm{mod}\\ N_{3}\\Rightarrow kc\\equiv km^{e}\\ \\textrm{mod}\\ p\\Rightarrow kc\\equiv km^{4s\\cdot sinv+3}\\ \\textrm{mod}\\ p$\n\n由欧拉定理可得：$km^{s\\cdot sinv}\\equiv km\\ \\textrm{mod}\\ p$，从而$kc\\equiv km^{4+3}\\ \\textrm{mod}\\ p$，即$kc\\equiv km^{7}\\ \\textrm{mod}\\ p$\n\n则$p|(km^{7}-kc)\\Rightarrow p=(km^{7}-kc,N_{3})$，因此$N_{3}$的一个因子是其与$km^{7}-kc$的公约数，进而分解出$N_{3}$；\n\n分解出$N_{3}$后，解密$c_{3}$得到Level 2的密文，下面分析Level 2。\n\n**Level 2**\n\n从脚本可得的信息如下：\n\n$o,s$是两个随机生成的素数，$t$是$o$的下一个素数，$u$是$s$的下一个素数；\n\n已知$os=o\\cdot s,tu=t\\cdot u$，$N_{2}=o\\cdot s\\cdot t\\cdot u\\Rightarrow tu=N_{2}//os$，这道题在18年强网杯的nextrsa的第四关考察过，[此处](https://www.cnblogs.com/WangAoBo/p/8654120.html)是对其的writeup\n\n**Level 1**\n\n这一层很简单，从$(N_{1}//1323)^{1/4}$往下开始试除即可(第一次写的时候疏忽了，往上试除，程序跑了几分钟都没解出来)。\n\n### 解题\n\n上述链接中的solve.py为解题脚本，程序运行结果如下：\n\n```Bash\n$ python3 solve.py\nflag{4c2fd4e6-44de-445f-8c34-1235464de2de}\n```","tags":["CTF比赛","RSA"],"categories":["crypto"]},{"title":"drangon2020密码学部分详解","url":"/crypto/Drangon-2020-Cryptography-Section.html","content":"## Bit_Flip1\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/Drangon/bit_flip_1)\n\n### 分析\n\n**1.过一遍程序**\n\n* 生成16个随机的字节作为alice_seed，与接收到的flip_str异或取后32个字节(不够在前面加\\x00)即为seed；\n\n* 由于alice = DiffieHellman(flip_str(alice_seed))没有设置prime，因此alice初始化时会调用get_prime()来生成素数；\n\n* 重点来看get_prime()这个函数；它不停的调用getbits(512)直到生成的数是一个素数；\n\n* 来看getbits()的原理：先调用more_bytes()积累足够的“随机”字节，每次调用more_bytes()都会在generated后面加上seed的sha256哈希值(长256比特)；\n\n* seed的更新方式为seed=long_to_bytes(bytes_to_long(seed)+1,32)，在这里简单看作seed的值增1即可；\n\n* generated收集到足够的字节之后，取后num比特作为生成的随机数，未用到的“随机”字节仍然保存在generated中；\n\n* 判断getbits(512)生成的是否为素数，若不是继续调用getbits(512)；\n\n* 得到素数之后，会告知你iter——相对于一次生成就能得到素数，对getbits(512)增加的调用次数(易知每调用一次getbits(512)，seed自增2)；\n\n* 返回prime后；调用getbits()生成64位的mysecret(DH算法的私钥)，然后计算$mynumber\\equiv 5^{mysecret}\\ \\textrm{mod}\\ prime$(DH算法的公钥)，设置shared为1337后，alice的初始化工作完成。\n\nbob=DiffieHellman(urandom(16), alice.prime)按照同样的方式完成初始化工作，只不过此时bob的prime直接使用alice的prime；\n\nalice与bob经密钥协商得到双方都知道的协商密钥(与DH算法略有不同，多了一个与1337的异或操作)，该密钥作为AES的加密密钥对FLAG进行加密。\n\n**2.寻找突破**\n\n我相信程序输出的数据都是有它的作用的，print(\"bob number\", bob.my_number)给出bob的公钥是为了让我们得到prime与secret之后可以同样计算出协商密钥；输出iv与enc_flag作用也很明显；那么程序输出iter就值得注意了，一定是对我们解题有用！\n\n**3.利用iter**\n\n那么我们如何借助iter来获取足够多的信息以致于解出FLAG；iter间接体现了get_prime()调用getbits()的次数！\n\n由于程序会接收我发送的flip_str，因此我们可以改变seed的值，即使我们不知道seed的值，但是这仍然有用！\n\n既然我们不知道seed的值(是因为我们不知道alice_seed的值)，那我们记alice_seed的值为$s_{127}\\cdots s_{1}s_{0}$，我们的考虑这样的情况：\n\n我发送如下两个flip_str：\n\nflip_str_1：空字节\n\nflip_str_2：|$1$|$0$|\n\n那么经bit_flip()就能生成如下2种seed：\n\nseed_1：|$s_{127}$|$\\cdots$|$s_{1}$|$s_{0}$|\n\nseed_2：|$s_{127}$|$\\cdots$|$1\\oplus s_{1}$|$s_{0}$|\n\n由这2个seed生成素数的iter分别记为iter_1与iter_2；\n\n分类讨论：\n\n* $s_{1}=0$，seed_1+2=seed_2，如果iter_1非0，必有iter_1-iter_2=1；\n\n* $s_{1}=1$，seed_2+2=seed_1，如果iter_2非0，必有iter_2-iter_1=1；\n\n那么当$iter\\_1\\cdot iter\\_2\\neq 0$时，由于$s_{j}$非0即1，因此此时iter_1-iter_2=1与iter_2-iter_1=1至少(没写错，确实是至少)有一个成立！此时$s_{j}=0\\Rightarrow$iter_1-iter_2=1，因此(原命题的真假性与逆否命题的真假性一致)$iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$，即iter_1-iter_2=-1$\\Rightarrow s_{j}=1$。\n\n那如果$iter\\_1\\cdot iter\\_2=0$怎么办？这时根据iter_1-iter_2的值是无法判断$s_{1}$的值的！由于我们只需要保持|seed_1-seed_2|=2即可，因此我们可以改变flip_str前面的字节，这样得到的seed_x(x=1,2)的哈希值与原来显著不同，从而$iter\\_1\\cdot iter\\_2$的值有可能发生改变，不停的改变flip_str前面的字节直到$iter\\_1\\cdot iter\\_2\\neq 0$，就可以由上述分析过程解出$s_{1}$！\n\n一般地，类似于数学归纳法；假设我已经分析出$s_{j-1}\\cdots s_{1}$(这里没写错，$s_{0}$我是没有分析出来的)，借助已经得到的信息分析出$s_{j}$，思路如下：\n\n* 发送如下4种flip_str：\n\nflip_str_1：| $0$  | $1\\oplus s_{j-1}$ | $\\cdots$ | $1\\oplus s_{1}$ | $0$  |\n\nflip_str_2：| $1$  | $s_{j-1}$ | $\\cdots$ | $s_{1}$ | $0$  |\n\nflip_str_3：| $1$  | $1\\oplus s_{j-1}$ | $\\cdots$ | $1\\oplus s_{1}$ | $0$  |\n\nflip_str_4：| $0$  | $s_{j-1}$ | $\\cdots$ | $s_{1}$ | $0$  |\n\n那么经bit_flip()就能生成如下4种seed：\n\nseed_1：| $s_{127}$ | $\\cdots$ | $s_{j}$ | $1$  | $\\cdots$ | $1$  | $s_{0}$ |\n\nseed_2：| $s_{127}$ | $\\cdots$ | $1\\oplus s_{j}$ | $0$  | $\\cdots$ | $0$  | $s_{0}$ |\n\nseed_3：| $s_{127}$ | $\\cdots$ | $1\\oplus s_{j}$ | $1$  | $\\cdots$ | $1$  | $s_{0}$ |\n\nseed_4：| $s_{127}$ | $\\cdots$ | $s_{j}$ | $0$  | $\\cdots$ | $0$  | $s_{0}$ |\n\n由这4个seed生成素数的iter分别记为iter_1、iter_2、iter_3与iter_4；\n\n分类讨论：\n\n* $s_{j}=0$，seed_1+2=seed_2，如果iter_1非0，必有iter_1-iter_2=1；\n\n* $s_{j}=1$，seed_3+2=seed_4，如果iter_3非0，必有iter_3-iter_4=1；\n\n那么当$iter\\_1\\cdot iter\\_3\\neq 0$，由于此时$s_{j}$非0即1，因此iter_1-iter_2=1与iter_3-iter_4=1必有一个成立！同样地，$iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$；因此，当$iter\\_1\\cdot iter\\_3\\cdot ((iter\\_1-iter\\_2)\\cdot (iter\\_3-iter\\_4)-1)\\neq 0$时，$iter\\_3-iter\\_4=1\\Rightarrow iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$。\n\n如果$iter\\_1\\cdot iter\\_3\\cdot ((iter\\_1-iter\\_2)\\cdot (iter\\_3-iter\\_4)-1)=0$，同样地，改变flip_str前面的字节直到进入上述情形!\n\n综上，我给出了对$s_{1}$的分析思路，也给出了由$s_{j-1}\\cdots s_{1}$推出$s_{j}$的分析思路；最终我可以还原出alice_seed除$s_{0}$之外的所有比特位，而$s_{0}$非0即1，因此最后解出的结果与alice_seed的值相差不超过1！\n\n接下来按照同样的方式生成AES密钥，对密文进行解密即可！\n\n### 解题\n\n这道题我并没有在比赛的时候做出来，因此我对task.py的交互方式作了一些改变；flag是自己设置的；上述链接中的solve.py为解题脚本，程序运行结果如下：\n\n```Bash\nλ python3 solve.py\nb'1\\xbc\\xfa\\x1b+5\\xed1\\x99\\xf7\\xa0\\x07\\x8e\\tQ\\xee'\nDrangon{just_for_test_flag}\n```\n\n## Bit_Flip2\n\n### 题目信息\n\n附件仍然是一个Python脚本，相对于Bit_Flip1只有1行代码不同，它将print(\"bob number\", bob.my_number)这一行注释起来；[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/Drangon/bit_flip_2)\n\n### 分析\n\n同Bit_Flip1的方法可解出alice_seed，可此时我并不知道bob.my_number；虽然当时想过控制alice.my_secret为0，但是觉得太不切实际，而事实上writeup就是这么做的！这需要你对比特币有一定的了解，知道使用块散列算法(可[参见此处](https://chu-kangming.gitee.io/crypto/Bitcoin-Block-hashing-algorithm.html))可以生成以一定长度的0字节结尾的哈希值。按同样的方法推测出alice_seed后发送特定的flip_str使得alice以特定的seed初始化，使得alice.my_secret为0，那么bob.my_number就对我们解密出flag无关紧要了。\n\n### 解题\n\n上述链接中的solve.py为解题脚本，同样因为题目没有在比赛的时候做出了，flag是我自己设置的；程序运行结果如下：\n\n```Bash\n$ python solve.py\nb'Drangon{just_for_test_flag}\\x00\\x00\\x00\\x00\\x00'\n```","tags":["bitcoin","CTF比赛"],"categories":["crypto"]},{"title":"Bitcoin—块散列算法","url":"/crypto/Bitcoin-Block-hashing-algorithm.html","content":"## BTC Block\n\n[BTC Block](https://live.blockcypher.com/btc/)\n\n{% asset_img 1.png pic1 %}\n\n点击进入Height为658423的哈希值(000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c)\n\n{% asset_img 2.png pic2 %}\n\n## Block hash算法\n\n[Block hash算法](https://en.bitcoin.it/wiki/Block_hashing_algorithm)\n\n它有多强大呢？举个例子：\n\n```Python\n>>> from hashlib import sha256\n>>> d=bytes.fromhex('01000000'+'81cd02ab7e569e8bcd9317e2fe99f2de44d49ab2b8851ba4a308000000000000'+'e320b6c2fffc8d750423db8b1eb942ae710e951ed797f7affc8892b0f1fc122b'+'c7f5d74d'+'f2b9441a'+'42a14695')\n>>> h=sha256(d).digest()\n>>> sha256(h).hexdigest()\n'1dbd981fe6985776b644b173a4d0385ddc1aa2a829688d1e0000000000000000'\n```\n\n通过它构造的消息，其哈希值后面有很长的一段0！想知道上面的消息怎么构造，请往下看：\n\n### 准备工作\n\n* 安装pyCryptodome库\n\n```Bash\npip3 install pyCryptodome -i https://pypi.douban.com/simple\n```\n\n* 安装curl工具\n\n如果你用的Linux系统，curl工具可通过命令行安装；\n\n对于我使用的Windows系统，去[官网](https://curl.se/windows/)下载工具包，解压到C:\\Windows\\System32目录下或者将bin目录下的curl.exe的路径加入环境变量；\n\n### 获取构造特定哈希值的信息\n\n对我们想要的哈希值000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c，在命令行运行：\n```Bash\n# curl https://blockchain.info/rawblock/000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c > data\n```\n因为返回的消息太多了，因此输出重定向到文件中存下来；我们主要关注的有：ver、prev_block、mrkl_root、time、bits与nonce；这些值提取出来如下：\n```Python\ndata={'ver':541065216,\n'prev_block':'00000000000000000009f1410ac69d92199991a699b268d56d99daf6067c8711',\n'mrkl_root':'9ad7e80cf4a94f57c36876ab999f3cf23de188d482b8a3af8fb5e08ec1e18a6e',\n'time':1606199690,\n'bits':386924253,\n'nonce':232397866}\n```\n注意：ver、time、bits与nonce找最前面的，prev_block与mrkl_root找最后面的，不然算出来的哈希值会不是我们想要的。\n\n接下来，使用我写好的脚本如下，通过将这些信息组合起来就可以构造出消息，其哈希值就是000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c！\n\n```Python\nfrom hashlib import sha256\nfrom binascii import hexlify,unhexlify\nfrom Crypto.Util.number import long_to_bytes\n\n#curl https://blockchain.info/rawblock/000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c\ndata={'ver':541065216,\n'prev_block':'00000000000000000009f1410ac69d92199991a699b268d56d99daf6067c8711',\n'mrkl_root':'9ad7e80cf4a94f57c36876ab999f3cf23de188d482b8a3af8fb5e08ec1e18a6e',\n'time':1606199690,\n'bits':386924253,\n'nonce':232397866}\n\ndef num_to_Bytes(n):\n    byte_n=long_to_bytes(n,4)\n    return byte_n[::-1]\n\ndef hex_to_Bytes(h):\n    s=unhexlify(h)\n    return s[::-1]\n    \ndef Bitcoin_demo():\n    d=num_to_Bytes(data['ver'])+hex_to_Bytes(data['prev_block'])+hex_to_Bytes(data['mrkl_root'])+num_to_Bytes(data['time'])+num_to_Bytes(data['bits'])+num_to_Bytes(data['nonce']%pow(2,32))\n    h=sha256(d).digest()\n    return sha256(h).digest()\n\nif __name__=='__main__':\n    ret=Bitcoin_demo()\n    print(hexlify(ret[::-1]))\n```\n\n程序运行结果如下：\n\n```Bash\n# python3 Bitcoin.py\nb'000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c'\n```","tags":["密码学知识","bitcoin"],"categories":["crypto"]},{"title":"win10正版安装+配置记录","url":"/config/Win10-legal-installation-configuration-records.html","content":"## 前言\n\n自己以前作为一个电脑小白，重装系统时直接在百度上面搜索，搜到的全是各种下载站，从这些网站上面下载的系统其实已经改过了，安装完之后会给你预装很多软件，你又要花时间把他们删掉，可以说很不方便；去微软官网上面找，如果不知道怎么找，可能很不容易找到，于是写下这篇博客备忘，也方便他人。\n\n## 下载镜像并制作启动盘\n\n安装前，准备好8GB以上的U盘(必须真的是8G以上，U盘质量一定要过关；另外，U盘里面的数据要备份好，制作启动盘会让原来的数据不复存在)\n\n**1.**先去[微软官方镜像下载地址](https://www.microsoft.com/zh-cn/software-download/windows10/)，下载MediaCreationTool；\n\n**2.**以管理员方式，运行MediaCreationTool；首先给出声明与许可条款，选择接受；此时会给你两种操作，升级本机或者创建安装介质，我习惯创建安装介质；\n\n**3.**选择语言、体系结构与版本，直接默认就好；\n\n**4.**选择要使用的介质，我这里选择U盘；插上事先准备好的U盘，如下图点击下一步：\n\n**5.**等待工具下载win10\n\n**6.**创建安装介质\n\n创建完成后，点击完成，工具做一些清理工作就会退出。\n\n打开文件资源管理器，可以看到启动盘已经制作完毕：\n\n## 安装\n\n1.如果安装时鼠标用不了，可以使用tab键进行切换；\n\n2.安装过程中最好联网；\n\n3.删除不常用文件夹\ncmd-->regedit\n3D对象：HKEY_LOCAL_MACHINE->SOFTWARE->Microsoft->Windows->CurrentVersion->Explorer->MyComputer\n->NameSpace->{0DB7E03F-FC29-4DC6-9020-FF41B59E513A}\n音乐：{3dfdf296-dbec-4fb4-81d1-6a3438bcf4de}\n\n4.“开始”关掉设置、图片。\n\n\n## 安装常用软件\n\n[360zip国际版](https://www.360totalsecurity.com/zh-cn/360zip/)\n\n[百度网盘](http://pan.baidu.com/download)\n\n[Clover](http://en.ejie.me/)\n\n```Bash\n注：我们知道win10下面的文件资源管理器打开多个位置时是多个窗口，这个插件就可以以多标签页来管理，特别好用。\n但是你要忍受经常的广告的骚扰\n```\n\n[Chrome浏览器](https://www.google.cn/intl/zh-CN/chrome/)\n\n[TIM](https://office.qq.com/download.html)\n\n```Bash\n注：窗口设置和微信差不多，感觉比QQ好用。\n```\n\n[迅雷&迅雷影音](https://www.xunlei.com/)\n\n[腾讯会议](https://meeting.tencent.com/download-center.html?from=1001)\n\n[cmder](https://cmder.net/)\n\n```Bash\n控制台模拟器，让你有一种用上Linux终端的感觉。\n更改快捷键Ctrl-T(新建标签页)为Crtl-Shift-T，避免与ctags的快捷键冲突。\n```\n\n[WPS](https://pc.wps.cn/)\n\n```Bash\n记得在“我的电脑”隐藏网盘。\n```\n\n[Python3.6.4](https://www.python.org/downloads/windows/)\n\n```Bash\n注：安装的时候注意勾选添加到环境变量；将python改成python3以与python2程序区分；\nwin10菜单搜索[管理应用执行别名]，关闭下面两个按钮[应用安装程序])；\n安装ctf密码学常用python库。\n```\n\n[VirtualBox](https://www.virtualbox.org/wiki/Downloads)\n\n[Vim](https://github.com/vim/vim-win32-installer/releases)\n\n```Bash\n添加环境变量：右键此电脑->属性->高级系统设置->环境变量，选中Path，并点击编辑，新建->填写vim程序的路径，点击3个确定才算成功添加；\n在安装vim的文件夹下有一个_vimrc文件，备份好之后写上自己的配置)；\n安装ctags插件：http://ctags.sourceforge.net；像ctags58.zip这种名称是支持win10的，下载下来之后只需要将ctags.exe复制到vim的安装目录下即可！\n```\n\n[yafu](https://sourceforge.net/projects/yafu/files/)\n\n```Bash\n强大的因子分解工具。\n```\n\n[Sagemath](https://github.com/sagemath/sage-windows/releases)\n\n[Curl](https://curl.se/windows/)，利用URL规则在命令行下工作的文件传输工具。\n\n[Telegram](https://desktop.telegram.org/)\n\n另外在win10应用商店里有几个不错的应用：微信、网易云音乐，淘宝。\n\nIDA Pro、SSR就看自己了。\n\n注：安装IDA Pro之后会顺带安装python2.7，同样将其安装的路径加入环境变量。","tags":["windows"],"categories":["config"]},{"title":"ByteCTF2020密码学部分详解","url":"/crypto/BytectF2020-cryptography-section-details.html","content":"## noise\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/ByteCTF/noise)\n\n### 分析\n\n穷举通过proof_of_work之后，我们来看代码逻辑：\n\n*   secret=getrandbits(1024)，注意他自己实现的getrandbits(1024)实际上是生成长1017~1024位的随机数；\n*   对上述生成的secret，服务器最多只会与你交互64次；\n*   若op为'god'，服务器会返回num * getrandbits(992) % secret，这里num也由我指定；\n*   若op为'bless'，服务器会判断num与secret是否相等，若相等服务器返回FLAG。\n\n由于我至少要留一次交互机会发送我计算出的secret，因此我必须在63次交互内计算出secret！为下面叙述方便，声明如下记号：\n\n*   第 i 次发送的num记为$n_{i}$；\n*   第 i 次getrandbits(992)记为$g_{i}$；\n*   第 i 次接收的num * getrandbits(992) % secret记为$c_{i}$。\n\n记secret为$m$，则：\n\n$c_{i} \\equiv n_{i}\\cdot g_{i}\\ \\textrm{mod}\\ m,i=1,\\cdots ,63$\n\n即存在$k_{i}\\in Z$，$n_{i}\\cdot g_{i}=c_{i}+k_{i}\\cdot m$\n\n对等式两边模$n_{i}$则有：\n\n$c_{i}+k_{i}\\cdot m \\equiv 0\\ \\textrm{mod}\\ n_{i}$\n\n若我能够控制$k_{i}=1$，那么：\n\n$m \\equiv (n_{i}-c_{i})\\ \\textrm{mod}\\ n_{i}$\n\n同时得到多个如上形式的等式可考虑使用中国剩余定理解出$m$！\n\n### 利用$n_{i}$控制$k_{i}$\n\n$m$有$1/2$的概率长1024比特，$g_{i}$有$1/2$的概率长992比特；此时，要控制$k_{i}=1$，即：\n$$\n\\left\\{\n\\begin{aligned}\nn_{i}\\cdot g_{i} &>m \\\\\nn_{i}\\cdot g_{i} &<2m\n\\end{aligned}\n\\right.\n$$\n对上式两边取对数：\n$$\n\\left\\{\n\\begin{aligned}\nlog(n_{i})+log(g_{i}) &>log(m) \\\\\nlog(n_{i})+log(g_{i}) &<log(m)+1\n\\end{aligned}\n\\right.\n$$\n记$log(g_{i})=991+\\alpha,log(n_{i})=32+\\beta,log(m)=1023+\\gamma;\\alpha,\\beta,\\gamma \\in (0,1)$(其中$X=2^{\\alpha},Y=2^{\\gamma}$服从$[1,2]$上的均匀分布)。上式改写为：\n$$\n\\left\\{\n\\begin{aligned}\n\\alpha+\\beta &>\\gamma \\\\\n\\alpha+\\beta &<1+\\gamma\n\\end{aligned}\n\\right.\n$$\n综上，$P(k_{i}=1)=P(\\alpha+\\beta>\\gamma,\\alpha+\\beta<1+\\gamma)=P(2^{\\beta}\\cdot X>Y,2^{\\beta-1}\\cdot X<Y)$\n\n直观地看，$\\beta$越大越有利于约束条件$\\alpha+\\beta>\\gamma$而不利于约束条件$\\alpha+\\beta<1+\\gamma$，反之，$\\beta$越小越有利于约束条件$\\alpha+\\beta<1+\\gamma$而不利于约束条件$\\alpha+\\beta>\\gamma$。\n\n注意到我可以判断是否满足约束条件$\\alpha+\\beta>\\gamma$—若$n_{i}\\cdot g_{i}<m$则$c_{i}=n_{i}\\cdot g_{i}$从而$c_{i}\\equiv 0\\  \\textrm{mod}\\ n_{i}$。\n\n由此，我选择$n_{i}$时应该尽量满足约束条件$\\alpha+\\beta<1+\\gamma$，即$\\beta$应尽量小，为何不设置$\\beta$为0，理由如下：\n\n当$\\beta=0$时，$P(k_{i}=1)=P(\\alpha>\\gamma,\\alpha<1+\\gamma)=P(\\alpha>\\gamma)=1/2$；\n\n由上述：$n_{i}$长$33$比特，而$m$长$1024$比特；由中国剩余定理可知：我们需要32个如下形式的同余式才能解出$m$！\n\n$m \\equiv (n_{i}-c_{i})\\ \\textrm{mod}\\ n_{i}$\n\n要得到如上形式的同余式，即需要$k_{i}=1$，而$P(k_{i}=1)=1/2$，那么我得到$32$个如上形式的同余式“平均”需要$64$次交互，从而我没有发送secret的交互机会。\n\n综上，$\\beta$应在大于0的前提下尽量小！\n\n### 值得注意的地方\n\n通过2.1，我知道了$n_{i}$值多大时可以解出$m$，结合中国剩余定理，同余式的模数之间是互素的，即我选择的$n_{i}$需两两互素，因此$n_{i}$不是取确定的值而是在一定的取值范围内取素数！\n\n### 解题\n\n上述链接中的solve.py为解题的Python脚本，程序运行(成功时)结果如下：\n\n```bash\n$ python3 solve.py\n[+] Opening connection to 182.92.153.117 on port 30101: Done\n[+] MBruteforcing: Found key: \"l9a\"\nsuccess!\n95613903744255213782277288259288084531700829576284706991256294359734535087821985034716432798049279163174069238632678362676474782669781482301447573436852554131343117198284150657465643396718720128642929008328391123641254705186541184339088382138616985634723733544083949806487213357784626124965521562172300016682\nb'CONGRATULATIONS ByteCTF{Noise_i5_rea11y_ANN0YING}\\n'\n[*] Closed connection to 182.92.153.117 port 30101\n```\n\n注：此程序并非次次运行都能解出secret\n\n## threshold\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/ByteCTF/threshold)\n\n### 分析\n\n程序又臭又长，但其实考点特别简单，稍微使用一下欧拉定理即可！我来分析一下程序的逻辑：\n\n在类TSM2初始化时：\n\n$pks \\equiv [(sk+1)\\cdot sks]^{n-2}\\ \\textrm{mod}\\ n$\n\n接着在output_p1函数中：\n\n$s \\equiv (d_{1}\\cdot k_{1}\\cdot s_{2}+d_{1}\\cdot s_{3}-r)\\ \\textrm{mod}\\ n$\n\n其中$d_{1}=sks$，而$r,s_{2},s_{3}$均由我指定，那么我令$r=s_{2}=0,s_{3}=1$，则得到的$s$即为$d_{1}$在模$n$下的值，即：\n\n$s \\equiv sks\\ \\textrm{mod}\\ n$\n\n注意到$n$是素数，欧拉函数$\\phi(n)=n-1$，显然$(n-2,n-1)=1$，即存在$x\\in Z,x\\cdot (n-2)\\equiv 1\\ \\textrm{mod}\\ \\phi(n)$\n\n由欧拉定理：$pks^{x}\\equiv [(sk+1)\\cdot sks]^{(n-2)x}\\equiv (sk+1)\\cdot sks\\ \\textrm{mod}\\ n$\n\n因此$(sk+1)\\equiv pks^{x}\\cdot sks^{-1}\\equiv pks^{x}\\cdot s^{-1}\\ \\textrm{mod}\\ n$，而密钥$sk$是小于阶$n$的，因此解出密钥$sk$，有了密钥干什么不行呢，按照程序的要求，对消息b'Hello, Welcome to ByteCTF2020!'签名即可！\n\n### 解题\n\n略","tags":["CTF比赛","CRT","SM"],"categories":["crypto"]},{"title":"Ubuntu安装metasploit-framework(方便安全可秒全网现有各种方法)","url":"/config/Ubuntu-Installs-Metasploit-Framework-Easy-Secure-Instable.html","content":"## 前言\n\n做项目需要用到metasploit-framework这款强大的渗透工具，学长给的[GitHub链接](https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers)下载起来巨慢，重新在网上找方法：网上几乎都是添加Kali源来安装metasploit-framework，但是自己手残在apt update后加了一条apt upgrade -y，然后电脑开始下很多奇奇怪怪的东西直到电脑完全动不了，最后只能重装Ubuntu！所以总结一下网上在Ubuntu安装metasploit-framework的两种方法要么慢，要么危险。\n\n## deb包安装\n\n推荐一种安全又快捷的方法，使用deb包进行安装：[deb包链接在此](https://apt.metasploit.com/)；翻到最下面，可以看到有metasploit-framework的deb包\n\n\n\n选择最新版的下载下来，使用gdebi来安装deb包即可\n```Bash\nsudo gdebi metasploit-framework_6.0.13+20201023102229~1rapid7-1_amd64.deb\n```\n可以看看安装好的效果：\n\n\n## 后记\n\n我来说一下上面的deb包链接是怎么找到的；从上述的[GitHub链接](https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers)开始，下面的Installing\n\n\n点击the free installer,再到下面的Linux manual installation\n\n\nhttps://apt.metasploit.com 就是deb包的链接。","tags":["Ubuntu","metasploit"],"categories":["config"]},{"title":"return2libc实验","url":"/program/Return2libc-experiment.html","content":"**前言**\n[实验程序GitHub链接](https://github.com/coderall/return-to-libc-attack)\n注：实验环境为Ubuntu16.04的32位虚拟机(virtualbox)\n\n## 预备工作\n关闭地址随机化，否则攻击失败\n```Bash\nsudo sysctl -w kernel.randomize_va_space=0\n```\n<div style=\"width:80%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n## 任务1—查找libc函数的地址\n编译retlib.c，设置-fno-stack-protector关闭ubuntu上StackGuard保护机制，设置-z -execstack/noexecstack可打开或关闭可执行栈的机制，使用gdb来获取当前system()与exit()的地址\n```Bash\nsudo gcc retlib.c -fno-stack-protector -z noexecstack -o retlib -g\nsudo chmod 4755 retlib\ngdb -q retlib\n#进入gdb命令行\nb main\nr\np system\np exit\nq\n```\n<div style=\"width:90%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\n我们可以看到system()函数的地址是0xb7e43da0，exit()函数的地址是0xb7e379d0，使用上述得到的地址更改程序exploit.c：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\n改完之后：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n## 任务2—将shell字符串放入内存中\n创建环境变量MYSH来记录/bin/sh路径，编译getenv.c，运行getenv程序获取/bin/sh的地址\n```Bash\nexport MYSH=\"/bin/sh\"\ngcc getenv.c -z noexecstack -o getenv -g\n./getenv MYSH ./retlib\n```\n<div style=\"width:75%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n可以看到/bin/sh的地址为0xbffffe41，使用上述得到的地址更改程序exploit.c：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n&nbsp;\n\n改完之后：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n## 任务3—找出栈溢出地址相对buffer的偏移\n\n下面我们介绍  *(long *) &buf[24] = 0xb7e5f430 ;   //  system()  中的24是怎么得到的；\n首先你应该对return to libc的原理有一定了解(不了解先参见[此处](https://www.ibm.com/developerworks/cn/linux/1402_liumei_rilattack/index.html))(原理看完就可以回来了，实验部分这里讲得更清楚^_^)\n这里的24就是栈溢出地址相对buffer的偏移；一种有用的办法是这样做的：生成较长的由a-zA-Z组成的随机字符串(比如我生成长100的这样的字符串)，将它写入badfile文件，然后用gdb调试retlib程序；\nrand.py程序如下：\n\n```Python\nfrom string import ascii_letters as al\nfrom random import randint\n\nX=[randint(0,51) for _ in range(100)]\nprint ''.join([al[x] for x in X])\n```\n\n```Bash\npython rand.py >> badfile\ngdb -q retlib\n#进入gdb命令行\nr\n```\n\n<div style=\"width:75%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n&nbsp;\n\n不用设置断点，直接运行然后会发生栈溢出错误，并且告诉你栈溢出的地址，在我调试的过程中，栈溢出的地址为0x4a4c4e49，把这个地址转换为字符串并反转是INLJ(之所以要反转是因为地址的表示为大端表示)，INLJ在上述生成的随机字符串中的索引就是24，说明栈溢出地址相对buffer的偏移为24；\n\n## 任务4—利用缓冲区溢出漏洞\n编译exploit.c，攻击，进入/bin/sh程序\n```Bash\ngcc exploit.c -z noexecstack -o exploit\n./exploit\n./retlib\n```\n<div style=\"width:75%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n## 任务5—增加调用setuid进行提权\n首先按照同样的方式获取setuid()函数的地址，然后更改程序exploit.c；\n```Bash\ngdb -q retlib\n#进入gdb命令行\nb main\nr\np setuid\nq\n```\n<div style=\"width:75%;margin:auto\">{% asset_img 10.png pic10 %}</div>\n\n&nbsp;\n\n可以看到setuid()函数的地址为0xb7eba2e0，使用上述得到的地址更改程序exploit.c，改完之后：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\n重新编译exploit.c然后进行攻击(如果攻击失败，尝试：重启->关闭地址随机化->export MYSH=\"/bin/sh\"，然后重新执行下面三行命令)\n```Bash\ngcc exploit.c -z noexecstack -o exploit\n./exploit\n./retlib\n```\n攻击结果如下。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 12.png pic12 %}</div>","tags":["实验","ret2libc"],"categories":["program"]},{"title":"Makefile初探","url":"/program/The-Makefile-que.html","content":"## 背景\n\n如果做过工程，或者读过一些优秀的开源代码的话；了解.c文件需要分开写，每个.c文件实现特定的一小部分功能，另外还有一些.h文件，这种文件主要引用一些头文件，声明一些函数(虽然函数可以直接定义无需声明，但是先声明再定义是一个好习惯，另外一些虚函数是仅仅声明而不定义的)与宏；这些.c文件再被不同的目录组织；以上就是工程一般的框架，这些.c文件既可能依赖.h文件，也可能依赖其他.c文件，单单一行gcc的编译命令已经解决不了，这时需要Makefile来指导编译过程！\n\n## 语法规则\n\n目标文件：依赖文件\n|tab|编译规则\n\n注：|tab|代表一个tab键\n\n## Demo\n\n我的文件组织如下：\n```Bash\n.\n├── include\n│   └── head.h\n├── Makefile\n└── src\n    ├── add.c\n    ├── div.c\n    ├── master.c\n    ├── mul.c\n    └── sub.c\n```\n\nhead.h的代码如下：\n```C\n#include <stdio.h>\n\nint add(int a,int b);\n\nint sub(int a,int b);\n\nlong mul(long a,long b);\n\nfloat div(float a,float b);\n```\n\nadd.c的代码如下：\n```C\n#include \"head.h\"\n\nint add(int a,int b)\n{\n\treturn a+b;\n}\n```\n差不多这个意思，其他的代码就自己完善吧；\n\n最后master.c代码如下：\n```C\n#include \"head.h\"\n\nint main()\n{\n\tint a,b;\n\ta=12;\n\tb=3;\n\tprintf(\"%d add %d = %d\\n\",a,b,add(a,b));\n\tprintf(\"%d sub %d = %d\\n\",a,b,sub(a,b));\n\tlong ma,mb;\n\tma=12;\n\tmb=3;\n\tprintf(\"%ld mul %ld = %ld\\n\",ma,mb,mul(ma,mb));\n\tfloat fa,fb;\n\tfa=12;\n\tfb=3;\n\tprintf(\"%f div %f = %f\\n\",fa,fb,div(fa,fb));\n\treturn 0;\n}\n```\n\n下面是Makefile文件：\n```Makefile\nmaster:rely1.o rely2.o rely3.o rely4.o rely5.o\n\tgcc -o master src/add.o src/sub.o src/mul.o src/div.o src/master.o\nrely1.o: src/master.c include/head.h\n\tgcc -c -I include src/master.c -o src/master.o\nrely2.o: src/add.c include/head.h\n\tgcc -c -I include src/add.c -o src/add.o\nrely3.o: src/sub.c include/head.h\n\tgcc -c -I include src/sub.c -o src/sub.o\nrely4.o: src/mul.c include/head.h\n\tgcc -c -I include src/mul.c -o src/mul.o\nrely5.o: src/div.c include/head.h\n\tgcc -c -I include src/div.c -o src/div.o\n.PHONY:clean\nclean:\n\tfind . -name '*.o'  | xargs rm -f\n```\n\n下面make生成可执行文件：\n```Bash\n$ make && make clean\ngcc -c -I include src/master.c -o src/master.o\ngcc -c -I include src/add.c -o src/add.o\ngcc -c -I include src/sub.c -o src/sub.o\ngcc -c -I include src/mul.c -o src/mul.o\ngcc -c -I include src/div.c -o src/div.o\ngcc -o master src/add.o src/sub.o src/mul.o src/div.o src/master.o\nfind . -name '*.o'  | xargs rm -f\n```\n\nmake clean会执行Makefile文件中clean下的命令，它会清除所有的目标文件(.o文件)，因为已经不需要了！\n\n我们测试一下可执行文件是否正确执行：\n```Bash\n$ ./master\n12 add 3 = 15\n12 sub 3 = 9\n12 mul 3 = 36\n12.000000 div 3.000000 = 4.000000\n```\n\n注：可以看到Makefile中的rely1.o等等只是代号，真正目标文件的名称设定由编译规则指定。","tags":["C语言","makefile"],"categories":["program"]},{"title":"i春秋\"巅峰极客\"2020密码学部分详解","url":"/crypto/I-Spring-and-Autumn-Peak-Geek-2020-Cryptography-in-detail.html","content":"## tryecc\n\n### 题目信息\n\n附件是一个sage脚本与一个文本文件，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/iCHUNQIU/tryecc)在此\n\n### 分析\n\n$$\nE_{1}: y^{2}\\equiv x^{3}+ax+c\\ \\textrm{mod}\\ N\n$$\n\n$$\nE_{2}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ N\n$$\n\n我们总结一下已知量和未知量：\n\n| 已知            | 未知      |\n| :-: | :-: |\n| $N,C,P_{1},P_{2},P_{3},P_{4}$ | $A,B,m_{1},m_{2}$ |\n\n那么已知$P_{1}(x_{1},y_{1}),P_{2}(x_{2},y_{2})$就可以计算出$a,b$：\n$$\ny_{1}^{2}\\equiv x_{1}^{3}+a\\cdot x_{1}+c\\ \\textrm{mod}\\ N\n$$\n$$\ny_{2}^{2}\\equiv x_{2}^{3}+a\\cdot x_{2}+b\\ \\textrm{mod}\\ N\n$$\n\n$$\na=(y_{1}^{2}-x_{1}^{3}-c)\\cdot x_{1}^{-1}\\ \\textrm{mod}\\ N\n$$\n\n$$\nb=y_{2}^{2}-x_{2}^{3}-a\\cdot x_{2}\\ \\textrm{mod}\\ N\n$$\n\n\n\n好在$x_{1}$在模$N$下有逆，于是$a,b$就可以解出，到此得到了$E_{1},E_{2}$；\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ in\\ E_{2}\n$$\n$$\nP_{4}=m_{2}\\cdot P_{2}\\ in\\ E_{2}\n$$\n\n\n\n丢到sgaemath里面去解离散对数，结果发现解不出来！\n\n但是发现$N$不是素数，用yafu分解一下$N$，发现$N$是两个素数的乘积，记为$N=p\\cdot q$，那么椭圆曲线$E_{2}$可重写为\n$$\nE_{2}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ p\\cdot q\n$$\n这样$E_{2}$上的点也满足下面两个等式：\n$$\nE_{p}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ p\n$$\n\n\n即$E_{2}$上的点同时在$E_{p}$与$E_{q}$上(试了一下，我们可以求解$P_{3},P_{4}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数)\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ in\\ E_{2}\n$$\n 则有：\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ \\ in\\ E_{p}\n$$\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ \\ in\\ E_{q}\n$$\n\n\n\n那是不是意味着我们解出$P_{3}$在椭圆曲线$E_{p}$上关于基点$P_{2}$的离散对数就是$m_{1}$呢？非也！我们解出的只是$m_{1}\\ \\textrm{mod}\\ order_{E_{p}}(P_{2})$，即$m_{1}$模了$P_{2}$在椭圆曲线$E_{p}$上的阶之后的值！\n\n要想解出$m_{1}$，需要将$P_{3}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数结合起来！\n$$\nm_{1}\\equiv s_{p}(1)\\ \\textrm{mod}\\ order_{E_{p}}(P_{2})\n$$\n$$\nm_{1}\\equiv s_{q}(1)\\ \\textrm{mod}\\ order_{E_{q}}(P_{2})\n$$\n\n\n\n这里$s_{p}(1),s_{q}(1)$分别是$P_{3}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数；\n\n使用中国剩余定理解上述方程组即可解出$m_{1}$，同理解出$m_{2}$\n\n### 解题\n\n上述链接中的solve.sage为解题的脚本；程序运行结果如下(运行时间有点长，稍微等一下)：\n\n```Bash\n$ sage solve.sage\n  ***   Warning: increasing stack size to 2000000.\nflag{de7a89ab1d074ef3930fb3054c0e3ac8}\n```\n\n## 后记\n\n一直在等师傅们关于密码学题目的writeup，结果一直没有找到；就只能把自己唯一做出来的一道题目的writeup写一下。","tags":["CTF比赛","CRT","ECC"],"categories":["crypto"]},{"title":"Sagemath在ctf密码学中的使用","url":"/crypto/Use-of-Sagemath-in-CTF-Cryptography.html","content":"## 基本的环和域\n\n```Python\n#整数域,有理数域和实数域\nZZ(3)\nQQ(0.25)\nRR(2^0.5)\n#复数域\nCC(1,2)\n#生成虚数单位i\ni=ComplexField().gen();(2+i)*(4+3*i)\n\n#构造多项式环,返回具有给定属性和变量名的全局唯一的单变量或多元多项式环\n#定义在整数域上的多项式环R，变量为w;ZZ也可换成其他数域\nR.<w>=PolynomialRing(ZZ);R\n(1 + w)^3\n\n#有限环\nRN=IntegerModRing(63)\nFR=Integers(17);FR\n#自身的代数扩展;exR=FR[w]/(w^2+3)\nexR=FR.extension(w^2+3)；exR\n#以python整数的形式返回所有可逆元素的列表\nFR.list_of_elements_of_multiplicative_group()\n#假设环的乘法群是循环的，返回这个环的乘法群的生成元\nFR.multiplicative_generator()\n#返回这个环的一个随机元素\nFR.random_element()\n#上述几种方法对如下的域同样支持\n\n#有限域\n#素数域\nG1=GF(37);G1\n#伽罗瓦域\nG2=GF(3^5);G2\n```\n\n## 数论基本函数\n\n```Python\n#同时求商与余数\nq,r=divmod(12,5)\n\n#求公约数\nd=gcd(12,5)\n\n#扩展的欧几里得算法\nd,u,v=xgcd(12,5)\n\n#12在模5下的逆\nu=inverse_mod(12,5)\n\n#生成[lb,ub)之间的随机素数,注意ub在前,lb在后,lb可缺省为0\n#可通过这种方式生成128位的随机素数\np=random_prime(2L**128,2L**127)\n\n#判断是否为素数\nis_prime(65537)\n\n#第20个素数\nnth_prime(20)\n\n#计算x^y mod n\nz=power_mod(12,5,17)\n\n#欧拉函数\neuler_phi(111)\n\n#中国剩余定理,A=[a1,...,an],M=[m1,...,mn]\n#ai=x mod mi,i=1,...,n\ncrt([1,2,3,4],[7,5,12,23])\n\n#求自身的n次根\nFR(12).nth_root(7,all='True')\n\n#求多项式的根，roots方法必须作用在域上\nR.<x>=PolynomialRing(G1)\nxt=G1(12)\nyt=xt^6\nf=x^6-yt\nf.roots()\n```\n\n## 线性代数\n\n```Python\n#定义矩阵，默认定义在实数域\nA = matrix([[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\nA^-1\n#定义在其他域上的矩阵，如有限域\nA = matrix(GF(13),[[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\nA^-1\n#可以看到两个逆矩阵不一样\n\n#定义向量，定义在有限域，默认定义在实数域\nw = vector(GF(13),[1,1,4,3])\nY=A*w;Y\nZ=w*A;Z\n\n#解线性方程组AX=Y\nX = A.solve_right(Y);X\n#也可以使用符号\\\nA\\Y\n#解线性方程组XA=Y\nX = A.solve_left(Z);X\n\n#格基约减\nA = matrix([[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\n#LLL算法\nA.LLL()\n#BKZ算法\nA.BKZ()\n```\n\n## 离散椭圆曲线\n以国密SM2算法使用的椭圆曲线为例；\n\n```Python\np=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF',16)\na=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC',16)\nb=ZZ('28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93',16)\n#有限域GF(p)上的椭圆曲线y^2 = x^3 + a*x + b mod p\nE=EllipticCurve(GF(p),[0,0,0,a,b])\n#基点\ng=E([ZZ('32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7',16),ZZ('bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0',16)])\n#基点的阶\nn=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123',16)\n#生成密钥\nsk=random_prime(2*n//3,n//3)\n#生成公钥\nG=sk*g\n```\n\n## 离散对数\n\n前言：求解以base为底，a的对数；ord为base的阶，可以缺省，operation可以是'+'与'\\*'，默认为'\\*'；bounds是一个区间(ld,ud)，需要保证所计算的对数在此区间内。\n\n```Python\n#通用的求离散对数的方法\nx=discrete_log(a,base,ord,operation)\n\n#求离散对数的Pollard-Rho算法\nx=discrete_log_rho(a,base,ord,operation)\n\n#求离散对数的Pollard-kangaroo算法(也称为lambda算法)\nx=discrete_log_lambda(a,base,bounds,operation)\n\n#小步大步法\nx=bsgs(base,a,bounds,operation)\n```\n\n## coppersmith算法\n\n[coppersmith算法介绍链接](https://www.cnblogs.com/coming1890/p/13506057.html)\n\n使用sage实现coppersmith相关攻击，[GitHub链接](https://github.com/mimoo/RSA-and-LLL-attacks)\n\n最后，sage的[官方文档链接](https://doc.sagemath.org/html/en/reference/)","tags":["工具","sagemath"],"categories":["crypto"]},{"title":"Elgamal&RSA小结","url":"/crypto/Elgamal-RSA-summary.html","content":"## 前言\n\n要解决的问题：$c\\equiv m^{e}\\ \\textrm{mod}\\ N$($m<N$，$N$已被分解，但$(e,\\phi(N))>1$)。\n\n## 分类讨论\n\n首先给出求解方程($q,e$为素数)$y\\equiv x^{e}\\ \\textrm{mod}\\ q^{k}$的[Python脚本](https://github.com/KangMing-ux/AllRootModqk)\n\n注：当$k=1$时，可(使用Sagemath)直接在有限域$GF(q)$上对$y$开$e$次方；\n\n### $N=p^{a}$\n\n记$g=(e,\\phi(N)),e_{1}=e/g$，则$(e_{1},\\phi(N))=1$，因此可以计算$d_{1}\\equiv e_{1}^{-1}\\ \\textrm{mod}\\ \\phi(N)$；$c^{d_{1}}\\equiv m^{e\\cdot d_{1}}\\equiv (m^{g})^{d_{1}\\cdot e_{1}}\\equiv m^{g}\\ \\textrm{mod}\\ N$，从而可得$m^{g}\\ \\textrm{mod}\\ p^{a}$，接下来使用上述工具求解(最多有$g$个解)。\n\n### $N=p_{1}^{a_{1}}\\cdots p_{k}^{a_{k}}$\n$c\\equiv m^{e}\\ \\textrm{mod}\\ N\\Rightarrow c\\equiv m^{e}\\ \\textrm{mod}\\ (p_{1}^{a_{1}}\\cdots p_{k}^{a_{k}})$，则有\n$$\nc\\equiv m^{e}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nc\\equiv m^{e}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n记$\\phi_{i}=\\phi(p_{i}^{a_{i}})$，$g_{i}=(e,\\phi_{i})$，$e_{i}=e/g_{i}$，$d_{i}\\equiv e_{i}^{-1}\\ \\textrm{mod}\\ \\phi_{i}$\n$$\nm^{g_{1}}\\equiv c^{d_{1}}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nm^{g_{k}}\\equiv c^{d_{k}}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n这时处理的方式不唯一；我们只考虑那些$g_{i}$很小的线程同余方程，不妨设$g_{1},\\cdots,g_{t}$很小；\n\n(1)$g_{1}=\\cdots =g_{s}=r$，$s\\leqslant t$(不妨设前$s$个$g_{i}$相等)\n\n利用中国剩余定理求解前$s$个方程组成的方程组，得到方程组在模$p_{1}^{a_{1}}\\cdots p_{s}^{a_{s}}$下的解；当$m^{r}<p_{1}^{a_{1}}\\cdots p_{s}^{a_{s}}$时，直接对解开$r$次方即得$m$；\n\n(2)一般情况，$g_{i}(i=1,\\cdots,t)$很小但是大多数各不相同\n\n那么首先对每个方程组利用上述工具求解(记$x_{i}$为第$i$个方程的解，此时大多数方程组有多个解，每个方程组的解最多有$g_{i}$个)\n\n$$\nm\\equiv x_{1}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nm\\equiv x_{k}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n\n利用中国剩余定理求解前$t$个方程组成的方程组，得到方程组在模$p_{1}^{a_{1}}\\cdots p_{k}^{a_{t}}$下的解；当$m<p_{1}^{a_{1}}\\cdots p_{t}^{a_{t}}$时，$m$必在这些解中。\n\n注：其实这里也解释了为什么考虑那些$g_{i}$很小的线程同余方程，我们最多要求解$g_{1}\\cdots g_{t}$个这样的方程组，每个方程组会求出一个解；如果$g_{i}$很大，那么候选的解太多；但是我们要保证$p_{1}^{a_{1}}\\cdots p_{t}^{a_{t}}>m$。","tags":["密码学知识","CRT","RSA"],"categories":["crypto"]},{"title":"攻防世界-密码学-onetimepad","url":"/crypto/xctf-Onetimepad.html","content":"## 题目信息\n\n附件中包含实现加密的Python脚本，与密文文件。\n\n## 分析\n\n### 有限域$GF(2^{n})$\n\n构造有限域$GF(2^{n})$时，首先需要$GF(2)$上次数为n的本原多项式$g(x)$；对于$GF(2^{n})$上的每个元素$a$，都可以用一个次数不超过$n$的多项式$f_{a}$表示：$f_{a}(x)=\\sum_{i=0}^{n-1}a_{i}\\cdot x^{i}$，其中$a_{n-1}\\cdots a_{0}$是$a$的二进制表示；从而$GF(2^{n})$上的四则运算定义如下：\n\n* 加法：对于$a,b\\in GF(2^{n})$，它们的多项式表示分别为$f_{a},f_{b}$，记$f_{c}=f_{a}+f_{b}$(其中系数的加法为$GF(2)$上的加法，即异或运算)，则$c_{n-1}\\cdots c_{0}$的二进制值$c$为$a+b$的值；\n\n* 减法：由于$GF(2)$上的加法与减法等价，因此对于$a,b\\in GF(2^{n})$，$a+b=a-b$；\n\n* 乘法：同样地，$a,b$的多项式表示$f_{a},f_{b}$，记$f_c=f_{a}\\cdot f_{b}\\ \\textrm{mod}\\ g$，由于多项式$g$的次数为$n$，故多项式$f_{c}$的次数不超过$n$，则$c_{n-1}\\cdots c_{0}$的二进制值$c$为$a\\cdot b$的值；\n\n* 除法：先介绍(乘法)逆元，本原多项式是一种具有特殊性质的不可约多项式，对GF(2)上任意次数不超过$n$的多项式f，都存在$GF(2)$上次数不超过n的多项式$h$，使得$f\\cdot h \\equiv 1\\ \\textrm{mod}\\ g$；与$f$作除法等价于与$f$的逆元$h$作乘法；\n\n### process(m,k)\n\n考虑$t^{2},t\\in GF(2^{256})$，构造$GF(2^{256})$的本原多项式为$g=x^{256}+x^{10}+x^{5}+x^{2}+1$，记$t$的二进制表示为$t_{n-1}\\cdots t_{0}$，则$t$的多项式表示$f_{t}(x)=\\sum_{i=0}^{n-1}t_{i}\\cdot x^{i}=(((t_{n-1}\\cdot x+t_{n-2})\\cdot x+\\cdots +t_{1})\\cdot x+t_{0})$，考虑$t^{2}$：\n\n$f_{t}^{2}\\ \\textrm{mod}\\ g$\n\n$=(((t_{n-1}\\cdot x+t_{n-2})\\cdot x+\\cdots +t_{1})\\cdot x+t_{0})\\cdot f_{t}\\ \\textrm{mod}\\ g$\n\n$=((((t_{n-1}\\cdot f_{t})\\cdot x+t_{n-2}\\cdot f_{t})\\cdot x+\\cdots +t_{1}\\cdot f_{t})\\cdot x+t_{0}\\cdot f_{t})\\ \\textrm{mod}\\ g$\n\n$=((((((t_{n-1}\\cdot f_{t})\\cdot x+t_{n-2}\\cdot f_{t})\\ \\textrm{mod}\\ g)\\cdot x+\\cdots +t_{1}\\cdot f_{t})\\ \\textrm{mod}\\ g)\\cdot x+t_{0}\\cdot f_{t})\\ \\textrm{mod}\\ g$\n\n我们再来对比函数process(m,k)：\n\n```Python\ndef process(m, k):\n    tmp = m ^ k\n    res = 0\n    for i in bin(tmp)[2:]:\n        res = res << 1;\n        if (int(i)):\n            res = res ^ tmp\n        if (res >> 256):\n            res = res ^ P\n    return res\n```\nres=res<<1代表乘以x，多项式的系数全体左移一位；\n\nif (int(i)):res^=tmp等价于res^=int(i)*tmp，代表$+t_{i}\\cdot f_{t}$；\n\nif (res>>256):res^=P代表模本原多项式g；\n\n综上，process(m,k)实际上实现了$GF(2^256)$上的元素$m$与$k$之和的平方$(m+k)^{2}$；\n\n### 解密过程\n\n$k_{2}=(k_{1}+secret)^{2},k_{3}=(k_{2}+secret)^{2}$(在GF(2^256)上的运算)\n\n$c_{1}=m_{1}\\oplus k_{1},c_{2}=m_{2}\\oplus k_{2},c_{3}=m_{3}\\oplus k_{3}$，其中$c_{i}(i=1,2,3),m_{i}(i=1,2)$已知\n\n则$k_{2}=m_{2}\\oplus c_{2},k_{3}=m_{3}\\oplus c_{3}$，可解出secret：$secret=k_{3}^{1/2}+k_{2}$(在GF(2^256)上的运算)\n\n接下来解出$k_{1}$：$k_{1}=k_{2}^{1/2}+secret$(在GF(2^256)上的运算)\n\n然后解出flag(即$m_{1}$)：$m_{1}=c_{1}\\oplus k_{1}$\n\n## 解题\n\n实现的sage脚本如下：\n\n```Python\nfrom Crypto.Util.number import bytes_to_long,long_to_bytes\n\nK.<x>=GF(2L**256,modulus=x^256+x^10+x^5+x^2+1)\n\ndef polify(N):\n    bN=list(bin(N)[2:])\n    bN.reverse()\n    return K(bN)\n\ndef unpolify(Poly):\n    bN=Poly.polynomial().list()\n    bN.reverse()\n    return long(''.join([str(it) for it in bN]),2)\n\ndef solve():\n    cip1=polify(0xaf3fcc28377e7e983355096fd4f635856df82bbab61d2c50892d9ee5d913a07f)\n    cip2=polify(0x630eb4dce274d29a16f86940f2f35253477665949170ed9e8c9e828794b5543c)\n    cip3=polify(0xe913db07cbe4f433c7cdeaac549757d23651ebdccf69d7fbdfd5dc2829334d1b)\n    msg2=polify(bytes_to_long('I_am_not_a_secret_so_you_know_me'))\n    msg3=polify(bytes_to_long('feeddeadbeefcafefeeddeadbeefcafe'))\n    secret=cip2+msg2+(cip3+msg3).sqrt()\n    key1=(cip2+msg2).sqrt()+secret\n    msg1=cip1+key1\n    return long_to_bytes(unpolify(msg1))\n\nif __name__=='__main__':\n    print 'flag{'+solve()+'}'\n```\n\n程序运行结果如下：\n```Bash\n$ sage solve.sage\nflag{t0_B3_r4ndoM_en0Ugh_1s_nec3s5arY}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-sleeping-guard","url":"/crypto/xctf-Sleeping-Guard.html","content":"## 题目信息\n\n点击还原比赛场景后，会给出镜像服务器的ip以及连接端口。且提示：“只有真正的hacker才能看到这张图片”\n\n## 分析\n\n连接上服务器之后，服务器返回的数据看上去像base64编码，对此，解码即可；根据题目的提示，flag藏在图片中，解码后文件头数据不是png,jpg,bmp文件头格式(说明不是直接解码这么简单)，也不是zip,rar,7z文件头格式(说明不是将图片加密压缩)；实际上，原比赛的此题还有一个Python脚本，大致意思是使用长度为12的密钥与图片数据进行(循环)异或加密，有了这个信息之后，尝试使用各种图片格式的文件头与加密数据进行异或得到密钥，使用png格式的文件头与加密数据进行异或时，得到的结果“很像”密钥；接下来使用密钥解密即可。\n\n## 解题\n\n首先从服务器接收全部的数据，再进行base64解码(将解码后的数据存入文件data)；\n\n然后通过png文件头解出密钥，然后通过密钥解密，实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\nfrom binascii import unhexlify\nfrom Crypto.Util.strxor import strxor\n\ndef enc(data,key):\n    key=(key*(len(data)/len(key)+1))[:len(data)]\n    return strxor(data,key)\n\ndef solve(data):\n    head=unhexlify('89504e470d0a1a0a0000000d49484452')\n    key=strxor(head,data[:16])\n    with open('sleeping-guard.png','wb') as f:\n        f.write(enc(data,key[:12]))\n\nif __name__=='__main__':\n    with open('data','rb') as f:\n        solve(f.read())\n```\n\n最后解密出图片\n\n{% asset_img 1.png pic1 %}","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-streamgame1","url":"/crypto/xctf-StreamGame1.html","content":"## 题目信息\n\n附件给出实现流加密的Python脚本与一段输出的密钥流。\n\n## 分析\n\n通过对加密脚本的理解，可得本题的LFSR模型：\n{% asset_img 1.png pic1 %}\n\n其中 $a_{n-1},a_{n-2},\\cdots,a_0$ 为程序中 mask 的二进制位，当 $a_i=1$ 时，将 $b_i$ 输入异或运算，否则 $b_i$ 不输入异或运算；根据模型我们可以得到如下等式：\n\n$$\n\\begin{pmatrix}\nk_{1} \\\\\nk_{2} \\\\\n\\vdots \\\\\nk_{n-1} \\\\\nk_{n} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nb_{n-1} & b_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nb_{n-2} & b_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots  & \\vdots  & \\ddots & \\vdots & \\vdots \\\\\nb_{1}   & b_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nb_{0}   & k_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-1} \\\\\na_{n-2} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n其中的加法为异或，因为$a_{n-1} =1$，将上式重写如下：\n\n$$\n\\begin{pmatrix}\nk_{1} \\\\\nk_{2} \\\\\n\\vdots \\\\\nk_{n-1} \\\\\nk_{n} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nb_{n-1} \\\\\nb_{n-2} \\\\\n\\vdots \\\\\nb_{1} \\\\\nb_{0} \\\\\n\\end{pmatrix}\\oplus \\begin{pmatrix}\nb_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nb_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots  & \\ddots & \\vdots & \\vdots \\\\\nb_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nk_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-2} \\\\\na_{n-3} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n由异或性质：\n\n$$\n\\begin{pmatrix}\nb_{n-1} \\\\\nb_{n-2} \\\\\n\\vdots \\\\\nb_{1} \\\\\nb_{0} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nk_{1} \\\\\nk_{2} \\\\\n\\vdots \\\\\nk_{n-1} \\\\\nk_{n} \\\\\n\\end{pmatrix}\\oplus \\begin{pmatrix}\nb_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nb_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots  & \\ddots & \\vdots & \\vdots \\\\\nb_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nk_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-2} \\\\\na_{n-3} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n再将等式“还原”：\n\n$$\n\\begin{pmatrix}\nb_{n-1} \\\\\nb_{n-2} \\\\\n\\vdots \\\\\nb_{1} \\\\\nb_{0} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nk_{1} & b_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nk_{2} & b_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots & \\vdots  & \\ddots & \\vdots & \\vdots \\\\\nk_{n-1} & b_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nk_{n} & k_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-1} \\\\\na_{n-2} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n计算的顺序由下至上，即可解出初始状态的所有比特位。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom gmpy2 import c_div\n\ndef lfsr(R,mask):\n    output = (R << 1) & 0xffffff    \n    i=(R&mask)&0xffffff             \n    lastbit=0\n    while i!=0:\n        lastbit^=(i&1)    \n        i=i>>1\n    output^=lastbit\n    return (output,lastbit)\n\ndef cal(s,mask):\n    lm=len(bin(mask))-2\n    R=int(s[-1:]+s[:-1],2)\n    ss=''\n    for j in range(lm,0,-1):\n        (_,tk)=lfsr(R,mask)\n        ss=str(tk)+ss\n        R=int(s[j-2]+str(tk)+bin(R)[2:].rjust(lm,'0')[1:-1],2)\n    return ss\n\ndef solve():\n    mask=0b1010011000100011100\n    lm=len(bin(mask))-2\n    with open('key','rb') as f:\n        stream=f.read(c_div(lm,8))\n    s=''.join([bin(256+ord(it))[3:] for it in stream])\n    flag='flag{'+cal(s[:lm],mask)+'}'\n    return flag\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nflag{1110101100001101011}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"GACTF2020密码学部分详解","url":"/crypto/GACTF2020-Cryptography-Section.html","content":"### 前言\n\n比赛网址：[GACTF2020](https://adworld.xctf.org.cn/match/contest_challenge?event=147&hash=cf494a33-0f22-4e85-a48d-7a02efeedc90.event)\n[writeup参考链接](https://0xdktb.top/2020/08/30/WriteUp-GACTF2020-Crypto/)\n\n## ezAES\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF/ezAES)的challeng.py。\n\n### 分析\n\n整体浏览Python脚本后，可得此题考察CBC分组加密工作模式；总结一下脚本给出的信息：\n* key给出前14位(key长16位，即最后2位未知)\n* message的长度为86字节，因此明文最后一组填充10个'\\n'\n* 密文最后一组给出后10个字节\n\n因此，可穷举key的最后2位，每一位考虑所有可打印字符，有100种可能，因此穷举key的最后2位有$10^{4}$种可能，处于合理范围；对每一个key，解密最后一组密文，将解密出的明文后10位与上一组密文后10位异或，若异或后均为'\\n'，则说明穷举出正确的key；\n解出正确的key之后，可按照同样的方式计算出SECRET，从而获取整个明文；\n已知所有明文之后，由CBC工作模式：$m_{i}=D(c_{i};key)\\oplus c_{i-1},i=n,\\cdots,1$，其中$c_{0}=IV$，那么已知最后一组密文，就可以递推出IV：$c_{i-1}=D(c_{i};key)\\oplus m_{i},i=n,\\cdots,1$\n\n### 解题\n\n上述链接中的solve.py为解题的Python脚本；\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\n[+] MBruteforcing: Found key: \"pd\"\n9j_for_aes_cbc!!\n```\n\n## what_r_the_noise\n\n### 题目信息\n\n噪音太大，听不见，China:124.71.145.165:9999(现在应该已经失效了)。\n\n### 分析\n\n大致意思是服务器返回的数据是加入了噪声的，让你去掉噪声，解出正确的明文；有点概率论知识应该想到获取多次数据取平均值。\n\n### 解题\n\n解题的Python脚本在[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/what_r_the_noise)中；\n\n解出的flag可能不完全正确，但是你基本可以猜出是什么单词了！\n\n最后得到flag为gactf{you_know_much_about_differential_privacy}\n\n## da Vinci after rsa\n\n### 题目信息\n\n附件中包含两个文本文件encryption与output；encryption中是一列数，output给出“RSA公钥”与密文；[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/da_Vinci_after_rsa)\n\n### 分析\n\nda Vinci翻译了一下(英语不好)是达芬奇，这既然是密码学题目，自然去查了一下达芬奇密码，发现这是一本书，在网上不停地查这本书，找到一个片段，“打乱的数字”一下引起我的注意，后面马上提到“斐波那契数列”，回去一看，encryption中的那一列数确实是打乱的斐波那契数列，到此encryption的作用弄明白了；\n\n接下来将公钥的模数N放到yafu中分解，得到三个因子；但是我想，不怕，和RSA问题一样求解$d\\equiv e^{-1}\\ \\textrm{mod}\\ \\phi(N)$即可解出$m\\equiv c^{d}\\ \\textrm{mod}\\ N$，编好程序运行时发现$e$在$\\phi(N)$下没有逆，这一下子就不知道怎么办了，其实这样的方程也是有办法求解的，[求解思路链接在此](https://chu-kangming.gitee.io/crypto/Elgamal-RSA-summary.html)\n\n解出的$m$虽然有多个，但是flag每个字符都是可见字符，这样最后只剩下一个$m$，这还不是flag；花括号内正好25个字符，encryption中正好25个数，按照一样的规则打乱花括号内的25个字符即得到真正的flag；\n\n### 解题\n\n上述GitHub备份链接中的solve.sage脚本为解题的sage脚本；\n\n程序运行结果如下：\n\n```Bash\n$ sage solve.sage\nflag{w5awd4fa994f87_dwad3123_2}\n```\n\n## elgamal_rsa\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/elgamal_rsa)\n\n### 分析\n\n$g^{q}\\equiv 1\\ \\textrm{mod}\\ p,h\\equiv g^{d}\\ \\textrm{mod}\\ p$\n\n$c_{1}\\equiv g^{r_{1}}\\ \\textrm{mod}\\ p,c_{2}\\equiv m\\cdot h^{r_{1}}\\ \\textrm{mod}\\ p$\n\n$c_{11}\\equiv g^{r_{2}}\\ \\textrm{mod}\\ p,c_{22}\\equiv m\\cdot h^{r_{2}}\\ \\textrm{mod}\\ p$\n\n其中，$r_{2}\\equiv (B\\cdot r_{1}+A)\\ \\textrm{mod}\\ q$\n\n这里的$m$就是$secret$，$secret$是下面“RSA”加密的模数，因此首先要解出$secret$，这也是很好解的；\n\n$c_{2}^{B}\\cdot h^{A}\\equiv (m\\cdot h^{r_{1}})^{B}\\cdot h^{A}\\equiv m^{B}\\cdot h^{B\\cdot r_{1}+A}\\equiv m^{B-1}\\cdot c_{22}\\ \\textrm{mod}\\ p$\n\n$m^{B-1}\\equiv c_{2}^{B}\\cdot h^{A}\\cdot c_{22}^{-1}\\ \\textrm{mod}\\ p$，计算$t\\equiv (B-1)^{-1}\\ \\textrm{mod}\\ (p-1)$\n\n那么$(c_{2}^{B}\\cdot h^{A}\\cdot c_{22}^{-1})^{t}\\equiv m\\ \\textrm{mod}\\ p$\n\n解出$secret$后，放到yafu里面分解(因子是真的多，一度怀疑自己解错了)，[求解flag的思路链接](https://www.cnblogs.com/coming1890/p/13616763.html)\n\n### 解题\n\n上述GitHub备份链接中的solve文件夹中为解题的脚本，解题分两步；第一步，解出secret；第二步，求解方程$c\\equiv m^{e}\\ \\textrm{mod}\\ N$($m<N$，$N$已被分解，但是$(e,\\phi(N))>1$)；\n\n程序运行结果如下：\n\n```Bash\n$ python step1.py\n329380824451982777596468080979390700896875051159309053251427777390225223390054462862874890632092714850180031743329031313028975903871751004003831036860000454098274963081490031808010876171935539110201531253322208564941373067673598629247111527738724700328114569409692796434368030258427126193825227856160081569366870307559297674909108870298864572520476006338972072593434914773857347865349086098662711283463352902488164071184362082990162654586995346553108747183805073294471613391819978413596510467204977114038549473397779377039088475929677184284430986636686769839308217865627271293739711926018699557041530631349486791876338842184994986024157099233298972714917732995013317087756483\n```\n\n```Bash\n$ sage step2.sage\nyou_4re_good_at_b0th_el94mal_and_rs4\n```\n\n## babycrypto\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/GACTF2020/babycrypto)\n\n### 分析\n\n在GF(p)上定义的点集$\\{(x,y)|x,y\\in GF(p)\\}$上定义加法\"+\"：$(x_{1},y_{1})+(x_{2},y_{2})=(x_{1}x_{2}-y_{1}y_{2},x_{1}y_{2}+x_{2}y_{1})$，定义乘法\"$\\cdot$\"：$k\\cdot (x,y)=(x,y)+\\cdots +(x,y)$\n\n给出基点g，$A=a\\cdot g,B=b\\cdot g$，给出A,B；\n\n$shared=b\\cdot A$，再利用shared生成AES密钥进行加密；\n\np未知！！！先介绍Edwards曲线E：$x^{2}+y^{2}\\equiv 1+dx^{2}y^{2}\\ \\textrm{mod}\\ p$，曲线上的加法定义为$(x_{1},y_{1})+(x_{2},y_{2})=((x_{1}y_{2}+x_{2}y_{1})/(1+dx_{1}x_{2}y_{1}y_{2}),(x_{1}x_{2}-y_{1}y_{2})/(1-dx_{1}x_{2}y_{1}y_{2}))$\n\n令d=0，则E：$x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p$，则加法重写为$(x_{1},y_{1})+(x_{2},y_{2})=(x_{1}y_{2}+x_{2}y_{1},x_{1}x_{2}-y_{1}y_{2})$\n\n若我们设定d=0，那么$A(x_{1},y_{1}),B(x_{2},y_{2})$满足方程$x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p$，求$x_{1}^{2}+y_{1}^{2}-1$与$x_{2}^{2}+y_{2}^{2}-1$的公约数，则p是其最大素因子；\n\n下面考虑如何解出b，这是一个离散对数问题，难点是sage并未实现Edwards曲线及其运算；\n\n给出一个有用的结论：$\\{(x,y)|x,y\\in GF(p),x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p\\}$与$H=F_{p}(w)/(w^{2}+1)$(有限域$F_{p}$上的多项式在模$w^{2}+1$下的剩余环)同构，同构映射$\\sigma :E\\rightarrow H$，$\\sigma((x,y))=x+yw$\n\n在sage中通过extend函数就可以生成H，从而可以求解此离散对数问题；\n\n### 解题\n\n上述GitHub备份链接中的solve文件夹中为解题的脚本，解题分两步；第一步，解出p；第二步，解出b然后以同样的方式生成AES密钥再对消息进行解密；\n\n程序运行结果如下：\n\n```Bash\n$ python step1.py\n435393448000740628395634230535241428961470055780764193459123534837759996\n```\n\n使用yafu分解，可得到p(在solve.sage中有给出)\n\n```Bash\n$ sage solve.sage\ngactf{354b6ce4c03387a828a3c30061213204}\n```","tags":["CTF比赛","CRT","Edwards"],"categories":["crypto"]},{"title":"攻防世界-密码学-xor_game","url":"/crypto/xctf-XOR-GAME.html","content":"## 题目信息\n\n题目给出实现加密的程序，且指出明文是一首诗。\n\n## 分析\n\n先总结一下有用的信息：\n* 明文是有意义的英文，即明文均为可见字符且明文中的各字母出现的频率接近统计规律(在够长的一段话里，各个字母的占比大致稳定，并且这个稳定值已经用巨大的语料库统计出来了，这就是字母频率)\n\n* 密钥均为可见字符\n\n* 加密时对密钥进行了重用\n\n解决方案可分为程序分析与如果人工分析两部分；\n(1)程序分析：穷举密钥的长度，对每一长度的密钥，筛选密钥每一位可行的字符集合(要求此密钥位为可见字符，且那些被此密钥位解密出的明文位亦为可见字符)，如果密钥某一位可行的字符集合为空，则说明当前穷举的长度不是密钥的长度，这一步结束之后，可确定密钥的长度，以及密钥每一位可能的字符值；\n\n注：就实际情况来看，如果穷举的长度不是密钥的长度，几乎一定会有密钥某一位可行的字符集合为空。\n\n接下来，利用词频分析对密钥每一位进行爆破：对密钥的每一位，使用上一步得到的候选字符集中不同字符将解密出不同的明文，其中各字母出现的频率也不会相同，计算各字母出现的频率分布与统计规律的相似程度，选择相似程度最高的字符作为此密钥位。\n\n注：相似度计算公式：$score=\\sum_{i=1}^{26}p_{i}*q_{i}$，其中$p_{i}$是明文中第$i$个字母出现的频率，$q_{i}$是已统计出的第$i$个字母的频率。$q_{i}$的值见下面的程序。\n\n(2)人工分析：经过(1)，可猜对大部分密钥位，之后再结合解密出的明文对错误的密钥位进行修正。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom Crypto.Util.strxor import strxor\nfrom string import printable\nfrom base64 import b64decode\n\nfreq={'e':0.12702,'t':0.09056,'a':0.08167,'o':0.07507,\n        'i':0.06966,'n':0.06749,'s':0.06327,'h':0.06094,\n        'r':0.05987,'d':0.04253,'l':0.04025,'c':0.02782,\n        'u':0.02758,'m':0.02406,'w':0.02360,'f':0.02228,\n        'g':0.02015,'y':0.01974,'p':0.01929,'b':0.01492,\n        'v':0.00978,'k':0.00772,'j':0.00153,'x':0.00150,\n        'q':0.00095,'z':0.00074\n        }\n\ndef frequency(msg):\n    global freq\n    cnum=[len([s for s in msg if s==cc or s==cc.upper()]) for cc in freq.keys()]\n    csum=sum(cnum)\n    if csum==0:\n        return 0\n    return sum([x*y for x,y in zip(freq.values(),cnum)])/csum\n\ndef analysis(ks,cip):\n    lks=[len(sk) for sk in ks]\n    lc=len(cip)\n    step=len(lks)\n    key=[]\n    for ii,sk in enumerate(ks):\n        scores=[frequency(''.join([strxor(cip[ind],ik) for ind in range(ii,lc,step)])) for ik in sk]\n        key.append(sk[scores.index(max(scores))])\n    return key\n\ndef guessK(cip,low=4,high=33):\n    lc=len(cip)\n    for step in range(low,high):\n        ks=[]\n        for c1 in range(step):\n            optK=list(printable[:-6])\n            optK=[ik for ik in optK if ik not in \"{}'\\\"`^\"]\n            for ind in range(c1,lc,step):\n                tt=optK[:]\n                for ik in tt:\n                    if not strxor(cip[ind],ik) in printable:\n                        optK.remove(ik)\n            if len(optK)==0:\n                break\n            ks.append(optK[:])\n        if len(ks)<step:\n            continue\n        return analysis(ks,cip)\n\ndef enc(data, key):\n    key=(key*(len(data)/len(key)+1))[:len(data)]\n    return strxor(data,key)\n\ndef solve():\n    with open('cipher.txt','r') as f:\n        cip=b64decode(f.read())\n    key=guessK(cip)\n    lc=len(cip)\n    lk=len(key)\n    while 1:\n        while 1:\n        print('\\033[1;31m'+''.join(key)+'\\033[0m')\n        msg=enc(cip,''.join(key))\n        out=['['+str(ii/lk)+']['+msg[ii:(ii+lk)]+']' for ii in range(0,lc-lk,lk)]\n        out.append('['+str(lc/lk)+']['+msg[-(lc%lk+lk):-(lc%lk)]+']')\n        if lc%lk:\n            out.append('['+str(lc/lk+1)+']['+msg[-(lc%lk):]+']')\n        print ''.join(out)\n        if raw_input('\\033[1;31m need correction(y) or not(n)\\033[0m')=='n':\n            break\n        row=int(raw_input('\\033[1;31m row \\033[0m'))\n        col=int(raw_input('\\033[1;31m col \\033[0m'))\n        cor=raw_input('\\033[1;31m correction \\033[0m')\n        key[col]=strxor(cip[row*lk+col],cor)\n    with open('msg','w') as f:\n        f.write(msg)\n    print('\\033[1;31m'+''.join(key)+'\\033[0m')\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```txt\n$ python solve.py\nxo7_is_,nte,estingn@f\n[0][\nL,fe, 1hin~and li(h1][1][-o#f ti(e a0d timeoa\"][2][ai+\nFri3olo+s tire#e6][3][s\n*ne\nIehea,d the *c-][4][o,efromethe~valley< $][5][ndethe -ear*\nOpen ;oe][6][th  lon ly -oul ofos,][7][ck)e ha7ves*ing\nRe?e$][8][t *utri\"htl', but .l6][9][o 7epea1 th; well--e,][10][ngeof\nE3ent+ally s8a<][11][in\" in 1he :esert  a6][12][isOI be)iev; I am\no7][13][n $s th  br7ght su\"m ][14][r #lowe7s\nD1 not w&t-][15][er d un!efe?ted fi*r<][16][ d mon 7uleTHeart =a1][17][e $nd b7eat6ing toob ][18][arethe )oad~of theoc0][19][mb rsom \nBo,ed\nTwoEIe][20][he$rd t-e m+sic, f=o(][21][ t-e mo*n a0d carc.s6][22][\nA0xili$ry ;xtremeoa ][23][st-etic,sm <ait tooc$][24][pt0re m,styTFillin( 1][25][heeinte+se 2ife, b:te][26][al6o fi)lin9 the p:r ][27][\nT-ere $re ?lways \"e(][28][or,es t-rou9hout t'ee][29][ea7th\nIebel7eve I .mO][30][Di d asethe~quiet -e$][31][ut< of $utu3n leav*sO][32][Sh ng i6 no* chaosc 6][33][mo.e ge6tur;\nEven 8i)][34][t $lso 7eta7ned bo!ee][35][pr*udlyeQin9 Feng \"u6][36][cl \nOcc0lt\n\nhree\nIoh ][37][arelovei I <elieveoi+][38][ l*ve\nL*ve 7s a po le][39][ofestru\"gli0g bluebg7][40][ee+ alg$e\nA- desol.t ][41][ m,cro-'urs* of wi!dO][42][Bl edin\" th,ough m6 3][43][ei+s\nYe$rs -tation*de][44][inethe 'eli;f\nFourEIe][45][be)ieveetha* all c.ne][46][he$r\nEv n a0ticipa;ee][47][di6cret , I~met th* *][48][th r th ir 1wn\nSom* &][49][anenot \"ras. the m m ][50][ntOLefteto *he Eas; 1][51][o \"o We6t, *he dea+ (][52][us1 noteret+rn to !o2][53][he7e\nSe , I~wear Z.ne][54][Fl*werseon 3y headc ,][55][n #ull 'loo3 alongot-][56][e 2ay a)l t6e way\n\tr ][57][qu ntlyemis-ed som*,e][58][bu1 als* de;ply mo9e!][59][ b< win!, f,ost, s!o2][60][ o7 rai+\nFi(e\nPraj!ae][61][Pa7amit$, s1on as <o*][62][n $s\nli#e b; beaut&f0][63][l )ike 6umm;r flow*r6][64][ a+d de$th 2ike au;u(][65][n )eave6\nAl-o careoa'][66][n )eave6\nAl-o careoa'][67][ou1 wha1 ha-]\nneed correction(y) or not(n)y\nrow: 0\ncol: 2\ncorrection: i\nxor_is_,nte,estingn@f\n[0][\nLife, 1hin~and li(h1][1][-off ti(e a0d timeoa\"][2][ain\nFri3olo+s tire#e6][3][s\none\nIehea,d the *c-][4][o, fromethe~valley< $][5][nd the -ear*\nOpen ;oe][6][the lon ly -oul ofos,][7][ckle ha7ves*ing\nRe?e$][8][t outri\"htl', but .l6][9][o repea1 th; well--e,][10][ng of\nE3ent+ally s8a<][11][ing in 1he :esert  a6][12][is\nI be)iev; I am\no7][13][n as th  br7ght su\"m ][14][r flowe7s\nD1 not w&t-][15][ered un!efe?ted fi*r<][16][ demon 7uleTHeart =a1][17][e and b7eat6ing toob ][18][ar the )oad~of theoc0][19][mbersom \nBo,ed\nTwoEIe][20][heard t-e m+sic, f=o(][21][ the mo*n a0d carc.s6][22][\nAuxili$ry ;xtremeoa ][23][sthetic,sm <ait tooc$][24][pture m,styTFillin( 1][25][he inte+se 2ife, b:te][26][also fi)lin9 the p:r ][27][\nThere $re ?lways \"e(][28][ories t-rou9hout t'ee][29][earth\nIebel7eve I .mO][30][Died asethe~quiet -e$][31][uty of $utu3n leav*sO][32][Sheng i6 no* chaosc 6][33][moke ge6tur;\nEven 8i)][34][t also 7eta7ned bo!ee][35][proudlyeQin9 Feng \"u6][36][cle\nOcc0lt\n\nhree\nIoh ][37][ar lovei I <elieveoi+][38][ love\nL*ve 7s a po le][39][of stru\"gli0g bluebg7][40][een alg$e\nA- desol.t ][41][ micro-'urs* of wi!dO][42][Bleedin\" th,ough m6 3][43][eins\nYe$rs -tation*de][44][in the 'eli;f\nFourEIe][45][believeetha* all c.ne][46][hear\nEv n a0ticipa;ee][47][discret , I~met th* *][48][ther th ir 1wn\nSom* &][49][an not \"ras. the m m ][50][nt\nLefteto *he Eas; 1][51][o go We6t, *he dea+ (][52][ust noteret+rn to !o2][53][here\nSe , I~wear Z.ne][54][Flowerseon 3y headc ,][55][n full 'loo3 alongot-][56][e way a)l t6e way\n\tr ][57][quentlyemis-ed som*,e][58][but als* de;ply mo9e!][59][ by win!, f,ost, s!o2][60][ or rai+\nFi(e\nPraj!ae][61][Paramit$, s1on as <o*][62][n as\nli#e b; beaut&f0][63][l like 6umm;r flow*r6][64][ and de$th 2ike au;u(][65][n leave6\nAl-o careoa'][66][n leave6\nAl-o careoa'][67][out wha1 ha-]\nneed correction(y) or not(n)y\nrow: 0\ncol: 7\ncorrection: t\nxor_is_inte,estingn@f\n[0][\nLife, thin~and li(h1][1][-off time a0d timeoa\"][2][ain\nFrivolo+s tire#e6][3][s\none\nI hea,d the *c-][4][o, from the~valley< $][5][nd the hear*\nOpen ;oe][6][the lonely -oul ofos,][7][ckle harves*ing\nRe?e$][8][t outrightl', but .l6][9][o repeat th; well--e,][10][ng of\nEvent+ally s8a<][11][ing in the :esert  a6][12][is\nI believ; I am\no7][13][n as the br7ght su\"m ][14][r flowers\nD1 not w&t-][15][ered undefe?ted fi*r<][16][ demon ruleTHeart =a1][17][e and breat6ing toob ][18][ar the load~of theoc0][19][mbersome\nBo,ed\nTwoEIe][20][heard the m+sic, f=o(][21][ the moon a0d carc.s6][22][\nAuxiliary ;xtremeoa ][23][stheticism <ait tooc$][24][pture mistyTFillin( 1][25][he intense 2ife, b:te][26][also fillin9 the p:r ][27][\nThere are ?lways \"e(][28][ories throu9hout t'ee][29][earth\nI bel7eve I .mO][30][Died as the~quiet -e$][31][uty of autu3n leav*sO][32][Sheng is no* chaosc 6][33][moke gestur;\nEven 8i)][34][t also reta7ned bo!ee][35][proudly Qin9 Feng \"u6][36][cle\nOccult\n```\n\n\n\n```txt\nhree\nIoh ][37][ar love, I <elieveoi+][38][ love\nLove 7s a po le][39][of struggli0g bluebg7][40][een algae\nA- desol.t ][41][ micro-burs* of wi!dO][42][Bleeding th,ough m6 3][43][eins\nYears -tation*de][44][in the beli;f\nFourEIe][45][believe tha* all c.ne][46][hear\nEven a0ticipa;ee][47][discrete, I~met th* *][48][ther their 1wn\nSom* &][49][an not gras. the m m ][50][nt\nLeft to *he Eas; 1][51][o go West, *he dea+ (][52][ust not ret+rn to !o2][53][here\nSee, I~wear Z.ne][54][Flowers on 3y headc ,][55][n full bloo3 alongot-][56][e way all t6e way\n\tr ][57][quently mis-ed som*,e][58][but also de;ply mo9e!][59][ by wind, f,ost, s!o2][60][ or rain\nFi(e\nPraj!ae][61][Paramita, s1on as <o*][62][n as\nlife b; beaut&f0][63][l like summ;r flow*r6][64][ and death 2ike au;u(][65][n leaves\nAl-o careoa'][66][n leaves\nAl-o careoa'][67][out what ha-]\nneed correction(y) or not(n)y\nrow: 0\ncol: 11\ncorrection:  \nxor_is_interestingn@f\n[0][\nLife, thin and li(h1][1][-off time and timeoa\"][2][ain\nFrivolous tire#e6][3][s\none\nI heard the *c-][4][o, from the valley< $][5][nd the heart\nOpen ;oe][6][the lonely soul ofos,][7][ckle harvesting\nRe?e$][8][t outrightly, but .l6][9][o repeat the well--e,][10][ng of\nEventually s8a<][11][ing in the desert  a6][12][is\nI believe I am\no7][13][n as the bright su\"m ][14][r flowers\nDo not w&t-][15][ered undefeated fi*r<][16][ demon rule\nHeart =a1][17][e and breathing toob ][18][ar the load of theoc0][19][mbersome\nBored\nTwoEIe][20][heard the music, f=o(][21][ the moon and carc.s6][22][\nAuxiliary extremeoa ][23][stheticism bait tooc$][24][pture misty\nFillin( 1][25][he intense life, b:te][26][also filling the p:r ][27][\nThere are always \"e(][28][ories throughout t'ee][29][earth\nI believe I .mO][30][Died as the quiet -e$][31][uty of autumn leav*sO][32][Sheng is not chaosc 6][33][moke gesture\nEven 8i)][34][t also retained bo!ee][35][proudly Qing Feng \"u6][36][cle\nOccult\nThree\nIoh ][37][ar love, I believeoi+][38][ love\nLove is a po le][39][of struggling bluebg7][40][een algae\nAs desol.t ][41][ micro-burst of wi!dO][42][Bleeding through m6 3][43][eins\nYears station*de][44][in the belief\nFourEIe][45][believe that all c.ne][46][hear\nEven anticipa;ee][47][discrete, I met th* *][48][ther their own\nSom* &][49][an not grasp the m m ][50][nt\nLeft to the Eas; 1][51][o go West, the dea+ (][52][ust not return to !o2][53][here\nSee, I wear Z.ne][54][Flowers on my headc ,][55][n full bloom alongot-][56][e way all the way\n\tr ][57][quently missed som*,e][58][but also deeply mo9e!][59][ by wind, frost, s!o2][60][ or rain\nFive\nPraj!ae][61][Paramita, soon as <o*][62][n as\nlife be beaut&f0][63][l like summer flow*r6][64][ and death like au;u(][65][n leaves\nAlso careoa'][66][n leaves\nAlso careoa'][67][out what has]\nneed correction(y) or not(n)y\nrow: 0\ncol: 18\ncorrection: g\nxor_is_interesting!@f\n[0][\nLife, thin and ligh1][1][-off time and time a\"][2][ain\nFrivolous tirele6][3][s\none\nI heard the ec-][4][o, from the valleys $][5][nd the heart\nOpen toe][6][the lonely soul of s,][7][ckle harvesting\nRepe$][8][t outrightly, but al6][9][o repeat the well-be,][10][ng of\nEventually swa<][11][ing in the desert oa6][12][is\nI believe I am\nBo7][13][n as the bright summ ][14][r flowers\nDo not wit-][15][ered undefeated fier<][16][ demon rule\nHeart ra1][17][e and breathing to b ][18][ar the load of the c0][19][mbersome\nBored\nTwo\nIe][20][heard the music, fro(][21][ the moon and carcas6][22][\nAuxiliary extreme a ][23][stheticism bait to c$][24][pture misty\nFilling 1][25][he intense life, bute][26][also filling the pur ][27][\nThere are always me(][28][ories throughout thee][29][earth\nI believe I amO][30][Died as the quiet be$][31][uty of autumn leavesO][32][Sheng is not chaos, 6][33][moke gesture\nEven wi)][34][t also retained bonee][35][proudly Qing Feng mu6][36][cle\nOccult\nThree\nI h ][37][ar love, I believe i+][38][ love\nLove is a poole][39][of struggling blue-g7][40][een algae\nAs desolat ][41][ micro-burst of windO][42][Bleeding through my 3][43][eins\nYears stationede][44][in the belief\nFour\nIe][45][believe that all cane][46][hear\nEven anticipatee][47][discrete, I met the *][48][ther their own\nSome &][49][an not grasp the mom ][50][nt\nLeft to the East 1][51][o go West, the dead (][52][ust not return to no2][53][here\nSee, I wear Zane][54][Flowers on my head, ,][55][n full bloom along t-][56][e way all the way\nFr ][57][quently missed some,e][58][but also deeply move!][59][ by wind, frost, sno2][60][ or rain\nFive\nPrajnae][61][Paramita, soon as so*][62][n as\nlife be beautif0][63][l like summer flower6][64][ and death like autu(][65][n leaves\nAlso care a'][66][n leaves\n```\n\n\n\n```txt\nAlso care a'][67][out what has]\nneed correction(y) or not(n)y\nrow: 0\ncol: 20\ncorrection: t\nxor_is_interesting!@#\n[0][\nLife, thin and light][1][-off time and time ag][2][ain\nFrivolous tireles][3][s\none\nI heard the ech][4][o, from the valleys a][5][nd the heart\nOpen to ][6][the lonely soul of si][7][ckle harvesting\nRepea][8][t outrightly, but als][9][o repeat the well-bei][10][ng of\nEventually sway][11][ing in the desert oas][12][is\nI believe I am\nBor][13][n as the bright summe][14][r flowers\nDo not with][15][ered undefeated fiery][16][ demon rule\nHeart rat][17][e and breathing to be][18][ar the load of the cu][19][mbersome\nBored\nTwo\nI ][20][heard the music, from][21][ the moon and carcass][22][\nAuxiliary extreme ae][23][stheticism bait to ca][24][pture misty\nFilling t][25][he intense life, but ][26][also filling the pure][27][\nThere are always mem][28][ories throughout the ][29][earth\nI believe I am\n][30][Died as the quiet bea][31][uty of autumn leaves\n][32][Sheng is not chaos, s][33][moke gesture\nEven wil][34][t also retained bone ][35][proudly Qing Feng mus][36][cle\nOccult\nThree\nI he][37][ar love, I believe in][38][ love\nLove is a pool ][39][of struggling blue-gr][40][een algae\nAs desolate][41][ micro-burst of wind\n][42][Bleeding through my v][43][eins\nYears stationed ][44][in the belief\nFour\nI ][45][believe that all can ][46][hear\nEven anticipate ][47][discrete, I met the o][48][ther their own\nSome c][49][an not grasp the mome][50][nt\nLeft to the East t][51][o go West, the dead m][52][ust not return to now][53][here\nSee, I wear Zan ][54][Flowers on my head, i][55][n full bloom along th][56][e way all the way\nFre][57][quently missed some, ][58][but also deeply moved][59][ by wind, frost, snow][60][ or rain\nFive\nPrajna ][61][Paramita, soon as soo][62][n as\nlife be beautifu][63][l like summer flowers][64][ and death like autum][65][n leaves\nAlso care ab][66][n leaves\nAlso care ab][67][out what has]\nneed correction(y) or not(n)n\nxor_is_interesting!@#\n```\n\n","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-equation-2","url":"/crypto/xctf-Equation-2.html","content":"## 题目信息\n\n题目描述“RSA私钥上面的部分被屏蔽了请恢复私钥并解密文件”，附件给出私钥编码的截图，但是只能看见最后5行。\n\n## 分析\n\n### OpenSSL私钥结构\n\n私钥信息按如下顺序排列：\nversion | pad | n | pad | e | pad | d | pad | p | pad | q | pad | x1 | pad | x2 | pad | x3\n其中，pad是填充信息，各pad并不同，$x_{1}= d\\ \\textrm{mod}\\ (p-1),x_{2}= d\\ \\textrm{mod}\\ (q-1),x_{3}=p^{-1}\\ \\textrm{mod}\\ q$，填充pad用来注释接下来的大数的(字节)长度，\\x02为pad开头的标记，有时后面接\\x81或\\x82，这用来标记长度值所占用的字节(\\x81代表占用1个字节，\\x82代表占用2个字节)，有时后面不接\\x81或\\x82而直接放置长度；\n例：\\x02\\x03代表接下来的大数的字节长度为3个字节；\\x02\\x81\\x80，首先，\\x81代表长度占用1个字节，因此\\x80就是长度值，即128，表明接下来的大数的字节长度为128个字节。\n\n将私钥信息按照上述顺序排列好之后，再进行base64编码。\n\n### 利用已知信息恢复私钥\n\n截图可见编码为\n```Bash\nOs9mhOQRdqW2cwVrnNI72DLcAXpXUJ1HGwJBANWiJcDUGxZpnERxVw7s0913WXNtV4GqdxCzG0pG5EHThtoTRbyX0aqRP4U/hQ9tRoSoDmBn+3HPITsnbCy67VkCQBM4xZPTtUKM6Xi+16VTUnFVs9E4rqwIQCDAxn9UuVMBXlX2Cl0xOGUF4C5hItrX2woF7LVS5EizR63CyRcPovMCQQDVyNbcWD7N88MhZjujKuSrHJot7WcCaRmTGEIJ6TkU8NWt9BVjR4jVkZ2EqNd0KZWdQPukeynPcLlDEkIXyaQx\n```\n\n解码后结合OpenSSL私钥结构分析可得：x1,x2,x3为已知；但是仅有x1,x2,x3并不能恢复出p,q与d，若我们假设e为常用的指数3,65537等等，则可试出p与q：\n\n$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ (p-1)(q-1)$\n则有$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ (p-1)$与$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ (q-1)$；\n由$x_{1}$与$x_{2}$的定义可得$x_{1}\\cdot e\\equiv 1\\ \\textrm{mod}\\ (p-1)$，$x_{2}\\cdot e\\equiv 1\\ \\textrm{mod}\\ (q-1)$；\n因此$(p-1)|(x_{1}\\cdot e-1)$；\n记$x_{1}\\cdot e-1=r_{1}\\cdot (p-1)$；\n由于$x_{1}= d\\ \\textrm{mod}\\ (p-1)$，则$x_{1}<(p-1)$；\n几乎可以看做$x_{1}\\cdot e=r_{1}\\cdot (p-1)$，那么必有$r_{1}<e$；\n同理可得$r_{2}<e$，其中$x_{2}\\cdot e-1=r_{2}\\cdot (q-1)$\n可以看到，$r_{i}<e,i=1,2$，从而可使用试除法求出$r_{i},i=1,2$；\n则$p=(x_{1}\\cdot e-1)/r_{1}+1,q=(x_{2}\\cdot e-1)/r_{2}+1$；\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom Crypto.Util.number import bytes_to_long,isPrime,inverse\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5\n\ndef genKey(X1,X2,X3):\n    e=65537L\n    N1=X1*e-1\n    N2=X2*e-1\n    for r in range(e):\n        if N1%(e-r)==0:\n            p=N1/(e-r)+1\n            if isPrime(p):\n                break\n    for r in range(e):\n        if N2%(e-r)==0:\n            q=N2/(e-r)+1\n            if isPrime(q):\n                break\n    N=p*q\n    phi=(p-1)*(q-1)\n    d=inverse(e,phi)\n    assert inverse(q,p)==X3\n    return RSA.construct((N,e,long(d),p,q))\n\ndef solve():\n    X1=bytes_to_long('\\xd5\\xa2%\\xc0\\xd4\\x1b\\x16i\\x9cDqW\\x0e\\xec\\xd3\\xddwYsmW\\x81\\xaaw\\x10\\xb3\\x1bJF\\xe4A\\xd3\\x86\\xda\\x13E\\xbc\\x97\\xd1\\xaa\\x91?\\x85?\\x85\\x0fmF\\x84\\xa8\\x0e`g\\xfbq\\xcf!;\\'l,\\xba\\xedY')\n    X2=bytes_to_long('\\x138\\xc5\\x93\\xd3\\xb5B\\x8c\\xe9x\\xbe\\xd7\\xa5SRqU\\xb3\\xd18\\xae\\xac\\x08@ \\xc0\\xc6\\x7fT\\xb9S\\x01^U\\xf6\\n]18e\\x05\\xe0.a\"\\xda\\xd7\\xdb\\n\\x05\\xec\\xb5R\\xe4H\\xb3G\\xad\\xc2\\xc9\\x17\\x0f\\xa2\\xf3')\n    X3=bytes_to_long('\\xd5\\xc8\\xd6\\xdcX>\\xcd\\xf3\\xc3!f;\\xa3*\\xe4\\xab\\x1c\\x9a-\\xedg\\x02i\\x19\\x93\\x18B\\t\\xe99\\x14\\xf0\\xd5\\xad\\xf4\\x15cG\\x88\\xd5\\x91\\x9d\\x84\\xa8\\xd7t)\\x95\\x9d@\\xfb\\xa4{)\\xcfp\\xb9C\\x12B\\x17\\xc9\\xa41')\n    rsa_key=genKey(X1,X2,X3)\n    key= PKCS1_v1_5.new(rsa_key)\n    with open('flag.enc','rb') as f:\n        return key.decrypt(f.read(),'')\n\nif __name__=='__main__':\n    print solve()[:-1]\n```\n\n注：这里之所以猜测e为65537而不是3是因为$r_{i}<e,i=1,2$，如果e=3可能情况太少。\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\n0ctf{Keep_ca1m_and_s01ve_the_RSA_Eeeequati0n!!!}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-SM","url":"/crypto/xctf-SM.html","content":"## 题目信息\n\n附件中包含一个Python脚本sm.py，3个文本文件。\n\n## 分析\n\n读完一遍sm.py后，可以确定解题的思路是先由ps与r解出bchoose，再由bchoose按照同样的过程计算出密钥key，最后进行AES解密求出flag。首先看生成r的代码：\n\n```Python\nr=0\nfor i in range(512):\n    if bchoose[i]=='1':\n        r=r^ps[i]\n```\n\n即$r=\\sum_{i=1}^{512}\\textrm{bchoose[i]}\\cdot \\textrm{ps[i]}$(此处的加法是异或)；虽然生成方式类似背包加密，但是由于ps具有很好的性质，我们不使用破解背包加密的方法来解此题；我们来分析生成ps的gen512num函数：\n\n```Python\ndef gen512num():\n    order=[]\n    while len(order)!=512:\n        tmp=randint(1,512)\n        if tmp not in order:\n            order.append(tmp)\n    ps=[]\n    for i in range(512):\n        p=getPrime(512-order[i]+10)\n        pre=bin(p)[2:][0:(512-order[i])]+\"1\"\n        ps.append(int(pre+\"0\"*(512-len(pre)),2))\n    return ps\n```\n\norder是1,2,...,512的一个随机的排列，对ps[i]:首先生成一个长度为512-order[i]+10的素数，去掉此素数的最后10位，同时在尾部追加一个二进制位1，最后在后面填充0使得长度为512；我们首先考虑生成r的最后1个二进制位，ps中只有1个数最后1位为1，其余数最后1位均为0，那么最后1位为1的数如果没有“加入”异或运算，那么r的最后1位一定为0，否则，一定为1，这样我们通过r的最后1位就可以推断出bchoose的第j位(记order[j]=1)。接下来，$r\\oplus (\\textrm{bchoose[j]}\\cdot \\textrm{ps[j]})=\\sum_{i\\neq j}\\textrm{bchoose[i]}\\cdot \\textrm{ps[i]}$，在{ps[i]| i$\\neq$j}中，只有1个数倒数第2位为1，同理，可推断出bchoose的第k位(记order[k]=2)，直到推断出bchoose所有位。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\nfrom hashlib import md5\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.number import long_to_bytes\n\ndef cal_k():\n    with open('ps','r') as f:\n        ps=[long(x) for x in f.read().split('\\n')[:-1]]\n    with open('r','r') as f:\n        r=long(f.read())\n    pbits=[bin(x).rfind('1')-2 for x in ps]\n    bc=['0']*512\n    for le in range(512):\n        ind=pbits.index(511-le)\n        tt=bin(r)[2:].rjust(512,'0')[511-le]\n        if tt=='1':\n            bc[ind]='1'\n            r^=ps[ind]\n    return long(''.join(bc),2)\n\ndef solve():\n    with open('ef','rb') as f:\n        ef=b64decode(f.read())\n    key=long_to_bytes(int(md5(long_to_bytes(cal_k())).hexdigest(),16))\n    aes_obj = AES.new(key, AES.MODE_ECB)\n    return aes_obj.decrypt(ef)\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nflag{shemir_alotof_in_wctf_fun!}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-Decode_The_File","url":"/crypto/xctf-DECODE-THE-FILE.html","content":"## 题目信息\n\n附件是一个文本文件，里面有658行base64编码。\n\n## 分析\n\n先将附件中每行base64编码进行解码，得到一个Python脚本。但其实信息并非隐藏在解码后的数据中，而是隐藏在编码中。首先介绍[base64编码的原理](https://chu-kangming.gitee.io//tech/B32-64-encode-explanation.html)，当需要编码的数据剩下1或2字节时，编码与解码过程如下：\n{% asset_img 1.png pic1 %}\n\n\n可以看到，即使$a_{i} \\neq 0$，解码过程也能正确进行；从而可以使用$a_{i}$传递一些信息。因此，只要我们将编码中的$a_{i}$提取出来，就可以解出flag。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\nfrom string import uppercase,lowercase,digits\nfrom Crypto.Util.number import long_to_bytes\n\ndef solve():\n    with open('encode','r') as f:\n        codes=f.read()\n    Lc=codes.split('\\n')[:-1]\n    base=uppercase+lowercase+digits+'+/'\n    re2=[]\n    for code in Lc:\n        if '==' in code:\n            re2.append(bin(base.find(code[-3]))[2:].rjust(6,'0')[2:])\n        elif '=' in code:\n            re2.append(bin(base.find(code[-2]))[2:].rjust(6,'0')[4:])\n    ret=''.join(re2)\n    return long_to_bytes(long(ret[:ret.rfind('1')+1],2))\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nROIS{base_GA_caN_b3_d1ffeR3nT}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-简单流量分析","url":"/crypto/xctf-Simple-Traffic-Analysis.html","content":"## 题目信息\n\n题目背景：运维人员在日常安全检查的时候发现现场某设备会不时向某不知名ip发出非正常的ICMP PING包。这引起了运维人员的注意，他在过滤出ICMP包分析并马上开始做应急处理很可能已被攻击的设备，附件给出可疑流量包。\n\n## 分析\n\n流量分析题，分析的方法基本上有：binwalk、查找一些可疑字符串或16进制数据，排序流量包的长度(最长的流量包一般很可疑)；当我们对流量包的长度进行排序时，发现流量包最短90字节，最长也不过164字节，其中的data段数据长度从48到122，而ascii表中第48至122个字符为0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz，于是将每个流量包的长度转换为对应字符，然后连接成一段长字符串，看上去像base64编码，对字符串进行base64解码即可!\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom pyshark.capture.file_capture import FileCapture\nfrom base64 import b64decode\nfrom sys import argv\n\ndef solve(file_name):\n    packets=FileCapture(input_file=file_name)\n    res=''\n    for packet in packets:\n        for pkt in packet:\n            if pkt.layer_name=='icmp' and int(pkt.type,16):\n                res+=chr(int(pkt.data_len))\n    return b64decode(res)\n\nif __name__=='__main__':\n    print solve(argv[1])\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py fetus_pcap.pcap\n::\\nmongodb:!:17843:0:99999:7:::\\nubuntu:$6$LhHRomTE$M7C4n84UcFLAG{xx2b8a_6mm64c_fsociety}::\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-shanghai","url":"/crypto/xctf-Shanghai.html","content":"## 题目信息\n\n题目给出提示“维吉利亚密码”，密文在附件中。\n\n## 分析\n\n由于维吉利亚密码加密时密钥重用，导致可通过分析密文进行破解；由于明文中存在一些出现频率很高的单词：the,and,for,with等等，因此很有可能这些单词再次被同样的密钥加密，从而生成同样的密文，其间隔一定是密钥长度的倍数，因此可通过对密文进行分析得到密钥的长度；另外，由于这些密文对应着那些出现频率高的明文，因此可破解出密钥；自己写了一个[工具](https://gitee.com/chu-kangming/CTFs-Crypto/tree/tool/TRA/Virginia-analysis)来求解这类问题。\n\n## 解题\n\n如下是我使用工具的解题过程，注释是我自己加的，并非程序的输出\n```Bash\n$ python solve.py shanghai.txt\n# 先寻找密文中多次出现(本程序设定的至少3次)的词汇，并计算它们之间的距离，这有助于分析出密钥的长度\nword:  bju\ndistance:  [1078, 2222, 154, 814, 132, 264]\nthe minimum distance:  132\n\nword:  glv\ndistance:  [660, 408, 186, 374, 88, 66, 836, 44, 649, 110, 880, 88, 209, 66]\nthe minimum distance:  44\n\nword:  vxz\ndistance:  [1936, 154, 264, 253, 121, 517, 154, 440, 11, 220, 66]\nthe minimum distance:  11\n\nword:  bni\ndistance:  [22, 979, 2002, 583, 165, 132, 22]\nthe minimum distance:  22\n\nword:  xpg\ndistance:  [11, 396, 660, 2409, 11, 374, 37, 51, 572]\nthe minimum distance:  11\n\nword:  jcm\ndistance:  [1595, 88, 99, 297, 781, 11, 22, 110, 66, 231, 627]\nthe minimum distance:  11\n\nword:  zlr\ndistance:  [286, 583, 583, 154, 22, 154, 22, 407, 55, 396, 1155]\nthe minimum distance:  22\n\nword:  klm\ndistance:  [594, 308, 605, 2145, 231, 297, 44, 44, 198]\nthe minimum distance:  44\n\nword:  mfr\ndistance:  [44, 99, 99, 715, 1884, 536]\nthe minimum distance:  44\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  tyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  yiz\ndistance:  [165, 968, 550, 275, 220, 2167, 246, 106]\nthe minimum distance:  106\n\nword:  opk\ndistance:  [66, 1342, 385, 11, 1771, 583, 374]\nthe minimum distance:  11\n\nword:  tyi\ndistance:  [165, 968, 488, 62, 275, 220, 37, 1639, 491, 352]\nthe minimum distance:  37\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  pkv\ndistance:  [297, 33, 407, 1221, 572, 88]\nthe minimum distance:  33\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  xui\ndistance:  [638, 682, 77, 154, 55, 649, 363, 143]\nthe minimum distance:  55\n\nword:  tui\ndistance:  [55, 1628, 154, 286, 787, 797]\nthe minimum distance:  55\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n#到此我们应该也能看出，密钥的长度为11\n#接下来，进行已知明文攻击\n```\n```Bash\n#密文中有一段：frxnimp 1914 qil 1940，猜测是between 1914 and 1940\nplaintext:betweenand\ncipher:frxnimpqil\npossible key:enereicqvi len:10\n#如果需要更多的明-密文对分析，则输入y；否则，已计算出密钥，则可以进行解密你需要解密的内容\ntry more plain-cipher(y) or start decrypt(n)y\nplaintext:the\ncipher:opk\npossible key:vig len:3\ntry more plain-cipher(y) or start decrypt(n)n\nkey:enereicqvig\ncipher:jtcw, '{' vvj 'zvkvrmtudabiecveaaxpp' grq '}'\nfgyf, '{' rnh 'jacpnzpdzszsjupanwglh' ebv '}'\ndpps, '{' erb 'xfpnligqmwtgohnywntyl' ypa '}'\nbnyj, '{' ref 'rtuajgphzjxacmawuwkly' cjo '}'\nolws, '{' irs 'vnifwenqqwkewafjsutcl' pni '}'\ntyuq, '{' rif 'irctbrloznxrautofsrlc' cam '}'\nhdho, '{' prw 'vegnpwymxwoenynckfpjl' tnz '}'\nbrmb, '{' npf 'mrtrjkdzvuxvalrwykchj' cem '}'\nflag, '{' and 'vigenereisveryeasyhuh' and '}'\nspuu, '{' fab 'trxrailsnftcaprnwsvzu' ylm '}'\nfcyo, '{' tfo 'rpginvpmbkgayyiajwpnz' ljk '}'\nwpls, '{' ntt 'enereicqvylnwwrrwjthn' qwi '}'\n```\n\n解出flag为flag{vigenereisveryeasyhuh}。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-OldDriver","url":"/crypto/xctf-OldDriver.html","content":"## 题目信息\n\n附件是一份密文，其中包含10组RSA密钥-密文对。\n\n## 分析\n\nRSA秘钥的指数e=10，这些特征暗示低加密指数广播攻击；当加密一份消息给多人时，$c_{i}=m^{e} \\ \\textrm{mod}\\ N_{i},i=1,\\cdots,k$，当$k \\geq e$时，可由中国剩余定理求解$m^{e}$，再开方即得明文$m$。\n\n## 解题\n\n实现的sage脚本如下：\n\n```Python\nfrom Crypto.Util.number import long_to_bytes\nfrom gmpy2 import mpz,iroot\n\ncip_keys=[\n{\"c\": 7366067574741171461722065133242916080495505913663250330082747465383676893970411476550748394841437418105312353971095003424322679616940371123028982189502042, \"e\": 10, \"n\": 25162507052339714421839688873734596177751124036723831003300959761137811490715205742941738406548150240861779301784133652165908227917415483137585388986274803},\n{\"c\": 21962825323300469151795920289886886562790942771546858500842179806566435767103803978885148772139305484319688249368999503784441507383476095946258011317951461, \"e\": 10, \"n\": 23976859589904419798320812097681858652325473791891232710431997202897819580634937070900625213218095330766877190212418023297341732808839488308551126409983193},\n{\"c\": 6569689420274066957835983390583585286570087619048110141187700584193792695235405077811544355169290382357149374107076406086154103351897890793598997687053983, \"e\": 10, \"n\": 18503782836858540043974558035601654610948915505645219820150251062305120148745545906567548650191832090823482852604346478335353784501076761922605361848703623},\n{\"c\": 4508246168044513518452493882713536390636741541551805821790338973797615971271867248584379813114125478195284692695928668946553625483179633266057122967547052, \"e\": 10, \"n\": 23383087478545512218713157932934746110721706819077423418060220083657713428503582801909807142802647367994289775015595100541168367083097506193809451365010723},\n{\"c\": 22966105670291282335588843018244161552764486373117942865966904076191122337435542553276743938817686729554714315494818922753880198945897222422137268427611672, \"e\": 10, \"n\": 31775649089861428671057909076144152870796722528112580479442073365053916012507273433028451755436987054722496057749731758475958301164082755003195632005308493},\n{\"c\": 17963313063405045742968136916219838352135561785389534381262979264585397896844470879023686508540355160998533122970239261072020689217153126649390825646712087, \"e\": 10, \"n\": 22246342022943432820696190444155665289928378653841172632283227888174495402248633061010615572642126584591103750338919213945646074833823905521643025879053949},\n{\"c\": 1652417534709029450380570653973705320986117679597563873022683140800507482560482948310131540948227797045505390333146191586749269249548168247316404074014639, \"e\": 10, \"n\": 25395461142670631268156106136028325744393358436617528677967249347353524924655001151849544022201772500033280822372661344352607434738696051779095736547813043},\n{\"c\": 15585771734488351039456631394040497759568679429510619219766191780807675361741859290490732451112648776648126779759368428205194684721516497026290981786239352, \"e\": 10, \"n\": 32056508892744184901289413287728039891303832311548608141088227876326753674154124775132776928481935378184756756785107540781632570295330486738268173167809047},\n{\"c\": 8965123421637694050044216844523379163347478029124815032832813225050732558524239660648746284884140746788823681886010577342254841014594570067467905682359797, \"e\": 10, \"n\": 52849766269541827474228189428820648574162539595985395992261649809907435742263020551050064268890333392877173572811691599841253150460219986817964461970736553},\n{\"c\": 13560945756543023008529388108446940847137853038437095244573035888531288577370829065666320069397898394848484847030321018915638381833935580958342719988978247, \"e\": 10, \"n\": 30415984800307578932946399987559088968355638354344823359397204419191241802721772499486615661699080998502439901585573950889047918537906687840725005496238621}\n]\n\ncips=[]\nkeys=[]\n\nfor cip_key in cip_keys:\n\tcips.append(cip_key['c'])\n\tkeys.append(cip_key['n'])\n\nsol=crt(cips,keys)\nmsg,flag=iroot(mpz(str(sol)),mpz(str(10)))\nprint msg\nprint flag\nprint long_to_bytes(long(msg))\n```\n\n程序运行效果如下：\n\n```Bash\n$ sage wp.sage\n854589733786598088127099154138504953368140761371523704656865879247874533963639770706597129057405\nTrue\nflag{wo0_th3_tr4in_i5_leav1ng_g3t_on_it}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-Decrypt-the-Message","url":"/crypto/xctf-Decrypt-the-Message.html","content":"## 题目信息\n\n题目要求我们解密附件中的信息；打开附件，里面是一首诗，最后给出需要解密的信息。\n\n## 分析\n\n此题考察[Poem加密](http://wmbriggs.com/post/1001/)；举例说明加密过程。\n诗：for my purpose holds to sail beyond the sunset, and the baths of all the western stars until I die.\n明文：We have run out of cigars, situation desperate.\n从诗中选择5个词for,sail,all,stars,die，将这些词中的每个字母排序(相同的不合并)，即：\n```Bash\n f  o  r  s  a  i  l  a  l  l  s  t  a  r  s  d  i  e\n 6 12 13 15  1  7  9  2 10 11 16 18  3 14 17  4  8  5\n```\n上表共有18个字母，将明文以18个字母一组分成若干行，最后一行未满之处用a,b,...进行填充，即\n```Bash\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18\n w e h a v e r u n o  u  t  o  f  c  i  g  a\n r s s i t u a t i o  n  d  e  s  p  e  r  a\n t e a b c d e f g h  i  j  k  l  m  n  o  p\n```\n\n再根据第一个表将各列置换，即eud tdj ...，最后连接起来生成密文。\n\n破解的思路就是从诗中穷举各种取词情况，然后进行解密，然后选择可读的“明文”，已有人写好破解的[工具](https://github.com/abpolym/crypto-tools/tree/master/poemcode)\n\n## 解题\n\n将诗与密文分别存为poem.txt，cip.txt并移到与poemcode.py同目录下，使用工具破解：\n\n```Bash\n$ python poemcode.py poem.txt cip.txt\n...\nifytuothikcrnyptorapyisheansnweroyoturprbletheyoulodnotnowkwhatourrobemiuasbcdfgheijklnoprst\nifyouthinkcryptographyistheanswertoyourproblemthenyoudonotknowwhatyourproblemisabcdefghijklmnopqrstu\npakprictiyorhftyselorohyphurbeewterunhwooaywtooonrbpofjhsgkeilncmbrt\n...\n```\n中间的为明文。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-工业协议分析1","url":"/crypto/xctf-Industrial-Protocol-Analysis-1.html","content":"## 题目信息\n\n工业网络中存在异常，尝试通过分析PCAP流量包，分析出流量数据中的异常点，并拿到FLAG。flag形式为 flag{}，流量包在附件。\n\n## 分析\n\n将流量包的长度排序(由大到小)，第一个流量包的长度为10120，比第二长的流量包超过太多，猜测有问题；一段乱码之后，data=\"data:image/png;base64,后面是一段很长的base64编码。\n\n## 解题\n\n先将流量包中的base64编码复制到文本文件data.txt中，再进行解码，最后将解码的数据写入png文件，实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\n\nwith open('data.txt','r') as f:\n    da=f.read()\n\ndata=b64decode(da)\n\nwith open('flag.png','w') as g:\n    g.write(data)\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-fanfie","url":"/crypto/xctf-fanfile.html","content":"## 题目信息\n\n附件是一个文本文件，里面是一段长34的字符串。\n\n## 分析\n\n文本中的字符串看上去像base32编码，加填充后解码得乱码；很多时候比赛的名称是解密的谜面，对字符串BITSCTF进行base32编码得字符串IJEVIU2DKRDA====，与文本中的字符串MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI进行对比，发现字符I两次对应M，猜测是移位密码或仿射密码，加密运算的有限集为{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,2,3,4,5,6,7}，不理解的可以参见[对base编码的介绍](https://www.cnblogs.com/coming1890/p/13503574.html),尝试之后得加密方式为仿射密码，求得解密式为$x=5y+12\\ \\textrm{mod}\\ 32$。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom base64 import b32decode\n\ndef solve():\n    s='MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI'\n    dic='ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'\n    msg=''.join([dic[(5*dic.find(x)+12)%32] for x in s])\n    return b32decode(msg+'='*(8-len(msg)%8))\n\nif __name__=='__main__':\n    #python solve.py\n    print solve()\n```\n\n运行程序得如下结果：\n```Bash\n$ python solve.py\nBITSCTF{S2VyY2tob2Zm}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-ecb,_it’s_easy_as_123","url":"/crypto/xctf-ECB-it-is-easy-as-123.html","content":"## 题目信息\n\n附件提供了背景介绍(Somebody leaked a still from the upcoming Happy Feet Three movie, which will be released in 4K, but Warner Bros. was smart enough to encrypt it. But those idiots used a black and white bmp format, and that wasn't their biggest mistake. Show 'em who's boss and get the flag.)，与一个bmp文件。\n\n## 分析\n\n根据背景介绍，原图片应该是bmp格式，经ecb工作模式加密得ecb.bmp；由于ecb工作模式不会掩盖明文的统计规律，因此只要能够修复ecb.bmp就可以见到明文，要修复ecb.bmp，则要求文件的前128字节为bmp文件格式特有的字节。\n\n## 解题\n\n将ecb.bmp的前128字节替换为bmp文件格式特有的字节，则可以见到明文信息，实现的Python脚本如下：\n\n```Python\nfrom Crypto.Util.number import long_to_bytes\n\nwith open('ecb.bmp','rb') as f:\n    data=f.read()\npre=0x424d76483f00000000007600000028000000000f000070080000010004000000000000483f00000000000000000000000000000000000000000000008000008000000080800080000000800080008080000080808000c0c0c0000000ff0000ff000000ffff00ff000000ff00ff00ffff0000ffffff00ffffffffffffffffffffL\nout=long_to_bytes(pre)+data[128:]\n\nwith open('out.bmp','wb') as g:\n    g.write(out)\n```\n\nout.bmp可被照片查看器打开，从而见到flag。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-safer-than-rot13","url":"/crypto/xctf-Safer-Than-Rot13.html","content":"## 题目信息\n\n附件是一个文本文件，题目名称safer-than-rot13。\n\n## 分析\n\n由题目名称safer-than-rot13，先对密文进行rot13置换；依然看不出任何逻辑，再进行词频分析,找到flag。\n\n## 解题\n\n对密文进行rot13置换：\n\n```Bash\ncat cry100 | tr A-Za-z N-ZA-Mn-za-m > dec100\n```\n\n再进行[词频分析](https://quipqiup.com/)，找到flag为NO THIS IS NOT CRYPTO MY DEAR。","tags":["攻防世界"],"categories":["crypto"]},{"title":"ctf密码学常用python库","url":"/crypto/CTF-cryptography-uses-Python-libraries.html","content":"## pyCryptodome库\n\n```Bash\npip3 install pyCryptodome -i https://pypi.douban.com/simple\n```\n这个库是实现各种算法和协议的密码模块的集合，包含Cipher，Hash，Protocol，PublicKey，Signature，Util这些子包；\n\n### Cipher子包\n\n实现了分组加密(AES，DES，DES3，CAST，Blowfish，RC2)，流加密(RC4，XOR)与公钥加密(RSA PKCS#1与PKCS#1 OAEP，这两个区别在于加密前对数据的填充不同)；如下是文档给出的例子：\n\n```Python\nfrom Crypto.Cipher import AES\nfrom Crypto import Random\nkey = b'Sixteen byte key'\niv = Random.new().read(AES.block_size)\ncipher = AES.new(key, AES.MODE_CFB, iv)\nmsg = iv + cipher.encrypt(b'Attack at dawn')\nprint msg.encode('hex')\n```\n\n有时在解RSA的题时，已经知道了密钥，解出来的flag却是乱码，也许是加了一些填充如OAEP，PKCS#1导致的；这时就需要使用对应的秘钥解密；如下是一个PKCS#1填充的例子，加密的明文(字节)长度必须严格小于密钥(字节)长度-11\n\n```Python\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5\nfrom gmpy2 import invert\nfrom base64 import b64decode\n\ncip='bT633yPu4dOHEL66eKCHjg6cZb09CElt2mSSQZkRDHk='\n\nn=87924348264132406875276140514499937145050893665602592992418171647042491658461L\ne=65537L\n#http://factordb.com/\np=275127860351348928173285174381581152299L\nq=319576316814478949870590164193048041239L\nphi=(p-1)*(q-1)\nd=invert(e,phi)\n\nprivkey=RSA.construct((n,e,long(d),p,q))\n\n#原生RSA\nprint privkey.decrypt(b64decode(cip))\n\n#PKCS#1填充\nkey= PKCS1_v1_5.new(privkey)\nprint key.decrypt(b64decode(cip),'')\n```\n\n再举个OAEP填充的例子，加密的明文(字节)长度必须严格小于密钥(字节)长度减去41；你可以试一下在下面代码中的明文中多加一个字符运行就会报错。\n\n```Python\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_OAEP\nfrom base64 import b64encode,b64decode\n\nrsa_key=RSA.generate(1024)\nkey=PKCS1_OAEP.new(rsa_key)\ncip=b64encode(key.encrypt('PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}abcdef'))\nprint cip\n\nmsg=key.decrypt(b64decode(cip))\nprint msg\n```\n\n### Hash子包\n\n实现了哈希算法(MD2，MD4，MD5，RIPEMD，SHA，SHA224，SHA256，SHA384，SHA512，HMAC，hashalgo)；如下是文档给出的例子：\n\n```Python\nfrom Crypto.Hash import MD2\nh = MD2.new()\nh.update(b'Hello')\nprint h.hexdigest()\n```\n\n但是没有实现SHA1，要使用SHA1，需要导入hashlib库，正好验证一下Google之前给出的求得两个 sha1 值一样的pdf对：https://shattered.io/\n\n```Python\nfrom hashlib import sha1\n\nwith open('shattered-1.pdf','rb') as f1:\n    da1=f1.read()\nwith open('shattered-2.pdf','rb') as f2:\n    da2=f2.read()\n\nprint sha1(da1).hexdigest()\nprint sha1(da2).hexdigest()\n```\n\n### PublicKey子包\n\n实现了公钥加密和签名算法(RSA，DSA，ElGamal)；文档给出的例子：\n\n```Python\nfrom Crypto.PublicKey import RSA\nkey0 = RSA.generate(2048)\nwith open('mykey.pem','w') as f:\n    f.write(key0.exportKey('PEM'))\n\nwith open('mykey.pem','r') as g:\n    key = RSA.importKey(g.read())\n```\n\n### Util子包\n\n实现了各种有用的模块和功能(Util.number：数论函数，Util.randpool：随机数生成，Util.RFC1751：在128位键和可读的字串之间进行转换，Util.asn1：对ASN.1 DER编码的最小支持)；自己写个例子如下：\n\n```Python\nfrom Crypto.Util import number\ns='this is a demo'\n#字节转换为long型整数\nls=number.bytes_to_long(s)\n\nbits=8*len(s)\n#生成长度为bits的素数\ngp=number.getPrime(bits)\n\n#生成长度小于bits的随机数\ngri=number.getRandomInteger(bits)\n \n#生成长度为bits的随机数\ngrnbi=number.getRandomNBitInteger(bits)\n\n#生成长度不超过bits的随机数\ngrn=number.getRandomNumber(bits)\n \n#生成grn与2*grn之间的随机数\ngrr=number.getRandomRange(grn,2*grn)\n\n#生成强的素数（gsp-1，gsp+1均至少具有一个大的素因子）\ngsp=number.getStrongPrime(1024)\n\n#计算gri在模grn下的逆\niin=number.inverse(gri,grn)\n\n#判断iin是否为素数\nip=number.isPrime(iin)\n\n#long型整数转换为字节\ntb=number.long_to_bytes(ls)\n```\n\n由于这个库很多函数都很有用，因此我们直接使用\n```Python\nfrom Crypto.Util.number import *\n```\n来导入这个包的所有函数。\n\n## pwntools库\n\n```Bash\npip3 install pwntools -i https://pypi.douban.com/simple\n```\n\n这个库内容很多，只介绍比赛中用到的。\n\n### mbruteforce函数\n\n多线程穷举函数，详细定义如下：mbruteforce(func, alphabet, length, method='upto', start=None, threads=None)，其中，\n* func输入参数为字符串，输出布尔值，mbruteforce穷举直到func输出True；\n* alphabet为组成输入参数字符串的字符集合；\n* length指定输入参数字符串的长度上界；\n* method默认为'upto'，指定穷举的字符串长度从1增大到length；另外两个选项为'fixed'、'downfrom'，fixed'指定穷举的字符串长度仅为ength，'downfrom'指定穷举的字符串长度从length减小到1；\n* start=(N,i)，就是把搜索空间分成N块从第i块开始穷举；默认为(1,1)\n* threads指定穷举时的线程数，默认值是内核的数量；\n\n举个例子：\n\n```Python\nfrom pwn import pwnlib\nfrom pwnlib.util.iters import mbruteforce\nmbruteforce(lambda x: x == 'hello','helo',5,method='fixed')\n```\n\n### remote类\n\n用来与服务器交互；常用函数的用法注释到如下脚本中。\n\n```Python\nfrom pwn import pwnlib\nfrom pwnlib.tubes.remote import remote\n\n#创建到远程主机的TCP或udp连接，主机为cn.bing.com，连接主机的端口为443\n#ssl=True代表用SSL包装套接字\nr=remote('cn.bing.com',443,ssl=True)\n\n#向主机发送数据，只不过数据只能是一行\nr.sendline('GET /')\n\n#向主机发送数据，数据可以是多行\nr.send(b'\\r\\n\\r\\n')\n\n##上面两行代码等价于r.send(b'GET /\\r\\n\\r\\n')\n\n#从主机接收4个字节的数据\nre=r.recvn(4)\nprint re\n\n#从主机一直接收数据直到'Please'出现\nre=r.recvuntil('Please')\nprint re\n\n#从主机一直接收数据，最多接收4096字节\nre=r.recv()\nprint re\n\n#关闭连接\nr.close()\n```","tags":["工具","Python"],"categories":["crypto"]},{"title":"RSA攻击大全及其实现","url":"/crypto/RSA-attack-Daquo-and-its-implementation.html","content":"## RSA攻击大全\n\n### 模数分解\n\n* Small q：模数N有小素数因子；\n* fermat：模数N的因子p与q非常接近；\n* 模不互素：给出多组公钥，但是其中的模数共用了素因子；\n\n### 针对指数进行攻击\n\n* 小公钥指数攻击：指数很小；\n* 低加密指数广播攻击：相同的消息发送给多个接收者，且加密指数较低；\n\n### 针对私钥进行攻击\n\n* 维纳攻击：指数很大(理论上$d<N^{0.25}$此攻击起作用)；\n* Boneh-Durfee攻击：同样针对指数很大的情形，理论上$d<N^{0.29}$此攻击起作用；\n\n### Coppersmith相关攻击\n\nCoppersmith算法用于求解模$N$多项式$F(X)$($X$为单变量、二元变量甚至多元变量)所有小整数根($\\big\\|X\\big\\|<cN^{\\beta^{2}/\\delta}$，其中$\\delta$为多项式$F$的次数，假设$N$具有不小于$N^{\\beta}$的因子)\n\n* 明文高位泄露：明文的二进制位表示为$m_{b} \\cdots m_{t+1}m_{t} \\cdots m_{1}$，其高位$m_{b} \\cdots m_{t+1}$泄露，记$m'=m_{b} \\cdots m_{t+1}0 \\cdots 0$，则$m'$已知，但$\\Delta m=m_{t} \\cdots m_{1}$未知；由$c \\equiv m^{e}\\ \\textrm{mod}\\ N$，则$\\Delta m$是模多项式$F(X)=(m'+X)^{e}\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 因子低位泄露：因子的二进制位表示为$p_{b} \\cdots p_{t+1}p_{t} \\cdots p_{1}$，其高位$p_{b} \\cdots p_{t+1}$泄露，记$p'=p_{b} \\cdots p_{t+1}0 \\cdots 0$，则$p'$已知，但$\\Delta p=p_{t} \\cdots p_{1}$未知；由$p \\cdot q=N$，则$\\Delta p$是模多项式$F(X)=(p'+X)\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 明文低位泄露：明文的二进制位表示为$m_{b} \\cdots m_{t+1}m_{t} \\cdots m_{1}$，其低位$m_{t} \\cdots m_{1}$泄露，记$m'=m_{t} \\cdots m_{1}$，则$m'$已知，但$\\Delta m=m_{b} \\cdots m_{t+1}$未知；由$c \\equiv m^{e}\\ \\textrm{mod}\\ N$，则$\\Delta m$是模多项式$F(X)=(m'+2^{t}X)^{e}\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 因子低位泄露：因子的二进制位表示为$p_{b} \\cdots p_{t+1}p_{t} \\cdots p_{1}$，其低位$p_{t} \\cdots p_{1}$泄露，记$p'=p_{t} \\cdots p_{1}$，则$p'$已知，但$\\Delta p=p_{b} \\cdots p_{t+1}$未知；由$p \\cdot q=N$，则$\\Delta p$是模多项式$F(X)=(p'+2^{t}X)\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n[GithHub实现链接](https://github.com/mimoo/RSA-and-LLL-attacks)\n\n## 攻击工具\n\n### RsaCtfTool\nGitHub链接：[RsaCtfTool](https://github.com/Ganapati/RsaCtfTool)\n\n在Ubuntu18.04下的安装RsaCtfTool(进入RsaCtfTool目录下)：\n\n```Bash\napt install -y libgmp-dev\napt install -y libmpfr-dev\napt install -y libmpc-dev\npip3 install gmpy2 -i https://pypi.douban.com/simple\npip3 install -r requirements.txt -i https://pypi.douban.com/simple\n```\n\n### yafu\n\n我认为最强大的分解因子的工具。\n\n### 在线分解因子网站\n\n[factordb](http://factordb.com/)","tags":["密码学知识","工具","RSA"],"categories":["crypto"]},{"title":"b32&64encode详解","url":"/crypto/B32-64-encode-explanation.html","content":"以前只是用这些函数，从没想过这些编码的原理；还是因为一道ctf题让我好好的了解了一下这些编码方式！\n\n## b32encode\n\n我们知道每个字节是8比特，b32encode将5个字节分成8块，每块前三位补0，从而将5个字节扩展为8个字节；那么扩展后的每个字节的值不超过32，与32个字符\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"对应，有时我们发现编码的字符串中还有\"=\"这个字符，但是它是填充字符，以上就是b32encode；用Python写一个脚本来帮助理解：\n```Python\nfrom string import uppercase,digits\nfrom base64 import b32encode\n\ndef my_b32encode(s):\n    base=uppercase+digits[2:8]\n    assert(len(s))==5\n    bs=''.join([bin(ord(x))[2:].rjust(8,'0') for x in s])\n    assert len(bs)==40\n    sbs=[bs[5*ind:5*(ind+1)] for ind in range(8)]\n    re=[base[int(x,2)] for x in sbs]\n    return ''.join(re)\n\nif __name__=='__main__':\n    print my_b32encode('BITSC')\n    print b32encode('BITSC')\n```\n\n## b64encode\n\nb64encode将3个字节分成4块，每块前两位补0，从而将3个字节扩展为4个字节；那么扩展后的每个字节的值不超过64，与64个字符 \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"对应，同样地，\"=\"作为填充字符，以上就是b64encode；用Python写一个脚本来帮助理解：\n```Python\nfrom string import uppercase,lowercase,digits\nfrom base64 import b64encode\n\ndef my_b64encode(s):\n    base=uppercase+lowercase+digits+'+/'\n    assert len(s)==3\n    bs=''.join([bin(ord(x))[2:].rjust(8,'0') for x in s])\n    assert len(bs)==24\n    sbs=[bs[6*ind:6*(ind+1)] for ind in range(4)]\n    re=[base[int(x,2)] for x in sbs]\n    return ''.join(re)\n\nif __name__=='__main__':\n    print my_b64encode('BIT')\n    print b64encode('BIT')\n```","tags":["密码学知识","base64"],"categories":["crypto"]},{"title":"WMCTF2020密码学部分详解","url":"/crypto/WMCTF2020-Cryptography-Part-Detail.html","content":"比赛网址：[WMCTF2020](https://adworld.xctf.org.cn/match/contest_challenge?event=146&hash=684a58cc-1140-4937-99f2-ef347d777d9f.event)\n\n## piece_of_cake\n\n### 题目信息\n附件是一个py脚本，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/WMCTF/piece_of_cake)中的task.py。\n\n### 分析\n\neat_cake函数中的各个变量的定义如下：\n\n* $p,q$为512位随机素数，$ph=(p-1) \\cdot (q+1),N=p \\cdot q,d=e^{-1}\\ \\textrm{mod}\\ ph$\n\n* $cake$为768位随机素数，$q$重新赋值为1536位随机素数，将$d$的值赋给$f$，$g$为随机素数，$g$的位数等于$q$的位数减去$f$的位数再减去1\n\n* $h=f^{-1} \\cdot g\\ \\textrm{mod}\\ q$，$r$为512位随机素数，$c=(r \\cdot h+cake)\\ \\textrm{mod}\\ q$\n\n由：\n$$\nh=f^{-1} \\cdot g\\ \\textrm{mod}\\ q\n$$\n可得：\n$$\nf \\cdot h \\equiv g\\ \\textrm{mod}\\ q\n$$\n即存在$t\\in Z$，使得：\n$$\nf \\cdot h-t \\cdot q=g\n$$\n构造矩阵$M$如下：\n$$\nM=\\begin{pmatrix}\n1 & h\\\\\n0 & q\n\\end{pmatrix}\n$$\n则有：\n$$\n\\begin{pmatrix}\nf & -t\n\\end{pmatrix} \\cdot \\begin{pmatrix}\n1 & h\\\\\n0 & q\n\\end{pmatrix} = \\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$$\n则$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$是格$L(M)$上的短格基，因此有可能可使用LLL算法或BKZ算法求出，这里说有可能求出，因为在解题时并不是每次都能找到短格基$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$\n假设我们求出的短格基为$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$，再由公式$c=(r \\cdot h+cake)\\ \\textrm{mod}\\ q$\n\n则：\n\n$$\nf \\cdot c \\equiv f \\cdot (r \\cdot h+cake) \\equiv (r \\cdot g+f \\cdot cake)\\ \\textrm{mod}\\ q\n$$\n\n\n从而：\n\n$$\n(r \\cdot g+f \\cdot cake)= f \\cdot c\\ \\textrm{mod}\\ q\n$$\n\n\n两边模$g$可得：\n\n$$\nf \\cdot cake \\equiv (f \\cdot c\\ \\textrm{mod}\\ q)\\ \\textrm{mod}\\ g\n$$\n\n\n于是：\n\n$$\ncake=f^{-1} \\cdot (f \\cdot c\\ \\textrm{mod}\\ q)\\ \\textrm{mod}\\ g\n$$\n\n\n注意，上面等式中$f^{-1}$是$f$在$g$下的逆，不能与括号内的$f$抵消。\n\n### 解题\n\n上述链接中的solve.sage为解题的sage脚本。\n\n### 备注\n\n此exp并不能保证次次成功！不过它的有效性不可否认，上述链接中的test.sage即可验证。\n\n以下是我对test.sage四次的运行结果：\n\n```Bash\n$ sage test.sage\nsuccess! 48 -th\n$ sage test.sage\nsuccess! 2 -th\n$ sage test.sage\nsuccess! 50 -th\n$ sage test.sage\nsuccess! 24 -th\n```\n\n从而验证了解题脚本solve.sage的有效性。\n\n## babySum\n\n### 题目信息\n\n附件是两个py脚本与一个json文件，[Gitee备份](https://gitee.com/chu-kangming/CTFs-Crypto/tree/master/2020/WMCTF/babySum)中的task.py与check.py。\n\n### 分析\n\ntask.py告诉我们生成data中数据的逻辑，其实很好理解：生成$n=120$个150位的随机数，组成数组$A$，从中选$k=20$个相加生成和$s$；\n\n记数组$A=[a_{1},\\cdots,a_{n}]$，check.py读入120个数$b_{1},\\cdots,b_{n}(b_{i}={0,1})$，其中20个为1，另外100个为1，检验$\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s$，如果等式成立，就打印出flag。\n\n到这里我们共有3个约束条件：\n$$\n\\begin{cases}\n\\sum_{i=1}^{n}b_{i}=k\\\\\n\\\\\n\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s\\\\\n\\\\\nb_{i}=0,1;i=1,\\cdots,n\n\\end{cases}\n$$\n遇到这种问题一般转化为格基约减问题，构造矩阵$M$如下：\n$$\nM=\n\\begin{pmatrix}\n1 &   &   &   & a_{1} & 1 \\\\\n  & 1 &   &   & a_{2} & 1 \\\\\n  &   &\\ddots &   &\\vdots &\\vdots \\\\\n  &   &   & 1 & a_{n} & 1 \\\\\n  &   &   &   & -s & -k &\n\\end{pmatrix}\n$$\n\n\n那么$\n\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 1\n\\end{pmatrix} \\cdot M=\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 0 & 0\n\\end{pmatrix}\n$\n\n即通过格基约减可以求出$b_{1},\\cdots,b_{n}$。\n\n理想很丰满，现实很骨感！\n\n约减后的格基无法达到我们需要的结果！直到看到writeup，这里需要记住一个很有用的技巧，可类比约束优化问题对约束条件的处理，当不满足如下约束条件时\n$$\n\\begin{cases}\n\\sum_{i=1}^{n}b_{i}=k\\\\\n\\\\\n\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s\n\\end{cases}\n$$\n\n\n\n\n加大“惩罚”，我们重新设计格基矩阵$M$如下：\n$$\nM=\n\\begin{pmatrix}\n1 &   &   &   & N \\cdot a_{1} & N \\\\\n  & 1 &   &   & N \\cdot a_{2} & N \\\\\n  &   &\\ddots &   &\\vdots &\\vdots \\\\\n  &   &   & 1 & N \\cdot a_{n} & N \\\\\n  &   &   &   & -N \\cdot s & -N \\cdot k &\n\\end{pmatrix}\n$$\n其中$N=[\\sqrt{n}]$，此时仍然有$\n\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 1\n\\end{pmatrix} \\cdot M=\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 0 & 0\n\\end{pmatrix}\n$\n\n然后就是比较玄学的问题，对同一格，改变格基矩阵行的顺序，约减的结果也会不同，官方的writeup就是不断打乱格基矩阵的行，然后进行格基约减；再就是为了更快得到结果，需要进行多线程编程；上述链接中的solve.sage为解题的sage脚本；官方设置的8个线程，我自己改成6个线程，跑了几次，基本上都是20分钟左右出结果。\n\n```Bash\n$ sage solve.sage   \n(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0)\ncost time:  0:25:27\n```","tags":["CTF比赛","number","LLL"],"categories":["crypto"]},{"title":"攻防世界-密码学-说我作弊需要证据","url":"/crypto/xctf-Need-proof-that-I-cheated.html","content":"## 题目信息\n\n题目背景为在一次考试中两名学生作弊，给出他们的RSA公钥，附件两者通信的pcapng流量包。\n\n## 分析\n\n鉴于Alice与Bob的密钥位数如此地低，通过yafu或者去[factordb](http://factordb.com/)立马就分解出模数，进而计算出私钥。\n\n用wireshark打开流量包，按下Ctrl+Alt+Shift+T快捷键来追踪TCP流(并保存下来，比如我保存为data.txt)；通过数据格式应该可以确定是base64编码后的数据格式，那么先解码前三个看看编码的数据；\n```Bash\nSEQ = 13; DATA = 0x3b04b26a0adada2f67326bb0c5d6L; SIG = 0x2e5ab24f9dc21df406a87de0b3b4L;\nSEQ = 0; DATA = 0x7492f4ec9001202dcb569df468b4L; SIG = 0xc9107666b1cc040a4fc2e89e3e7L;\nSEQ = 5; DATA = 0x94d97e04f52c2d6f42f9aacbf0b5L; SIG = 0x1e3b6d4eaf11582e85ead4bf90a9L;\n```\n\nDATA应该是密文，但是另外两个数据也很重要，SEQ是明文的顺序，SIG是对明文的签名；因此对保存的TCP流依次解码，使用Bob的私钥对密文DATA解密，再验证SIG是否为Alice对明文的签名，如果是则放到明文列表的第SEQ位置；\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom Crypto.PublicKey import RSA\nfrom gmpy2 import invert,powmod\nfrom base64 import b64decode\n\ndef solve():\n    N1=0x53a121a11e36d7a84dde3f5d73cfL\n    N2=0x99122e61dc7bede74711185598c7L\n    e=0x10001L\n#   p1,q1=38456719616722997L,44106885765559411L\n    p2,q2=49662237675630289L,62515288803124247L\n    \n#   phi1=(p1-1)*(q1-1)\n    phi2=(p2-1)*(q2-1)\n#   d1=invert(e,phi1)\n    d2=invert(e,phi2)\n    \n#   rsa_key1=RSA.construct((N1,e,long(d1),p1,q1))\n    rsa_key2=RSA.construct((N2,e,long(d2),p2,q2))\n\n    with open('data.txt','r') as f:\n        data=f.read()\n\n    cips=data.split('\\n')\n    res=['']*len(cips)\n    for cip in cips[:-1]:\n        data=b64decode(cip)\n        seq=int(data[(data.find('= ')+2):data.find(';')])\n        cipher=data[(data.find('x')+1):data.find('L')]\n        sig=data[(data.rfind('x')+1):data.rfind('L')]\n        msg=rsa_key2.decrypt(long(cipher,16))\n        if msg==powmod(long(sig,16),e,N1):\n            res[seq]+=chr(msg)\n    return res\n\nif __name__=='__main__':\n    #python solve.py\n    print ''.join(solve())\n```\n\n运行结果如下：\n\n```Bash\n$ python solve.py\nflag{n0th1ng_t0_533_h3r3_m0v3_0n}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-Easy one","url":"/crypto/xctf-Easy-One.html","content":"## 题目信息\n\n题目这样描述：“破解密文，解密msg002.enc文件”，并且提供附件下载，附件中有4个文件：encryptor.c、msg001、msg001.enc与msg002.enc。\n\n## 分析\n\nencryptor.c向我们展示了加密的原理,\n\n```C\nc = (p + (k[i % strlen(k)] ^ t) + i*i) & 0xff;\n```\n对明文的每个字符p，按照上述代码生成密文c，之后t更新为p，i增1，再加密下一个字符。只不过，当我写了对应的解密程序进行解密时，得到的明文是乱码。\n\n我用encryptor.c重新加密了一遍msg001，发现得到的密文与所给的msg001.enc不同，结合加密程序分析，怀疑t的初值或者k被“做了手脚”，我首先穷举了t的256个初值，发现加密的结果均与msg001.enc不同，那么应该是真正加密所用的k并不是encryptor.c展示的k，所以第一步应该解出真正加密所用的k，根据加密原理，k的每一个字符x都能通过下式求出，也就是考察已知明密文求解密钥。\n\n```Python\nx=(ord(c)-ord(m)-ii*ii)&0xff\nx^=t\n```\n\n## 解题\n\n由密文求明文的程序很简单，难点在于你需要先通过msg001、msg001.enc求解出真正加密所用的密钥。\n\n```Python\ndef get_true_key(msg_data,cip_data):\n    xs=''\n    ii,t=0,0\n    for m,c in zip(msg_data,cip_data):\n        x=(ord(c)-ord(m)-ii*ii)&0xff\n        x^=t\n        t=ord(m)\n        ii+=1\n        xs+=chr(x)\n    return xs[:(xs[1:].find(xs[0])+1)]\n\ndef test(msg_data,cip_data,o_k):\n    tt=0\n    cip=''\n    lk=len(o_k)\n    for ii,m in enumerate(msg_data):\n        c=(ord(m)+(o_k[ii%lk]^tt)+ii*ii)&0xff\n        cip+=chr(c)\n        tt=ord(m)\n    return all(x==c for x,c in zip(cip,cip_data))\n\ndef solve():\n    with open('msg001','r') as f:\n        msg_data=f.read().strip()\n    with open('msg001.enc','r') as f:\n        cip_data=f.read().strip()\n    with open('msg002.enc','r') as f:\n        data=f.read().strip()\n    k=get_true_key(msg_data,cip_data)\n    print 'the true key is : ',k\n    o_k=[ord(c) for c in k]\n    assert test(msg_data,cip_data,o_k)\n    t=0\n    msg=''\n    for ii,c in enumerate(data):\n        p=(ord(c)-ii*ii-(o_k[ii%28]^t))&0xff\n        t=p\n        msg+=chr(p)\n    with open('msg002','w') as f:\n        f.write(msg)\n    return msg\n\nif __name__=='__main__':\n#   python solve.py\n    print solve().strip()\n```\n\n解出加密所用密钥，破解密文：\n\n```Bash\n$ python solve.py\nthe true key is : VeryLongKeyYouWillNeverGuess\nThe known-plaintext attack (KPA) is an attack model for cryptanalysis where the attacker has samples of both the plaintext (called a crib), and its encrypted version (ciphertext). These can be used to reveal further secret information such as secret keys and code books. The term \"crib\" originated at Bletchley Park, the British World War II decryption operation. \nThe flag is CTF{6d5eba48508efb13dc87220879306619}\n```\n简要介绍了已知明文攻击之后，后面给出flag。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-wtc_rsa_bbq","url":"/crypto/xctf-WTC-RSA-BBQ.html","content":"## 题目信息\n\n附件是一个压缩包，解压之后还是一个压缩包，再解压(禁止套娃!!!)得一个文件夹，里面包含公钥(key.pem)与密文(cipher.bin)信息。\n\n## 分析\n\n使用openssl查看公钥信息：\n\n```Bash\nopenssl rsa -pubin -in key.pem -text -modulus\n```\n\n发现模数很大，8587位；本来分解模数无脑丢到yafu里面分解就行，但是几个小时都没有分解出来，去[factordb](http://factordb.com/)也分解不出来；回顾针对RSA的各种攻击，对本题可以使用的剩下Small q,费马分解(p与q接近)，试着用费马分解时分解成功。\n\n## 解题\n\n使用工具[RSACTFTool](https://github.com/Ganapati/RsaCtfTool)进行分解,将key.pem与cipher.bin移到与RsaCtfTool.py同目录下：\n\n```Bash\nsudo python3 RsaCtfTool.py --publickey key.pem --uncipherfile cipher.bin --attack fermat\n```\n\n在明文最后给出flag为flag{how_d0_you_7urn_this_0n?}。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-banana-princess","url":"/crypto/xctf-Banana-Princess.html","content":"## 题目信息\n\n附件给出一个PDF文件，但是用阅读器打开显示文件已损坏。\n\n## 分析\n\n用vim打开PDF文件，开头为%CQS-1.5，既然是PDF文件，那就找找CQS与PDF的关系，首先想到的是凯撒密码，结果发现这三个字母均在字母表中相隔13，另外PDF文件中的小写字母也需要进行解密替换。\n\n## 解题\n使用Shell，一行就可以完成解密：\n\n```Bash\n$ cat cip.pdf | tr A-Za-z N-ZA-Mn-za-m > msg.pdf\n```\n\n结果发现flag被遮住了，另存为图片，flag可见，为BITSCTF{save_the_kid}。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-你猜猜","url":"/crypto/xctf-Guess.html","content":"## 题目信息\n\n附件是一个文本文件，里面是一串16进制数据。\n\n## 分析\n\n504B0304开头一般代表zip数据(另外还有526172211a0701开头代表rar数据，377abcaf271c开头代表7z数据)，于是将这一串16进制数据另存为一个zip文件，不用说，压缩时肯定进行了加密，使用fcrackzip工具进行破解。\n\n## 解题\n\n首先使用Python将16进制数据另存为一个zip文件：\n\n```Python\nfrom Crypto.Util.number import long_to_bytes\n\ns=0x504B03040A0001080000626D0A49F4B5091F1E0000001200000008000000666C61672E7478746C9F170D35D0A45826A03E161FB96870EDDFC7C89A11862F9199B4CD78E7504B01023F000A0001080000626D0A49F4B5091F1E00000012000000080024000000000000002000000000000000666C61672E7478740A0020000000000001001800AF150210CAF2D1015CAEAA05CAF2D1015CAEAA05CAF2D101504B050600000000010001005A000000440000000000\nwith open('data.zip','wb') as f:\n    f.write(long_to_bytes(s))\n```\n\n再使用fcrackzip工具破解密码：\n\n```Bash\n$ fcrackzip -b -c '1' -l 4-8 -u data.zip\n\nPASSWORD FOUND!!!!: pw == 123456\n```\n解密得到flag.txt，里面保存着flag。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-sherlock","url":"/crypto/xctf-Sherlock.html","content":"## 题目信息\n\n附件是网页上的一篇文章，先复制到txt中保存。\n\n## 分析\n\n如下是文章开头：\n\n```Bash\n(additional editing by jose menendeZ)\n\nthE adventuRes Of\nsherlOck holmes\n\nby\n\nsir arthur coNan doylE\n```\n\n奇怪之处是有些位置不应该使用大写字母，但是使用了大写字母，推断这些大写字母是用来传递消息的。将文章中的所有大写字母提取出来，得到一串全部由ZERO与ONE组成的字符串，ZERO替换为数字0，ONE替换为数字1，从而得到一个二进制表示的数，再将此数转换为字符串即可。\n\n## 解题\n\nPython代码如下：\n\n```Python\nfrom string import uppercase\nfrom Crypto.Util.number import long_to_bytes\n\ndef solve():\n    with open('paper','r') as f:\n        data=f.read()\n    cip=''\n    for c in data:\n        if c in uppercase:\n            cip+=c\n    cip=cip.replace('ZERO','0')\n    cip=cip.replace('ONE','1')\n    return long_to_bytes(long(cip,2))\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nBITSCTF{h1d3_1n_pl41n_5173}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-告诉你一个秘密","url":"/crypto/xctf-Tells-you-a-secret.html","content":"## 题目信息\n\n附件为两行数字与字母组成的字符串。\n\n## 分析\n\n字符串中的字母均未超过E，猜测是16进制编码，于是先将字符串进行16进制解码，解码之后看上去像base64编码，于是接着进行base64解码，得到两段全由字母组成的字符串，并且被空格隔开，每小段字符串包含3-4个字母，解密的方法就在眼前——键盘，每小段字符串的字母围起来的字母就是明文。\n\n## 解题\n\nPython代码如下：\n\n```Python\nfrom base64 import b64decode\n\ndef solve():\n    cips=[\n            '636A56355279427363446C4A49454A7154534230526D6843',\n            '56445A31614342354E326C4B4946467A5769426961453067'\n            ]\n    msgs=[]\n    for cip in cips:\n        msgs.append(b64decode(cip.decode('hex')))\n    return msgs\n\nif __name__=='__main__':\n    print solve()\n```\n\n运行程序得到如下结果：\n\n```Bash\n$ python solve.py\n['r5yG lp9I BjM tFhB', 'T6uh y7iJ QsZ bhM ']\n```\n\n接下来在键盘上找每小段字符串的字母围起来的字母，得到flag为tongyuan。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-flag in your hand","url":"/crypto/xctf-Flag-in-Your-Hand.html","content":"## 题目信息\n\n题目给了两个文件：index.html与script-min.js。\n\n## 分析\n\n先分析index.html的逻辑，第58行：\n\n```HTML\n<input type=\"button\" value=\"Get flag!\" onclick=\"getFlag()\" />\n```\n\n结合浏览器打开index.html的效果，我们知道点击 'Get flag!' 按钮时会调用getFlag()函数；\n\ngetFlag()函数的定义在第32行：\n```JavaScript\nfunction getFlag() {\n\tvar token = document.getElementById(\"secToken\").value;\n\tic = checkToken(token);\n\tfg = bm(token);\n\tshowFlag()\n}\n```\n\n在显示flag之前会调用checkToken(token)与bm(token)两个函数，我们先看一下显示flag的showFlag()函数，它定义在第39行：\n\n```JavaScript\nfunction showFlag() {\n\tvar t = document.getElementById(\"flagTitle\");\n\tvar f = document.getElementById(\"flag\");\n\tt.innerText = !!ic ? \"You got the flag below!!\" : \"Wrong!\";\n\tt.className = !!ic ? \"rightflag\" : \"wrongflag\";\n\tf.innerText = fg;\n}\n```\n\n可以看到是通过ic的布尔值判断我们是否输入正确的token，而ic由函数checkToken(token)返回，跳转到script-min.js中定义函数checkToken的地方看一下：\n\n```JavaScript\nfunction checkToken(s) {\n    return s === \"FAKE-TOKEN\";\n}\n```\n\n难不成FAKE-TOKEN就是正确的token？当然不是，还是抱着希望去试了一下，果然不是！那么问题只能出在函数bm中，它改变了ic的布尔值！\n\n于是去看一下函数bm，它定义如下：\n\n```JavaScript\nfunction bm(s){\n\treturn rb(rstr(str2rstr_utf8(s)));\n}\n```\n\n函数str2rstr_utf8与rb并没有改变ic的布尔值，是rstr调用的函数ck改变了ic的布尔值；函数ck的定义如下：\n\n```JavaScript\nfunction ck(s){\n    try {\n        ic\n    } catch (e) {\n        return;\n    }\n    var a = [118, 104, 102, 120, 117, 108, 119, 124, 48,123,101,120];\n    if (s.length == a.length) {\n        for (i = 0; i < s.length; i++) {\n            if (a[i] - s.charCodeAt(i) != 3)\n                return ic = false;\n        }\n        return ic = true;\n    }\n    return ic = false;\n}\n```\n\n看到这里明白了，checkToken就是个幌子，这里才决定ic布尔值！对函数ic的输入参数(字符串)s，只有s与列表a等长，且s每个字符在ascii表中的序号比列表a中每个对应元素小3时，ic才为True。\n\n于是可以写个python脚本求一下这里会让ic=True的s：\n\n```Python\na=[118,104,102,120,117,108,119,124,48,123,101,120];\nprint ''.join([chr(x-3) for x in a])\n```\n\n得到s为security-xbu字符串。\n\n综上，当函数ck的输入为字符串security-xbu时，会使ic的布尔值为True，从而得到正确的flag；通过分析调用过程，函数ck的输入为str2rstr_utf8(token)，那么token为何值时str2rstr_utf8(token)为字符串security-xbu呢？是不是要写个str2rstr_utf8的逆程序？其实不用，我们将script-min.js中的函数bm改一下，如下：\n\n```JavaScript\nfunction bm(s){\n\t//return rb(rstr(str2rstr_utf8(s)));\n\treturn rb(rstr(s))\n}\n```\n\n刷新index.html，填入security-xbu，就可以得到正确的flag！","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-工业协议分析2","url":"/crypto/xctf-Industrial-Protocol-Analysis-II.html","content":"## 题目信息\n\n在进行工业企业检查评估工作中，发现了疑似感染恶意软件的上位机。现已提取出上位机通信流量，尝试分析出异常点，获取FLAG。 flag形式为 flag{}。\n\n## 分析\n字符串'flag'的16进制编码为0x666c6167，在筛选器输入data contains \"666c61677b\"筛选包含666c61677b的流量包，筛选出两个包。\n\n## 解题\n任选一个提取出数据666c61677b37466f4d3253746b6865507a7d，再进行16进制解码得到flag{7FoM2StkhePz}","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-新手练习区","url":"/crypto/xctf-Beginner-Practice-Area.html","content":"## Caeser\n\n凯撒密码：替换加密——明文中的所有字母都在字母表上向后按照一个固定数目offset进行偏移后被替换成密文。由于不知道偏移量，因此将每个偏移量都试一下进行解密;事实上，解密过程既可以看作密文中的所有字母都在字母表上向前按照一个固定数目offset进行偏移，也可以看作密文中的所有字母都在字母表上向后按照一个固定数目(26-offset)进行偏移！\n\n如下是解题的Python代码：\n\n```Python\nfrom string import lowercase\n\nclass Caeser():\n    def __init__(self,dic=None):\n        if dic==None:\n            self.dic=lowercase\n        else:\n            self.dic=dic\n\n    def enc(self,msg,ofst):\n        dic=self.dic\n        ld=len(dic)\n        cip=''\n        for c in msg:\n            if c in dic:\n                index=dic.find(c)\n                cip+=dic[(index+ofst)%ld]\n            else:\n                cip+=c\n        return cip\n\ndef solve():\n    msg='oknqdbqmoq{kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz}'\n    caeser=Caeser()\n    for ii in range(len(caeser.dic)):\n        print caeser.enc(msg,ii)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp1.py\noknqdbqmoq{kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz}\nplorecrnpr{lbh_unir_yrnearq_pnrfne_rapelcgvba}\nqmpsfdsoqs{mci_vojs_zsofbsr_qosgof_sbqfmdhwcb}\nrnqtgetprt{ndj_wpkt_atpgcts_rpthpg_tcrgneixdc}\nsoruhfuqsu{oek_xqlu_buqhdut_squiqh_udshofjyed}\ntpsvigvrtv{pfl_yrmv_cvrievu_trvjri_vetipgkzfe}\nuqtwjhwsuw{qgm_zsnw_dwsjfwv_uswksj_wfujqhlagf}\nvruxkixtvx{rhn_atox_extkgxw_vtxltk_xgvkrimbhg}\nwsvyljyuwy{sio_bupy_fyulhyx_wuymul_yhwlsjncih}\nxtwzmkzvxz{tjp_cvqz_gzvmizy_xvznvm_zixmtkodji}\nyuxanlawya{ukq_dwra_hawnjaz_ywaown_ajynulpekj}\nzvybombxzb{vlr_exsb_ibxokba_zxbpxo_bkzovmqflk}\nawzcpncyac{wms_fytc_jcyplcb_aycqyp_clapwnrgml}\nbxadqodzbd{xnt_gzud_kdzqmdc_bzdrzq_dmbqxoshnm}\ncyberpeace{you_have_learned_caesar_encryption}\ndzcfsqfbdf{zpv_ibwf_mfbsofe_dbftbs_fodszqujpo}\neadgtrgceg{aqw_jcxg_ngctpgf_ecguct_gpetarvkqp}\nfbehushdfh{brx_kdyh_ohduqhg_fdhvdu_hqfubswlrq}\ngcfivtiegi{csy_lezi_pievrih_geiwev_irgvctxmsr}\nhdgjwujfhj{dtz_mfaj_qjfwsji_hfjxfw_jshwduynts}\niehkxvkgik{eua_ngbk_rkgxtkj_igkygx_ktixevzout}\njfilywlhjl{fvb_ohcl_slhyulk_jhlzhy_lujyfwapvu}\nkgjmzxmikm{gwc_pidm_tmizvml_kimaiz_mvkzgxbqwv}\nlhknaynjln{hxd_qjen_unjawnm_ljnbja_nwlahycrxw}\nmilobzokmo{iye_rkfo_vokbxon_mkockb_oxmbizdsyx}\nnjmpcaplnp{jzf_slgp_wplcypo_nlpdlc_pyncjaetzy}\n```\n\n看上去像句人话的就是cyberpeace{you_have_learned_caesar_encryption}，这就是flag。\n\n## Morse\n\n摩尔斯密码：使用0,1两种状态的二进制代码组合表示字母与数字；解密就是一个查找操作。如下是解题的Python代码：\n\n```Python\n#Morse Code\n\nclass Morse():\n    def __init__(self):\n        self.dic = {'a': '01',     'b': '1000',   'c': '1010',\n                'd': '100',    'e': '0',      'f': '0010',\n                'g': '110',    'h': '0000',   'i': '00',\n                'j': '0111',   'k': '101',    'l': '0100',\n                'm': '11',     'n': '10',     'o': '111',\n                'p': '0110',   'q': '1101',   'r': '010',\n                's': '000',    't': '1',      'u': '001',\n                'v': '0001',   'w': '011',    'x': '1001',\n                'y': '1011',   'z': '1100',   '_': '001101',\n                '0': '11111',  '1': '01111',  '2': '00111',\n                '3': '00011',  '4': '00001',  '5': '00000',\n                '6': '10000',  '7': '11000',  '8': '11100',\n                '9': '11110'\n                }\n\n    def enc(self,msg):\n        cip=''\n        dic=self.dic\n        for c in msg:\n            cip+=dic[c]\n            cip+=''\n        return cip\n\n    def dec(self,cip):\n        msg=''\n        dic=self.dic\n        key=list(dic.keys())\n        val=list(dic.values())\n        for c in cip.split():\n            msg+=key[val.index(c)]\n        return msg\n\ndef solve():\n    cip='11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110'\n    morse=Morse()\n    print morse.dec(cip)\n\nif __name__=='__main__':\n#   python wp2.py\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp2.py\nmorsecodeissointeresting\n```\n\n## 不仅仅是Morse\n\n由于得到的数据格式与上一个相同，因此仍然进行Morse解密，解密出\n```Bash\nmay_be_have_another_decodehhhhaaaaabaabbbaabbaaaaaaaabaababaaaaaaabbabaaabbaaabbaabaaaababaabaaabbabaaabaaabaababbaabbbabaaabababbaaabbabaaabaabaabaaaabbabbaabbaabaabaaabaabaabaababaabbabaaaabbabaabba\n```\n\n这还不是明文，提示你还需要一种解码；这种密码是培根密码：替换密码——根据所给表对应转换即可加密解密。\n\n如下是解题的Python代码：\n\n```Python\n#Morse code + Bacon cipher\n\nfrom wp2 import Morse\n\nclass Bacon():\n    def __init__(self):\n        self.dic={'a':'aaaaa','b':'aaaab','c':'aaaba','d':'aaabb',\n                'e':'aabaa','f':'aabab','g':'aabba','h':'aabbb',\n                'i':'abaaa','j':'abaab','k':'ababa','l':'ababb',\n                'm':'abbaa','n':'abbab','o':'abbba','p':'abbbb',\n                'q':'baaaa','r':'baaab','s':'baaba','t':'baabb',\n                'u':'babaa','v':'babab','w':'babba','x':'babbb',\n                'y':'bbaaa','z':'bbaab'\n                }\n\n    def enc(self,msg):\n        cip=''\n        dic=self.dic\n        for c in msg:\n            cip+=dic[c]\n        return cip\n\n    def dec(self,cip):\n        msg=''\n        dic=self.dic\n        key=list(dic.keys())\n        val=list(dic.values())\n        for c in [cip[5*ii:5*(ii+1)] for ii in range(len(cip)/5)]:\n            msg+=key[val.index(c)]\n        return msg\n\ndef solve():\n    cip='11 01 1011 001101 1000 0 001101 0000 01 0001 0 001101 01 10 111 1 0000 0 010 001101 100 0 1010 111 100 0 0000 0000 0000 0000 01 01 01 01 01 1000 01 01 1000 1000 1000 01 01 1000 1000 01 01 01 01 01 01 01 01 1000 01 01 1000 01 1000 01 01 01 01 01 01 01 1000 1000 01 1000 01 01 01 1000 1000 01 01 01 1000 1000 01 01 1000 01 01 01 01 1000 01 1000 01 01 1000 01 01 01 1000 1000 01 1000 01 01 01 1000 01 01 01 1000 01 01 1000 01 1000 1000 01 01 1000 1000 1000 01 1000 01 01 01 1000 01 1000 01 1000 1000 01 01 01 1000 1000 01 1000 01 01 01 1000 01 01 1000 01 01 1000 01 01 01 01 1000 1000 01 1000 1000 01 01 1000 1000 01 01 1000 01 01 1000 01 01 01 1000 01 01 1000 01 01 1000 01 01 1000 01 1000 01 01 1000 1000 01 1000 01 01 01 01 1000 1000 01 1000 01 01 1000 1000 01'\n    morse=Morse()\n    cip=morse.dec(cip)\n    print cip\n    cip=cip[cip.find('hhhh')+4:]\n    bacon=Bacon()\n    print bacon.dec(cip)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp3.py\nattackanddefenceworldisinteresting\n```\n\n## 幂数加密\n\n这题实际是云影密码：26个英文字母在字母表中的次序ord(x)<$2^{5}$，因此5位二进制数可以表示一个英文字母，即1,2,4,8,16的组合(求和)可表示一个英文字母，例如L在字母表中的次序为12=4+8，因此组合48就可以表示字母L；同时0作为分隔符。\n\n如下是解题的Python代码：\n\n```Python\ns='8842101220480224404014224202480122'\nls=s.split('0')\ndic='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nm=''\nfor c in ls:\n    t=0\n    for cc in c:\n        t+=int(cc)\n    m+=dic[t-1]\nprint m\n```\n\n运行上述程序：\n\n```Bash\n$ python wp4.py\nWELLDONE\n```\n\n## Railfence\n\n栅栏密码：将明文row个为一组，排列为col行(明文的长度可能小于为row$\\cdot$col，即最后一行可能不会填满)，再将第一列的字母从上至下连接起来，接下来是第二列，直到第row列，生成密文。\n\n但是此题是栅栏密码的一个变种——W型栅栏密码；例如，如下是一个密钥为5的W型栅栏密码，明文为1-19的自然数，将其按照W的形状排列，再由上至下，从左至右连接数字，生成密文[1,9,17,2,8,10,16,18,3,7,11,15,19,4,6,12,14,5,13]。\n\n```Bash\n1             9               17\n  2         8   10          16  18\n    3      7      11      15      19\n      4   6         12  14\n        5             13\n```\n\n如下是解题的Python代码(此题的密钥为5)：\n\n```Python\n#W kind Railfence cipher\n\nclass Railfence_W():\n    def __init__(self,key=2):\n        self.key=key\n\n    def enc(self,msg,mode):\n        #mode = 0 means decrypt,mode = 1 means encrypt\n        ls=len(msg)\n        key=self.key\n        rep=range(0,ls,2*(key-1))\n        for dd in range(1,key-1):\n            ind=dd\n            de1=2*(key-1-dd)\n            de2=2*dd\n            while ind<ls:\n                rep.append(ind)\n                ind+=de1\n                if ind>=ls:\n                    break\n                rep.append(ind)\n                ind+=de2\n        rep.extend(range(key-1,ls,2*(key-1)))\n        if mode:\n            cips=''.join([msg[ii] for ii in rep])\n        else:\n            cip=rep[:]\n            for ii in range(ls):\n                cip[rep[ii]]=msg[ii]\n            cips=''.join(cip)\n        return cips\n\ndef solve():\n    cip='ccehgyaefnpeoobe{lcirg}epriec_ora_g'\n    for step in range(2,8):\n        railfence_w=Railfence_W(step)\n        print railfence_w.enc(cip,0)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp5.py\ncccierhgg}yeaperfinepce_ooorbae_{gl\ncnipceeoeocbhe_{glocyirraga}ee_pfrg\ncal_cecfiornepgr}ehoeapogbr_iey{egc\ncyberpeace{railfence_cipher_gogogo}\ncgecraiioycaore_cgbeefe}_goe{nhplpr\nchfbriaegengcyp{}c__eleaeeocpogrrio\n```\n\n## easychallenge\n\n附件是一个pyc文件，使用uncompyle6进行反编译得到py脚本，脚本中定义了3个编码函数，这3个编码函数都是可逆的，从而可求解出与给定编码数据对应的明文。\n\n如下是解题的Python代码：\n\n```Python\nfrom base64 import b32decode\n\ndef decode1(ans):\n    s = ''\n    for i in ans:\n        x=ord(i)-25\n        x^=36\n        s+=chr(x)\n    return s\n\ndef decode2(ans):\n    s = ''\n    for i in ans:\n        x=ord(i)^36\n        x-=36\n        s+=chr(x)\n    return s\n\ndef decode3(ans):\n    return b32decode(ans)\n\ndef solve():\n    final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E==='\n    return decode1(decode2(decode3(final)))\n\nif __name__=='__main__':\n    print solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp6.py\ncyberpeace{interestinghhhhh}\n```\n\n## 转轮机加密\n\n题目提示托马斯·杰斐逊，搜索一下有一个关于此人的密码——杰斐逊密码：首先，转轮机每一圈有若干字母，共有若干圈；加密时，将转轮机调整至某一列为明文，然后任选其他的某一列，作为密文。因此解密时，转轮机调整至某一列为密文，然后分析其他列，找到语句通顺的就是明文。\n\n如下是解题的Python代码：\n\n```Python\n#Jefferson cipher\n\nclass Jefferson():\n    def __init__(self,key):\n        self.box=[\n                'ZWAXJGDLUBVIQHKYPNTCRMOSFE',\n                'KPBELNACZDTRXMJQOYHGVSFUWI',\n                'BDMAIZVRNSJUWFHTEQGYXPLOCK',\n                'RPLNDVHGFCUKTEBSXQYIZMJWAO',\n                'IHFRLABEUOTSGJVDKCPMNZQWXY',\n                'AMKGHIWPNYCJBFZDRUSLOQXVET',\n                'GWTHSPYBXIZULVKMRAFDCEONJQ',\n                'NOZUTWDCVRJLXKISEFAPMYGHBQ',\n                'XPLTDSRFHENYVUBMCQWAOIKZGJ',\n                'UDNAJFBOWTGVRSCZQKELMXYIHP',\n                'MNBVCXZQWERTPOIUYALSKDJFHG',\n                'LVNCMXZPQOWEIURYTASBKJDFHG',\n                'JZQAWSXCDERFVBGTYHNUMKILOP'\n                ]\n        self.key=key\n\n    def dec(self,cip):\n        box=self.box\n        key=self.key\n        lb=len(box)\n        tbox=[box[x-1] for x in key]\n        assert lb==len(cip)\n        for ii in range(lb):\n            ind=tbox[ii].find(cip[ii])\n            tbox[ii]=tbox[ii][ind:]+tbox[ii][:ind]\n        for ii in range(len(box[0])):\n            print (''.join([x[ii] for x in tbox])).lower()\n\ndef solve():\n    cip='NFQKSEVOQOFNP'\n    key=[2,3,7,5,13,12,9,1,8,10,4,11,6]\n    jefferson=Jefferson(key)\n    jefferson.dec(cip)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp7.py\n...\nsambkvlqsiaav\nfireinthehole\nuzaulcdkfprst\n...\n```\n\n唯一一句人话就是fireinthehole，这就是flag。","tags":["攻防世界"],"categories":["crypto"]},{"title":"简历","url":"/job/SelfIntro.html","content":"\n未完待续...","tags":["introduction"],"categories":["job"]},{"title":"help","url":"/help/index.html","content":"\n**1**这博客很好看，是怎么做的？\n答：本博客使用Hexo制作，采用的jsimple主题，部署在Gitee Pages上，搭建步骤请参考：[使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)](https://chu-kangming.gitee.io/conf/Build-a-personal-blog-based-on-Gitee-Pages-using-Hexo-with-JSimple-Theme.html)，也可以多参考[主题作者的README](https://github.com/tangkunyin/hexo-theme-jsimple/blob/master/README.zhCN.md)\n\n**2**部署到Gitee Pages上面时布局一团糟怎么办？\n答：这可能是因为你没有做到`根目录部署`，导致数据索引不到，同样建议参考[使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)](https://chu-kangming.gitee.io/conf/Build-a-personal-blog-based-on-Gitee-Pages-using-Hexo-with-JSimple-Theme.html)这篇博客，在最后指出如何正确创建`根目录部署`\n\n**3**Gitee Pages与本地的博客效果不一致是为什么？\n答：因为您没有氪金，单用`hexo deploy`是不会更新Gitee Pages的，还需要手动更新，同样建议参考[使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)](https://chu-kangming.gitee.io/conf/Build-a-personal-blog-based-on-Gitee-Pages-using-Hexo-with-JSimple-Theme.html)这篇博客\n\n**4**怎么才能多给我打赏？\n答：好意心领了，我相信千里送鹅毛，礼轻情意重"},{"title":"about","url":"/about/index.html","content":"\n姓名：褚康明\n\n籍贯：湖北省孝感市\n\n本科：西安电子科技大学，数学与应用数学\n\n硕士：中国科学院大学信息工程研究所，电子信息\n\n方向：CTF密码学，Linux内核"},{"title":"tags","url":"/tags/index.html"},{"title":"links","url":"/links/index.html","content":"\n[hexo文档](https://hexo.io/zh-cn/docs/)\n\n[hexo 主题大全](https://hexo.io/themes/)\n\n[jsimple主题](https://github.com/tangkunyin/hexo-theme-jsimple)\n\n[攻防世界](https://adworld.xctf.org.cn)\n\n[pexels](https://www.pexels.com/)\n\n[Gnome-look](https://www.gnome-look.org)\n\n[中文马克思主义文库：毛泽东](https://www.marxists.org/chinese/maozedong/index.htm)\n\n[抗美援朝](http://www.12371.cn/2020/10/12/VIDA1602474174035898.shtml)\n\n[国务院公报](http://www.gov.cn/zwgk/2011-11/09/content_1989024.htm)\n\n\n\n\n\n"}]