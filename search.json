[{"title":"第五章第一节 类","url":"/course/cpp-ch5-par1.html","content":"\n## protected\n\nprotected成员相对于private成员扩大的访问范围表现在：基类的protected成员可以在派生类的成员函数中被访问。\n\n## 继承\n\n```c++\nclass proQueue : public Queue { /* ... ... */ };\n```\n\n类proQueue继承了类Queue；当构造一个派生类对象时，会先调用基类的构造函数；若存在成员是类，会调用成员类的构造函数，最后再调用其自身构造函数，析构函数的调用顺序与之相反。\n\n但是基类的析构函数应设置为虚函数（默认），可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。但是构造函数不能声明为虚函数。\n\n三种继承总结如下图\n\n<div style=\"width:90%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n## 虚继承\n\n虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题\n\n```c++\nclass B :virtual public A{};\n```\n\n## 友元\n\nC++中私有变量对外部类是不能直接访问的，也是不能继承的。\n\n使用友元类可以访问类中的私有方法、私有变量，虽然对类的封装有一定的破坏，但是有时也是很实用的。在实际中，在修改已有代码时，为了不大改动已有代码：\n\n对于没有继承关系的类，如果有关联，使用友元类还是比较方便的。\n\n对于有继承关系的类，如果有关联，可以将变量访问由private改为protected。\n\n总结：\n\n外部类可访问public；\n\n友元类可访问public、protected与private；\n\n子类可访问public与protected；\n\n## 虚函数\n\n使用`virtual`关键字修饰的函数为虚函数，子类需要对基类的虚函数进行重写。当基类指针或引用指向派生类对象时，当使用该指针或引用调用基类的虚函数时，会自动调用派生类实现的函数——动态绑定。\n\n* 存在虚函数的类都有一个一维的虚函数表即虚表。每个存在虚函数的类对应一个虚表，该类实例化的每个对象对应一个虚表指针；\n* 纯虚函数=虚函数=0；\n* 存在至少一个纯虚函数的类即抽象类；抽象类不可实例化，必须由派生类继承重写纯虚函数后。派生类才能被实例化。\n\n## 构造函数\n\n* 缺省构造函数；\n* 拷贝构造函数（参数为const引用）；\n* 移动构造函数（参数为右值引用）；\n* 初始化构造函数（程序员定义）；\n\n## 析构函数\n\n销毁类对象之前调用的函数，替类对象返还相关的资源或自动释放资源。与构造函数相对应。\n\n## 类模板\n\n```c++\ntemplate <class T>\n    class Queue{\n        /* 与类定义的内容相同 */\n    }\n```\n\n","tags":["C++"],"categories":["course"]},{"title":"第四章第一节 域与生命期","url":"/course/cpp-ch4-par1.html","content":"\n## 声明与定义\n\n关键字`extern`为声明但不定义一个对象提供了一种方法，它承诺该对象会在其他地方被定义，一般在公共头文件中声明一次，在源文件中被定义。其他源文件若要使用此对象，包含其声明所在的头文件即可。\n\n## 局部静态对象\n\n由于局部对象在函数返回后会被丢弃，为了使一个局部对象在该函数多次调用中一直有效，就可以将该对象声明为`static`，且函数内局部可见。\n\n## 左值与右值\n\n左值：可寻址的变量；\n\n右值：不可寻址的常量、表达式求值过程中出现的无名临时对象；\n\n","tags":["C++"],"categories":["course"]},{"title":"第三章第一节 函数","url":"/course/cpp-ch3-par1.html","content":"\n## extern \"C\"\n\n链接提示符extern \"C\"表明该函数是用C语言编写的。链接提示符必须放在函数体外，建议放在头文件中。\n\n\n## 重载函数\n\n函数名相同，但是参数列表（参数的类型，数目）不同的函数。\n\n函数重载解析的步骤如下：\n\n* 确定函数调用考虑的重载函数的集合；\n* 从重载函数集合中选择函数，该函数可以在给出实参个数与类型的情况下调用；\n* 选择与调用最匹配的函数；\n\n## 函数模板定义\n\n一种用来自动生成各种函数实例的算法，将函数接口（参数与返回类型）的全部或部分类型进行参数化，而函数体保持不变\n\n```c++\ntemplate <class Type>\nType min (Type a, Type b){\n    return a < b ? a : b;\n}\n```\n\n## 异常处理\n\nC++中异常用类来实现，即针对每一种异常，要定义一个对应的类。如\"栈空时pop异常\"。\n\n```c++\nclass poPOnEmpty{\n    /* ... ... */\n};\n```\n\n在出现异常的时候抛出此异常\n\n```c++\nclass istack{\n    /* ... ... */\n    void pop(){\n        if(! this->empty()){\n            /* ... ... */\n        }\n        else{\n            throw poPOnEmpty();\n        }\n    }\n}\n```\n\n因此，在其他函数调用istack类的pop方法时就有可能出现此异常，使用try-catch来捕获异常\n\n```c++\n{\n    try{\n        stack_context.pop()\n    }\n    catch(poPOnEmpty()){\n        /* ... ... */\n    }\n}\n```\n\n","tags":["C++"],"categories":["course"]},{"title":"第二章第一节 显式类型转换","url":"/course/cpp-ch2-par1.html","content":"\n显式类型转换操作符：static_cast、dynamic_cast、const_cast与reinterpret_cast。\n\n显式转换的形式如下\n\n```c++\n/* cast-name = static_cast | dynamic_cast | const_cast | reinterpret_cast */\ncast-name<type> (expression);\n```\n\n## static_cast\n\n编译器隐式执行的任何类型转换都可以由static_cast显式完成。\n\nQ：为何要这样做\n\nA：因为从一个较大类型到一个较小类型的赋值 会导致编译器产生一个警告以提醒我们潜在的精度损失 当我们提供显式强制转换时 警告消息被关闭 强制转换告诉编译器和程序的读者 我们不关心潜在的精度损失。\n\n## dynamic_cast\n\ndynamic_cast操作符可以用来将一个类对象的指针转换成同一类层次结构中的其他类类型的指针，同时也可以用它把一个类对象的左值转换成同一类层次结构中其他类类型的引用。\n\n它支持在运行时刻识别（即RTTI）由指针或引用指向的类对象。\n\ndynamic_cast 操作符被用来执行从基类指针到派生类指针的安全转换，它常常被称为安全的向下转换。\n\n```bash\n用指向基类类型的指针来操纵派生类类型的对象，这通常通过虚函数自动处理，但是在某些情形下使用虚拟函数是不可能的，dynamic_cast 为这些情形提供了替代的机制，但是这种机制比虚拟成员函数更易出错，应该小心使用\n```\n\n## reinterpre_cast\n\nreinterpre_cast通常对于操作数的位模式执行一个比较低层次的重新解释，它的正确性很大程度上依赖于程序员的主动管理。\n\n## const_cast\n\nconst_cast用于转换表达式的常量性，即改变对象的底层const。\n\n```bash\nconst的修饰原则：\n\n优先修饰左边，即int * const p;中const修饰int *\n\n若左边无内容，则修饰右边\n```\n\n```c++\nint num=1;\nint * const p1 = & num;//const修饰int *，即p1是一个常量，顶层const\nint const cnum;//const修饰int，即cnum是一个常量，顶层const\nconst int * p2 = & cnum;//const修饰p2指向的变量cnum，底层const\n\n总结：\n顶层const：（顶层const）本身是一个常量；\n底层const：作为指针指向的对象是常量\n```\n\n所谓用于转换表达式的常量性，即\n\n```c++\nconst char * pc;\n\nchar * p = const_cast<char *>(pc);\n```\n\n此时p与pc的值相同，但是p指向的内容仍是常量，不可修改！\n\n当一个对象的值可能会在编译器的控制或监测之外被改变时，该对象应声明为volatile。const_cast也会转换volatile对象的volatile性。\n\n```bash\nvolatile会在多线程中被使用，当两个或多个线程都要用到同一变量且该变量的值会被改变时，就需要用volatile声明，以防止编译器为了优化代码而将该变量装入CPU寄存器中，而是每次使用该变量都需要从内存中读取\n```\n\n","tags":["C++"],"categories":["course"]},{"title":"第一章第五节 类","url":"/course/cpp-ch1-par5.html","content":"\n类用于支持新类型的设计，类的基本结构如下。\n\n```c++\nclass CLASSName{\npublic:\n    /* 公开变量 */\n    \n    /* 构造函数 */\n    CLASSName();\n    CLASSName(para_1,..., para_m);\n    \n    /* 公开函数 */\n    \n    /* 析构函数 */\n    ~CLASSName();\n    ~CLASSName(para_1,..., para_k);\n    \n    /* 运算符重载 */\n    CLASSName & operator = (const CLASSName &);\n    inline bool operator == (const CLASSName &);//对于频繁调用的函数，声明为内联的可以消除函数调用的开销\n    var_type & operator[] (int);\n\nprotected:\n    /* 受保护的变量 */\n    \n    /* 受保护的函数 */\n\nprivate:\n    /* 私有变量 */\n    \n    /* 私有函数 */\n}\n```\n","tags":["C++"],"categories":["course"]},{"title":"musikcube之第三方库","url":"/program/musikcube-third-party-library.html","content":"\n## 前言\n\n在项目的实现过程中，使用了不少优秀的第三方库，这里只介绍与C++网络编程相关的第三方库。\n\n## ev++\n\n[libev文档](file:///C:/Users/coming/Documents/CSAT/cppnet/libev/libev.html)\n\n## boost库\n\n```bash\nBoost库是一个可移植、提供源代码的C++库，作为标准库的后备，是C++标准化进程的开发引擎之一，是为C++语言标准库提供扩展的一些C++程序库的总称。 Boost库由C++标准委员会库工作组成员发起，其中有些内容有望成为下一代C++标准库内容。在C++社区中影响甚大，是不折不扣的“准”标准库。Boost由于其对跨平台的强调，对标准C++的强调，与编写平台无关。大部分boost库功能的使用只需包括相应头文件即可，少数（如正则表达式库，文件系统库等）需要链接库。但Boost中也有很多是实验性质的东西，在实际的开发中使用需要谨慎。\n```\n\n[boost库简单介绍](https://www.cnblogs.com/whiteBear/p/14017186.html)\n\n## SQLite库\n\n[SQLite](https://www.sqlite.org/docs.html)是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。基本的使用逻辑如下：\n\n```bash\n调用sqlite3_reset（）函数将准备好的语句对象重置回初始状态，以便重新执行。使用sqlite3_bind_*（）API将值绑定到的任何SQL语句变量都会保留其值。使用sqlite3_clear_bindings（）重置绑定。\n```\n\n**BEGIN IMMEDIATE TRANSACTION**\n\n```bash\n除非在事务内，否则不会进行读取或写入。任何访问数据库的命令（基本上是任何SQL命令，除了一些PRAGMA语句）都将自动启动一个事务（如果尚未生效）。自动启动的事务在最后一条SQL语句完成时提交。可以使用BEGIN命令手动启动事务。此类事务通常持续到下一个提交或回滚命令。但是，如果数据库关闭，或者发生错误并指定了回滚冲突解决算法，事务也将回滚。有关回滚冲突解决算法的更多信息，请参阅on CONFLICT子句的文档。END TRANSACTION是提交的别名。\n\n使用BEGIN创建的事务。。。承诺不要嵌套。对于嵌套事务，请使用SAVEPOINT和RELEASE命令。上面语法图中显示的ROLLBACK命令的“TO SAVEPOINT name”子句仅适用于保存点事务。在事务中调用BEGIN命令的尝试将失败并出现错误，无论该事务是由保存点还是之前的BEGIN启动的。COMMIT命令和ROLLBACK命令（不带TO子句）对保存点事务的作用与对BEGIN启动的事务的作用相同。\n\nSQLite支持来自不同数据库连接的多个同时读取事务，可能在不同的线程或进程中，但只支持一个同时写入事务。只读事务用于只读。写事务允许读和写。读事务由SELECT语句启动，写事务由CREATE、DELETE、DROP、INSERT或UPDATE等语句启动（统称为“写语句”）。如果在读事务处于活动状态时出现write语句，则读事务将升级为写事务（如果可能）。如果其他数据库连接已经修改了数据库或正在修改数据库，则无法升级到写事务，并且在SQLITE_BUSY时，write语句将失败。\n\n当读事务处于活动状态时，启动读事务的数据库连接将看不到由单独的数据库连接实现的对数据库的任何更改。如果数据库连接X持有读取事务，则当X的事务仍处于打开状态时，其他一些数据库连接Y可能会更改数据库的内容，但是在事务结束之前，X将无法看到这些更改。当其读取事务处于活动状态时，X将继续在Y实施更改之前看到数据库的历史快照。\n\n事务可以是延迟的、即时的或独占的。默认事务行为被延迟。延迟意味着在首次访问数据库之前，事务实际上不会启动。在内部，BEGIN DEFERRED语句只在数据库连接上设置一个标志，该标志关闭自动提交，该自动提交通常在最后一条语句完成时发生。这会导致自动启动的事务持续存在，直到显式提交或回滚，或者直到错误或ON CONFLICT ROLLBACK子句引发回滚。如果BEGIN DEFERRED之后的第一条语句是SELECT，则启动读取事务。如果可能的话，后续的write语句会将事务升级为write事务，或者返回SQLITE_BUSY。如果BEGIN DEFERRED之后的第一条语句是write语句，则会启动一个write事务。\n\n立即导致数据库连接立即开始新的写操作，而无需等待write语句。如果另一个数据库连接上的另一个写事务已处于活动状态，则在SQLITE_繁忙时，立即开始可能会失败。EXCLUSIVE类似于IMMEDIATE，因为写入事务会立即启动。独占和立即在WAL模式中是相同的，但在其他日志记录模式中，独占阻止其他数据库连接在事务进行时读取数据库。\n```\n\n**auto_vacuum**\n\n```bash\nauto_vacuum的默认设置为0或“无”，除非使用SQLITE_default_AUTOVACUUM编译时选项。“无”设置意味着自动真空被禁用。当禁用自动真空并从数据库中删除数据时，数据库文件的大小保持不变。未使用的数据库文件页将添加到“自由列表”中，并在后续插入时重复使用。因此不会丢失任何数据库文件空间。但是，数据库文件不会收缩。在此模式下，真空命令可用于重建整个数据库文件，从而回收未使用的磁盘空间。\n\n当auto_vacuum为1或“已满”时，自由列表页面将移动到数据库文件的末尾，数据库文件将被截断，以在每次事务提交时删除自由列表页面。但是请注意，自动抽真空只会截断文件中的自由列表页面。自动抽真空不会像vacuum命令那样对数据库进行碎片整理，也不会重新打包单个数据库页面。事实上，因为自动抽真空可以在文件中移动页面，所以它实际上会使碎片更严重。\n\n只有当数据库存储了一些额外的信息，使每个数据库页面可以追溯到其引用者时，自动清空才可能。因此，在创建任何表之前，必须启用自动吸尘。创建表格后，无法启用或禁用自动真空。\n\n当自动抽真空的值为2或“增量”时，自动抽真空所需的附加信息存储在数据库文件中，但自动抽真空不会在每次提交时自动发生，就像在auto_vacuum=full时一样。在增量模式下，必须调用单独的增量真空pragma以使自动真空发生。\n\nThe database connection can be changed between full and incremental autovacuum mode at any time. However, changing from \"none\" to \"full\" or \"incremental\" can only occur when the database is new (no tables have yet been created) or by running the VACUUM command. To change auto-vacuum modes, first use the auto_vacuum pragma to set the new desired mode, then invoke the VACUUM command to reorganize the entire database file. To change from \"full\" or \"incremental\" back to \"none\" always requires running VACUUM even on an empty database.\n```\n\n## sigslot库\n\n```bash\nsigslot库 实质上是一个对象之间传递消息的库。一些复杂的工程，包含有大量的类。造成对象之间耦合度非常之大。该库实际上模拟了信号的发送对象send，以及信号的接受对象recv。然后将send对象的信号函数connect到对应的接收对象的函数实现。此时尽管调用send对象的类成员函数即可以完成recv对象的一些操作。这样在send对象中就不需要拥有recv对象的句柄，减小了耦合性。\n```\n\n[sigslot库简介](https://www.cnblogs.com/kanego/articles/sigslot.html)\n\n[sigslot库分析](https://zhuanlan.zhihu.com/p/30389662)\n\n## WebSocket++\n\n```bash\nWebSocket++ 是一个 C++ 库，可用于实现 WebSocket 功能。 该项目的目标是提供可移植、灵活、轻量级、底层和高性能的 WebSocket 实现。WebSocket++ 是一个只有标头的 C++ 库，它实现了 RFC6455 WebSocket 协议。 它允许将 WebSocket 客户端和服务器功能集成到 C++ 程序中。 它使用可互换的网络传输模块，包括一个基于原始字符缓冲区、一个基于 C++ iostreams 和一个基于 Asio（通过 Boost 或独立）。 最终用户可以根据需要编写额外的传输策略来支持其他网络或事件库。\n```\n\n[WebSocket++文档](https://docs.websocketpp.org/)\n","tags":["音乐播放器"],"categories":["program"]},{"title":"musikcube之消息队列","url":"/program/MessageQueue.html","content":"\n该类提供订阅-发布模式的消息队列机制，供其他需要消息队列机制的类使用。定义于src/musikcore/runtime/MessageQueue.h\n\n```cpp\nclass MessageQueue : public IMessageQueue {\n    public:\n        MessageQueue(const MessageQueue&) = delete;\n        MessageQueue(const MessageQueue&&) = delete;\n        MessageQueue& operator=(const MessageQueue&) = delete;\n        MessageQueue& operator=(const MessageQueue&&) = delete;\n        /* nextMessageTime设置为1 */\n        MessageQueue() noexcept;\n        /* 投递消息：先判断消息的目标是否注册到本消息队列的targets中，若注册了才将此消息加入队列queue */\n        void Post(IMessagePtr message, int64_t delayMs = 0) override;\n        /* 判断message是否设置了target，若设置了则报错（因为这是广播消息），否则调用Enqueue将其加入消息队列 */\n        void Broadcast(IMessagePtr message, int64_t messageMs = 0) override;\n        /* 将消息队列中目标为target、类型为type（若type=-1，则匹配任意类型）的消息删除（消息本身也删除），然后重新设置nextMessageTime */\n        int Remove(IMessageTarget *target, int type = -1) override;\n        /* 判断消息队列中是否存在目标为target、类型为type（若type=-1，则匹配任意类型）的消息 */\n        bool Contains(IMessageTarget *target, int type = -1) override;\n        /* 删除消息队列中目标与类型与message一致的消息，然后投递消息message，延时为delayMs */\n        void Debounce(IMessagePtr message, int64_t delayMs = 0) override;\n        /* target加入到消息队列的目标targets中，如同target订阅消息 */\n        void Register(IMessageTarget* target) override;\n        /* target从消息队列的目标中移除，如同target取订消息；然后调用Remove函数 */\n        void Unregister(IMessageTarget* target) override;\n        /* target加入到消息队列的广播目标receivers中，如同target订阅广播消息 */\n        void RegisterForBroadcasts(IMessageTargetPtr target) override;\n        /* target从消息队列的广播目标receivers中，如同target取订广播消息 */\n        void UnregisterForBroadcasts(IMessageTarget *target) override;\n        /* “等待”并执行Dispatch函数（若queue非空且消息队列中已有消息超时未投递，则调用执行Dispatch函数；若queue非空且消息队列中还未有消息到时且timeoutMillis大于等于0，则wait_for min(this->queue.front()->time-system_clock::now().time_since_epoch(), timeoutMillis)再调用Dispatch函数；若queue非空且消息队列中还未有消息到时且timeoutMillis小于0，则wait_for直到queue头部的消息设置的投递时间；若queue为空且timeoutMillis大于等于0，则wait_for timeoutMillis；若queue为空且timeoutMillis小于0，则一直wait，但是如果有消息插入到queue中，就会被唤醒） */\n        void WaitAndDispatch(int64_t timeoutMillis = -1) override;\n        /* 在类中定义了两个名为Dispatch的函数，此处的参数表为空，用于处理所有超时消息，具体实现如下：判断是否有消息到期（即nextMessageTime是否大于0且小于等于now），若无消息到期则退出；若有消息到期且其目标在targets中或其类型为广播消息，则将其存入dispatch，然后只要消息到期就将其从queue中移除，将所有到期的消息收集完成后，调用Dispatch(IMessage*)依次进行处理；这里试着分析一下为什么先收集到期且仍然有效的消息：处理消息的时间是不可控，可能很短，也可能很长，当处理完再收集下一个到期消息时，也许时间过了很久，那么这时仅根据函数开头得到的now判断消息是否到期是不准确的 */\n        void Dispatch() override;\n\n    protected:\n        int64_t GetNextMessageTime() noexcept {\n            return nextMessageTime.load();\n        }\n\n    private:\n        typedef std::weak_ptr<IMessageTarget> IWeakMessageTarget;\n        /* 根据延迟时间delayMs计算出消息的投递时间，再将其插入到以投递时间为序的队列queue中，若message在queue的开头，那么需要重新设置nextMessageTime为message的投递时间，并通知所有等待在waitForDispatch上的线程（关于此处waitForDispatch.notify_all的一点看法：所有的成员函数中，只有Enqueue成员函数会在一些条件下执行waitForDispatch.notify_all，因此它是必不可少的；在WaitAndDispatch中，只有waitForDispatch.wait(lock)必须由它唤醒，而只有在queue为空且timeoutMillis<0时才会执行至这条语句，而当queue为空时插入的消息message一定会在queue的头部，从而恰好执行waitForDispatch.notify_all将等待在waitForDispatch上的线程唤醒；另一种执行至waitForDispatch.notify_all的情形是queue非空，message插入到了queue的头部，等待在条件变量waitForDispatch上的线程只会阻塞在waitForDispatch.wait_for，此时执行Dispatch不一定有消息到期，因此Dispatch函数在最开始进行了判断） */\n        void Enqueue(IMessagePtr message, int64_t delayMs);\n        /* 对于设置了target的消息，调用其target的ProcessMessage函数处理message；对于未设置target的消息，先拷贝receivers的一个副本copy，这样可以避免在receivers中的target依次处理message过程中，一直将receivers加锁；然后遍历copy，每个target要处理message时，先对自身加锁，若加锁成功，则调用其ProcessMessage函数处理message，否则，设定一个标志表示至少有一个weak_ptr对应的对象已经被销毁，则依次遍历receivers中的weak_ptr，若已失效，则将其从receivers中删除 */\n        void Dispatch(IMessage* message);\n        /* 被插入队列的消息结构：消息主体与设置的投递时间 */\n        struct EnqueuedMessage {\n            IMessagePtr message;\n            std::chrono::milliseconds time;\n        };\n        /* 自定义类（结构体）比较函数less：重载()运算符\n         * http://www.javashuo.com/article/p-zufmcrln-eg.html\n         */\n        struct WeakPtrLess { /* https://stackoverflow.com/a/12875729 */\n            template <typename T>\n            bool operator() (const std::weak_ptr<T>& l, const std::weak_ptr<T>& r) const {\n                return l.lock().get() < r.lock().get();\n            }\n        };\n        /* 关于queue的互斥量 */\n        std::mutex queueMutex;\n        /* 消息队列，按照消息设置的投递时间排序 */\n        std::list<EnqueuedMessage*> queue;\n        /* 保存超时要处理的消息 */\n        std::list<EnqueuedMessage*> dispatch;\n        /* set类型定义如下：\n         * template <\n         *     class Key,   \n         *     class Traits=less<Key>,   \n         *     class Allocator=allocator<Key> >  \n         * class set\n         * https://blog.csdn.net/zy2317878/article/details/78981726\n         */\n        std::set<IWeakMessageTarget, WeakPtrLess> receivers;\n        /* 消息订阅者 */\n        std::set<IMessageTarget*> targets;\n        /* 标志Dispatch函数所需的条件是否准备好 */\n        std::condition_variable_any waitForDispatch;\n        /* 始终存储消息队列中最先到期的消息的投递时间 */\n        std::atomic<int64_t> nextMessageTime;\n};\n```\n\n注：在WaitAndDispatch函数对queueMutex加锁，并未看到对queueMutex进行解锁，就调用了Dispatch函数，而Dispatch函数又对queueMutex加锁，而queueMutex是非递归锁，不可被同一线程多次获取；事实上，这里的{}指明了变量的作用域，在{}内声明的局部变量其作用域自变量声明开始，到{}之后终结。因此在调用Dispatch函数之前queueMutex就已被解锁。\n\n总结一下消息队列的运行机制。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 1.JPEG pic1 %}</div>\n\n## EvMessageQueue\n\n在main.cpp中，使用的是继承自MessageQueue类的EvMessageQueue类；其定义如下\n\n```cpp\nclass EvMessageQueue: public MessageQueue {\n    public:\n        void Post(IMessagePtr message, int64_t delayMs) {\n            MessageQueue::Post(message, delayMs);\n\n            if (delayMs <= 0) {\n                write(pipeFd[1], &EVENT_DISPATCH, sizeof(EVENT_DISPATCH));\n            }\n            else {\n                double delayTs = (double) delayMs / 1000.0;\n                loop.once<\n                    EvMessageQueue,\n                    &EvMessageQueue::DelayedDispatch\n                >(-1, ev::TIMER, (ev::tstamp) delayTs, this);\n            }\n        }\n\n        void DelayedDispatch(int revents) {\n            this->Dispatch();\n        }\n\n        static void SignalQuit(ev::sig& signal, int revents) {\n            write(pipeFd[1], &EVENT_QUIT, sizeof(EVENT_QUIT));\n        }\n\n        void ReadCallback(ev::io& watcher, int revents) {\n            short type;\n            if (read(pipeFd[0], &type, sizeof(type)) == 0) {\n                std::cerr << \"read() failed.\\n\";\n                exit(EXIT_FAILURE);\n            }\n            switch (type) {\n                case EVENT_DISPATCH: this->Dispatch(); break;\n                case EVENT_QUIT: loop.break_loop(ev::ALL); break;\n            }\n        }\n\n        void Run() {\n            io.set(loop);\n            io.set(pipeFd[0], ev::READ);\n            io.set<EvMessageQueue, &EvMessageQueue::ReadCallback>(this);\n            io.start();\n\n            sio.set(loop);\n            sio.set<&EvMessageQueue::SignalQuit>();\n            sio.start(SIGTERM);\n\n            write(pipeFd[1], &EVENT_DISPATCH, sizeof(EVENT_DISPATCH));\n\n            loop.run(0);\n        }\n\n    private:\n        ev::dynamic_loop loop;\n        ev::io io;\n        ev::sig sio;\n};\n```\n\n可见EvMessageQueue类只是对MessageQueue类的Post与DelayedDispatch的重写，并增加了SignalQuit、ReadCallback与Run函数，以及新增三个变量loop(类型)、io(ev::io类型)与sio(ev::sig类型)。\n","tags":["音乐播放器"],"categories":["program"]},{"title":"musikcube之WebSocketClient类","url":"/program/WebSocketClient.html","content":"\nWebSocketClient类就是负责程序与远程音乐资料库的连接。它定义于src/musikcore/net/WebSocketClient.h，继承自类IMessageTarget，接收程序的请求并与远程音乐资料库交互。\n\n```cpp\nclass WebSocketClient: public musik::core::runtime::IMessageTarget {\n    public:\n        using ClientPtr = std::unique_ptr<RawWebSocketClient>;\n        /* typedef lib::shared_ptr< message > \tptr，WebSocket消息类型 */\n        using ClientMessage = websocketpp::config::asio_client::message_type::ptr;\n        /* 唯一标识连接的句柄 */\n        using Connection = websocketpp::connection_hdl;\n        using Query = std::shared_ptr<musik::core::db::ISerializableQuery>;\n        /* 连接状态 */\n        enum class State: int {\n            Disconnected = 0,\n            Connecting = 1,\n            Authenticating = 2,\n            Connected = 3,\n            Disconnecting = 4,\n        };\n        /* 查询错误值 */\n        enum class QueryError: int {\n            QueryFailed = 1,\n            Disconnected = 2,\n            AuthFailed = 3,\n            QueryNotFound = 4,\n            ParseFailed = 5,\n        };\n        /* 连接错误值 */\n        enum class ConnectionError : int {\n            None = 0,\n            InvalidPassword = 1,\n            IncompatibleVersion = 2,\n            ConnectionFailed = 3,\n            ClosedByServer = 4,\n        };\n        /* 专门用于处理各种异常情况，RemoteLibrary类将其继承 */\n        class Listener {\n            public:\n                using Client = WebSocketClient;\n                using State = Client::State;\n                using QueryError = Client::QueryError;\n                /* 密码错误 */\n                virtual void OnClientInvalidPassword(Client* client) = 0;\n                /* 更新连接状态 */\n                virtual void OnClientStateChanged(Client* client, State newState, State oldState) = 0;\n                /* 查询成功 */\n                virtual void OnClientQuerySucceeded(Client* client, const std::string& messageId, Query query) = 0;\n                /* 查询失败 */\n                virtual void OnClientQueryFailed(Client* client, const std::string& messageId, Query query, QueryError result) = 0;\n        };\n        /* 构造函数（设置messageQueue、rawClient（mode、open_handler、fail_handler、message_handler与close_handler）、listener） */\n        WebSocketClient(\n            musik::core::runtime::IMessageQueue* messageQueue,\n            Listener* listener);\n\n        WebSocketClient(const WebSocketClient&) = delete;\n        /* 析构函数（关闭网络连接、重置rawClient、this从messageQueue中注销） */\n        virtual ~WebSocketClient();\n        /* 判断传入的host、port、password、useTls是否与该类设置的完全一致；若不完全一致，则将该类的设置为传入的参数；然后根据设置的参数重新连接 */\n        void Connect(\n            const std::string& host,\n            unsigned short port,\n            const std::string& password,\n            bool useTls);\n        /* 对mutex加锁，断开连接，重置io，从setting.json中读取timeout配置项，设置状态为State::Connecting，开辟一个线程处理新连接；线程断开连接后状态设置为State::Disconnected */\n        void Reconnect();\n        /* io_service停止，thread右值传递给oldThread，oldThread调用join函数等待被销毁 */\n        void Disconnect();\n        /* 返回连接状态 */\n        State ConnectionState() const;\n        /* 返回上次连接的connectionError */\n        ConnectionError LastConnectionError() const;\n        /* 返回上次连接的serverVersion */\n        std::string LastServerVersion() const;\n        /* 返回uri */\n        std::string Uri() const;\n        /* 加锁，若状态不是State::Connected且禁止离线队列，则插入失败；若query为空，则返回空字符串；生成此query唯一的messageId，并在messageIdToQuery中建立映射关系，若处于连接状态，则发送此请求；返回messageId */\n        std::string EnqueueQuery(Query query);\n        /* 设置消息队列，若传入的参数messageQueue与messageQueue成员相同，直接退出，否则，若messageQueue成员非空，则注销this；messageQueue成员设置为传入的参数messageQueue，并注册this；并向this投递一个ping请求 */\n        void SetMessageQueue(musik::core::runtime::IMessageQueue* messageQueue);\n\n        /* IMessageTarget */\n        /* 处理消息队列中的消息，仅支持kPingMessage类型的消息；发送ping请求之后再投递一个ping请求 */\n        void ProcessMessage(musik::core::runtime::IMessage& message) override;\n\n    private:\n        /* 设置状态，若state为State::Disconnected，则重置连接并调用InvalidatePendingQueries；若state为State::connected，则connectionError设置为ConnectionError::None，将messageIdToQuery中的所有query发送；再设置state成员为state参数，listener成员也要切换状态 */\n        void SetState(State state);\n        /* 取消所有的query，清空messageIdToQuery */\n        void InvalidatePendingQueries();\n        /* 将messageIdToQuery中的所有query发送 */\n        void SendPendingQueries();\n        /* 将connectionError设置为errorCode，再调用SetState将状态切换为State::Disconnected */\n        void SetDisconnected(ConnectionError errorCode);\n        /* HTTP协议与HTTPS协议的客户端对象 */\n        ClientPtr rawClient;\n         /* 唯一标识连接的句柄 */\n        Connection connection;\n         /* io_service对象 */\n        boost::asio::io_service io;\n         /* 线程对象 */\n        std::unique_ptr<std::thread> thread;\n```\n```cpp\n         /* 互斥锁 */\n        mutable std::recursive_mutex mutex;\n         /* 是否使用TLS协议 */\n        bool useTls{ false };\n         /* 密码 */\n        std::string uri, password;\n         /* messageId到Query的映射 */\n        std::unordered_map<std::string, Query> messageIdToQuery;\n         /* 是否退出 */\n        std::atomic<bool> quit{ false };\n        ConnectionError connectionError{ ConnectionError::None };\n         /* 服务端版本 */\n        std::string serverVersion;\n         /* 连接状态 */\n        State state{ State::Disconnected };\n        Listener* listener{ nullptr };\n         /* 消息队列 */\n        musik::core::runtime::IMessageQueue* messageQueue;\n};\n```\n\nWebSocketClient类用到了类RawWebSocketClient，它是对`websocketpp::client<websocketpp::config::asio_client>`与`websocketpp::client<websocketpp::config::asio_tls_client>`的封装。\n\n```cpp\nclass RawWebSocketClient {\n    public:\n        /* HTTP协议 */\n        using PlainTextClient = websocketpp::client<websocketpp::config::asio_client>;\n        using PlainTextClientPtr = std::unique_ptr<PlainTextClient>;\n        /* HTTPS协议 */\n        using TlsClient = websocketpp::client<websocketpp::config::asio_tls_client>;\n        using TlsClientPtr = std::unique_ptr<TlsClient>;\n        /* SSL协议内容 */\n        using SslContext = std::shared_ptr<boost::asio::ssl::context>;\n        /* typedef lib::shared_ptr< message > \tptr，WebSocket消息类型 */\n        using Message = websocketpp::config::asio_client::message_type::ptr;\n        /* 唯一标识连接的句柄 */\n        using Connection = websocketpp::connection_hdl;\n\n        using OpenHandler = std::function<void(Connection)>;\n        using FailHandler = std::function<void(Connection)>;\n        using MessageHandler = std::function<void(Connection, Message)>;\n        using CloseHandler = std::function<void(Connection)>;\n        using SendMessageErrorHandler = std::function<void(std::error_code)>;\n        /* 模式：明文传输与TLS加密传输 */\n        enum class Mode: int {\n            PlainText = 0,\n            TLS = 1\n        };\n        /* 构造函数（构造plainTextClient与tlsClient对象并对其初始化）*/\n        RawWebSocketClient(boost::asio::io_service& io);\n        RawWebSocketClient(const RawWebSocketClient&) = delete;\n        /* 析构函数*/\n        ~RawWebSocketClient();\n        /* 设置协议类型 */\n        void SetMode(Mode mode);\n        /* 设置HTTP协议客户端的XX与HTTP协议客户端的XX */\n        void SetOpenHandler(OpenHandler openHandler);\n        void SetFailHandler(FailHandler failHandler);\n        void SetMessageHandler(MessageHandler messageHandler);\n        void SetCloseHandler(CloseHandler closeHandler);\n        void SetSendMessageErrorHandler(SendMessageErrorHandler errorHandler);\n        /* 根据设置的mode调用plainTextClient->send或tlsClient->send，若出错则调用sendMessageErrorHandler处理错误 */\n        void Send(Connection connection, const std::string& message);\n        /* 设置等待ping操作回复的时间，若超时未收到回复则认为连接已断开，用于这可以用作keepalive或检测断开的连接 */\n        void SetPongTimeout(long timeoutMs);\n        /* 连接操作 */\n        void Connect(const std::string& uri);\n        /* 根据设置的mode调用plainTextClient->run或tlsClient->run */\n        void Run();\n\n    private:\n        /* 协议类型（HTTP还是HTTPS） */\n        Mode mode;\n        /* HTTP协议的客户端 */\n        TlsClientPtr tlsClient;\n        /* HTTPS协议的客户端 */\n        PlainTextClientPtr plainTextClient;\n        /* 处理发送消息错误的句柄 */\n        SendMessageErrorHandler sendMessageErrorHandler;\n};\n```\n\nWebSocketClient类用到了几个静态函数`create*Request`生成各种请求。\n","tags":["音乐播放器"],"categories":["program"]},{"title":"musikcube之数据库模块","url":"/program/Connection-Indexer.html","content":"\n## 前言\n\nConnection类与Indexer类负责项目的数据库模块。Connection类相当于数据库的服务端；Indexer类相当于数据库的客户端。\n\n## Connection类\n\n该类作为数据库服务端，提供管理数据库底层的接口；定义于src/musikcore/db/Connection.h\n\n```cpp\nclass Connection {\n    public:\n        DELETE_COPY_AND_ASSIGNMENT_DEFAULTS(Connection)\n\n        Connection() noexcept;\n        ~Connection();\n\n        int Open(const std::string &database, unsigned int options = 0, unsigned int cache = 0);\n        /* 关闭数据库连接 */\n        int Close() noexcept;\n        /* 编译并执行SQL语句 */\n        int Execute(const char* sql);\n        /* 返回数据库连接D上最近一次成功插入到rowid表或虚拟表中的rowid */\n        int64_t LastInsertedId() noexcept;\n        /* 这些函数返回由唯一参数指定的数据库连接上最近完成的INSERT、UPDATE或DELETE语句修改、插入或删除的行数 */\n        int LastModifiedRowCount() noexcept;\n        /* 中断长时间运行的查询 */\n        void Interrupt();\n        /* 检查数据库：简而言之，sqlite3_wal_checkpoint（D，X）会将数据库连接D上的数据库X的预写日志中的内容传输到数据库文件中，并重置预写日志  */\n        void Checkpoint() noexcept;\n\n    private:\n        /* 初始化 */\n        void Initialize(unsigned int cache);\n        /* 更新引用计数 */\n        void UpdateReferenceCount(bool init);\n        /* 运行一条SQL语句 */\n        int StepStatement(sqlite3_stmt *stmt) noexcept;\n\n        friend class Statement;\n        friend class ScopedTransaction;\n        /* 该SQL连接上的事务数 */\n        int transactionCounter;\n        sqlite3 *connection;\n        /* 对象的互斥锁 */\n        std::mutex mutex;\n};\n```\n\nConnection类有两个友元类Statement类（src/musikcore/db/Statement.h）与ScopedTransaction类（src/musikcore/db/ScopedTransaction.h）。ScopedTransaction类是对即时事务的封装，Statement类对应SQL语句。\n\n```cpp\nclass ScopedTransaction {\n    public:\n        DELETE_CLASS_DEFAULTS(ScopedTransaction)\n        /* 设置数据库连接并开启即时事务 */\n        ScopedTransaction(Connection &connection);\n        /* 提交事务并退出 */\n        ~ScopedTransaction();\n        /* 取消事务的提交 */\n        void Cancel() noexcept;\n        /* 提交事务并开启新的即时事务 */\n        void CommitAndRestart();\n\n    private:\n        /* 开启即时事务 */\n        inline void Begin();\n        /* 提交事务（若事务取消则回滚，否则提交） */\n        inline void End();\n        /* 数据库连接 */\n        Connection *connection;\n        /* 标志事务是否取消 */\n        bool canceled;\n};\n\nclass Statement {\n    public:\n        DELETE_CLASS_DEFAULTS(Statement)\n\n        Statement(const char* sql, Connection &connection) noexcept;\n        virtual ~Statement() noexcept;\n        /* 设置SQL语句的参数（如果有的话） */\n        void BindInt32(int position, int bindInt) noexcept;\n        void BindInt64(int position, int64_t bindInt) noexcept;\n        void BindFloat(int position, float bindFloat) noexcept;\n        void BindText(int position, const std::string& bindText);\n        void BindNull(int position) noexcept;\n        /* 获取SQL语句结果行第column列的值 */\n        const int ColumnInt32(int column) noexcept;\n        const int64_t ColumnInt64(int column) noexcept;\n        const float ColumnFloat(int column) noexcept;\n        const char* ColumnText(int column) noexcept;\n        /* 判断SQL语句结果行第column的列值是否为空 */\n        const bool IsNull(int column) noexcept;\n        /* 处理一行SQL语句并更新处理的行数 */\n        int Step();\n        /* 调用sqlite3_reset（）函数将准备好的语句对象重置回初始状态，以便重新执行 */\n        void Reset() noexcept;\n        /* 重置准备好的语句上的所有参数绑定 */\n        void Unbind() noexcept;\n        void ResetAndUnbind() noexcept;\n\n    private:\n        friend class Connection;\n        /* 将SQL语句编译为字节码程序 */\n        Statement(Connection &connection) noexcept;\n        /* 编译的字节码程序 */\n        sqlite3_stmt *stmt;\n        /* 数据库连接 */\n        Connection *connection;\n        int modifiedRows;\n};\n```\n\n## Indexer类\n\n该类作为数据库客户端，提供各种接口用于向数据库服务端发起相应的请求；定义于src/musikcore/db/Indexer.h，继承了类IIndexer、IIndexerWriter与IIndexerNotifier，IIndexerWriter类与IIndexerNotifier类仅声明了一些虚函数，Indexer类将它们实现。因此只额外解析IIndexer类\n\n```cpp\nclass Indexer :\n    public mymusic::core::IIndexer,\n    public mymusic::core::sdk::IIndexerWriter,\n    public mymusic::core::sdk::IIndexerNotifier\n{\n    public:\n        /* 类构造函数（根据属性设置判断是否打开日志文件，设置tagReaders、audioDecoders与sources插件；设置dbFilename与libraryPath后连接数据库；查询paths所有的路径并按照id排序，再将结果存入paths中） */\n        Indexer(\n            const std::string& libraryPath,\n            const std::string& dbFilename);\n\n        Indexer(const Indexer&) = delete;\n        /* 若打开了日志文件logFile，则将其关闭；然后线程thread停止运行 */\n        virtual ~Indexer();\n\n        /* IIndexer */\n        /* 规范化路径并存入AddRemoveContext对象的path成员，add成员置true代表加入路径，路径存入paths，将要加入的AddRemoveContext对象存入addRemoveQueue  */\n        void AddPath(const std::string& path) override;\n        /*  规范化路径并存入AddRemoveContext对象的path成员，add成员置false代表删除路径，路径从paths中删除，将要加入的AddRemoveContext对象存入addRemoveQueue */\n        void RemovePath(const std::string& path) override;\n        /* 将paths中存储所有的路径存入path字符串 */\n        void GetPaths(std::vector<std::string>& paths) override;\n        void Schedule(SyncType type) override;\n        /* 停止线程thread（清空syncQueue，状态切换为StateStopping，通知等待在stateMutex互斥锁对应的条件变量上的线程；调用join方法等待被创建线程的结束，并回收它的资源） */\n        void Stop() override;\n\n        State GetState() noexcept override {\n            return this->state;\n        }\n\n        /* IIndexerWriter */\n        /* 生成一个ITagStore对象 */\n        mymusic::core::sdk::ITagStore* CreateWriter() override;\n        bool RemoveByUri(mymusic::core::sdk::IIndexerSource* source, const char* uri) override;\n        bool RemoveByExternalId(mymusic::core::sdk::IIndexerSource* source, const char* id) override;\n        /* 删除source对应的所有轨迹 */\n        int RemoveAll(mymusic::core::sdk::IIndexerSource* source) override;\n        /* 事务提交程序 */\n        void CommitProgress(mymusic::core::sdk::IIndexerSource* source, unsigned updatedTracks) override;\n        /* 获取上一次修改的时间 */\n        int GetLastModifiedTime(mymusic::core::sdk::IIndexerSource* source, const char* id) override;\n\n        bool Save(\n            mymusic::core::sdk::IIndexerSource* source,\n            mymusic::core::sdk::ITagStore* store,\n            const char* externalId = \"\") override;\n\n        /* IIndexerNotifier */\n        /* 基于给定的新source重新Schedule */\n        void ScheduleRescan(mymusic::core::sdk::IIndexerSource* source) override;\n\n    private:\n        /* 要添加或删除的内容 */\n        struct AddRemoveContext {\n            bool add{ false };\n            std::string path;\n        };\n        /* 要同步的内容 */\n        struct SyncContext {\n            SyncType type;\n            int sourceId;\n        };\n        typedef std::vector<std::shared_ptr<\n            mymusic::core::sdk::ITagReader>> TagReaderList;\n        typedef std::vector<std::shared_ptr<\n            mymusic::core::sdk::IDecoderFactory>> DecoderList;\n        typedef std::vector<std::shared_ptr<\n            mymusic::core::sdk::IIndexerSource>> IndexerSourceList;\n        /* 主线程要运行的函数 */\n        void ThreadLoop();\n        /* 同步（基于数据库连接创建索引，处理AddRemoveQueue，删除不再具有相应源的轨迹，若context.type为SyncType::Rebuild则重建：移除所有分配了id的source对应的轨迹，type重置为SyncType::All；刷新sources；同步本地音乐资料到数据库并重新创建索引） */\n        void Synchronize(const SyncContext& context, boost::asio::io_service* io);\n        /* 同步的善后工作 */\n        void FinalizeSync(const SyncContext& context);\n        /* 删除数据库中所有不再引用有效路径条目的轨道 */\n        void SyncDelete();\n        /* 清理工作（将已经删除的音乐文件在数据库中相关的数据删除） */\n        void SyncCleanup();\n        /* 更新播放列表中轨道文件的次序 */\n        void SyncPlaylistTracksOrder();\n        /* 将source与paths指定路径下的内容同步 */\n        mymusic::core::sdk::ScanResult SyncSource(\n            mymusic::core::sdk::IIndexerSource* source,\n            const std::vector<std::string>& paths);\n        /* 处理AddRemoveQueue上要添加或删除的路径 */\n        void ProcessAddRemoveQueue();\n        /* 对数据库中genres、artists、albums、meta_values四个表排序 */\n        void SyncOptimize();\n        /* 对数据库中的每条轨道，调用每种解码器进行解析，只要有一个解码器可以解析，就将这条轨道解析后的数据保存下来 */\n        void RunAnalyzers();\n        /* 获取不再具有相应源的轨迹 */\n        std::set<int> GetOrphanedSourceIds();\n        /* 删除sourceId对应的所有轨迹 */\n        int RemoveAllForSourceId(int sourceId);\n        /* 调度：对stateMutex加锁，若thread为空，则生成thread对象；若成员为type与source->SourceId()的context在syncQueue中已存在，则退出；否则，将构造的该context对象加入syncQueue中；最后通知所有等待在stateMutex上的线程 */\n        void Schedule(SyncType type, mymusic::core::sdk::IIndexerSource *source);\n        /* 被扫描轨迹的数量增delta；若累计增加的扫描轨道数超过TRANSACTION_INTERVAL，则提交事务并开启新的即时事务，通知process的订阅者，incrementalUrisScanned置0 */\n        void IncrementTracksScanned(int delta = 1);\n```\n```cpp\n        /* 递归地遍历目录下的所有文件，若文件的扩展名对应的格式可解析，则调用ReadMetadataFromFile函数以流的形式从中读取数据 */\n        void SyncDirectory(\n            boost::asio::io_service* io,\n            const std::string& syncRoot,\n            const std::string& currentPath,\n            int64_t pathId);\n        /* 以流的形式从中读取数据 */\n        void ReadMetadataFromFile(\n            boost::asio::io_service* io,\n            const boost::filesystem::path& path,\n            const std::string& pathId);\n        /* 判断线程是否已退出或将要退出 */\n        bool Bail() noexcept;\n        /* 数据库连接 */\n        db::Connection dbConnection;\n        /* 资料库路径 */\n        std::string libraryPath;\n        /* 资料库名 */\n        std::string dbFilename;\n        /* 标志状态 */\n        std::atomic<State> state;\n        /* 状态的互斥锁 */\n        boost::mutex stateMutex;\n        /* 状态的条件变量 */\n        boost::condition waitCondition;\n        /* 线程对象 */\n        std::unique_ptr<std::thread> thread;\n        /* 数据库自上次提交事务以来，程序扫描轨道的次数；从程序开始运行起，程序扫描轨道的次数 */\n        std::atomic<int> incrementalUrisScanned, totalUrisScanned;\n        /* 要添加或删除路径组成的队列 */\n        std::deque<AddRemoveContext> addRemoveQueue;\n        /* 要同步的内容组成的队列 */\n        std::deque<SyncContext> syncQueue;\n        /* TagReader列表 */\n        TagReaderList tagReaders;\n        /* 解码器列表 */\n        DecoderList audioDecoders;\n        /* IndexerSource列表 */\n        IndexerSourceList sources;\n        /* 设置的属性 */\n        std::shared_ptr<mymusic::core::Preferences> prefs;\n        std::shared_ptr<mymusic::core::db::ScopedTransaction> trackTransaction;\n        /* 资料库所在目录 */\n        std::vector<std::string> paths;\n        /* 当前Source */\n        std::shared_ptr<mymusic::core::sdk::IIndexerSource> currentSource;\n};\n\nclass IIndexer {\n    public:\n        /* 使用sigslot库传递消息，减少对象之间的耦合性 */\n        sigslot::signal0<> Started;\n        sigslot::signal1<int> Finished;\n        sigslot::signal1<int> Progress;\n        /* 枚举类型State来表示运行状态 */\n        enum State {\n            StateIdle = 0,\n            StateIndexing = 1,\n            StateStopping = 2,\n            StateStopped = 3\n        };\n        /* 枚举类型SyncType来表示同步类型 */\n        enum class SyncType {\n            All = 0,\n            Local = 1,\n            Rebuild = 2,\n            Sources = 3\n        };\n\n        virtual ~IIndexer() { }\n        virtual void AddPath(const std::string& path) = 0;\n        virtual void RemovePath(const std::string& path) = 0;\n        virtual void GetPaths(std::vector<std::string>& paths) = 0;\n        virtual void Schedule(SyncType type) = 0;\n        virtual void Stop() = 0;\n        virtual State GetState() = 0;\n};\n```\n\n其中，Track类提供对轨道数据的各种读操作接口，TagStore类提供轨道数据的各种写操作接口；\n","tags":["音乐播放器"],"categories":["program"]},{"title":"musikcube之RemoteLibrary类","url":"/program/RemoteLibrary.html","content":"\n该类管理远程的音乐资料库并提供编辑远程音乐资料库的接口，定义于src/musikcore/library/RemoteLibrary.h，继承了ILibrary、IMessageTarget、Listener、IResourceLocator类，并通过继承模板类std::enable_shared_from_this使得this指针成为shared_ptr指针。\n\n```cpp\nclass RemoteLibrary :\n    public ILibrary,\n    public mymusic::core::runtime::IMessageTarget,\n    public std::enable_shared_from_this<RemoteLibrary>,\n    public mymusic::core::net::WebSocketClient::Listener,\n    public ILibrary::IResourceLocator\n{\n    public:\n        using Client = mymusic::core::net::WebSocketClient;\n        using Query = std::shared_ptr<mymusic::core::db::ISerializableQuery>;\n        using MessageQueue = mymusic::core::runtime::IMessageQueue;\n        /* 生成一个LocalLibrary对象，返回其智能指针 */\n        static ILibraryPtr Create(std::string name, int id, MessageQueue* messageQueue);\n         /* RemoteLibrary类构造函数：传递messageQueue与this指针构造WebSocketClient对象—成员wsc；identifier设置为id的字符串形式；创建thread成员，运行的函数为ThreadProc；调用ReloadConnectionFromPreferences函数根据配置文件重新加载数据库连接；若messageQueue成员非空，在messageQueue上注册它本身 */\n        RemoteLibrary(std::string name, int id, MessageQueue* messageQueue);\n        RemoteLibrary(const RemoteLibrary&) = delete;\n        /*  RemoteLibrary类析构函数：关闭该类（释放indexer成员，thread成员置空，清空queryQueue，exit置为true，通知所有等待在queueCondition上的线程，等待线程thread的结束，并回收它的资源）；若messageQueue成员非空，将this从其中注销 */\n        virtual ~RemoteLibrary();\n\n        /* ILibrary */\n        /* 判断是否为完全本地的查询，若为，则调用LocalLibrary单例的EnqueueAndWait函数；将查询对象序列化；对互斥量queueMutex加锁，创建QueryContext对象并将其智能指针加入queryQueue，然后通知其他线程；直到query处理完（包括出错）然后退出！ */\n        int Enqueue(QueryPtr query, Callback = Callback()) override;\n        /* 判断是否为完全本地的查询，若为，则调用LocalLibrary单例的EnqueueAndWait函数；将查询对象序列化；对互斥量queueMutex加锁，创建QueryContext对象并将其智能指针加入queryQueue，然后通知其他线程；若timeoutMs=0，返回query的ID即可；若timeoutMs=-1，直到query处理完（包括出错）然后退出！若timeoutMs>0且不等于-1，则要么等待 timeoutMs退出，要么query提前被处理完（包括出错）然后退出 */\n        int EnqueueAndWait(QueryPtr query, size_t timeoutMs = kWaitIndefinite, Callback = Callback()) override;\n        /* 返回NullIndexer对象kNullIndexer */\n        mymusic::core::IIndexer *Indexer() override;\n        /* 返回id成员的值 */\n        int Id() override;\n        /* 返回name成员的值 */\n        const std::string& Name() override;\n        /* 设置消息队列messageQueue成员 */\n        void SetMessageQueue(mymusic::core::runtime::IMessageQueue& queue) override;\n        /* 返回messageQueue成员 */\n        mymusic::core::runtime::IMessageQueue& GetMessageQueue() noexcept override { return *messageQueue; }\n        ILibrary::IResourceLocator& GetResourceLocator() noexcept override { return *this; }\n        /* 配置文件中RemoteLibraryViewed的属性值 */\n        bool IsConfigured() override;\n        /* 获取连接状态connectionState */\n        ConnectionState GetConnectionState() const override { return this->connectionState; }\n        /* 类型：远程 */\n        Type GetType() const noexcept override { return Type::Remote; }\n        /* 关闭该类（关闭socket连接，清空queryQueue，exit置为true，thread成员置空） */\n        void Close() override;\n\n        /* IMessageTarget */\n        /* 处理消息（对于MESSAGE_QUERY_COMPLETED类型的message，向连接到QueryCompleted上的接收者通知context对应的查询完成的消息，再执行回调函数；对于MESSAGE_RECONNECT_SOCKET类型的message，若wsc的状态为Disconnected，则根据配置文件重新加载数据库连接；对于MESSAGE_UPDATE_CONNECTION_STATE类型的message，将状态更新为message所设置的状态） */\n        void ProcessMessage(mymusic::core::runtime::IMessage &message) override;\n\n        /* WebSocketClient::Listener */\n        /* 将验证失败的消息加入消息队列，以通知this */\n        void OnClientInvalidPassword(Client* client) override;\n        /* 若messageQueue非空，根据上一次连接出错的原因与newState判断是否重新连接，若重新连接则先将消息队列中所有目标为this、类型为MESSAGE_RECONNECT_SOCKET的消息删除、然后将目标为this、类型为MESSAGE_RECONNECT_SOCKET的消息加入消息队列延迟2500ms投递；再向消息队列中加入MESSAGE_UPDATE_CONNECTION_STATE类型的消息（data为newState）给this */\n        void OnClientStateChanged(Client* client, State newState, State oldState) override;\n        /* 调用OnQueryCompleted(messageId, query) */\n        void OnClientQuerySucceeded(Client* client, const std::string& messageId, Query query) override;\n        /* 调用OnQueryCompleted(messageId, query) */\n        void OnClientQueryFailed(Client* client, const std::string& messageId, Query query, Client::QueryError reason) override;\n\n        /* IResourceLocator */\n        /* 返回值格式：musikcore://remote-track/<{{ \"uri\", scheme + host + \":\" + std::to_string(port) + \"/audio/id/\" + std::to_string(track->GetId())},\n        { \"originalUri\", std::string(track->Uri()) }, \n        { \"type\", type }, \n        { \"password\", password }\n        }.dump()> */\n        std::string GetTrackUri(mymusic::core::sdk::ITrack* track, const std::string& defaultUri) override;\n\n        /* RemoteLibrary */\n        /* 根据配置文件重新加载数据库连接 */\n        void ReloadConnectionFromPreferences();\n        /* 返回wsc对象 */\n        const mymusic::core::net::WebSocketClient& WebSocketClient() const;\n\n    private:\n        /* 专门用来表示QueryCompleted的消息 */\n        class QueryCompletedMessage;\n\n        struct QueryContext {\n            std::shared_ptr<mymusic::core::db::ISerializableQuery> query;\n            Callback callback;\n        };\n\n        using QueryContextPtr = std::shared_ptr<QueryContext>;\n        using QueryList = std::list<QueryContextPtr>;\n        /* 处理查询消息（对queueMutex加锁，再调用RunQueryOnWebSocketClient） */\n        void RunQuery(QueryContextPtr context);\n        void RunQueryOnLoopback(QueryContextPtr context);\n        /* 在WebSocketClient上运行查询（将query插入wsc的队列，若插入成功，会返回对应的messageId，否则，调用OnQueryCompleted函数发送此查询完成的消息，然后通知所有等待在syncQueryCondition上的线程） */\n        void RunQueryOnWebSocketClient(QueryContextPtr context);\n        /* 根据messageId得到对应的context=queriesInFlight[messageId]，再将这对映射关系从queriesInFlight中删除；再调用OnQueryCompleted(context)，然后通知所有等待在syncQueryCondition上的线程 */\n        void OnQueryCompleted(const std::string& messageId, Query query);\n        /* 若messageQueue非空，则将要投递给this的MESSAGE_QUERY_COMPLETED类型的消息加入消息队列，否则，向连接到QueryCompleted上的接收者通知context对应的查询完成的消息，再执行回调函数 */\n        void OnQueryCompleted(QueryContextPtr context);\n        /* 向连接到QueryCompleted上的接收者通知context对应的查询完成的消息，再执行回调函数 */\n        void NotifyQueryCompleted(QueryContextPtr context);\n        /* 判断是否在queryQueue或queriesInFlight中 */\n        bool IsQueryInFlight(Query query);\n        /* thread线程要运行的函数 */\n        void ThreadProc();\n```\n```cpp\n        /* 获取queryQueue中的下一个QueryContextPtr */\n        QueryContextPtr GetNextQuery();\n        /* 要查询的QueryContext先放到queryQueue，等wsc将QueryContext加入到待发送队列后，QueryContext移入queriesInFlight */\n        QueryList queryQueue;\n        /* 消息队列 */\n        mymusic::core::runtime::IMessageQueue* messageQueue;\n        /* WebSocketClient对象，作为客户端 */\n        mymusic::core::net::WebSocketClient wsc;\n        /* 标识符 */\n        std::string identifier;\n        int id;\n        /* 音乐资料库名 */\n        std::string name;\n        /* 那些加入到wsc待发送消息的队列中的QueryContextPtr，和与之对应的messageId */\n        std::unordered_map<std::string, QueryContextPtr> queriesInFlight;\n        /* 开辟的专门用来查理查询消息的线程 */\n        std::unique_ptr<std::thread> thread;\n        std::condition_variable_any queueCondition, syncQueryCondition;\n        /* 互斥量，保证任一时刻最多只有一个线程处理queryQueue+queriesInFlight */\n        std::recursive_mutex queueMutex;\n        /* 连接状态 */\n        std::atomic<ConnectionState> connectionState{ ConnectionState::Disconnected };\n        /* 是否退出 */\n        std::atomic<bool> exit;\n};\n```\n","tags":["音乐播放器"],"categories":["program"]},{"title":"musikcube之LocalLibrary类","url":"/program/LocalLibrary.html","content":"\n该类管理本地的音乐资料库并提供编辑本地音乐资料库的接口，定义于src/musikcore/library/LocalLibrary.h，继承了ILibrary、IMessageTarget类，并通过继承模板类std::enable_shared_from_this使得this指针成为shared_ptr指针。\n\n```cpp\nclass LocalLibrary :\n    public ILibrary,\n    public mymusic::core::runtime::IMessageTarget,\n    public std::enable_shared_from_this<LocalLibrary>\n{\n    public:\n        using LocalQuery = mymusic::core::library::query::QueryBase;\n        using LocalQueryPtr = std::shared_ptr<LocalQuery>;\n        using MessageQueue = mymusic::core::runtime::IMessageQueue;\n        using IIndexer = mymusic::core::IIndexer;\n        /* 生成一个LocalLibrary对象，返回其智能指针 */\n        static ILibraryPtr Create(std::string name, int id, MessageQueue* messageQueue);\n        LocalLibrary(const LocalLibrary&) = delete;\n        /*  LocalLibrary类析构函数：关闭该类（释放indexer成员，thread成员置空，清空queryQueue，exit置为true，通知所有等待在queueCondition上的线程，等待线程thread的结束，并回收它的资源）；若messageQueue成员非空，将this从其中注销 */\n        virtual ~LocalLibrary();\n        /* ILibrary */\n        /* 将context加入queryQueue并通知所有等待在queryQueue上的线程 */\n        int Enqueue(QueryPtr query, Callback cb = Callback()) override;\n        /* 若timeoutMs=-1，则直接处理，无需加入队列；若timeoutMs=0，将context加入queryQueue并通知所有等待在queryQueue上的线程即可！若timeoutMs>0，则要么等待 timeoutMs退出，要么query提前被处理完（包括出错）然后退出 */\n        int EnqueueAndWait(QueryPtr query, size_t timeoutMs = kWaitIndefinite, Callback cb = Callback()) override;\n        /* 返回indexer成员 */\n        IIndexer *Indexer() override;\n        /* 返回id成员的值 */\n        int Id() override;\n        /* 返回name成员的值 */\n        const std::string& Name() override;\n        /* 设置消息队列messageQueue成员 */\n        void SetMessageQueue(mymusic::core::runtime::IMessageQueue& queue) override;\n        /* 返回messageQueue成员 */\n        MessageQueue& GetMessageQueue() override { return *messageQueue; }\n        /* 返回sResourceLocator */\n        IResourceLocator& GetResourceLocator() override;\n        /* 判断indexer成员是否设置了音乐资料库的路径 */\n        bool IsConfigured() override;\n        ConnectionState GetConnectionState() const override { return ConnectionState::Connected; }\n        Type GetType() const override { return Type::Local; }\n        /* 关闭该类（释放indexer成员，thread成员置空，清空queryQueue，exit置为true） */\n        void Close() override;\n        /* IMessageTarget */\n        /* 处理消息队列上的消息message */\n        void ProcessMessage(mymusic::core::runtime::IMessage &message) override;\n\n        /* implementation specific */\n        db::Connection& GetConnection() { return this->db; }\n        /* 获取资料库所在目录 */\n        std::string GetLibraryDirectory();\n        /* 获取数据库文件名 */\n        std::string GetDatabaseFilename();\n        /* 创建数据库 */\n        static void CreateDatabase(db::Connection &db);\n        /* indexes */\n        static void DropIndexes(db::Connection &db);\n        /* 创建数据库索引 */\n        static void CreateIndexes(db::Connection &db);\n        /* 删除播放记录 */\n        static void InvalidateTrackMetadata(db::Connection &db);\n    private:\n        class QueryCompletedMessage;\n\n        struct QueryContext {\n            LocalQueryPtr query;\n            /* 回调函数 */\n            Callback callback;\n        };\n\n        using QueryContextPtr = std::shared_ptr<QueryContext>;\n        /* 未使用... */\n        using QueryList = std::list<QueryContextPtr>;\n        /* LocalLibrary类构造函数：若messageQueue成员非空，在messageQueue上注册它本身；其identifier设置为id的字符串形式；与数据库文件*db建立连接 创建thread成员，运行的函数为ThreadProc */\n        LocalLibrary(std::string name, int id, MessageQueue* messageQueue); /* ctor */\n        /* 运行查询语句，查询完成后，若messageQueue成员非空，将查询完成的消息投递到messageQueue中；否则，通过sigslot消息传递机制来传递查询完成消息 */\n        void RunQuery(QueryContextPtr context, bool notify = true);\n        /* 主线程要运行的函数 */\n        void ThreadProc();\n        /* 获取queueCondition的第一个context（如果非空的话） */\n        QueryContextPtr GetNextQuery();\n        /* 查询队列 */\n        QueryList queryQueue;\n        /* 消息队列 */\n        mymusic::core::runtime::IMessageQueue* messageQueue;\n        /* 标识符 */\n        std::string identifier;\n        int id;\n        /* 音乐资料库名 */\n        std::string name;\n        /* 线程对象 */\n        std::thread* thread;\n        /* 条件变量，与mutex的锁配合使用 */\n        std::condition_variable_any queueCondition;\n        /* 互斥量 */\n        std::recursive_mutex mutex;\n        /* 标志是否退出 */\n        std::atomic<bool> exit;\n        /* 数据库的客户端 */\n        core::IIndexer *indexer;\n        /* 数据库连接 */\n        core::db::Connection db;\n};\n```\n\n","tags":["音乐播放器"],"categories":["program"]},{"title":"musikcube之LibraryFactory类","url":"/program/LibraryFactory.html","content":"\n该类管理并访问音乐资料库（本地+远程），定义于src/musikcore/library/LibraryFactory.h\n\n```cpp\nclass LibraryFactory {\n    public:\n        using LibraryVector = std::vector<ILibraryPtr>;\n        using LibraryMap = std::map<int, ILibraryPtr>;\n        /* 使用sigslot库传递消息，减少对象之间的耦合性 */\n        using LibrariesUpdatedEvent = sigslot::signal0<>;\n        using IMessageQueue = mymusic::core::runtime::IMessageQueue;\n        /* 传递消息的发送端 */\n        LibrariesUpdatedEvent LibrariesUpdated;\n        /* 不做任何操作 */\n        ~LibraryFactory();\n        /* 设置消息队列 */\n        static void Initialize(IMessageQueue& messageQueue);\n        /* 单例懒汉模式 */\n        static LibraryFactory& Instance();\n        /* 依次关闭每个资料库，再关闭向量libraries与Map libraryMap */\n        static void Shutdown();\n        /* 返回默认本地音乐资料库的指针 */\n        ILibraryPtr DefaultLocalLibrary();\n        /* 返回默认远程音乐资料库的指针 */\n        ILibraryPtr DefaultRemoteLibrary();\n        /* 返回type类型对应的默认音乐资料库 */\n        ILibraryPtr DefaultLibrary(ILibrary::Type type);\n        /* 返回libraries成员 */\n        LibraryVector Libraries();\n        /* 先判断类型为type，名为name的音乐资料库是否已创建，若已创建且未被删除，则返回此资料库的指针即可\n         * 若已创建但被删除，则重新调用AddLibrary创建；若之前从未创建此资料库，则为其分配一个唯一的id，并创建资料库 */\n        ILibraryPtr CreateLibrary(const std::string& name, ILibrary::Type type);\n        /* 根据id获取对应的资料库 */\n        ILibraryPtr GetLibrary(int identifier);\n\n    private:\n        /* 调用CreateLibrary创建名为default-local-library的本地音乐资料库与名为default-remote-library的远程音乐资料库 */\n        LibraryFactory();\n        /* 调用type类型资料库类的Create函数创建资料库，并存入libraries，然后通知LibrariesUpdated连接到的接收者\n         * 最后返回资料库的指针 */\n        ILibraryPtr AddLibrary(int id, ILibrary::Type type, const std::string& name);\n        /* 存储资料库 */\n        LibraryVector libraries;\n        /* 维护id与资料库的映射关系 */\n        LibraryMap libraryMap;\n};\n```\n\n关于CreateLibrary，其主要部分是根据情况调用LocalLibrary类或RemoteLibrary类的Create函数，下面详细介绍LocalLibrary类与RemoteLibrary类\n","tags":["音乐播放器"],"categories":["program"]},{"title":"musikcube之PluginFactory类","url":"/program/PluginFactory.html","content":"\n该类负责对plugins文件夹下的动态链接库进行组织，与其中函数的调用。定义于src/musikcore/plugin/PluginFactory.h\n\n```cpp\nclass PluginFactory {\n    public:\n        /* 单例懒汉模式 */\n        static PluginFactory& Instance();\n        /* 模板结构体，将运算符()重载为释放 */\n        template <typename T>\n        struct ReleaseDeleter {\n            void operator()(T* t) {\n                t->Release();\n            }\n        };\n\n        template <typename T>\n        struct NullDeleter {\n            void operator()(T* t) {\n            }\n        };\n        /* 调用functionName对应的函数，并将该函数的返回值作为参数传入handler */\n        template <class T, class D> void QueryInterface(\n            const std::string& functionName,\n            std::function<void(mymusic::core::sdk::IPlugin*, std::shared_ptr<T>, const std::string&)> handler)\n        {\n            std::unique_lock<std::mutex> lock(this->mutex);\n\n            typedef T * STDCALL(PluginInterfaceCall);\n\n            for (std::shared_ptr<Descriptor> descriptor : this->plugins) {\n                if (functionName == \"GetPlugin\" || prefs->GetBool(descriptor->key.c_str(), true)) { /* enabled */\n                    PluginInterfaceCall funcPtr =\n#ifdef WIN32\n                        (PluginInterfaceCall) GetProcAddress((HMODULE)(descriptor->nativeHandle), functionName.c_str());\n#else\n                        (PluginInterfaceCall)dlsym(descriptor->nativeHandle, functionName.c_str());\n#endif\n                    if (funcPtr) {\n                        T* result = funcPtr();\n\n                        if (result) {\n                            handler(descriptor->plugin, std::shared_ptr<T>(result, D()), descriptor->filename);\n                        }\n                    }\n                }\n            }\n        }\n        /* 获取动态链接库中所有有名为functionName的函数的plugin */\n        template <class T, class D> std::vector<std::shared_ptr<T> > QueryInterface(const std::string& functionName) {\n            std::vector<std::shared_ptr<T> > plugins;\n\n            QueryInterface<T, D>(\n                functionName,\n                [&plugins](\n                    mymusic::core::sdk::IPlugin* unused,\n                    std::shared_ptr<T> plugin,\n                    const std::string& fn)\n                    {\n                        plugins.push_back(plugin);\n                    });\n\n            return plugins;\n        }\n        /* 调用动态链接库中所有名为functionName的函数 */\n        template <class T> void QueryFunction(\n            const std::string& functionName,\n            std::function<void(mymusic::core::sdk::IPlugin*, T)> handler)\n        {\n            std::unique_lock<std::mutex> lock(this->mutex);\n\n            for (std::shared_ptr<Descriptor> descriptor : this->plugins) {\n                if (prefs->GetBool(descriptor->key.c_str(), true)) { /* if enabled by prefs */\n                    T funcPtr =\n#ifdef WIN32\n                        (T) GetProcAddress((HMODULE)(descriptor->nativeHandle), functionName.c_str());\n#else\n                        (T)dlsym(descriptor->nativeHandle, functionName.c_str());\n#endif\n                    if (funcPtr) {\n                        handler(descriptor->plugin, funcPtr);\n                    }\n                }\n            }\n        }\n        /* 查询Guid为guid的plugin */\n        std::shared_ptr<mymusic::core::sdk::IPlugin> QueryGuid(const std::string& guid) {\n            using T = mymusic::core::sdk::IPlugin;\n            std::shared_ptr<T> result;\n            using Deleter = PluginFactory::ReleaseDeleter<T>;\n            Instance().QueryInterface<T, Deleter>(\n                \"GetPlugin\",\n                [&result, guid](T* unused, std::shared_ptr<T> plugin, const std::string& fn) {\n                    if (std::string(plugin->Guid()) == guid) {\n                        result = plugin;\n                    }\n                });\n            return result;\n        }\n```\n```cpp\n    private:\n        /* plugin的描述符 */\n        struct Descriptor {\n            mymusic::core::sdk::IPlugin* plugin;\n            /* 对应的动态链接库文件描述符 */\n            void* nativeHandle; \n            /* 对应的动态链接库文件的绝对路径 */\n            std::string filename;\n            /* 对应的动态链接库文件名 */\n            std::string key;\n        };\n        /* 设置对象的属性于prefs，然后调用LoadPlugins */\n        PluginFactory();\n        /* 依次释放每个动态链接库对应的plugin，然后关闭对应的动态链接库；最后清除plugins向量 */\n        ~PluginFactory();\n        /* 加载plugins目录下的所有动态链接库，调用其中的GetPlugin函数获取该动态链接库对应的plugin，并设置对应的Descriptor\n         * 所有的这些plugin存入plugins向量中*/\n        void LoadPlugins();\n        /* 存储所有的plugin */\n        std::vector<std::shared_ptr<Descriptor> > plugins;\n        /* 对象的互斥锁  */\n        std::mutex mutex;\n        /* 对象的属性  */\n        std::shared_ptr<mymusic::core::sdk::IPreferences> prefs;\n};\n```\n","tags":["音乐播放器"],"categories":["program"]},{"title":"musikcube之Preferences类","url":"/program/Preferences.html","content":"\n类Preferences就是用来处理项目的配置文件。它定义于src/musikcore/support/Preferences.h，继承自类IPreferences（类IPreferences定义于src/musikcore/sdk/IPreferences.h，仅定义了一些读取与设置配置项的虚函数，具体由子类实现）\n\n```cpp\nclass Preferences : public mymusic::core::sdk::IPreferences {\n    public:\n        enum Mode {\n            ModeTransient,\n            ModeReadOnly,\n            ModeReadWrite,\n            ModeAutoSave\n        };\n        /* 调用plugins文件夹下每个动态链接库中的SetPreferences函数（如果存在的话）来设置每个插件的属性 */\n        static void LoadPluginPreferences();\n        /* 保存所有插件的配置项 */\n        static void SavePluginPreferences();\n\n        static mymusic::core::sdk::IPreferences* Unmanaged(const std::string& name);\n        /* 获取pluginName对应插件的属性 */\n        static std::shared_ptr<Preferences>\n            ForPlugin(const std::string& pluginName);\n        /* 获取c，mode对应组件的属性 */\n        static std::shared_ptr<Preferences>\n            ForComponent(const std::string& c, Mode mode = ModeAutoSave);\n        /* 在ModeAutoSave模式下，保存该属性的值再析构  */\n        ~Preferences();\n\n        /* IPreferences (for plugin use) */\n        /* 在ModeTransient模式下，释放该属性结构体内存区域  */\n        virtual void Release() override;\n        /* 查询key对应的属性项是否被允许，若未设置该属性项的值则默认设置为false  */\n        bool GetBool(const char* key, bool defaultValue = false) override;\n        /* 获取key对应的属性项的值，若未设置该属性项的值则默认设置为0  */\n        int GetInt(const char* key, int defaultValue = 0) override;\n        /* 获取key对应的属性项的值（double类型），若未设置该属性项的值则默认设置为0.0  */\n        double GetDouble(const char* key, double defaultValue = 0.0f) override;\n        /* 获取key对应的属性项的值，若未设置该属性项的值则默认设置为空字符串  */\n        int GetString(const char* key, char* dst, size_t size, const char* defaultValue = \"\") override;\n        /* 设置key对应的属性项的值  */\n        void SetBool(const char* key, bool value) override;\n        void SetInt(const char* key, int value) override;\n        void SetDouble(const char* key, double value) override;\n        void SetString(const char* key, const char* value) override;\n\n        void Save() override;\n\n        /* easier interface for internal use */\n        bool GetBool(const std::string& key, bool defaultValue = false);\n        int GetInt(const std::string& key, int defaultValue = 0);\n        double GetDouble(const std::string& key, double defaultValue = 0.0f);\n        std::string GetString(const std::string& key, const std::string& defaultValue = \"\");\n\n        void SetBool(const std::string& key, bool value);\n        void SetInt(const std::string& key, int value);\n        void SetDouble(const std::string& key, double value);\n        void SetString(const std::string& key, const char* value);\n        /* 获取json中所有的键  */\n        void GetKeys(std::vector<std::string>& target);\n        /* 判断key是否在json中  */\n        bool HasKey(const std::string& key);\n        /* 将key从json中删除  */\n        void Remove(const std::string& key);\n\n    private:\n        Preferences(const std::string& component, Mode mode);\n        void Load();\n        /* 对象的互斥锁  */\n        std::mutex mutex;\n        /* 存储属性项及其值  */\n        nlohmann::json json;\n        /* 该属性对象对应的组件名称  */\n        std::string component;\n        /* 该对象的属性项的值保存方式  */\n        Mode mode;\n};\n```\n","tags":["音乐播放器"],"categories":["program"]},{"title":"musikcube之plugins类","url":"/program/plugins.html","content":"\n## 前言\n\n为更方便地理解muscikcube这个项目，我下载muscikcube的[standalone_linux版](https://github.com/clangen/musikcube/releases)，是muscikcube源码在Linux平台下编译出的bin文件夹。\n\n根目录下的文件如下\n\n```bash\nlib  libmusikcore.so  locales  musikcube  musikcubed  plugins  share  themes\n```\n\nplugins文件夹下就是项目中各个插件对应的动态链接库。\n\n```bash\nlibalsaout.so                libgmedecoder.so      libnullout.so                   libpipewireout.so  libserver.so                libsupereqdsp.so\nlibffmpegdecoder.so  libhttpdatastream.so  libopenmptdecoder.so  libpulseout.so        libstockencoders.so  libtaglibreader.so\n```\n\n## plugin命名空间\n\nplugin是项目中很重要的一个命名空间，其中的函数完成对plugins文件夹下的动态链接库的加载。\n\nplugin命名空间的定义如下(src/musikcore/plugin/Plugins.h)\n\n```cpp\nnamespace musik { namespace core { namespace plugin {\n\n    void Init();\n\n    void Start(\n        musik::core::runtime::IMessageQueue* messageQueue,\n        musik::core::sdk::IPlaybackService* playback,\n        musik::core::ILibraryPtr library);\n\n    musik::core::sdk::IEnvironment& Environment();\n\n    void Deinit();\n\n} } }\n```\n\n该命名空间中有三个函数：Init、Start与Deinit。\n\n## Init函数\n\n```cpp\nvoid Init() {\n    /* preferences */\n    Preferences::LoadPluginPreferences();\n\n    /* debug */\n    PluginFactory::Instance().QueryFunction<SetDebug>(\n        \"SetDebug\",\n        [](mymusic::core::sdk::IPlugin* plugin, SetDebug func) {\n        func(&debugger);\n    });\n}\n```\n\nplugin::Init函数在客户端/服务端启动时运行，初始化项目插件。其主要内容就是加载各插件的属性值，通过调用类Preferences的LoadPluginPreferences函数完成。\n\n## Start函数\n\n```cpp\nvoid Start(IMessageQueue* messageQueue, IPlaybackService* playbackService, ILibraryPtr library) {\n    /* metadata proxies */\n    delete metadataProxy;\n    ::messageQueue = messageQueue;\n    ::defaultLibrary = library;\n    ::playbackService = playbackService;\n    ::playbackPrefs = Preferences::ForComponent(prefs::components::Playback);\n\n    /* even if the local client is connected to a remote server, the metadata proxy\n    always uses the default local library. */\n    ::metadataProxy = new LocalMetadataProxy(LibraryFactory::Instance().DefaultLocalLibrary());\n\n    PluginFactory::Instance().QueryFunction<SetMetadataProxy>(\n        \"SetMetadataProxy\",\n        [](mymusic::core::sdk::IPlugin* plugin, SetMetadataProxy func) {\n            func(metadataProxy);\n        });\n    \n    /* indexer */\n    IIndexerNotifier* indexerNotifier =\n        dynamic_cast<IIndexerNotifier*>(library->Indexer());\n\n    PluginFactory::Instance().QueryFunction<SetIndexerNotifier>(\n        \"SetIndexerNotifier\",\n        [indexerNotifier](mymusic::core::sdk::IPlugin* plugin, SetIndexerNotifier func) {\n            func(indexerNotifier);\n        });\n\n    /* environment */\n    PluginFactory::Instance().QueryFunction<SetEnvironment>(\n        \"SetEnvironment\",\n        [](mymusic::core::sdk::IPlugin* plugin, SetEnvironment func) {\n            func(&environment);\n        });\n}\n```\n\nStart函数完成一些设置。整个程序的运行由EvMessageQueue类的对象messageQueue的Run函数带动。\n","tags":["音乐播放器"],"categories":["program"]},{"title":"musikcube项目概述","url":"/program/general.html","content":"\n## 前言\n\n[muscikcube](https://github.com/clangen/musikcube)其实还不算大型的项目，但即便如此，不理清它的结构，看起来还是很头疼的！\n\n本文使用的是muscikcube目前的最新版本—[0.97.0](https://github.com/clangen/musikcube/releases)；下载源码解压，根目录下的文件如下。\n\n```bash\nCHANGELOG.txt  CMakeLists.txt  CONTRIBUTORS.txt  LICENSE.txt  musikcube.sln  musikcube.spec  README.md  script  src\n```\n\n源码在src目录下，有如下文件\n\n```bash\n3rdparty  core_c_demo  musikcore  musikcube  musikcubed  musikdroid  musikwin  plugins\n```\n\n根据名字也很容易猜出来：\n\n* 3rdparty  使用的第三方库\n* musikcore  muscikcube的核心功能\n* musikcube  muscikcube的客户端\n* musikcubed  musikcube的服务端\n* musikwin  musikcube适配Windows系统额外增加的代码\n* musikdroid  musikcube适配安卓系统额外增加的代码\n* plugins  插件（后面会具体讲）\n\n当然，本项目有CMakeLists.txt，那么这才是理解此项目最有效的切入点，但是在此之前需要学习cmake的语法。\n\n## CMAKE\n\n```cmake\nset  将普通的、缓存的或环境变量设置为给定值\n```\n\n```cmake\ninclude  可用于包含cmake的模块，便于之后调用模块中的方法；也可用于包含.cmake目录下的cmake脚本\n```\n\n```cmake\nmessage  输出信息\n```\n\n```cmake\ninclude_directories  指定查找头文件的目录，可简化源文件中要包含的头文件的路径\n```\n\n```cmake\nfind_package  找到一个包（通常由项目外部的东西提供），并加载其包特定的细节\n```\n\n```cmake\nfind_library  此命令用于查找库\n```\n\n```cmake\nadd_subdirectory  将子目录添加到build中，将执行子目录下的CMakeLists.txt\n```\n\n```cmake\nadd_dependencies  在顶级目标之间添加依赖关系\n```\n\n更多信息参考[cmake官方文档](https://cmake.org/cmake/help/latest/)\n\n## 理解CMakeList\n\n从CMakeList.txt中我们可以看出\n\n* musikcube与musikcubed依赖于musikcore\n* plugins中的文件夹各自编译出对应的动态链接库，musikcubed在初始化时将其加载\n\n接下来介绍一些重要的类（Preferences、PluginFactory、Connection、Indexer、ISerializableQuery、LibraryFactory（LocalLibrary与RemoteLibrary）、EvMessageQueue、PlaybackService、WebSocketClient），以及命名空间plugin中的函数，弄清楚了这些类与函数，也就基本上理解了这个项目。\n\n通常，一个C++网络编程项目的标准框架如下\n\n```bash\n____________________________________________________________\n|    _________           __________             ______________           |\n|    |网络库  |           |数据库   |             |  消息队列    |           |\n|    |________|           |_________|             |_____________|          |\n|                                                                                         |\n|    ___________           ____________              ____________       |\n|    |RPC框架  |           |配置文件   |             |  序列化    |        |\n|    |__________|           |___________|             |___________|       |\n|___________________________________________________________|\n```\n\nWebSocketClient类对应网络库\n\nConnection类与Indexer类对应数据库\n\n(Ev)MessageQueue类对应消息队列\n\nPreferences类对应配置文件\n\nISerializableQuery对应序列化（只是对nlohmann::json类的封装）\n\n分析RPC实现的原理（callback）\n","tags":["音乐播放器"],"categories":["program"]},{"title":"第一章第四节 关联容器","url":"/course/cpp-ch1-par4.html","content":"\n## map容器\n\n提供一对一映射功能的容器，内部采用红黑树实现。定义于`<map>`。\n\n构造\n\n```c++\n/* 默认初始化：定义一个空的map容器 */\nmap<int, string> ismap;\n\n/* 赋值构造 */\nmap<int, string> ismap{{1, \"one\"}, {2, \"two\"}, {3, \"three\"}};\n\n/* 拷贝复制 */\nmap<int, string> ismap(ismap_0);\n\n/* 移动构造\n * 区别在于此处的ismap_0是右值\n * ismap接管了ismap_0所在内存\n * 无需拷贝，相比拷贝复制构造更快\n */\nmap<int, string> ismap(ismap_0);\n\n/* 拷贝从it_low到it_high（左闭右开）的元素 */\nmap<int, string> ismap(it_low, it_high);\n```\n\n插入\n\n```c++\nismap.insert(pair<int, string>(2, \"two\"));\n\nismap.insert(map<int, string>::value_type(2, \"two\"));\n\n/* 先判断ismap的key集合中是否有2，若有则修改对应的value；否则插入键-值 */\nismap[2]=string(\"two\");\n```\n\n查找\n\n```c++\n/* 返回0代表2不存在，返回1代表2存在 */\nismap.count(2);\n\n/* 若2存在返回所在位置的迭代器，否则返回ismap.end() */\nismap.find(2);\n```\n\n删除\n\n```c++\nismap.erase(it);\n\nismap.erase(it_low, it_high);\n```\n\n**multimap**：一个键可以多次出现，对应的查找操作也有所不同，定义于`<map>`\n\n```c++\n/* equal_range返回一个pair<multimap<int, int>::iterator, multimap<int, int>::iterator>对象\n * 若3存在，则pos.first指向第一个键值等于3的元素\n * pos.second指向第一个键值大于3的元素（如果存在的话，否则指向iimap.end()）\n */\nauto pos=iimap.equal_range(3);\nmultimap<int, int>::iterator it;\nfor(it=pos.first; it != pos.second; ++it){}\n```\n\n**unorderd_map**：使用哈希表实现，元素无序。不利于查找，利于插入删除。操作与map相同。定义于`<unorderd_map>`。\n\n## set容器\n\n提供集合功能，内部采用红黑树实现。定义于`<set>`。\n\n```c++\n/* 默认初始化：定义一个空的map容器 */\nset<int> iset;\n\n/* 赋值构造 */\nset<int> iset{1, 2, 3};\n\n/* 拷贝复制 */\nset<int> iset(iset_0);\n\n/* 移动构造\n * 区别在于此处的ismap_0是右值\n * ismap接管了ismap_0所在内存\n * 无需拷贝，相比拷贝复制构造更快\n */\nset<int> iset(iset_0);\n\n/* 拷贝从it_low到it_high（左闭右开）的元素 */\nset<int> iset(it_low, it_high);\n```\n\n插入\n\n```c++\n/* 当num不存在于iset时，可插入 */\niset.insert(num);\n```\n\n查找\n\n```c++\n/* 返回0代表2不存在，返回1代表2存在 */\niset.count(2);\n\n/* 若2存在返回所在位置的迭代器，否则返回iset.end() */\niset.find(2);\n```\n\n删除\n\n```c++\niset.erase(it);\n\niset.erase(it_low, it_high);\n```\n\n**multiset**：一个元素可以出现多次，对应的查找操作也有所不同，定义于`<set>`\n\n```c++\n/* equal_range返回一个pair<multiset<int>::iterator, multiset<int>::iterator>对象\n * 若3存在，则pos.first指向第一个键值等于3的元素\n * pos.second指向第一个键值大于3的元素（如果存在的话，否则指向iimap.end()）\n */\nauto pos=imset.equal_range(3);\nmultiset<int>::iterator it;\nfor(it=pos.first; it != pos.second; ++it){}\n```\n\n**unorderd_set**：使用哈希表实现，元素无序。不利于查找，利于插入删除。操作与set相同。定义于`<unorderd_set>`。\n","tags":["C++"],"categories":["course"]},{"title":"第一章第三节 容器适配器","url":"/course/cpp-ch1-par3.html","content":"\n## stack容器适配器\n\nstack基于deque容器进一步封装，只能从栈顶插入与删除。定义于`<stack>`。\n\n构造\n\n```c++\n/* 默认初始化：定义一个空的stack容器 */\nstack<int> istack;\n\n/* 拷贝复制 */\nstack<int> istack(istack_0);\n```\n\n插入\n\n```c++\n/* 从栈顶添加一个值为num的元素 */\nistack.push(num);\n```\n\n删除\n\n```c++\n/* 从栈顶删除一个元素 */\nistack.pop();\n```\n\n## queue容器适配器\n\nqueue容器基于dqueue容器进一步封装，只支持从队头删除，从队尾插入。定义于`<queue>`。\n\n构造\n\n```c++\n/* 默认初始化：定义一个空的queue容器 */\nqueue<int> iqueue;\n\n/* 拷贝复制 */\nqueue<int> iqueue(iqueue_0);\n```\n\n插入\n\n```c++\n/* 从queue容器尾部添加一个值为num的元素 */\niqueue.push(num);\n```\n\n删除\n\n```c++\n/* 从queue容器头部删除一个元素 */\niqueue.pop();\n```\n\n## priority_queue容器适配器\n\npriority_queue容器适配器的定义如下，默认基于vector容器。除了具有queue容器适配器的特性——只支持从队头删除，从队尾插入之外，它还会将元素按照优先级大小从大到小进行排序。定义于`<priority_queue>`。\n\n```c++\ntemplate <typename T,\n        typename Container=std::vector<T>,\n        typename Compare=std::less<T> >\nclass priority_queue{\n    /* ... ... */\n}\n```\n\n插入\n\n```c++\n/* 从priority_queue容器尾部添加一个值为num的元素\n * 并按照优先级进行排序\n */\nipriority_queue.push(num);\n```\n\n删除\n\n```c++\n/* 从priority_queue容器头部删除一个元素 */\nipriority_queue.pop();\n```\n\n","tags":["C++"],"categories":["course"]},{"title":"第一章第二节 顺序容器类型","url":"/course/cpp-ch1-par2.html","content":"\n## vector容器\n\nvector类是C++为内置数组引入的一种替代表示，建议使用。要使用vector类，需包含头文件`vector`。通过动态数组实现。定义于`<vector>`\n\n构造\n\n```c++\n/* 默认初始化：定义一个空的vector容器 */\nvector<int> ivec;\n\n/* 赋值构造 */\nvector<int> ivec={3, 6,9, 2, 5, 7};\n/* 构造包含为7个值为3的元素的vector容器，若3未指定，则默认为0 */\nvector<int> ivec(7, 3);\n\n/* 拷贝复制 */\nvector<int> ivec(ivec_0);\n\n/* 通过数组arr[0:3]（左闭右开）构造 */\nvector<int> ivec(arr, arr+3);\n```\n\n插入\n\n```c++\n/* 从vector容器尾部添加一个值为num的元素 */\nivec.push_back(num);\n```\n\n注：虽然使用insert泛型算法可以在容器的任意位置插入元素，但是不建议这么做，因为vector是通过动态数组实现，在其他位置插入元素会有很大的开销，如果需要在任意位置插入，建议选择其他的容器类型。\n\n删除\n\n```c++\n/* 删除vector容器尾部的元素*/\nivec.pop_back();\n```\n\n## 迭代器\n\n除了使用下标访问vector的元素，还可以使用迭代器进行访问。以vector为例，其他容器同理。\n\n```cpp\nvector<int>::iterator it;\nfor(it=ivec.begin(); it != ivec.end(); ++it)\n```\n\n其中，支持迭代器的容器类型有：vector、list、string、deque、set、map；不支持的有：stack、queue、priority_queue。\n\n对于支持迭代器的顺序容器，其具有访问第一个与最后一个元素的捷径：front方法与back方法；除此之外，queue也具有。\n\n## list容器\n\nlist容器是对C语言中链表的替代表示，内存区域非连续，通过双向链表实现。定义于`<list>`\n\n构造\n\n```c++\n/* 默认初始化：定义一个空的list容器 */\nlist<int> ilist;\n\n/* 赋值构造 */\nlist<int> ilist={3, 6,9, 2, 5, 7};\n\n/* 构造包含为7个值为3的元素的list容器，若3未指定，则默认为0 */\nlist<int> ilist(7, 3);\n\n/* 拷贝复制 */\nlist<int> ilist(ilist_0);\n\n/* 通过数组arr[0:3]（左闭右开）构造 */\nlist<int> ilist(arr, arr+3);\n/* 通过其他类型的容器的一部分（左闭右开）构造 */\nlist<int> ilist(ivec.begin(), ivec.begin()+3);\n```\n\n插入\n\n```c++\n/* 从list容器头部添加一个值为num的元素 */\nilist.push_front(num);\n\n/* 从list容器尾部添加一个值为num的元素 */\nilist.push_back(num);\n\n/* list_it为迭代器，在list_it所在位置插入num */\nilist.insert(list_it, num);\n```\n\n删除\n\n```c++\n/* 从list容器头部删除一个元素 */\nilist.pop_front();\n\n/* 从list容器尾部删除一个元素 */\nilist.pop_back();\n\n/* list_it为迭代器，删除list_it所在位置的元素 */\nilist.erase(list_it);\n/* 删除list_it_low与list_it_high之间的元素（不包含* list_it_high）*/\nilist.erase(list_it_low, list_it_high);\n```\n\n## string\n\nC++标准库提供了字符串类抽象的一个公共实现——string。定义于`<string>`\n\n构造\n\n```c++\n/* 默认初始化：定义一个空的list容器 */\nstring str;\n\n/* 构造包含为7个'a'的元素的string*/\nstring str(7, 'a');\n\n/* 拷贝复制 */\nstring str(str_0);\nstring str(\"hello\");\n\n/* 通过C风格字符串构造 */\nstring str(const char * str_c);\nstring str=\"hello\";\n```\n\n插入\n\n```c++\n/* 在字符串str后添加一个字符ch */\nstr.push_back(ch);\n\n/* 在str的pos处插入字符串str_str */\nstr.insert(pos, string str_str);\nstr.insert(pos, const char * str_str);\n\n/* 在str的pos处插入字符子串str_str[subpos: (subpos+sublen)]（左闭右开）*/\nstr.insert(pos, string str_str, subpos, sublen);\n\n/* 在str的pos处插入字符串str_str的前n个字符 */\nstr.insert(pos, const char * str_str, n);\n\n/* 在str的pos处插入n个字符ch */\nstr.insert(pos, n, ch);\n\n/* 在迭代器it所在位置插入字符ch，并返回插入后迭代器的位置 */\nstr.insert(it, ch);\n\n/* 在迭代器it所在位置插入n个字符ch，并返回插入后迭代器的位置 */\nstr.insert(it, n, ch);\n```\n\n删除\n\n```c++\n/* 删除从pos（默认为0）处开始的len个字符 */\nstr.erase(pos, len);\n\n/* 删除it所在位置的字符，并返回删除后迭代器的位置 */\nstr.erase(it);\n\n/* 删除从it_low到it_high（不包含* it_high）的字符 */\nstr.erase(it_low, it_high);\n```\n\n拼接\n\n```c++\nstr.append(\"hello\");\nstr.append(str_str);\n```\n\n比较\n\n```c++\nstr.compare(string str_str);\nstr.compare(const char * str_str);\n\n/* 将str[pos（默认为0）: (pos+len)]（左闭右开）与str_str比较 */\nstr.compare(pos, len, string str_str);\nstr.compare(pos, len, const char * str_str);\n\n/* 将str[pos（默认为0）: (pos+len)]（左闭右开）与str_str[subpos: (subpos+sublen)]（左闭右开）比较 */\nstr.compare(pos, len, string str_str, subpos, sublen);\n\n/* 将str[pos（默认为0）: (pos+len)]（左闭右开）与str_str的前n个字符组成的字符串比较 */\nstr.compare(pos, len, const char * str_str, n);\n```\n\n子串\n\n```c++\nstr.substr(pos, len);\n```\n\n查找\n\n```c++\n/* 从pos（默认为0）开始查找字符串str_str\n * 若未找到字符串str_str则返回str.npos（表示在str中不存在的位置）\n */\nstr.find(const string str_str, pos);\nstr.find(const char * str_str, pos);\n\n/* 从pos（默认为0）开始查找字符ch\n * 若未找到字符ch则返回str.npos（表示在str中不存在的位置）\n */\nstr.find(ch, pos);\n\n/* 从pos（默认为str.size()-1）开始向前查找字符串str_str\n * 若未找到字符串str_str则返回str.npos（表示在str中不存在的位置）\n */\nstr.rfind(const string str_str, pos);\nstr.rfind(const char * str_str, pos);\n\n/* 从pos（默认为str.size()-1）开始向前查找字符ch\n * 若未找到字符ch则返回str.npos（表示在str中不存在的位置）\n */\nstr.find(ch, pos);\n\n/* 查找字符串str_str中任一字符第一次出现的位置\n * 若未找到则返回str.npos（表示在str中不存在的位置）\n */\nstr.find_first_of(const string str_str);\nstr.find_first_of(const char * str_str);\n\n/* 查找字符串str_str中任一字符最后一次出现的位置\n * 若未找到则返回str.npos（表示在str中不存在的位置）\n */\nstr.find_last_of(const string str_str);\nstr.find_last_of(const char * str_str);\n\n/* 查找第一个str_str未包含的字符\n * 若未找到则返回str.npos（表示在str中不存在的位置）\n */\nstr.find_first_of(const string str_str);\nstr.find_first_of(const char * str_str);\n\n/* 查找最后一个str_str未包含的字符\n * 若未找到则返回str.npos（表示在str中不存在的位置）\n */\nstr.find_last_of(const string str_str);\nstr.find_last_of(const char * str_str);\n```\n\n获取输入\n\n```c++\ngetline(cin, str);\n```\n\n## deque容器\n\ndeque容器为双向队列的抽象表示。通过双端数组实现，内存区域连续。定义于`<deque>`\n\n构造\n\n```c++\n/* 默认初始化：定义一个空的deque容器 */\ndeque<int> ideque;\n\n/* 构造包含为7个值为3的元素的deque容器，若3未指定，则默认为0 */\ndeque<int> ideque(7, 3);\n\n/* 赋值构造 */\ndeque<int> ideque={3, 6,9, 2, 5, 7};\n\n/* 拷贝复制 */\ndeque<int> ideque(ideque_0);\n\n/* 通过其他类型的容器的一部分（左闭右开）构造 */\ndeque<int> ideque(list_it_low, list_it_high);\n```\n\n插入\n\n```c++\n/* 从deque容器头部添加一个值为num的元素 */\nideque.push_front(num);\n\n/* 从deque容器尾部添加一个值为num的元素 */\nideque.push_back(num);\n```\n\n删除\n\n```c++\n/* 从deque容器头部删除一个元素 */\nideque.pop_front();\n\n/* 从deque容器尾部删除一个元素 */\nideque.pop_back();\n```\n\n","tags":["C++"],"categories":["course"]},{"title":"第一章第一节 高级数据类型","url":"/course/cpp-ch1-par1.html","content":"\n## 引用类型\n\n引用的定义如下。\n\n```cpp\nElementType & refvar=var;\n```\n\nrefvar就是一个指向var的引用，对引用的所有操作都作用在它指向的对象上。\n\n引用主要在函数的形式参数中被用到。\n\n## 枚举类型\n\n定义如下。\n\n```cpp\nenum enum_name {val_1,...,val_n};\n```\n\nC++11引入限定作用域的枚举类型`enum class`或`enum struct`，称为枚举类。\n\n## pair类型\n\npair类型用于将两个对象关联起来。\n\n```cpp\npair<Element_1, Element_2> RELA(var_1, var_2);\n```\n\n创建了一个pair对象RELA，它包含两个对象var_1与var_2；要访问var_1，使用RELA.first；要访问var_2，使用RELA.second。\n\n若要定义多个相同pair类型的对象，可使用typedef。\n\n```cpp\ntypedef pair<Element_1, Element_2> RELA;\n```\n\n","tags":["C++"],"categories":["course"]},{"title":"第九章第一节 事务的实现","url":"/course/sql-ch9-par1.html","content":"\nredo：恢复提交事务修改的页操作；undo：回滚行记录到某个特定的版本。\n\nredo是物理日志，记录页的物理修改操作；undo是逻辑日志，对每个行记录进行日志的记录。\n\nredo用来保证事务的持久性；\n\nundo只是将数据库在逻辑上恢复到事务执行前的状态，在物理层面，并不保证与事务执行前的状态完全相同。\n\n## group commit\n\n事务提交会进行两个阶段的操作：\n\n* 修改内存中事务对应的信息，将日志写入重做日志缓冲；\n* 调用fsync将日志从重做日志缓冲写入磁盘；\n\ngroup commit将多个事务的重做日志通过一次fsync刷新到磁盘，提高了数据库的整体性能。\n\n开启二进制日志后，为保证存储引擎层中的事务与二进制日志的一致性，二者使用了两阶段事务，\n\n* 事务提交时InnoDB存储引擎进行perpare操作；\n* MySQL数据库上层写入二进制日志；\n* InnoDB存储引擎将日志写入重做日志文件：(1)修改内存中事务对应的信息，并将日志写入重做日志缓冲；(2)调用fsync将日志从重做日志缓冲写入磁盘。\n\n整个过程如下图。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 36.png pic36 %}</div>\n\n&nbsp;\n\n在MySQL5.6之前，为保证MySQL数据库上层二进制日志的写入顺序与InnoDB层的事务提交顺序一致，InnoDB存储引擎使用prepare_commit_mutex这个锁；那么在prepare_commit_mutex加锁之后，其他要提交的事务在\"MySQL数据库上层写入二进制日志\"这一步就需要等待。\n\n为解决加锁之后不能group commit的问题，使用队列来组织所有要提交的事务的日志。\n\nMySQL5.6 BLGC的实现方式为将事务提交的过程分为如下几步。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 37.png pic37 %}</div>\n\n&nbsp;\n\n* Flush阶段：将事务的二进制日志写入内存；\n* Sync阶段：将内存中的二进制日志刷新到磁盘；\n* Commit阶段：事务按照先后顺序被提交；\n\n这样一组事务在进行group commit时，其他事务可以进行Flush阶段。\n","tags":["数据库"],"categories":["course"]},{"title":"第八章第一节 一致性锁定读","url":"/course/sql-ch8-par1.html","content":"\n## 一致性锁定读\n\nInnoDB存储引擎支持加锁语句，即使对于SELECT的只读操作。其中，`SELECT ...FOR UPDATE`对读取的记录加一个X锁，其他事务不能再对该行加上任何锁；`SELECT ... LOCK IN SHARE MODE `对读取的记录加一个S锁，其他事务可以对该行加S锁，但不能加X锁。\n\n## 锁的算法\n\n* Record Lock：单个行记录的锁；\n* Gap Lock：间隙锁，锁定一个范围，但不包含记录本身；\n* Next-Key Lock：锁定一个范围+单个行记录的锁；\n\nNext-Key Locking机制使InnoDB存储引擎避免了幻象问题：在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果。\n\n## 锁问题\n\n### 脏读\n\n一个事务可以读到另外一个事务未提交的数据。\n\n## 不可重复读\n\n在一个事务中对某数据的两次读取之间，由于其他事务的修改，使得两次读取的数据不一样；注意，这里不可重复读读到的是已经提交的数据。\n\n### 丢失更新\n\n一个事务的更新操作被另一事务的更新操作覆盖。要避免更新丢失，需要让事务在这种情况下的操作变成串行化，而不是并行的操作。\n","tags":["数据库"],"categories":["course"]},{"title":"第七章第二节 哈希索引与全文检索","url":"/course/sql-ch7-par2.html","content":"\n## 哈希索引\n\nInnoDB存储引擎是使用哈希算法对字典进行查找，其冲突机制采用链表方式，哈希函数采用除法散列。被除数K=sapce_id<<20+sapce_id+offset。\n\n## 全文检索\n\n全文检索使用倒排索引实现，它在辅助表中存储单词与单词自身在一个或多个文档中所在位置的映射，这使用关联数组实现，存在两种表现形式：\n\n* inverted file index：{单词，单词所在文档的ID}；\n* full inverted index：{单词，(单词所在文档的ID, 在文档中的具体位置)}；\n\n存放这些映射关系的表称为辅助表(Auxiliary Table)，与之相对应的内存中的镜像为全文检索索引缓存(FTS Index Cache)。\n\n全文检索索引缓存是一个红黑树结构，当对全文检索进行查询时，辅助表先将全文检索索引缓存中对应的word字段合并到辅助表\n\n在InnoDB存储引擎中，必须有一列与word进行映射，该列被命名为FTS_DOC_ID，其类型必须为BIGINT UNSIGNED NOT NULL。\n\nword的插入在事务提交时完成，而对于删除操作，在事务提交时，InnoDB存储引擎并不会删除辅助表中的记录，而只是删除全文检索索引缓存中的记录。对这些从全文检索索引缓存中删除的记录，InnoDB存储引擎会记录其\"单词所在文档的ID\"并将其保存到DELETED辅助表中，\n\n这样，每次删除记录时，不但不会将辅助表中的记录删除，还会写入DELETED辅助表中，为此，InnoDB存储引擎提供了OPTIMIZE TABLE命令将已经删除的记录从索引中彻底删除。\n","tags":["数据库"],"categories":["course"]},{"title":"第七章第一节 B+树索引","url":"/course/sql-ch7-par1.html","content":"\n## 聚集索引\n\n按照每张表的主键构造一棵B+树，叶子节点存放行记录；\n\n可见一张表只能有一个聚集索引。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 32.png pic32 %}</div>\n\n&nbsp;\n\n事实上，聚集索引的存储并不是物理连续的，而是逻辑连续的：(1)页通过双向链表连接，页按照主键的顺序排序；(2)每个页中的记录通过双向链表维护，物理存储上可以不按照主键存储。\n\n## 辅助索引\n\n聚集索引与辅助索引的区别在于，聚集索引的叶节点存放行记录；辅助索引的叶节点存放书签，InnoDB存储引擎通过这个书签可以找到与索引相对应的行记录。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 33.png pic33 %}</div>\n\n&nbsp;\n\n## B+树索引的分裂\n\nB+树索引的节点的插入不完全同于B+树的节点的插入；这是因为通常情况下，插入是按照主键顺序来的，这就导致对半分裂会浪费磁盘空间。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 34.png pic34 %}</div>\n\n&nbsp;\n\n此时插入应该向右分裂，而不是对半分裂。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 35.png pic35 %}</div>\n\n&nbsp;\n\n**Fast Index Creation**：对于辅助索引的创建，InnoDB存储引擎对创建索引的表加上S锁。\n\n## Cardinality值\n\n对于B+树索引，通常在访问表中很少一部分时使用B+树索引才有意义。Cardinality值记为索引中不重复记录数的预估值。Cardinality值/n_row接近1时，创建B+树索引是很有必要的。Cardinality值采用抽样统计。\n\nCardinality值的更新发生在INSERT与UPDATE操作中，但不是每次；在满足如下条件之一时更新：\n\n* 表中1/16的数据已经发生变化；\n* stat_modified_counter>200000000；\n\n## B+树中索引的使用\n\n**覆盖索引**：从辅助索引就可以查询到的记录而不需要查询聚集索引的记录。\n\n**Multi-Range Read优化**：减少磁盘的随机访问，并将随机访问转化为较为顺序的数据访问。其工作原理如下。\n\n* 将查询得到的辅助索引键值存放于一个缓存(此时按照辅助索引排序)；\n* 将缓存中的键值按照主键排序；\n* 根据主键的排序顺序来访问实际的数据文件；\n\n此外，Multi-Range Read还能将某些范围查询拆分为键值对，从而进行批量的数据查询，在拆分的过程中直接过滤掉不符合查询条件的数据。\n\n**Index Condition Pushdown优化**：当进行索引查询时，先根据索引查找记录，再根据WHERE条件来过滤记录，在支持Index Condition Pushdown后，InnoDB存储引擎在取出索引的同时会判断是否满足WHERE条件。\n","tags":["数据库"],"categories":["course"]},{"title":"第六章第一节 存储结构","url":"/course/sql-ch6-par1.html","content":"\n## 索引组织表\n\n根据主键顺序组织存放的表称为索引组织表。InnoDB存储引擎选择建表时第一个定义的非空唯一索引为主键。\n\n## 逻辑存储结构\n\n数据库中的数据存放在表空间，表空间又由段、区、页组成。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 31.png pic31 %}</div>\n\n&nbsp;\n\n* 段：数据段(B+树的叶节点)、索引段(B+树的非叶节点)、回滚段；\n* 区：区的大小永远是1MB；\n* 页：默认页的大小为16KB；通过参数innodb_page_size可将页设置为其他尺寸，但一旦设置之后不可对其再次修改直到导入/导出数据库；\n\n","tags":["数据库"],"categories":["course"]},{"title":"第五章第二节 存储引擎文件","url":"/course/sql-ch5-par2.html","content":"\n## 表空间文件\n\nInnoDB采用将存储的数据按表空间进行存放的设计，在默认配置下会有一个初始大小为10MB，名为ibdata1的文件，该文件即默认的表空间文件。\n\n用户可以通过多个文件(innodb_data_file_path指定)组成一个表空间，同时制定文件的属性。设置innodb_data_file_path参数后，所有基于InnoDB存储引擎的表的数据都会记录到该共享表空间；\n\n若设置了参数innodb_file_per_table，则用户可对每个表单独创建一个独立表空间。即使这样，这些单独表空间仅存储该表的数据、索引与插入缓冲BITMAP等信息，其余信息仍然存放在默认的表空间中。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 30.png pic30 %}</div>\n\n&nbsp;\n\n## 重做日志\n\n在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0与ib_logfile1的文件；作为InnoDB存储引擎的重做日志文件。\n","tags":["数据库"],"categories":["course"]},{"title":"第五章第一节 辅助文件","url":"/course/sql-ch5-par1.html","content":"\n## 参数文件\n\n默认情况下，MySQL会按照一定的顺序在指定的位置读取参数文件，用户可使用mysql --help | grep my.cnf来查看详细信息。\n\n参数可以看作时一组键/值对。如innodb_buffer_pool_size。参数可以分为动态参数(可在MySQL实例运行中修改)与静态参数(在整个MySQL实例周期内均不可修改)\n\n## 日志文件\n\n常见的日志文件有：(1)错误日志；(2)二进制日志；(3)慢查询日志；(4)查询日志。\n\n### 错误日志\n\n该日志对MySQL的启动、运行、关闭过程进行了记录；在数据库遇到问题时应该首先查看该文件。\n\n### 慢查询日志\n\nMySQL在启动时设定一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。数据库管理员每过一段时间对其进行检查从而对数据库进行优化。\n\n### 查询日志\n\n查询日志记录了所有对MySQL数据库请求的信息，无论请求是否可以正确执行。\n\n### 二进制日志\n\n记录对MySQL数据库执行更改的所有操作，包括未使数据库发生变化的操作。\n\n## 套接字文件\n\nunix域socket文件\n\n## pid文件\n\nMySQL实例启动时，会将自身的进程ID写入一个文件，即为pid文件。\n\n## 表结构定义文件\n\nMySQL数据的存储是根据表进行的，每个表都有一个对应的文件来存储表的结构定义，文件后缀名为frm。frm文件还用来存放视图的定义，可直接使用cat命令查看。\n","tags":["数据库"],"categories":["course"]},{"title":"第四章第四节 InnoDB其他关键特性","url":"/course/sql-ch4-par4.html","content":"\n## 两次写\n\n在数据库发生宕机时，若InnoDB存储引擎正在将某个页写入磁盘，这种情况称为部分写失效。此时页本身发生了损坏，而不是对页的修改未完全写入，故无法通过重做日志恢复。为此，引入doublewrite技术解决部分写失效的问题。\n\ndoublewrite的架构图如下。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 29.png pic29 %}</div>\n\n&nbsp;\n\ndoublewrite由两部分组成：(1)内存中的doublewrite buffer，大小2MB；(2)磁盘上共享表空间中连续的128个页，同样为2MB；在对缓冲池中的脏页进行刷新时，先通过memcpy函数将脏页复制到内存中的doublewrite buffer，之后分两次，从doublewrite buffer中每次1MB顺序地写入共享表空间，再立即调用fsync函数立即同步磁盘；\n\n由于共享表空间是连续的，因此从doublewrite buffer中将页写入共享表空间的速度很快；而从共享表空间同步到磁盘则是离散写，速度较慢；此时的写可能被宕机终止，数据库系统重启后只需要从共享表空间复制副本即可！\n\n## 自适应哈希索引\n\n通过哈希查找的时间复杂度为O(1)，InnoDB存储引擎会监控表上各索引页的查询，如果观察到建立哈希索引可用带来速度的提升，则建立哈希索引，即自适应哈希索引(AHI)。AHI通过缓冲池的B+树页构造而来，而不需要对整张表建立哈希索引，因此建立起来很快。\n\n查询的条件称为访问模式；当客户端以同样的访问模式连续访问，且(1)以该模式连续访问100次；(2)页通过该模式访问了N次，N=页中记录数/16；\n\n## 异步IO\n\n当前数据库均采用异步IO来处理磁盘操作；其中，同步IO是指每次进行IO操作，需等待此IO操作结束再进行接下来的操作；异步IO是指每次进行IO操作，不用等待此IO操作结束即可进行接下来的操作；\n\n## 刷新邻接页\n\n当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，若是脏页，则一起进行刷新，这样做可通过异步IO将多个IO操作合并为一个IO操作。\n","tags":["数据库"],"categories":["course"]},{"title":"InnoDB关键特性—插入缓冲","url":"/course/sql-ch4-par3.html","content":"\n## 插入缓冲\n\nInnoDB存储引擎设计插入缓冲用于非聚集索引的插入与更新操作，并非每次直接插入索引页；而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；否则，先将其放入Insert Buffer对象中，再以一定的频率和情况进行Insert Buffer与辅助索引页子节点的merge(合并)操作，这时可将多个插入合并到一个操作中，从而提高了非聚集索引插入的性能。\n\nInsert Buffer的使用需同时满足以下两个条件\n\n* 索引是辅助索引；\n* 索引不是唯一的(在插入缓冲时，InnoDB存储引擎并不会去查找索引页来判断插入记录的唯一性)；\n\n## Change Buffer\n\nInnoDB存储引擎对INSERT、DELETE、UPDATE均进行缓冲，即Insert Buffer、Delete Buffer与Purge Buffer；\n\n## Insert Buffer的内部实现\n\n在MySQL的实现中，全局只有一棵Insert Buffer树，负责对所有表的辅助索引进行Insert Buffer。在通过idb文件进行恢复时，还需要进行REPAIR TABLE操作来重建表上所有的辅助索引。\n\nInsert Buffer是一棵B+树，由叶节点与非叶节点组成，非叶节点存放查询的键值，其结构如下图。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 26.png pic26 %}</div>\n\n&nbsp;\n\n其中space表示待插入记录所在表的表空间id，占4字节；marker占1字节，用于兼容旧版本的Insert Buffer；offset表示页所在的偏移量，占4字节。当一个辅助索引要插入到页(space, offset)时，若该页不在缓冲池中，则InnoDB存储引擎首先根据上述规则构造一个search key，接下来查询Insert Buffer这颗B+树，再将这条记录插入到树的叶节点。\n\n叶节点需按照如下结构。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 27.png pic27 %}</div>\n\n&nbsp;\n\n插入的具体内容从第五列开始。为保证将Insert Buffer中的辅助索引成功合并到磁盘上的辅助索引页，需要用一个特殊的页来标记每个辅助索引页的可用空间，这种页称为Insert Buffer Bitmap。\n\n 每个Insert Buffer Bitmap页用来标记$2^{15}$个辅助索引页，每个Insert Buffer Bitmap页都是这$2^{15}$个页的第二个页；每个辅助索引页在Insert Buffer Bitmap页中占用4位，存储的信息如下表。\n\n<div style=\"width:95%;margin:auto\">{% asset_img 28.png pic28 %}</div>\n\n&nbsp;\n\n## 合并插入缓冲\n\n合并插入缓冲操作发生在以下情形。\n\n* 辅助索引页被读取到缓冲池；\n* Insert Buffer Bitmap页注意到该辅助索引页已无可用空间时：若辅助索引页可用空间少于1/32页，则InnoDB存储引擎会强制进行一个合并操作；\n* Master线程：根据srv_innodb_io_capactiy的百分比来决定需要合并的辅助索引页数，再随机选择Insert Buffer B+树的一个页，读取该页中space，读取space所指定表空间的页，页数为之前确定的页数；\n\n若进行合并操作时，要合并的表已经被删除，则直接将对应的辅助索引丢弃即可！\n","tags":["数据库"],"categories":["course"]},{"title":"第四章第二节 Master线程工作方式","url":"/course/sql-ch4-par2.html","content":"\n先介绍InnoDB1.0.x版本之前的Master线程。\n\nMaster线程具有最高的线程优先级别，其内部由多个循环组成：主循环(loop)、后台循环(backgroup loop)、刷新循环(flush loop)、暂停循环(suspend loop)，下面分别介绍。\n\n## 主循环\n\n其中有两大部分的操作——每秒的操作与每10秒的操作；\n\n每秒的操作包括\n\n* 日志缓冲刷新到磁盘(即使该事务还未提交，总是)：即使再大的事务，它提交的时间也很短。\n* 合并插入缓冲(可能)：并非每秒都会发生，InnoDB存储引擎判断当前一秒内发生IO次数是否小于5次，若小于5次则InnoDB存储引擎认为当前IO的压力很小，可以执行合并插入缓冲的操作；\n* 至多刷新100个InnoDB的缓冲池中的脏页到磁盘(可能)：并非每秒都会发生，InnoDB存储引擎判断当前缓冲池中的脏页所占比例是否超过配置文件中innodb_max_dirty_pages_pct这个参数，若超过，则进行此操作；\n* 若当前无用户活动，则切换到后台循环；\n\n每10秒的操作包括\n\n* 刷新100个脏页到磁盘(可能)：InnoDB存储引擎判断过去10秒内磁盘的IO操作是否小于200次，若小于200次则InnoDB存储引擎认为当前有足够的磁盘IO操作能力，就可以将100个脏页刷新到磁盘；\n* 合并至多5个插入缓冲(总是)\n* 将日志缓冲刷新到磁盘(总是)\n* 删除至多20个无用的Undo页(总是)：即full purge操作，因为对表进行update、delete操作时，对应的行先标记为删除，但是还需要保留这些行的版本信息，在full purge过程中，InnoDB存储引擎判断当前事务系统中标记为删除的行是否可以删除，\n* 刷新100个或者10个脏页到磁盘(总是)：InnoDB存储引擎判断缓冲池中脏页所占比例，若超过70%，则刷新100个脏页到磁盘，否则，刷新10个脏页到磁盘；\n\n## 后台循环\n\n后台循环执行以下操作：\n\n* 删除无用的UNDO页(总是)\n* 合并20个插入缓冲(总是)\n* 跳转到主循环(总是)\n* 不断刷新100个页直到符合条件(可能，在flush循环中完成)\n\n## 刷新循环\n\n若刷新循环中没有事件需要处理，InnoDB存储引擎会切换到suspend_loop中，将Master线程挂起，等待事件的发生。\n\n**小结**：综上，Master线程的伪代码描述如下。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 23.png pic23 %}</div>\n\n<div style=\"width:75%;margin:auto\">{% asset_img 24.png pic24 %}</div>\n\n<div style=\"width:75%;margin:auto\">{% asset_img 25.png pic25 %}</div>\n\n&nbsp;\n\n## 版本1.2.x之前的升级日志\n\n* 引入参数innodb_io_capacity表示磁盘IO的吞吐量，在合并插入缓冲时，合并插入缓冲的页数为innodb_io_capacity的5%；在从缓冲池刷新脏页时，刷新脏页的数量为innodb_io_capacity；\n* 将参数innodb_max_dirty_pages_pct从90%调整为75%；使得数据库恢复的时间缩短；\n* 引入参数innodb_adaptive_flushing(自适应刷新)控制每秒刷新脏页的数量；\n* 引入参数innodb_purge_batch_size控制每次full_purge回收UNDO页的数量；\n\n版本1.2.x之后，刷新脏页的操作分离到单独的Page Cleaner线程中执行。\n","tags":["数据库"],"categories":["course"]},{"title":"第四章第一节 InnoDB体系架构","url":"/course/sql-ch4-par1.html","content":"\n## InnoDB引擎架构\n\n<div style=\"width:65%;margin:auto\">{% asset_img 21.png pic21 %}</div>\n\n&nbsp;\n\n后台线程负责刷新内存池中的数据，保证缓冲池中的内存缓存是最近的数据；此外，后台线程还需要将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常时能够恢复到正常状态。\n\n### 后台线程\n\nInnoDB存储引擎为多线程模型，其中Master线程为主线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性(脏页的刷新，合并插入缓冲，UNDO页的回收等)；IO线程多使用AIO(异步IO)来处理IO请求，这可以极大地提高数据库性能；Purge线程回收已经使用并分配的undo页；Page Cleaner线程专门用来将脏页刷新到磁盘。\n\n### 内存\n\nInnoDB存储引擎基于磁盘存储，并将数据用页来组织，而由于CPU与磁盘的速度之间的鸿沟，InnoDB存储引擎需要使用缓冲池技术来提高数据库的整体性能。\n\n缓冲池是一块内存区域，在客户端从磁盘中读取数据时，先将数据所在页读到缓冲池，再从缓冲池读取数据；下次读取该页就只需要从缓冲池中读取。因此，在客户端读取数据时先判断该数据所在页是否已在缓冲池中，若在可直接从缓冲池读取。\n\n对磁盘中页的修改(必然已被读入缓冲池)，应首先修改缓冲池中的页，再以一定的频率刷新到磁盘上，刷新的机制称为Checkpoint。\n\n具体地，缓冲池中缓存的数据页类型有：索引页、数据页、UNDO页、插入缓存(Insert buffer)、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 22.png pic22 %}</div>\n\n&nbsp;\n\nInnoDB1.0.x版本开始允许多个缓冲池实例，\n\n### 页的组织\n\n缓冲池中的页面通常使用LRU算法来管理，当缓冲池不能存放新读取到的页时，会释放LRU列表尾端的页释放。\n\n在InnoDB存储引擎中，缓冲池中页的默认大小为16KB，并做了优化——midpoint：新读取的页并不是直接放在LRU列表的头部，而是放在LRU列表的midpoint位置，midpoint默认为5/8，之所以不将新读取的页放在LRU列表头部，是因为客户端有时会做一些全局或部分的扫描，这些页仅仅在这次查询中会用到，这样反而将之后会经常用到的页移除，将之后不会再用到的页放入。\n\nInnoDB存储引擎引入参数innodb_old_blocks_time表示页读取到mid位置后需要等待多久才会被加入LRU列表的热端，即前midpoint部分。\n\nInnoDB1.0.x版本开始支持压缩页，即将默认的16KB的页压缩为1KB、2KB、4KB与8KB，这些页使用unzip_LRU列表进行管理。unzip_LRU对不同大小的压缩页分别管理，并使用伙伴算法进行内存的分配。\n\n&nbsp;\n\n缓冲池中的脏页存放在Flush列表中(也同时存放在LRU列表中)，其中LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理需要刷新回磁盘的页。\n\n### 重做日志缓冲\n\nInnoDB存储引擎先将日志信息存入该缓冲区中，再按一定频率(每秒)将其刷新到重做日志文件；此外，每个事务提交时会将重做日志缓冲刷新到重做日志文件；当重做日志缓冲区剩余空间小于1/2时，重做日志缓冲也需要刷新到重做日志文件。\n\n### 额外的内存池\n\n在InnoDB存储引擎中，由堆对内存进行管理，而管理所用到的数据结构的内存就是从这个额外的内存池中分配。因此，在申请大的缓冲池时也应该增大额外的内存池的大小。\n\n## Checkpoint技术\n\n客户端对页的操作首先在缓冲池中完成，InnoDB存储引擎需要将该页的新版本刷新回磁盘。若每次页发生变化都将新版本刷新回磁盘，则开销会很大，；同时，如果在刷新时磁盘发生了宕机，数据也会丢失。\n\n当前存储引擎通常采用Write Ahead Log策略，即事务提交时，先写重做日志，在写磁盘中的页。这保证了事务ACID特性中的D性(持久性)。\n\nCheckpoint解决如下问题。\n\n* 缩短数据的恢复时间(在磁盘宕机时，只需要对Checkpoint之后的重做日志进行恢复)；\n* 在缓冲池或重做日志不够用时将脏页刷新回磁盘；\n\n重做日志设计为循环使用，如果要使用的部分还没有产生Checkpoint，则必须强制产生Checkpoint，将对应缓冲池中的页刷新回磁盘。\n\nInnoDB存储引擎通过LSN来标记(页、重做日志、Checkpoint)版本，LSN长8字节，单位为字节。\n\n在InnoDB存储引擎中，Checkpoint发生的时间，条件以及脏页的选择都很复杂。其中有两种Checkpoint：Sharp Checkpoint与Fuzzy Checkpoint。在InnoDB存储引擎内部可能发生如下几种情况的Fuzzy Checkpoint。\n\n* Master Thread Checkpoint\n* FLUSH_LRU_LIST Checkpoint\n* Async/Sync Flush Checkpoint\n* Dirty Page too much Checkpoint\n\n### Master Thread Checkpoint\n\n在Master线程中，几乎以每秒/每十秒的频率各刷新一定比例的页回磁盘；该过程是异步的，即此时InnoDB存储引擎仍可以进行其他的操作，用户查询线程不会阻塞。\n\n### FLUSH_LRU_LIST Checkpoint\n\nInnoDB存储引擎需保证LRU列表中至少有100个空闲页可供使用，若LRU列表中不够100个空闲页，则InnoDB存储引擎会将LRU列表尾部的页移除，而如果其中哪个页也在Flush列表中，就需要进行Checkpoint。\n\nInnoDB1.2.x版本开始，这个检查(LRU列表中是否有100个空闲页)被放在一个单独的Page Cleaner线程中进行，不会再阻塞用户的查询操作。\n\n### Async/Sync Flush Checkpoint\n\n在日志文件不可用时，这时需要将一些脏页强制刷新到磁盘；记checkpoint_lsn为缓冲区里面已经刷新回磁盘的最新页的LSN，redo_lsn为日志里面最新页的LSN。定义checkpoint_age=redo_lsn-checkpoint_lsn，即还需要刷新回磁盘里的字节数。\n\n定义async_water_mark=75% * total_log_file_size，sync_water_mark=90% * total_log_file_size；\n\n* 当checkpoint_age<async_water_mark时，无需刷新脏页到磁盘；\n* 当async_water_mark<checkpoint_age<sync_water_mark时触发Async Flush，从Flush列表中刷新足够的脏页使得刷新后的checkpoint_age<async_water_mark；\n* checkpoint_age>sync_water_mark一般不会发生；\n\n从InnoDB1.2.x版本开始这个刷新操作单独放在Page Cleaner线程中，不会再阻塞用户的查询操作。\n\n### Dirty Page too much Checkpoint\n\n在脏页数量太多时，InnoDB存储引擎会强制进行Checkpoint，从InnoDB1.0.x开始，当脏页占到缓冲池中页面的75%时会触发该操作。\n","tags":["数据库"],"categories":["course"]},{"title":"第三章 事务处理","url":"/course/sql-ch3.html","content":"\n## 预备知识\n\n**事务**：事务是用户定义的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的执行序列。\n\n**事务的ACID特性**：原子性、一致性、隔离性与持续性。\n\n事务的ACID特性可能遭到破坏的原因之一是多个事务对数据库的并发操作造成的。\n\n为此，需要对并发操作进行控制。是一个用户事务的执行不受其他事务的干扰。\n\n并发控制的主要技术有锁、时间戳、乐观控制法与多版本并发控制(MVCC)等。\n\n## 锁\n\n基本的锁有两种：写锁与读锁；\n\n写锁：简称X锁，当事务T对数据对象A加上X锁后，则只有T能够读取与修改A，其他事务不能再对A加任何的锁，直到T将A上的锁释放。\n\n读锁：简称S锁，当事务T对数据对象A加上S锁后，则事务T只能读A但是不能修改A，其他事务可以对A再加S锁但不能加X锁，直到T释放A上的S锁为止。\n\n在使用X锁与S锁时，需要约定一些规则，这些规则称为封锁协议。下面介绍三级封锁协议。\n\n```bash\n一级：事务T在修改数据R之前必须先对其加X锁\n\n二级：在一级封锁协议的基础上，事务T在读取数据R之前必须先对其加S锁，读完即可释放S锁\n\n三级：在一级封锁协议的基础上，事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放S锁\n```\n\n## 活锁与死锁\n\n活锁是指事务一直请求锁而未被系统分配。\n\n死锁是指两个事务互相等待造成的。\n\n### 死锁的预防\n\n一次封锁法：每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。\n\n顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按照这个顺序实施封锁。\n\n预防的成本过高，数据库系统通常采用诊断死锁并在死锁出现后解除的方案。\n\n### 死锁的诊断与解除\n\n检测死锁的方法包括超时法与等待图法。其中，等待图法指并发控制系统周期性生成事务等待图，并进行检测，若图中发现回路，则表示系统发生了死锁。\n\n通常解除死锁的方法为将代价最小的事务的所有资源释放，使得其他事务可以运行下去。\n\n## 锁的粒度\n\n锁的对象大小称为锁的粒度，锁的对象可以是属性，属性集合、元组、关系、索引项，整个索引甚至整个数据库这些逻辑单元。也可以是页、物理记录等物理单元。\n\n锁的粒度与系统的并发度和并发控制的开销相关。若一个系统同时支持多种粒度的锁则是最理想的，这种锁称为多粒度锁。\n\n使用多粒度锁，加锁需分析其对应的多粒度树；多粒度树以数据库为根节点，代表最大的锁粒度，叶节点则代表最小的锁粒度。\n\n对多粒度树上的节点加锁意味着这个节点的所有后裔节点也被加锁，由于不是对其直接加锁，故称为隐式锁，而这个节点的锁称为显式锁。\n\n那么，在对一个数据对象加锁时，既要考虑其所有上级节点，又要考虑其所有后裔节点。这种检查方法效率很低，为此引入`意向锁`。\n\n### 意向锁\n\n对任一节点加锁时，必须先对它的上层节点加意向锁。三种常用的意向锁：意向共享锁(IS锁)、意向排他锁(IX锁)与共享意向排他锁(SIX锁)。\n\n* 对一个节点加S锁，则需要先对该节点的所有上级节点加IS锁；\n* 对一个节点加X锁，则需要先对节点的所有上级节点加IX锁；\n* 若一个节点已经加S锁，其后裔节点要加X锁，则对该节点加SIX锁；\n\n下面是三种意向锁加上读写锁的偏序关系。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 20.png pic20 %}</div>\n\n&nbsp;\n\n一个事务在申请加锁时以强锁代替弱锁是安全的，加锁时应该自上而下进行，解锁时应该自下而上进行。\n","tags":["数据库"],"categories":["course"]},{"title":"第二章 数据库关系理论","url":"/course/sql-ch2.html","content":"\n## 定义\n\n关系：$D_{1}\\times D_{2}\\cdots D_{n}$的子集称为在域$D_{1}, \\cdots, D_{n}$上的关系。表示为R($D_{1}, \\cdots, D_{n}$)\n\n关系的描述称为关系模式，它可以形式化地表示为R(U, D, DOM, F)。其中R为关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向与域的映像集合，F为属性间数据的依赖关系集合。\n\n所有关系的集合构成一个关系数据库。关系数据库使用了关系模型。\n\n关系模型的数据结构为二维表，数据操作包括查询、插入、删除与更新数据，关系的完整性约束包括实体完整性、参照完整性与用户定义完整性。\n\n## 关系数据理论\n\n### 预备知识\n\n关系模式R(U, D, DOM, F)。\n\n**第一范式**：关系模型的数据结构作为二维表，它的每个分量必须是不可分的数据项，满足这个条件的关系模式就属于**第一范式**；\n\n**函数依赖**：设R(U)是属性集U上的关系模式，X、Y为U的子集。若对于R(U)的任意一个可能的关系r，若r中两个在X上的属性值相等的元组在Y上的属性值相等，则称X函数确定Y，记为$X\\rightarrow Y$。\n\n**完全函数依赖**：在R(U)中，若$X\\rightarrow Y$，且对X中任何一个真子集SX，SX都不能函数确定Y，则称Y对X完全函数依赖。否则，称Y**部分函数依赖于**X\n\n**传递函数依赖**：在R(U)中，若$X\\rightarrow Y(Y\\subsetneq X)$但Y不能决定X，$Y\\rightarrow Z$，则称Z传递依赖于X。\n\n**候选码**：设K为`R<U,F>`中的属性或属性集合，若K能够在关系R中函数确定U，则K称为R的候选码。候选码都可以成为主码。后面将主码与候选码统称为码。\n\n**范式**：关系数据库中的关系需要满足一定要求，满足不同程度的要求称为不同的范式。将第x范式记为xNF。满足第x+1范式的关系一定满足第x范式。\n\n### 第二范式\n\n**定义**：关系R满足第一范式，且每个非主属性完全函数依赖于任何一个候选码，则称R满足第二范式。\n\n若关系模式不满足第二范式，则需要将其投影分解为多个关系模式。\n\n```bash\n2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖\n```\n\n### 第三范式\n\n**定义**：关系`R<U,F>`满足第一范式，若R中不存在这样的码X，属性组Y及非主属性Z($Y\\subsetneq Z$)，使得$X\\rightarrow Y, Y\\rightarrow Z$成立(Y不能函数确定X)，则称`R<U,F>`满足第三范式。\n\n```bash\n3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。\n```\n\n### BCNF范式\n\n**定义**：关系`R<U,F>`满足第一范式，若$X\\rightarrow Y$且$Y\\subsetneq X$时X必含有码，则称`R<U,F>`满足BC范式。\n\n```bash\nBCNF在3NF的基础上消除主属性对于码的部分与传递函数依赖\n```\n\n### 小结\n\n<div style=\"width:65%;margin:auto\">{% asset_img 19.png pic19 %}</div>\n\n## 参考链接\n\n[数据库的范式](https://zhuanlan.zhihu.com/p/20028672)\n","tags":["数据库"],"categories":["course"]},{"title":"第一章第九节 SQL的使用(九)高级特性","url":"/course/sql-ch1-par9.html","content":"\n## 约束\n\n管理如何插入或处理数据库数据的规则称为约束。DBMS通过在数据库表上施加约束来实现引用完整性。\n\n主键的定义：(1)在创建表时在作为主键的列加上PRIMARY KEY；(2)使用CONSTRAINT语句；\n\n```sql\nALTER TABLE Vendors ADD CONSTRAINT PRIMARY KEY (vend_id);\n```\n\n外键：外键是表中的一列，其值必须在另一表的主键中列出，用来保证引用完整性。\n\n外键的定义：(1)在创建表时加上REFERENCES form_name(pri_id)；(2)使用CONSTRAINT语句；\n\n```sql\nALTER TABLE Orders ADD CONSTRAINT REFERENCES Customers(cust_id);\n```\n\n唯一约束：用来保证一列中的数据唯一。\n\n检查约束：用来保证一列中的数满足一组指定的条件。\n\n检查约束的定义：(1)在创建表时加上CHECK statement；(2)使用CONSTRAINT语句；\n\n```sql\nALTER TABLE Orders ADD CONSTRAINT CHECK (gender LIKE '[MF]') # gender列中的数据只能是'M'或'F'\n```\n\n## 索引\n\nDBMS保存的列中数据排过序的列表。\n\n创建索引\n\n```sql\nCREATE INDEX prod_name_ind ON PRODUCTS(prod_name);\n```\n\n## 触发器\n\n触发器是特殊的存储过程，它在特定的数据库活动发生时自动执行，可与特定表上的INSERT、UPDATE、DELETE操作。\n\n一般来说，约束的处理比触发器快，因此应该尽量使用约束。\n\n","tags":["数据库"],"categories":["course"]},{"title":"第一章第八节 SQL的使用(八)使用游标","url":"/course/sql-ch1-par8.html","content":"\n## 游标\n\nSQL检索操作返回一组称为结果集的行，有时，需要在结果集中取特定行，而不是直接输出所有行，这就需要游标——存储在DBMS服务器上的数据库查询。\n\n游标常见的选项如下。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n<div style=\"width:65%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n&nbsp;\n\n使用游标的步骤如下。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 18.png pic18 %}</div>\n\n&nbsp;\n\n### 创建游标\n\n使用DECLARE语句声明游标\n\n```sql\nDECLARE cur_name CURSOR FOR select_statement;\n```\n\n### 打开游标\n\n```sql\nOPEN cur_name;\n```\n\n### 游标取值\n\n使用FETCH语句从游标中取值\n\n```sql\nFETCH cur_name INTO var1, var2[,...];\n```\n\n### 关闭游标\n\n```sql\nCLOSE cur_name;\n```\n\n游标需要在存储过程或函数中使用。\n","tags":["数据库"],"categories":["course"]},{"title":"第一章第七节 SQL的使用(七)存储过程与事务处理","url":"/course/sql-ch1-par7.html","content":"\n## 存储过程\n\n由于一些复杂的操作无法通过一条SQL语句解决，每次处理这些操作都需要多条SQL语句；为此，可以创建存储过程：为以后的使用而保存的多条SQL语句的集合。\n\n存储过程有下面这些好处。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n<div style=\"width:65%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n&nbsp;\n\n创建存储过程的格式如下。\n\n```sql\nCREATE PROCEDURE  存储过程名 (参数列表)\nBEGIN\n    SQL语句代码块\nEND\n```\n\n其中，参数列表的形式为：`[IN|OUT|INOUT] param_name type`\n\n例如\n\n```sql\nDELIMITER $\nCREATE PROCEDURE MailingListCount\n(OUT ListCount INT)\nBEGIN\n    SELECT COUNT(*) INTO ListCount FROM Customers\n    WHERE cust_email IS NOT NULL;\nEND $\n```\n\n其中，为了正确定义存储过程，因而不能让SQL语句在 ; 之后结束，因此需要重新定义结束符；这就是第一行的作用。\n\n若需要在查询过程中对变量赋值，则使用SELECT语句。其他情况使用SET关键字为变量赋值，如`SET num=10;`。\n\n调用存储过程使用CALL关键字，类似于函数调用。\n\n```sql\nCALL MailingListCount(@ret) $\n```\n\n检验存储过程的值\n\n```sql\nSELECT @ret;\n```\n\n删除存储过程使用DROP PROCEDURE语句。\n\n```sql\nDROP PROCEDURE IF EXISTS MailingListCount;\n```\n\n## 管理事务处理\n\n事务处理可用来维护数据库的完整性，它保证成批的SQL语句要么完全执行，要么完全不执行。\n\n考察给系统添加订单这一过程。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\n如果在其中某一步停了下来，这时可能不会出错，也可能会出错。要避免这种错误，就需要使用事务处理。\n\n例如，使用事务处理来给系统添加订单。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 15.png pic15 %}</div>\n\n&nbsp;\n\n其中，事务指一组SQL语句，回退指撤销指定SQL语句的过程，提交指将未存储的SQL语句结果写入数据库表，保留点指事务处理中设置的临时占位符，可对其发布回退。\n\n### 标志事务处理\n\nSTART TRANSACTION标志事务处理的开始。若所有的SQL语句都正确执行，则执行COMMIT语句提交。此时这些SQL语句的结果才会写入磁盘。若发生意外，也可以使用ROLLBACK语句回退。这时整个事务被撤销。\n\n### 保留点\n\n有时发生错误只需要回退一部分即可，这就需要用到保留点。\n\n保留点是放在合适位置的占位符，在需要时系统可回退到某个占位符。\n\n创建保留点使用SAVEPOINT语句\n\n```sql\nSAVEPOINT deL1;\n```\n\n回退到保留点\n\n```sql\nROLLBACK TO deL1;\n```\n\n综上，一个使用了保留点的事务处理\n\n```sql\nSTART TRANSACTION;\n\nDELETE FROM Customers WHERE cust_id='1000000006';\n\nSAVEPOINT deL1;\n\nUPDATE Customers SET cust_email=NULL WHERE cust_id='1000000005';\n\nROLLBACK TO deL1;\n\nCOMMIT;\n```\n\n所有的SQL语句完成的结果就是cust_id='1000000006'所在行被删除，而cust_id='1000000005'所在行的cust_email不变。\n","tags":["数据库"],"categories":["course"]},{"title":"第一章第六节 SQL的使用(六)视图","url":"/course/sql-ch1-par6.html","content":"\n视图为虚拟的表，它包含的不是数据而是根据需要检索数据的查询。视图可用来简化数据处理。\n\n如对下面的SELECT语句。\n\n```sql\nSELECT cust_name, cust_contact\n    FROM Customers, Orders, OrderItems\n    WHERE Customers.cust_id=Orders.cust_id\n    AND OrderItems.order_num=Orders.order_num\n    AND prod_id='RGAN01';\n```\n\n若将除最后一行外的所有查询包装为一个虚拟表ProCust，则检索简化为。\n\n```sql\nSELECT cust_name, cust_contact\n    FROM ProCust WHERE prod_id='RGAN01';\n```\n\n## 视图的优点\n\n视图有如下优点。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 10.png pic10 %}</div>\n\n&nbsp;\n\n对视图的使用与对表的使用相同。\n\n## 视图的限制\n\n视图的创建与使用有如下限制。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\n## 创建视图\n\n使用CREATE VIEW语句来创建，使用DROP VIEW删除视图，要更新视图，必须先DROP它然后再重新创建它。\n\n### 利用视图简化复杂的联结\n\n上述具体的视图ProCust的创建如下。\n\n```sql\nCREATE VIEW ProCust AS\n    SELECT cust_name, cust_contact, prod_id\n    FROM Customers, Orders, OrderItems\n    WHERE Customers.cust_id=Orders.cust_id\n    AND OrderItems.order_num=Orders.order_num;\n```\n\n利用视图，可一次性编写基础的SQL语句，再根据需要多次使用。\n\n### 利用视图重新格式化检索数据\n\n如之前使用的SQL语句如下\n\n```sql\nSELECT CONCAT(vend_name, '(', vend_country, ')') FROM Vendors ORDER BY vend_name;\n```\n\n将此查询定义为视图\n\n```sql\nCREATE VIEW VenLoc AS\nSELECT CONCAT(vend_name, '(', vend_country, ')') AS vend_title FROM Vendors;\n```\n\n也可以将视图应用于WHERE子句。\n\n### 视图与计算字段\n\n视图也可以简化计算字段的使用，如之前使用的SQL语句如下。\n\n```sql\nSELECT prod_id, quantity, item_price, quantity*item_price FROM OrderItems WHERE order_num=20008;\n```\n\n现将其转换为一个视图。\n\n```sql\nCREATE VIEW OrderItemsEx AS\nSELECT order_num, prod_id, quantity, item_price, quantity*item_price AS ex_price FROM OrderItems;\n```\n","tags":["数据库"],"categories":["course"]},{"title":"第一章第五节 SQL的使用(五)创建与编辑表","url":"/course/sql-ch1-par5.html","content":"\n## 创建表\n\n使用CREATE TABLE语句创建表，同时给出表名、表列的名字与定义；\n\n```sql\nCREATE TABLE Products\n(\n  prod_id    char(10)      NOT NULL ,\n  vend_id    char(10)      NOT NULL ,\n  prod_name  char(255)     NOT NULL ,\n  prod_price decimal(8,2)  NOT NULL ,\n  prod_desc  text          NULL \n);\n```\n\n每列的定义为：列名、列数据结构、是否允许NULL值。若要指定默认值，则在列定义的最后加上DEFAULT [值]。\n\n默认值通常用于日期或时间戳列，默认为当前日期或时间；Mysql获取当前日期的函数为CURRENT_DATE()。\n\n## 更新表\n\n使用ALTER TABLE语句更新表，对表进行修改有很多限制，建议在创建表时充分考虑未来的需求，以便今后不做大的改动。\n\n给已有表增加列。\n\n```sql\nALTER TABLE Vendors ADD vend_phone CHAR(20);\n```\n\n在已有表中删除列。\n\n```sql\nALTER TABLE Vendors DROP COLUMN vend_phone;\n```\n\n复杂的表结构更改一般需要手动删除过程，它涉及以下步骤。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n<div style=\"width:65%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n## 删除表\n\n使用DROP TABLE语句删除表，后面接表名。\n\n## 重命名表\n\n使用RENAME语句重命名表。RENAME [旧表名] [新表名]\n","tags":["数据库"],"categories":["course"]},{"title":"第一章第四节 SQL的使用(四)编辑行","url":"/course/sql-ch1-par4.html","content":"\n## 数据插入\n\n插入完整的行\n\n```sql\nINSERT INTO Customers(\n    cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)\n    VALUES('1000000006', 'Tot Land', '123 Any Street', 'New York', 'NY', '11111', 'USA', NULL, NULL);\n```\n\n若只指定了部分列，则未指定的列的值为空，或者为默认值；这就要求省略的列必须允许NULL值，或者定义了默认值。\n\n还能利用INSERT语句插入检索出的数据，这就是INSERT SELECT；从CustNew中将所有的数据导入Customers；\n\n```sql\nINSERT INTO Customers(\n    cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)\n    SELECT cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email\n    FROM CustNew;\n```\n\n从一个表复制到另一个表；\n\n```sql\nCREATE TABLE CustCopy AS SELECT * FROM Customers;\n```\n\n## 更新数据\n\n要更新表中的数据，可使用UPDATE语句。既能更新表中的特定行，也能更新表中的所有行。\n\nUPDATE语句需指定表、列名与新值，以及过滤条件。如更新客户的电子邮件地址。\n\n```sql\nUPDATE Customers SET cust_email='kim@thetoystore.com' WHERE cust_id='1000000005';\n```\n\n要更新多个列时，只需要在每对\"列=值\"之间用逗号分开。\n\n若要删除某列的值，可设置它为NULL；\n\n## 删除数据\n\n使用DELETE语句删除行，只需要指定该行即可。\n\n```sql\nDELETE FROM Customers WHERE cust_id='1000000006';\n```\n\n若要删除表中所有行，应使用TRUNCATE TABLE；\n","tags":["数据库"],"categories":["course"]},{"title":"第一章第三节 SQL的使用(三)子查询、联结与组合查询","url":"/course/sql-ch1-par3.html","content":"\n## 子查询\n\nSQL允许创建子查询，即嵌套在其他查询中的查询；\n\n如列出订购物品RGAN01的所有客户，由物品RGAN01检索出所有的订单编号，再根据订单编号检索出客户ID，再根据客户ID获得客户信息。\n\n使用子查询来获取\n\n```sql\nSELECT cust_name, cust_contact FROM Customers\n    where cust_id IN (SELECT cust_id\n    FROM Orders\n    WHERE order_num IN (SELECT order_num\n    FROM OrderItems\n    WHERE prod_id='RGAN01'));\n```\n\n作为计算字段使用子查询，如列出Customers表中每个客户的订单总数；\n\n```sql\nSELECT cust_name, cust_state,\n    (SELECT COUNT(*) FROM Orders\n    WHERE Orders.cust_id=Customers.cust_id) AS orders\n    FROM Customers ORDER BY cust_name;\n```\n\n## 联结表\n\n分解数据为多个表能更有效地存储，更方便地处理，并具有更大的可伸缩性。\n\n此时数据存储在多个表，如何用单条SELECT语句检索出数据——联结。\n\n联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。\n\n```sql\nSELECT vend_name, prod_name, prod_price\n    FROM Vendors, Products\n    WHERE Vendors.vend_id=Products.vend_id;\n```\n\n上述联结称为等值联结，它基于两个表之间的相等测试；这种联结也称为内部联结。\n\n另一种指定联结的方式如下。\n\n```sql\nSELECT vend_name, prod_name, prod_price\n    FROM Vendors INNER JOIN Products\n    ON Vendors.vend_id=Products.vend_id;\n```\n\nSQL不限制SELECT语句中可以联结的列的数目，创建联结的基本规则也相同——列出所有表，再定义表之间的关系。\n\n```sql\nSELECT prod_name, vend_name, prod_price, quantity\n    FROM OrderItems, Products, Vendors\n    WHERE Products.vend_id=Vendors.vend_id\n    AND OrderItems.prod_id=Products.prod_id\n    AND order_num=20007;\n```\n\n另一种语法表示为\n\n```sql\nSELECT prod_name, vend_name, prod_price, quantity\n    FROM OrderItems INNER JOIN Products INNER JOIN Vendors\n    ON Products.vend_id=Vendors.vend_id\n    AND OrderItems.prod_id=Products.prod_id\n    AND order_num=20007;\n```\n\n\n## 创建高级联结\n\n外部联结：为包含那些不符合关系的行，就需要外部联结。外部联结使用OUTER JOIN指定联结的类型，LEFT指定要包含所有行的表是OUTER JOIN左边的表——Customers。\n\n```sql\nSELECT Customers.cust_id, Orders.order_num\n    FROM Customers LEFT OUTER JOIN Orders\n    ON Customers.cust_id=Orders.cust_id;\n```\n\n在联结时也可以使用聚集函数。\n\n```sql\nSELECT Customers.cust_id, COUNT(Orders.order_num) AS num_ord\n    FROM Customers INNER JOIN Orders\n    ON Customers.cust_id=Orders.cust_id\n    GROUP BY Customers.cust_id;\n```\n\n## 组合查询\n\nSQL支持执行多个查询并将结果以单个查询结果返回，这就是组合查询。实际就是对这些查询结果取并操作。\n\n创建组合查询，使用UNION关键字将多个SELECT语句连接。\n\n如查询位于Illinois、Indiana与Michigan以及Fun4All单位的客户。\n\n```sql\nSELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_state IN ('IL', 'IN', 'MI') UNION\n    SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_name='Fun4All';\n```\n\n在WHERE语句过于复杂时，使用UNION语句将会是更好的办法。\n\n使用UNION语句需要注意如下几条规则。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\nUNION语句默认会将重复的行合并，若不想其合并，可使用UNION ALL关键字；\n\n若要对组合查询的结果排序，只能在最后一条SELECT语句之后使用ORDER BY语句。\n","tags":["数据库"],"categories":["course"]},{"title":"第一章第二节 SQL的使用(二)数据处理","url":"/course/sql-ch1-par2.html","content":"\n## 创建计算字段\n\n在有些情况下，存储在表中的数据不是应用程序所需要的，需要从数据库中转换、计算或格式化过的数据，这就需要用到计算字段。因为数据库系统对这些运算做了优化，所以计算字段比在应用程序上做这些运算要快得多。\n\n拼接字段\n\n```sql\nSELECT CONCAT(vend_name, '(', vend_country, ')') FROM Vendors ORDER BY vend_name;\n```\n\n必须给计算得到的列一个别名，以便应用程序可以引用它。别名用AS关键字赋予。\n\n```sql\nSELECT CONCAT(RTRIM(vend_name), '(', RTRIM(vend_country), ')') AS vend_title FROM Vendors ORDER BY vend_name;\n```\n\n执行算术计算\n\n就是普通的+、-、*、/。\n\n```sql\nSELECT prod_id, quantity, item_price, quantity*item_price FROM OrderItems WHERE order_num=20008;\n```\n\n## 数据处理函数\n\n如下是常用的文本处理函数。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\n如下是常用的数值处理函数。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n## 汇总数据\n\n聚集函数：运行在行组上，计算和返回单个值的函数。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n计算Products表中所有产品的平均价格\n\n```sql\nSELECT AVG(prod_price) AS avg_price FROM Products;\n```\n\n计算特定供应商所提供产品的平均价格\n\n```sql\nSELECT AVG(prod_price) AS avg_price FROM Products WHERE vend_id='DLL01';\n```\n\n使用COUNT(*)可对表中行的数目进行计数；使用COUNT(column)对特定列中具有值的行进行计数。\n\nSUM返回指定列值的和\n\n```sql\nSELECT SUM(quantity) AS items_ordered FROM OrderItems WHERE order_num =20005;\n```\n\n若要聚集不同值，需指定DSITINCT参数。\n\n```sql\nSELECT AVG(DISTINCT prod_price) AS avg_price FROM Products;\n```\n\n也可以在SELECT语句中使用多个聚集函数。\n\n```sql\nSELECT COUNT(*) AS num_items, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max, AVG(prod_price) AS price_avg FROM Products;\n```\n\n## 分组数据\n\n为处理\"计算每个供应商提供商品的平均价格\"这类问题，就需要用到数据分组。\n\n使用GROUP BY语句建立分组\n\n```sql\nSELECT vend_id, AVG(prod_price) AS avg_price FROM Products GROUP BY vend_id;\n```\n\n使用ORDER BY子句有如下规定。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\nGROUP BY子句出现在WHERE子句之后、ORDER BY子句之前\n\n过滤分组：HAVING [判断条件]\n\n```sql\nSELECT vend_id, AVG(prod_price) AS avg_price FROM Products GROUP BY vend_id HAVING COUNT(*)>2;\n```\n\n小结：SELECT子句的顺序\n\n<div style=\"width:65%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n","tags":["数据库"],"categories":["course"]},{"title":"第一章第一节 SQL的使用(一)检索数据并过滤","url":"/course/sql-ch1-par1.html","content":"\n## SQL基础介绍\n\n数据库：保存有组织的数据的容器；\n\n表：某种特定类型数据的结构化清单；\n\n列：表中的一个字段。表由多个列组成；\n\n数据类型：列允许的数据的类型；限制列中存储的数据；\n\n行：表中的一个记录；\n\n主键：表中每一行都应该有可以唯一标识自己的一(组)列，其值可以唯一标识表中的每一行；这(组)列就是主键；\n\n## 检索数据\n\n检索单个列；\n\n```sql\nSELECT prod_name FROM Products;\n```\n\n检索多个列；\n\n```sql\nSELECT prod_id, prod_name, prod_price FROM Products;\n```\n\n检索所有列；\n\n```sql\nSELECT * FROM Products;\n```\n\n## 排序检索数据\n\n子句：在SQL语句中，一个关键字加上所提供的数据组成一个子句，SQL由多个子句组成；排序SELECT语句检索出的数据使用ORDER BY子句；\n\nORDER子句取一个或多个列，据此对输出进行排序；ORDER子句必须是SELECT语句的最后一条子句；ORDER BY子句中的列不一定是SELECT中的列。\n\n```sql\nSELECT prod_name FROM Products ORDER BY prod_name;\n```\n\nORDER BY子句的排序默认为升序，若需要对列进行降序排列，需在列的后面加上DESC关键字。若要对多个列降序排序，则需每个列都指定DESC关键字。\n\n## 过滤数据\n\n在检索时通常只需要检索所需的数据，这可以通过在WHERE子句中指定搜索条件来实现；WHERE子句在表名之后给出。\n\n```sql\nSELECT prod_name,  prod_price FROM Products WHERE prod_price=3.49;\n```\n\n这样数据库只返回所需的数据。\n\nWHERE子句操作符有如下这些。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\n在使用BETWEEN操作符执行范围检查时，需要使用两个值，这两个值用AND连接。\n\nWHERE [列名] IS NULL是为了查找该列为空值的行。\n\n## 高级数据过滤\n\n为了进行更强的过滤控制，SQL允许使用多个WHERE子句；这些子句通过AND或OR连接；为了保证你想要的运算次序，建议使用括号明确分组各子句。\n\nIN操作符：可用来指定条件范围，范围中的每个条件都可以进行匹配。IN的用法为：IN (val_1, val_2, ..., val_m)\n\nIN相比OR操作符，使语法更加清楚直观。\n\nNOT操作符：否定它之后所跟的任何条件。\n\n## 用通配符进行过滤\n\n通配符：用来匹配值的一部分的特殊字符。\n\n搜索模式：由字面值、通配符或两者组合构成的搜索条件。\n\nLIKE操作符后连接搜索模式以进行通配符过滤；\n\n%通配符：任何字符出现任意次数(包括0次)；\n\n_通配符：只匹配单个的任意字符；\n\n注：SQL通配符很有用，但是它处理的时间较长，特别是将通配符放在开头时。\n","tags":["数据库"],"categories":["course"]},{"title":"第九章第一节 KMP算法","url":"/course/al-ch9-par1.html","content":"\n本节考察字符串查找问题：在主串T中寻找模式串P。普遍的情况是，T的某部分与P的一部分匹配，但是并没有完全匹配；这时平凡的想法是模式串移一位，然后重新检查，但是这样复杂度非常高；\n\nKMP算法希望利用这部分匹配的信息，保证不重复考察主串中的元素。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 30.png pic30 %}</div>\n\n&nbsp;\n\n第一次匹配失败后并没有模式串移动一位然后重新检查，而是直接将模式串移到如下位置。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 31.png pic31 %}</div>\n\n&nbsp;\n\n这就是KMP算法的高明之处，主串中的i指针不变，模式串中的j指针回退。因此，下面的关键就是j应该回退到何处。\n\n由于j可能在模式串中任一位置回退，因此将所有j要回退的位置存到数组next中。\n\nKMP算法与平凡想法重合的一种情况是j=0回退时，都是将模式串右移一位重新检查，因此`next[0]=-1`；\n\n求解next数组的方法类似\"数学归纳法\"，假设已知所有不大于j的r的next值，且记next[j]=k，下面介绍如何求得next[j+1]。\n\n如上图，j回退到k则须`P[0 : k-1]=T[i-k : i-1]`，再根据部分匹配的信息：`T[i-k : i-1]=P[j-k : j-1]`从而`P[0 : k-1]=P[j-k : j-1]`，这就是k作为next[j]的定义；\n\n那么next[j+1]应满足：`P[0 : next[j+1]-1]=P[j+1-next[j+1] : j]`；从而那些`P[0 : m]=P[j-m-1 : j-1]`的m可作为next[j+1]-2的候选值，在P[m+1]=P[j]时m+2便是next[j+1]！\n\n如何得到所有的m？\n\n由next[j]定义可知它必然小于j，故next[k]也是已知的：`P[0 : next[k]-1]=P[k-next[k] : k-1]`联立`P[0 : k-1]=P[j-k : j-1]`可得`P[0 : next(k)-1]=P[j-next[k] : j-1]`，可见next[k]-1就是m的一个候选值；\n\n以此类推，next[next[k]]-1...都是m的一个候选值，当其中的某个m满足P[m+1]=P[j]时就得到next[j+1]=m+2；即next[j+1]是k+1、next[k]+1、next[next[k]]+1、...中的一个。最后给出求解next数组的伪代码。\n\n```c\nint getNext(char * ps, int * next) {\n    int next[strlen(ps)];\n    int j = 0, k = -1;\n    next[0] = -1;\n    while (j < p.len() - 1) {\n       if (k == -1 || p[j] == p[k]) {\n           next[++j] = ++k;\n       } else {\n           k = next[k];\n       }\n    }\n    return 0;\n}\n```\n\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第八章第五节 回溯算法","url":"/course/al-ch8-par5.html","content":"\n## 回溯算法\n\n对于一些问题，每一步均存在许多的尝试，并没有一种确定的解决方案，即未到最后一步之前，并不知道所做选择是否可行。\n\n这时，有一种处理的算法是每一步先作出当前的可行选择，然后进入下一步，下一步同理；若直到最后一步依然可行，则得到一个解决方案；\n\n否则，即在一连串的选择下到达某一步后没有可做的选择，于是撤销上一步的选择并尝试上一步其他的选择，这一过程即回溯；\n\n回溯算法的基本框架就是尝试选择并在无解后回溯直到找到可行方案或在尝试了所有方案之后无解。\n\n## 收费公路重建\n\nX轴上N个点组成的集合$V=\\{v_{1}, ..., v_{N}\\}$，其中每对点的距离组成的集合$D=\\{|u-v||u,v\\in V \\ \\textrm{and}\\ u\\neq v\\}$；由$V$显然是很容易得到$D$的，而由$D$却不容易重建出$V$。\n\n不妨设D中元素已排序，V中最小元素置于0处；显然，可置$v_{N}$于$\\textrm{max}(D)$处，以及$v_{N-1}$于$\\textrm{max}(D-\\{v_{N}\\})$，并从D中移除$v_{N}, v_{N-1}, v_{N}-v_{N-1}$；\n\n进入循环：依然取D中的最大值d，当前未确定点有两种可选位置：d与$v_{N}-d$；\n\n* 若选择的位置与所有已确定点的距离都在D中(从D中移除这些距离)，则考虑下一个未确定点的位置；\n* 否则，若还有其他位置可选择，选择另一位置，再考察选择的位置与所有已确定点的距离是否都在D中，若是，从D中移除这些距离，并考虑下一个未确定点的位置；\n* 否则，只能回溯；撤销上一步的选择并尝试上一步其他的选择；\n\n直到D为空表明找到一个可行解；或者尝试所有选择之后无解退出。\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第八章第四节 随机化算法","url":"/course/al-ch8-par4.html","content":"\n##  跳跃表\n\n考虑一组数据用一条链表组织，那么在查询数据的复杂度为O(N)；为此，考虑每隔一个节点加一个指针连接。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 27.png pic27 %}</div>\n\n&nbsp;\n\n将这种想法扩展，考虑每个$2^{k}$的节点都加一个指针指向下一个$2^{k}$节点，总指针数仅仅加倍。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 28.png pic28 %}</div>\n\n&nbsp;\n\n但是，这种结构又导致插入过程过于复杂，考虑稍微放松一下限制条件，即不严格要求每个$2^{k}$的节点都指向下一个$2^{k}$节点，而是以$P\\{NumofVec=k\\}=1/2^{k}$的概率来随机决定一个插入的节点应有的指针数。这就是跳跃表。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 29.png pic29 %}</div>\n\n&nbsp;\n\n那么对应跳跃表的查找、插入、删除操作如下。\n\n* 从头节点的最高阶指针开始，沿该阶前进直到该阶的下一节点的值大于要查找的值，保存该阶上查找所到的最后的节点，然后来到下一阶继续上述过程直到在最低阶停下来，此时或者当前节点的值就是要查找的值；或者当前节点的值小于要查找的值，则进入下面的插入过程；\n* 随机决定此插入节点的指针数；从最低阶开始，将保存的该阶上查找所到的最后的节点指向插入节点，然后来到上一阶继续上述过程直到最高阶；\n* 删除，其实就是多次的链表删除操作；\n\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第八章第三节 动态规划","url":"/course/al-ch8-par3.html","content":"\n动态规划是将要解决的问题分成若干小问题，且这些小问题会被重复调用。如斐波那契数列的计算、Dijkstra算法等。下面介绍解决多源最短路径的Freud算法。\n\n## Freud算法\n\n在第k轮，图中每对顶点以$v_{1}, ..., v_{k}$为中介的最短路径要么是以$v_{1},...,v_{k-1}$为中介的最短路径，要么是由$v_{i}$到$v_{k}$的最短路径与$v_{k}$到$v_{j}$的最短路径的拼接。\n\n初始时，相邻顶点间的最短路径为这两个顶点，其长度为边的权；不相邻顶点间的最短路径长度记为$\\infty$；\n\n算法经$|V|$轮得到图中所有顶点间的最短路径。\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第八章第二节 分治算法","url":"/course/al-ch8-par2.html","content":"\n分治算法由两部分组成：(1)分：递归解决较小规模的问题；(2)治：由子问题的解构建原问题的解；一般来说，一个问题至少要分成两个子问题，算法才算分支算法；\n\n## 最近点问题\n\n对平面上一列点，找出欧式距离最短的一对点；直观的做法是检查所有的点对，但这样需花费O(N*N)的时间；下面介绍一种使用分治算法的解决方案。\n\n不妨设这些点已按照X坐标排序，还有一个按照Y坐标排序的副本；\n\n根据X坐标可以将这些点分成数目最多差一的两部分，记为P_L与P_R，并在中间设置一条分割线L;\n\n那么点对可以分成三个部分：都在P_L中、都在P_R中、分别在P_L与P_R中；\n\n对于前两部分点对中欧式距离最小者，可递归解决，那么要处理的问题就是分别在P_L与P_R中的点对欧式距离最小者；\n\n考虑先得到两个子问题的解，记这两个解的最小值为d；显然，只需要考虑距分割线d以内的点组成的点对即可！\n\n按照Y坐标由小到大依次考察P_L中距分割线d以内的点，考察P_R中那些Y坐标大于它且相差不超过d的点与它的距离，一直保留最小值及其对应点对。\n\n## 选择问题\n\n选择问题指找出有N个元素的表S中第k个最小的元素。介绍平均时间为O(N)的算法——快速选择。\n\n* 若S中只有一个元素，则k必为1，将S中的元素返回即可；\n* 否则，选择一个枢纽元v；\n* 将集合S-{v}分割为S_1与S_2；\n* 若$k\\leq |S_{1}|$则第k个最小元素必在$S_{1}$中，接下来quicksearch(S_1, k)；若$k=|S_{1}|+1$则枢纽元就是第k个最小元素；若k大于$|S_{1}|+1$则第k个最小元素必在$S_{2}$中，接下来quicksearch(S_2, k-$|S_{1}|$-1)。\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第八章第一节 贪婪算法","url":"/course/al-ch8-par1.html","content":"\n贪婪算法分阶段工作，每个阶段作出最优选择，而最后的结果也是最优的；如Dijkstra算法、Prime算法、Kruskal算法；而用贪婪算法处理网络流问题则得不到最优解。下面介绍几个使用贪婪算法的解决方案。\n\n## 简单的调度问题\n\n有作业P_1, . . . , P_N，它们对应的运行时间分别为t_1, . . . , t_N，而处理器只有一个；要将这些作业的平均完成时间最小化(作业一旦开始处理，就必须运行直到完成)，那么，这些作业平均完成时间最小的解决方案是按运行时间由小到大进行处理，这就是一种贪婪算法。对于多个处理器就是按运行时间由小到大轮流进行分配。\n\n## 赫夫曼编码\n\n将一段字符进行编码，以使得这段字符被编码后长度最短；显然，ASCII编码可以满足每个字符被编码后可被区分从而可正确解码，但是其长度过长；给定一段字符，对其中的每个字符进行赫夫曼编码，即如下的赫夫曼算法。\n\n先介绍编码树，将编码的字符以树组织，编码第k位为0则进入第k层(由上至下)的左分支，第k位为1则进入第k层(由上至下)的右分支；\n\n<div style=\"width:80%;margin:auto\">{% asset_img 26.png pic26 %}</div>\n\n&nbsp;\n\n对一段字符，由C种字符组成，初始时每个字符都是一个单节点树，每次选择频率和最小的两个树，生成一个以这两个树为子树的新树；直到只有一个树。根据这些字符对应节点的位置即可得到其编码，这就是赫夫曼编码。\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第七章第五节 深度优先遍历","url":"/course/al-ch7-par5.html","content":"\n## 深度优先遍历\n\n从图中任一顶点X开始遍历，在遍历任一时刻，若当前顶点有相邻的未被遍历的顶点，则访问该顶点，否则沿原路退回；\n\n* 在沿原路返回X的路径上存在某个顶点还有未被遍历的相邻顶点，则继续遍历；\n* 返回到X且X没有未被遍历的相邻顶点，退出；\n\n## 深度优先生成树\n\n图中深度优先遍历程序经过的边组成深度优先生成树(次序小者指向次序大者)，图中其余边为背边(次序大者指向次序小者)\n\n## 双连通性\n\n若一个连通的无向图G中任一顶点删除之后的图仍然连通，则图G是双连通的。若一个图不是双连通的，即存在一个顶点X，将其删除之后图不再连通，那么这个顶点就称为割点，割点在图中非常重要，而使用深度优先遍历，可以求出图中所有割点。\n\n首先，在深度优先遍历的过程中，顶点v被遍历的次序为Num(v)；得到深度优先生成树之后，对树上每个顶点v，需计算v对应如下三种值中的最小值Low(v)：\n\n* Num(v)；\n* min(Num(w), (v, w)为背边)；\n* min(Low(w), (v, w)为树边)；\n\n由Low值的定义可知，需后序遍历深度优先生成树。\n\n对图中的一个顶点v，若v不是深度优先生成树的根节点，则v为割点当且仅当在v在深度优先生成树中存在子节点w使得Low(w)>=Num(v)；若v是深度优先生成树的根节点，则v为割点当且仅当在v在深度优先生成树中有多于一个的子节点。\n\n## 欧拉回路\n\n对一个无向图G，若能找到一条路径，恰好经过每条边一次然后又回到起点，则这条路径称为欧拉回路；事实上，一个图存在欧拉回路当且仅当所有顶点的度为偶数。在线性时间内就可以判断一个图是否存在欧拉回路，而求出图的欧拉回路基本操作是深度优先遍历。\n\n有所不同的是，这时的深度优先遍历需要标记访问过的边而不是顶点；用邻接表存储图。\n\n初始：使用链表P存储路径上的顶点，初始为空；随机选择一个顶点开始遍历；\n\n循环：链表TP存储每一轮得到的路径，初始为空；从当前顶点开始执行深度优先遍历；\n\n* 当前顶点加入链表TP，然后遍历当前顶点的邻接子链表直到找到一个未被标记的边对应的顶点X，对该邻接子链表保存最后访问的顶点X，标记这条未被标记的边，当前顶点来到X；以此类推，直到当前顶点回到本轮的起点，本轮遍历过程结束；\n* 若P为空，则TP=P；否则，将TP拼接到P中(P中此轮顶点的前置指向TP的头节点，TP的尾节点指向P中此轮顶点的后继)\n* 在链表P中从本轮起点开始遍历直到找到一个有未被标记的边的顶点，将该顶点作为下一轮的起点；\n\n退出：未找到新的起点(即所有的边都已经加入路径中)\n\n## 有向图的深度优先遍历\n\n遍历过程大同小异，除了深度优先遍历过程中会经过的边是树边，有向图中还会有其余三种边。\n\n* 背向边：深度优先生成树中的后裔顶点指向祖父顶点；\n* 前向边：深度优先生成树中的祖父顶点指向后裔顶点；\n* 交叉边： 深度优先生成树中没有\"直系血缘\"关系的两个顶点；\n\n可在深度优先遍历的过程中将这三种边区分，在此之前，定义图中顶点在深度优先遍历过程中的三种状态：初始状态(未被遍历)，被遍历，遍历完成；当深度优先遍历程序到达该顶点时，顶点的状态从初始状态变成被遍历状态，当深度优先遍历程序从顶点退出时，顶点的状态从被遍历状态变成遍历完成状态。\n\n在深度优先遍历时一个数组state用来存放所有顶点的状态，初始化全为0；被遍历state置1，遍历完成state置2；当边(u, v)被考察时：\n\n* state[v]=0则(u, v)为树边；\n* state[v]=1则(u, v)为背边；\n* state[v]=2且u先于v被访问，则(u, v)为前向边；\n* state[v]=2且v先于u被访问，则(u, v)为交叉边；\n\n**参考链接**\n\n[深度优先遍历中的各种边](https://www.cnblogs.com/2020pengxiyue/p/8371241.html)\n\n## 查找强分支\n\n有向图的强连通分支为强分支；查找强分支的做法为：在图G上做一次深度优先遍历，再对得到的深度优先生成森林进行后序遍历对其顶点编号，再将G中所有的边反向，得到的图记为G_r；\n\n查找强分支的算法为：每轮从G_r中未被遍历的顶点中选择序号最高者做深度优先遍历，执行完一轮深度优先遍历即可得到一个强分支；\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第七章第四节 最小生成树","url":"/course/al-ch7-par4.html","content":"\n## 生成树\n\n对于一个无向有权图G，在其连通时，它的生成树就是一个由连接了G所有顶点的边生成的树；而最小生成树就是其所有边的权之和最小的生成树。\n\n对于最小生成树，有两种算法可以求出。\n\n## Prime算法\n\n初始：已添加到生成树中的顶点集K，初始只包含图中任一顶点。\n\n循环：将$w=\\textrm{argmin}\\{c(u,v)|(u,v)\\in E, u\\in K, v\\notin K\\}$加入K；\n\n退出：所有顶点均添加到K中；\n\n为求出w，可定义$d(v)=\\textrm{min}\\{c(u,v)|u\\in K\\}$，而在每轮$d(v)(v\\notin K)$的更新为$d(v)=\\textrm{min}\\{d(v),c(w,v)\\}$，其中w为新加入K中的顶点。\n\n## Kruskal算法\n\n每次按照最小的权选择边，并且当所选的边不会使生成树产生环时，将其加入生成树的边TE，生成树的顶点集记为TV。判断环的办法是所选边的两个顶点是否都属于TV。\n\n判断两个顶点是否都属于TV，可使用不相交集；\n\n* 对两个顶点使用Find运算，若其返回值相等，则表明它们均属于TV(不属于TV的顶点属于其自身，因此只有当它们均属于TV时，它们Find的返回值才会相同)，即加入这条边会使生成树形成环；\n* 找到要加入的边之后，将不在TV中的顶点使用Union运算合并到TV中，并将这条边加入TE。\n\n选择边可通过构建一个最小堆(堆中元素可以是指向边的指针，避免了大量数据的移动)，每次考察堆根节点的边(能加入TE或不能加入TE)后，都将这条边从最小堆中\"删除\"(事实上只需要移动即可)。\n\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第七章第三节 网络流问题","url":"/course/al-ch7-par3.html","content":"\n给定边容量为c(v, w)的有向图G=(V, E)，其中有一个起点，记为s，有一个收点记为t，最大流问题就是求出从s到t可以通过的最大流量。\n\n为求取最大流，首先使用贪婪算法求出一个流量相对较大的流，然而这样求出的流所通过的流量并不一定是最大的，还需要进行一系列的修正过程。\n\n## 简单的最大流算法\n\n该算法能求出相对较大流量的流，后续还需要修正过程。\n\n**初始**：图对应的流图各边的流量均为0，残余图与图相同，如下图所示。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 25.png pic25 %}</div>\n\n&nbsp;\n\n**循环**：\n\n* 寻找残余图中从s到t的一条路径，这条路径可以通过的流量为该路径上每条边流量的最小值，记为D；\n* 在流图中该路径上每条边的流量增加D；\n* 在残余图中该路径上每条边的流量减少D，若残余图中有的边流量为0，则将其从残余图中删除。\n\n**退出**：残余图中不存在从s到t的路径。\n\n退出时，流图中的流就是找到的一个流量较大的流。但是这个流不一定是最大流，还需要如下的修正过程。\n\n## 修正\n\n给定图G及其上的流f，它对应的增广图G_f定义如下：对图G中任一条边(u, v)\n\n* (u, v)在流中且f(u, v)小于c(u, v)，则增广图中有一条从u到v的边，其流量为c(u, v)-f(u, v)；还要一条从v到u的边，其流量为f(u, v)；\n* (u, v)在流中且f(u, v)=c(u, v)，则增广图中有一条从v到u的边，其流量为f(u, v)；\n* (u, v)不在流中，则增广图中有一条从u到v的边，其流量为c(u, v)；\n\n于是，修正过程如下。\n\n**循环**：给定图G及其上的流f，它对应的增广图G_f，在增广图中寻找一条从s到t的路径，根据找到的路径修改流f。\n\n具体修正过程为：对路径中的边(u, v)\n\n* 若(u, v)已在f中，则f(u, v)加上路径上的流量即可；\n* 若(v, u)在f中，则f(u, v)减去路径上的流量；\n* 若(u,v)不在f中，则将(u,v)加到流中，f(u, v)为路径上的流量；\n\n**退出**：增广图中不存在一条从s到t的路径，退出循环；此时的流f就是最大流。\n\n**参考链接**\n\n[最大流问题](https://zhuanlan.zhihu.com/p/382977642)\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第七章第二节 最短路径","url":"/course/al-ch7-par2.html","content":"\n## 无权最短路径\n\n对图中一个顶点，找出它到图中所有其他顶点的最短路径。对于找出图G=(E,V)中顶点s到其他顶点的最短路径：\n\n初始：两个集合——Cur与Next，Cur为{s}，Next为s相邻的顶点的集合；s到Next中顶点v的最短路径为L(s,v)=(s,v)；\n\n循环：将Cur更新为Next，将Next更新为Cur中顶点相邻的顶点；s到Next中顶点v的最短路径为L(s,v)=(L(s,u),v)，其中u为使得v进入Next中的顶点；\n\n## Dijkstra算法\n\n如果是有权图，则需要使用Dijkstra算法求最短路径。\n\n初始：集合K包含已知最短路径的节点；K初始为空；D为s到所有顶点的最短路径长度，除D[s]为0外，其余均为$\\infty$；\n\n循环：选择V\\K中D[x]最小的x放入K中，对V\\K中顶点y，若D[x]+w(x,y)小于D[y]，则更新D[y]为D[x]+w(x,y)，此时s到y的最短路径更新为(L(s,x),y)；\n\n退出：V\\K为空集；\n\n如果图较稀疏，则可以将D实现为堆，每次删除根节点。\n\n对于无环图，不必使用复杂的Dijkstra算法，而是以拓扑排序来选择顶点，具体如下。\n\n初始：集合K包含已知最短路径的顶点，K初始为{s}，将s从图中删除；\n\n循环：将刚刚从图中删除的顶点x的相邻顶点y删除并加入K，s到y的最短路径为(L(s,x),y)；\n\n退出：V\\K为空集；\n\n## 关键路径\n\n有向无环图更重要的一个问题是关键路径：对于一系列任务，可能一些任务之间存在依赖，根据这种依赖可生成对应的有向无环图；从最初的任务开始，可推算每个任务最早可以完成的时间；最后一个任务的最早完成时间就是整个项目的完成时间，也是最后一个任务最迟完成的时间；\n\n以最后一个任务的最迟完成时间倒推，可推出每个任务最迟的完成时间；\n\n对于一个任务(顶点)，若其最早完成时间与最迟完成时间相同，则称为零松弛顶点，由零松弛顶点组成的路径就是关键路径。\n\n一个任务(顶点)的最早完成时间为所[依赖任务(顶点)的最早完成时间+该任务工期]的最大值；\n\n一个任务(顶点)的最迟完成时间为[依赖它的任务的最迟完成时间-该任务工期]的最大值；\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第七章第一节 图的定义与表示","url":"/course/al-ch7-par1.html","content":"\n## 图的定义\n\n一个图由顶点集与边集组成，边就是一个点对；\n\n图分为有向图和无向图，若无向图中任意两个点均存在一条路径，则称它是连通的；对于有这种性质的有向图，称为强连通的，否则，若其对应的无向图是连通的，则该有向图称为弱连通的。若每一对顶点之间均存在一条边，则该图称为完全图。\n\n## 图的表示\n\n第一种表示方式为使用一个二维数组，称为邻接矩阵；对每条边(u,v)，置`A[u][v]=1`，其余元素为0；若要对边赋权，则可以用很大或很小的权，如$\\infty$代表不存在的航线。这种表示方式简单，但是在图的边比较稀疏时，这种表示方式代价很大；于是，有了特意为稀疏图准备的表示方式——邻接表。\n\n邻接表对每个顶点，用一个链表存储其相邻的顶点。\n\n## 拓扑排序\n\n拓扑排序是对有向无环图的一种排序：若存在一条从u到v的路径，则在排序中u应该出现在v之前。\n\n拓扑排序的算法如下。\n\n初始时：先遍历图中所有顶点求其入度，并将入度为0的顶点存入集合S，所有节点的入度存入一个数组A用来记录；\n\n循环：每轮删除S中的一个顶点，并将该顶点指向的顶点的入度减1，即更新数组A，然后将入度刚成为0的顶点存入S中；\n\n直到图中所有顶点删除完毕，各顶点按照删除的顺序为序。\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第六章 不相交集","url":"/course/al-ch6-par1.html","content":"\n## 等价关系\n\n等价关系是满足以下三条性质的关系：(1)自反性；(2)对称性；(3)传递性。\n\n对一个集合S，a是S中的一个元素，a的等价类是所有与a等价的元素组成的集合；等价类形成对集合S的一个划分；因此，要确定两个元素是否等价，只需要判断它们是否在一个等价类中。\n\n在集合S上有两种运算：(1)Find：找出一个元素所在等价类；(2)Union：将两个等价类合并；\n\n## 数据结构\n\n要表示一个等价类，可使用树，两个相同的元素在同一棵树上，因此有同一个根节点，将根节点作为此等价类的标识；此时只需要每个节点的父节点信息，因此只需使用一个数组P存储每个节点的父节点，而根节点的父节点置0。\n\n对于Find运算，一直索引到根节点即可(判断根节点即P[x]是否为0)；\n\n对于Union运算，将一个树的根节点指向另一棵树的根节点即可；\n\n## Union运算\n\n若随机地挂接树会导致出现一些很坏的情形；为此，在挂接时，考察树的节点个数，将节点少的树挂接到节点多的树上；因此，需要记录一个树的节点个数，这可以记录在根节点，将树的节点个数的相反数置为根节点的P[x]。\n\n## 路径压缩\n\n为使Find运算更快，使用路径压缩：在寻找一个元素的等价类时，将其遍历的节点的父节点均置为根节点，这可以极大地降低下次Find的代价。\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第五章 排序","url":"/course/al-ch5-par1.html","content":"\n## 插入排序\n\n对需要排序的数组A，首先开辟一个同样大小的数组B；遍历A中元素，对当前元素X，将它插入到它在数组B中应在的位置。最坏情况下复杂度$O(N^{2})$。\n\n## 希尔排序\n\n首先设置一个增量序列${h_{k}}(h_{k+1}<h_{k})$，每轮要使得数组中间隔为$h_{k}$的元素有序；排序方式为从左向右地为相隔为$h_{k}$的元素在逆序时进行交换。最坏情况下复杂度$O(N^{2})$。\n\n## 堆排序\n\n首先构造堆，复杂度为O(N)。然后不断删除根节点，注意到堆有len与size两个属性，在删除时只需要将len减1，而数组的长度实际上并没有变小；\n\n于是，在删除一次根节点后，就会空出一个位置，而这个位置上正好可以放上刚删除的根节点，在将堆中所有元素都删除之后(len为0而size不变)，存储堆的数组上就是原堆中元素的降序排列。\n\n如果要得到堆中元素的升序排列，则构造一个最大堆即可！\n\n堆排序的时间复杂度为$O(N\\cdot log(N))$\n\n## 归并排序\n\n分治法的典型应用。最坏情况下复杂度为$O(N\\cdot log(N))$；\n\n归并排序算法的基本操作是合并两个已排序的数组：记两个数组为A、B，算法还需一个输出数组C，其中size(C)=size(A)+size(B)；\n\n初始有三个计数器atr、btr、ctr均置为0；每次将A[atr]、B[btr]中较小者复制到数组C中；如A[atr]小于B[btr]，则将A[atr] 复制到数组C，然后atr加1，ctr加1；若A[atr]大于B[btr]，同理；当其中一个数组的元素全部复制到数组C后，只需要将另一个数组剩余元素复制到数组C即可！\n\n介绍了如何合并两个已排序的数组，再介绍归并排序。对一个需要排序的数组，先递归地将数组的左半部分与右半部分归并排序，然后再将这两个排好序的子数组合并；可以看到：递归触底时，待排序的子数组只有一个元素，自然是排好序的，然后反弹，排好序的子数组不断合并，最终得到整个排好序的数组。\n\n空间复杂度：事实上，只需要开辟一个同样大小的数组空间，就能满足递归全程的数组使用；\n\n## 快速排序\n\n使用快速排序算法quicksort将数组S排序由如下四步组成：\n\n* 若S中的元素不超过两个，则返回；\n* 取S中任一元素v，作为枢纽元；\n* 将S-{v}分为两个集合$S_{1}=\\{x\\in S|x\\leq v\\}$​、$S_{2}=\\{x\\in S|x>v\\}$​；\n* quicksort($S_{1}$)后继v，再后继quicksort($S_{2}$)即可得到排好序的数组S；\n\n### 枢纽元\n\n枢纽元的选取最安全的做法是每轮随机选取，可这种做法需耗费大量时间。退求其次，使用\"三数中值分割法\"，即每次选取左端、中间、右端三个元素的中位数作为枢纽元。这可以排除最坏情形。\n\n### 分割\n\n具体分割$S_{1}$与$S_{2}$的办法为：将枢纽元与数组最后一个元素交换，low指向第一个元素、high指向倒数第一个元素；\n\nlow向右移动，直到遇到大于枢纽元的元素、而high向左移动，直到遇到小于枢纽元的元素；然后交换low、high所指元素；然后low、high继续这样向右/向左移动，直到high<low，再将low所指向的元素与最后一个元素交换，即完成分割过程。\n\n## 桶式排序\n\n若输入的数据由小于M的正整数组成，那么可对其使用桶式排序；使用一个长度为M的数组C，读入X时，将C[X]加1；读完数据后，扫描数组C，将N打印C[N]次即得到排序的输入数据。\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第四章第三节 二项队列","url":"/course/al-ch4-par3.html","content":"\n## 二项队列\n\n二项队列是堆序树的集合，这些堆序树是是二项树，每一个高度上最多存在一个二项树；高度为0的二项树是一个单节点树，高度为k的二项树$B_{k}$通过将一个$B_{k-1}$二项树附接到另一个$B_{k-1}$二项树上；如下图示所示，高度为0、1、2、3、4的二项树如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 24.png pic24 %}</div>\n\n&nbsp;\n\n高度为k的二项树的节点数为$2^{k}$，因此二项队列可以有任意个节点。\n\n## 合并\n\n对两个二项队列，首先取并集，按树的高度由高到低考察，对于高度相同的，将其中一个附接到另外一个的根节点上，此时可能又会与已有的二项树高度相同，那么再次合并；遍历一遍之后合并操作完成。\n\n同样的，插入就是合并的特殊情形。\n\n## 删除\n\n一般指删除最小的根节点。首先，从二项队列中删除这个根节点所在的树，然后这个树删除根节点变成含有两个二项树的二项队列，然后与之前的二项队列合并。\n\n## 具体实现\n\n使用链表，每个节点指向自己的第一个子节点与右兄弟节点，对于根节点，则是指向下一个二项树的根节点(二项树按照高度排序)。\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第四章第二节 左式堆与斜堆","url":"/course/al-ch4-par2.html","content":"\n## 左式堆\n\n为了使\"合并\"操作更高效，介绍特殊的堆——左式堆。首先，将一个节点X的零路径长Npl(X)定义为从X到一个没有双子节点的节点的最短(这里的最短是指在所有的没有双子节点的节点中)路径长度。显然，具有0或1个子节点的节点的Npl为0；将Npl(NULL)记为-1。\n\n一个堆是左式堆当堆中任一节点的左子节点的零路径长不小于右子节点的零路径长；\n\n## 合并\n\n插入可以看作合并的特殊情形；合并采用递归的做法：对两个堆，将大根值的堆与小根值的堆的右子堆进行合并(递归进行)，合并之后若堆不是左式堆，则交换左右子堆即可！交换完之后需要更新零路径长(右子树的零路径长加1)。合并的新堆作为小根值堆的右子堆。\n\n## 删除\n\n一般删除根节点，删除之后将两个左式堆合并即可！\n\n## 斜堆\n\n斜堆是左式堆的自调节形式，实现及其简单；与左式堆一样，斜堆也是为合并操作而设计。对斜堆的合并也是采用递归的方法，不同之处在于此时不会比较左右节点的零路径，而是一律交换左右子堆；\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第四章第一节 堆(优先队列)","url":"/course/al-ch4-par1.html","content":"\n## 二叉堆\n\n一棵完全二叉树称为一个(最小)堆当每个非叶节点的值均小于其子节点的值；最大堆同理。\n\n完全二叉树具有良好的性质：若将完全二叉树的元素从上到下，从左向右放入数组中AT，则AT[i]的左子节点为AT[2i]、右子节点为AT[2i+1]；\n\n下面介绍二叉堆的几个操作——插入、删除，最小值。而构建堆可通过一系列的插入操作来实现。\n\n## 插入\n\n要插入一个元素X，首先在下一空虚位置创建一个空节点；若将X放在此空节点处不破坏堆序，则插入完成；否则，将空节点的父节点与空节点交换，以此类推，直到将X放在空节点满足堆序。这种策略称为上滤。\n\n注：实际实现时只需要父节点下移即可。\n\n## 删除\n\n对于堆的删除，特指删除最小元素，即根节点。删除根节点后，根节点为空，考虑将堆的最后一个元素X放到空节点处，若X放在该空节点不破坏堆序，则将X放在该空节点，然后删除完成；否则，将空节点的子节点较小者与空节点交换，以此类推，直到将X放在空节点满足堆序，这种策略称为下滤。\n\n注：实际实现时只需要子节点上移即可。\n\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第三章 散列表","url":"/course/al-ch3-par1.html","content":"\n## 散列函数\n\n散列表通过散列函数将每个关键字映射到0至Tabsize-1中的某个数X，然后将该关键字放在散列表第X项；下面的问题就是如何选择一个好的散列函数。\n\n不管如何选择散列函数，总会产生冲突，因为关键字的个数比散列表的长度要大。解决冲突的方法有：分离链接法与开放定址法。\n\n## 分离链接法\n\n将映射到同一项的关键字用链表组织起来，如下图所示。\n\n<div style=\"width:30%;margin:auto\">{% asset_img 22.png pic22 %}</div>\n\n&nbsp;\n\n## 开放定址法\n\n在冲突发生时，尝试将关键字放到另外的项。下面介绍三个具体的算法。\n\n### 线性探测法\n\n冲突函数是线性函数，即以固定步长考察散列表(可绕回)，直到找到空单元。\n\n### 平方探测法\n\n冲突函数是平方函数，用来解决聚集问题；即步长依次为1、4、9等等(这里二次项系数为1)。\n\n### 双散列\n\n如冲突函数$F(i)=i\\cdot hash_{2}(X)$，$hash_{2}$是另外一个散列函数。\n\n## 再散列\n\n对于使用平方探测的开放定址散列表，若表的元素填到一定程度，插入将会消耗时间过长甚至可能失败。解决的办法是建立一个大约原长度两倍的散列表，并将原散列表中的元素重新计算后填入新散列表。上述过程就是再散列。\n\n再散列的时刻可以有多种选择方案：(1)表满一半即再散列；(2)当插入失败时即再散列；(3)途中策略：当散列表的装填因子(散列表的元素个数/散列表大小)到达某个值时。\n\n## 可扩散列\n\n取关键字若干比特，作为\"目录\"，每个树叶的这些比特相同，每个树叶最多可容纳M个关键字，若一个树叶关键字个数超过M则\"目录\"再加一个比特，如下图所示。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 23.png pic23 %}</div>\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第二章第七节 红黑树","url":"/course/al-ch2-par7.html","content":"\n## 红黑树的定义\n\nAVL树的一个流行的变种就是红黑树。红黑树是具有下列着色性质的二叉查找树。\n\n* 每一节点或着成红色，或着成黑色；\n* 根节点为黑色；\n* 红色节点的子节点必须是黑色；\n* 任一节点到NULL指针的每一条路径必须包含相同数目的黑色节点；\n\n如下图是一个红黑树的示例。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n注：红黑树是AVL树的变种，不再严格遵守AVL树的要求；对红黑树的插入即对二叉查找树的插入再加上一定的调整。\n\n## 插入-自底向上调整\n\n承认一个事实：根据第四条性质，插入的节点必须涂成红色！此时，若父节点就是黑色，则插入完成；否则与第三条性质冲突，必须对该树进行调整，调整包括改色与旋转。\n\n注意到红黑树也是AVL树，在插入的时候也需要进行对应的旋转操作；当插入完成后，还需要进行调整以满足红黑树的性质。记插入的节点为X，(已插入的)X的父节点为P，P的兄弟节点为S。\n\n若S是黑色节点，此时X与S的\"搭配\"有两种情形(每种都有对称情形)。所做的调整如下。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n&nbsp;\n\n调整之后红黑树的性质满足。\n\n若S为红色节点，再做如上图的调整仍不满足红黑树的性质，只能继续调整。\n\n由于S此时为红色节点，使得新树不满足第三条性质，故需要进行调整；同时，为了保证第四条性质，P-G-S中只能有一个黑色节点，因此只能将P、S涂成红色，G涂成黑色。若P的父节点为黑色节点，则插入完成；\n\n否则，还需要进行调整，记P的父节点为Y，则此时的(P , Y)就是初始时的(X, P)，因此对其进行同样的处理，直到某个\"父节点\"的兄弟节点为黑色节点或到达根节点(根节点为黑色节点，因此递归一定能结束)。\n\n## 插入-自顶向下调整\n\n插入之后自底向上调整需要一个栈来保存查找路径上的节点；事实上，插入也可以采用自顶向下的方式，在查找的过程中对树进行调整以保证\"S\"始终为黑色节点！\n\n对遍历的节点X，若X的两个子节点均为红色，由第三条性质，X必为黑色节点，将X与其子节点进行颜色对换，若X的父节点为黑色，则在X处的调整完成；\n\n否则，注意到X的父节点为红色，因此X的父节点的兄弟节点一定不是红色(否则会与它们的父节点进行颜色对换，从而X的父节点不会为红色)，因此可使用上图中的旋转进行处理。\n\n查找完成之后，将待插入节点插入路径终点对应子节点。\n\n注：在具体实现中，使用两个标记节点：根与NullNode；根标记将存储关键字$\\infty$以及指向真正根的右指针；\n\n## 自顶向下删除\n\n对于要删除的节点，有以下几种可能：叶节点、双子节点，单支红子黑节点；因为以下四种单支情况不可能出现。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 18.jpg pic18 %}</div>\n\n&nbsp;\n\n对于删除的任意非叶节点X，若它有右子树，则用右子树上的最小值节点将其替换(颜色使用X的颜色)，若X无右子树，那么它一定有左子树，则用左子树上的最大值节点将其替换(颜色使用X的颜色)，那么删除的节点就变为右子树上的最小值节点；\n\n这个节点最多有一个右子节点(左子节点)，如果它有一个右子节点(左子节点)，那么将它删除之后使用子节点涂黑补位即可！\n\n否则，删除的就是叶节点，若这个叶节点为红色，直接删除即可！\n\n否则，就是要删除一个黑色叶节点。\n\n综上，所有的情况都能转换成删除一个叶节点，若叶节点为红色，直接删除即可！否则，就是删除一个黑色叶节点。删除黑色叶节点可采用自底向上或自顶向下的方式，自底向上的方式过于复杂，感兴趣可参考[July对红黑树的讲解](https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md)；相比之下，自顶向下的删除有一个自始至终的目标——保证当前节点为红色。\n\n```bash\n初始：将根节点涂红; 当前节点记为X, X的兄弟节点记为T, X的父节点记为P\n\n循环：沿根节点至待删除黑色叶节点的路径下降\n\n新状态：新的P即原来的X, 故P为红色节点, X与T为黑色节点\n```\n\n**X的子节点均为黑色**\n\n(1) T的子节点亦全为黑色；则P、T、X颜色翻转即可；\n\n(2) T有一个红子节点，根据这个红子节点是左或右，进行如下图的旋转；\n\n<div style=\"width:70%;margin:auto\">{% asset_img 20.png pic20 %}</div>\n\n&nbsp;\n\n**X有红节点**\n\n先下降，若X落到红子节点，则继续下降即可；否则，将P、T进行颜色翻转，然后旋转P与T重新进入P红X黑T黑的情形。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 21.jpg pic21 %}</div>\n\n&nbsp;\n\n**参考链接**\n\n[红黑树的删除—自顶向下](https://blog.csdn.net/yw8355507/article/details/48932359)\n\n[红黑树在线演示](https://rbtree.phpisfuture.com/)\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第二章第六节 自顶向下伸展树","url":"/course/al-ch2-par6.html","content":"\n## 自顶向下伸展\n\n由于常规的伸展树需要从根节点遍历至对应叶节点再返回，这需要大量的内存开销，且必须处理很多特殊情况；因此，本节介绍自顶向下伸展树。\n\n在查找的同时，进行\"自顶向下\"展开，下面介绍针对三种情况下(对称情况略)的展开操作。\n\n**单旋转**\n\n<div style=\"width:70%;margin:auto\">{% asset_img 10.png pic10 %}</div>\n\n&nbsp;\n\n**一字型**\n\n<div style=\"width:70%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\n**之字型**\n\n<div style=\"width:70%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n其中，树L、R初始时为空，在展开的过程中不断添加节点；于是，在查找到达所在节点时，原来的一个树变成三个树，合并方法如下。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n&nbsp;\n\n此外，之字型的旋转还有简化版。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\n最后，给出一个自顶向下树的例子(其中\"之字型旋转\"注释有误，应为\"一字型旋转\")。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 15.png pic15 %}</div>\n\n## 插入\n\n为待插入节点分配一个新的指针。若树为空，则直接建立一棵单点树。否则，将树自顶向下伸展为一棵新树，新树的根节点记为NR。\n\n* 若待插入节点X的键值key(X)=key(NR)，则新树有X的一个复制拷贝；\n* 若待插入节点X的键值key(X)>key(NR)，则NR及其左子树成为X的左子树，NR的右子树成为X的右子树；\n* 若待插入节点X的键值key(X)<key(NR)，则NR及其右子树成为X的右子树，NR的左子树成为X的左子树；\n\n## 删除\n\n首先，在查找待删除节点X的同时将树自顶向下伸展为一棵新树NT，若NT的根节点为X(考虑到X在原树中可能不存在，因此需要判断)\n\n* 若NT的左子树为空，则将NT的右子树作为返回值即删除了待插入节点；\n* 否则，在NT的左子树NL中查找X的同时将NL自顶向下伸展为一棵新树NNL，由于NL中节点的键值均小于X的键值，因此NNL的根节点没有右子树，于是将NT的右子树接到NNL的根节点上(作为其右子树)即可；\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第二章第五节 B-树","url":"/course/al-ch2-par5.html","content":"\n## B-树的定义\n\n阶为M的B-树是具有下列结构特性的树。\n\n* 树的根或是一片树叶，或者子节点数在2-M之间；\n* 除根节点外，所有非叶节点的子节点数在$\\lceil (M+1)/2\\rceil$-M之间；\n* 叶节点中关键字的个数在$\\lceil (M+1)/2\\rceil$-M间，且所有树叶均处于同一深度；\n\n使用B-树组织数据时，数据都存储于叶节点。而非叶节点存储指向各子节点的指针$P_{0},...,P_{M-1}$以及在以这些子节点(除第一个)为根节点的子树上的最小值$k_{1},...,k_{M-1}$，其中有些指针可能为NULL，则对应的$k_{i}$也是未定义的。并且，各兄弟节点之间具有如下性质。\n$$\nmax\\{key(X)|X\\in Tree(P(i))\\}<min\\{key(X)|X\\in Tree(P(i+1))\\}\n$$\n因此，在每个非叶节点处经O(logM)次判断可找到接下来要查找的分支。下面介绍在B-树上的查找、插入与删除操作。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n## 查找\n\n记B-树的根为R，要查找的值为y；在每个非叶节点，记它的各子节点的指针$P_{0},...,P_{M-1}$以及在以这些子节点(除第一个)为根节点的子树上的最小值$k_{1},...,k_{M-1}$，则需要找到满足条件$k_{i}\\leq y<k_{i+1}$的$i$，使用二分查找可在O(logM)的时间内找出。最后到达叶节点，在叶节点上进行二分查找即可。\n\n## 插入\n\n开始的操作与查找相同，在找到对应的叶节点N后，将其插入到叶节点N中。\n\n插入之后，要考虑叶节点N是否可以容纳，若不能容纳，则叶节点N需要\"分裂\"，两个叶节点分别拿走原叶节点的$\\lceil (M+1)/2\\rceil$、$\\lfloor (M+1)/2\\rfloor$个节点；\n\n由于这时叶节点N的父节点多了一个子节点，因此，需要考虑N是否可以容纳，同样地，若不能容纳，则N的父节点也需要\"分裂\"；\n\n以此类推，沿着查找路径返回至根节点的同时将不能容纳子节点的节点\"分裂\"，以及各非叶节点的更新。\n\n## 删除\n\n到达对应叶节点N后，删除相应关键字，若叶节点N的关键字个数仍在$\\lceil (M+1)/2\\rceil$-M之间，再沿着查找路径返回至根节点的同时更新非叶节点。\n\n否则，考虑(左右)兄弟节点能否在满足关键字数在$\\lceil (M+1)/2\\rceil$-M之间的条件下，\"分\"一些关键字至N使得N的关键字数在$\\lceil (M+1)/2\\rceil$-M之间；若能，则左右兄弟节点\"分\"一些关键字至N，同时更新这三个叶节点。\n\n否则，需要删除叶节点N，然后将叶节点N的关键字\"分\"到左右兄弟节点中，然后将左右兄弟节点更新；此时，N的父节点也少了一个子节点，同样可能出现子节点数不够的情况，处理方式与上述类似；以此类推，沿着查找路径返回至根节点的同时进行相应操作。\n\n## B+树\n\nB+树在B-树的基础上，增加了叶节点之间的双向链表。由于增加了双向链表，在插入与删除时也需要维护双向链表。\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第二章第四节 伸展树","url":"/course/al-ch2-par4.html","content":"\n伸展树的实现相对AVL树更简单，且不用为每个节点保持平衡因子。虽然在最坏的情况下查找需要的时间是O(N)，但是对伸展树的每次操作的摊还代价为O(logN)。\n\n## 展开\n\n伸展树在查找操作时，顺便将查找的节点通过旋转操作移到根节点处。对查找的非根节点X，若X的父节点是根节点，则将X与根节点作旋转即可。\n\n否则，X拥有父节点P与祖父节点G，此时分类讨论。\n\n**之字型**\n\n即(1)X是P的右子节点，P是G的左子节点；(2)X是P的左子节点，P是G的右子节点；此时，使用对应的双旋转进行展开操作。\n\n对于情况(1)，对其进行如下图所示的双旋转。\n\n<div style=\"width:90%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n对于情况(2)同理；如此直到X为根节点或X为根的子节点。\n\n**一字型**\n\n即(1)X是P的左子节点，P是G的左子节点；(2)X是P的右子节点，P是G的右子节点；此时，使用对应的双旋转进行展开操作。\n\n对于\"一字型\"的情况，展开操作更为复杂，需要三次旋转；如图所示。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第二章第三节 AVL树","url":"/course/al-ch2-par3.html","content":"\n## AVL树的定义\n\nAVL树是其每个节点的左右子树高度最多差1的二叉查找树。为了保持AVL树的这个性质，它的插入、删除操作相对于二叉查找树的插入、删除操作还需要进行一定的调整。这种调整称为旋转。\n\n关于调整，先要分析有哪些不平衡的情况。记最深的不平衡点为A。\n\n* 对A的左子节点的左子树进行一次插入；\n* 对A的左子节点的右子树进行一次插入；\n* 对A的右子节点的左子树进行一次插入；\n* 对A的右子节点的右子树进行一次插入；\n\n对于第1和第4种情形，只需要对树进行一次单旋转；对于第2和第3种情形，需要对树进行双旋转。\n\n## 单旋转\n\n对于情形1。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\n对于情形4。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n## 双旋转\n\n对于情形2。\n\n<div style=\"width:90%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n对于情形3。\n\n<div style=\"width:90%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n注：在实现时只需要保存每个节点的左右子树高度之差，即平衡因子。\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第二章第二节 二叉查找树","url":"/course/al-ch2-par2.html","content":"\n## 二叉查找树的定义\n\n二叉树的一个重要应用——二叉查找。二叉树是二叉查找树当且仅当对于树中的每个节点X，它的左子树上所有节点的值小于X的值，它的右子树上所有节点的值大于X的值。\n\n关于二叉查找树，有置空、查找、最大值、最小值、插入、删除操作。\n\n## 查找\n\n记二叉查找树的根为R，要查找的值为y；则判断key(R)是否等于y，若相等，则查找完毕；否则，若key(R)>y，则在R的左子树上查找；若key(R)<y，则在R的右子树上查找。以此类推，直到查找到键值为y的节点或未能找到。\n\n## 最值\n\n最小值：从二叉查找树的根节点开始，一直向左直到节点无左子节点；最大值同理，从二叉查找树的根节点开始，一直向右直到节点无右子节点。\n\n## 插入\n\n对于一个二叉查找树，现插入键值为y的节点；寻找待插入节点的位置要遍历路径与查找操作的遍历路径一样，不同的是，在遍历的最后，将待插入节点放在下一步将遍历的位置。\n\n如下图所示，待插入节点的键值为5，它遍历的路径为6=>2=>4，下一步将要遍历键值为4的节点的右子树，可键值为4的节点无右子树，因此键值为4的节点就是遍历的终点，而待插入节点下一步将遍历的是其右子节点，故将待插入节点放在其右子节点。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n## 删除\n\n删除的情形比较复杂，下面分类讨论。\n\n* 被删除的节点是叶节点，则直接删除或打上删除标记即可；\n* 被删除的节点有一个子节点，则被删除的节点之父节点调整指向被删除的节点的指针为指向被删除的节点的子节点；\n* 被删除的节点有两个子节点，则使用其右子树的最小键值节点替换，然后删除在原位置的最小键值节点，由于在原位置的最小键值节点一定没有左子树(参见最值)因此删除原位置的最小键值节点转换为上一情形；\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第二章第一节 树的基础介绍","url":"/course/al-ch2-par1.html","content":"\n## 树的定义\n\n对树采用递归定义：树是一些节点的集合、这个集合可以是空集；否则，这棵树由称为根的节点R以及多个非空的子树$T_{1}, ..., T_{k}$组成，这些子树中每一棵树的根都被来自根R的一条有向边所连接。\n\n## 树的实现\n\n如下结构体可以用来表示树。\n\n```c\ntypedef struct TreeNode * PtrToNote;\n\nstruct TreeNode{\n    ElementType Element;\n    PtrToNode FirstChild;\n    PtrToNode Nextsibling;\n}\n```\n\n这样就能将一棵树组织起来。\n\n<div style=\"width:65%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\n## 树的遍历\n\n树的遍历有三种方式：先序、中序以及后序。\n\n* 先序：父节点优先于子节点(从左向右)遍历；\n* 中序：先遍历左子节点，再遍历父节点，最后遍历右子节点；\n* 后序：父节点晚于子节点(从左向右)遍历；\n\n## 二叉树\n\n二叉树是一棵树，且每个节点的子节点数都不大于2。\n\n由于二叉树的每个节点最多有两个子节点，因此在表示二叉树时，可以直接用指针指向每个节点的左右子节点。\n\n```c\ntypedef struct TreeNode * PtrToNote;\n\nstruct TreeNode{\n    ElementType Element;\n    PtrToNode Left;\n    PtrToNode Right;\n}\n```\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第一章 三种基础的抽象数据类型","url":"/course/al-ch1.html","content":"\n## 表\n\n表有数组和链表两种实现。表一般有插入、删除、查找、判空、打印等操作；此外，也可以增加前驱、后继等操作。一个数组或链表加上这些操作称为表。\n\n## 栈\n\n栈是限制插入与删除在一个位置上进行的表，此位置称为栈顶。栈一般有入栈、出栈、判空等基本操作。和表一样，栈也可以用数组或链表实现。\n\n## 队列\n\n队列是限制插入在一端、删除在另一端的表，插入一端称为队尾、删除一端称为队首。队列一般有出队、入队、判空等基本操作。和表一样，队列也可以用数组或链表实现。\n","tags":["数据结构与算法"],"categories":["course"]},{"title":"第十一章第一节 进/线程池概述","url":"/course/np-ch11.html","content":"\n通过动态创建子进程/线程实现并发服务器具有如下缺点：\n\n* 进程的创建与切换耗时；\n* 创建的进程/线程只能为一个客户服务，导致系统上产生大量的细微进程；\n* 由于动态创建的子进程是当前进程的完整映像，当前进程必须谨慎管理其分配的文件描述符与堆内存等系统资源；\n\n为解决上述问题，网络程序采用进程/线程池。下面对其进行介绍，给出其通用实现并利用进程/线程池实现一个简单的并发服务器。\n\n## 概述\n\n进程池与线程池类似，以进程池为例进行介绍。\n\n进程池是由服务器预先创建的一组子进程，这些子进程的数目在3-10个之间(如httpd守护进程就是使用包含7个子进程的进程池来实现并发)；线程池中的线程数量应与CPU数量差不多。\n\n有新任务到来时，主进程将通过某种方式选择进程池中的某一子进程为之服务。选择策略有两种。\n\n* 主进程使用某种算法来主动选择子进程；最简单常用的有随机算法、轮流选取算法；\n* 主进程与所有的子进程通过一个共享的工作队列来同步，子进程在没有任务时睡眠在该工作队列中。有新的任务到来后，主进程将任务添加到工作队列，所有睡眠的子进程被唤醒，但是只有一个子进程可以获得新任务的接管权，其他子进程返回继续睡眠；\n\n选择好子进程后，主进程还需要某种通知机制来告诉目标子进程有新任务需要处理，以及传递一些必要的数据(如函数的参数)；可在父进程与子进程间预先建立好一条管道，再使用管道进行进程间通信。\n\n综上，进程池的一般模型如下图。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 44.png pic44 %}</div>\n","tags":["网络编程"],"categories":["course"]},{"title":"第十章第七节 多线程环境","url":"/course/np-ch10-par7.html","content":"\n## 可重入函数\n\nLinux库函数只有一小部分是不可重入的，但Linux为其提供了对应的可重入版本，这些可重入版本的函数在原函数名尾部加_r；在多线程程序中调用库函数，必须使用其可重入版本。\n\n## fork与互斥锁\n\n考虑下面情况：一个多线程程序的某个线程调用了fork函数，则子进程仅拥有一个执行线程，即调用fork的线程的完整复制，且子进程将自动继承父进程中互斥锁、POSIX信号量、条件变量的状态。即，父进程中被加锁的互斥锁在子进程中也是锁住的，但子进程并不清楚该互斥锁的状态，此时如果再次加锁，就会导致死锁。\n\n为此，pthread专门提供了pthread_atfork函数以确保fork调用后父进程与子进程都清楚锁的状态。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    prep: 在fork系统调用创建子进程之前被执行, 用来锁住所有父进程中的互斥锁\n    parent: 在fork系统调用创建子进程之后 & fork系统调用返回之前, 在父进程中执行, 释放所有在prep中被锁住的互斥锁\n    child: fork系统调用返回之前, 在子进程中被执行, 释放所有在prep中被锁住的互斥锁\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_atfork(void (* prep)(void), void (* parent)(void), void(* child)(void));\n```\n\n## 线程与信号\n\n在多线程下应用程序应使用pthread版本的sigprocmask函数——pthread_sigmask。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_sigmask(int how, const sigset_t * set);\n```\n\n函数的参数含义与sigprocmask的参数含义相同。\n\n由于进程中所有线程共享进程的信号，因此线程库将根据线程掩码决定将信号发送到哪个具体的线程，但如果在每个子进程中都单独设置信号掩码，则很容易导致逻辑错误；此外，所有线程共享信号处理函数，当一个线程设置了某个信号的信号处理函数后，它将覆盖其他线程为同一信号设置的信号处理函数。\n\n综上，应用程序应该定义一个专门的线程处理所有的信号。实现步骤如下。\n\n* 在主线程创建出其他子线程之前就调用pthread_sigmask来设置好信号掩码，所有新创建的子线程都将自动继承这个信号掩码；从而所有的线程都不会响应被屏蔽的信号；\n* 在某个线程中调用sigwait函数来等待信号并处理它；\n\n```c\n/*\n    引用方式: #include <signal.h>\n    set: 要等待的信号的集合\n    sig: 存储函数返回的信号值\n    返回0: 成功 || 返回错误码: 失败\n*/\nint sigwait(const sigset_t * set, int * sig);\n```\n\n若sigwait正确返回，应用程序可对接收的信号作出处理；此时，应用程序无需再为信号设置信号处理函数。\n\n最后，pthread提供了pthread_kill函数以将一个信号明确地发送给指定线程。\n\n```c\n/*\n    引用方式: #include <signal.h>\n    thread: 指定目标线程\n    sig: 指定待发送的信号; sig为0则pthread_kill不发送任何信号, 但仍然执行错误检查, 可利用这种方式来检测目标线程是否存在\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_kill(pthread_t thread, int sig);\n```\n","tags":["网络编程"],"categories":["course"]},{"title":"第十章第六节 条件变量","url":"/course/np-ch10-par6.html","content":"\n条件变量用于在线程之间同步共享数据的值。条件变量提供一种线程间的通知机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的线程。\n\n下面介绍5个主要的函数。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    cond: 目标条件变量\n    attr: 指定条件变量的属性; 置NULL使用默认属性\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_cond_init(pthread_cond_t * cond, const pthread_condattr_t * attr);\n```\n\npthread_cond_init函数用于初始化条件变量；此外，还可以使用如下方式来初始化一个条件变量。\n\n```c\npthread_cond_t cond=PTHREAD_COND_INITIALIZER;\n```\n\n宏PTHREAD_COND_INITIALIZER实际上就是将条件变量的各个字段均置0。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    cond: 目标条件变量\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_cond_destroy(pthread_cond_t * cond);\n```\n\npthread_cond_destroy函数用于销毁条件变量，以释放其占用的内核资源；销毁一个正在被等待的条件变量将失败并返回EBUSY。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    cond: 目标条件变量\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_cond_broadcast(pthread_cond_t * cond);\n```\n\npthread_cond_broadcast函数以广播的方式唤醒所有等待目标条件变量的线程。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    cond: 目标条件变量\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_cond_signal(pthread_cond_t * cond);\n```\n\npthread_cond_signal函数用于唤醒一个等待目标条件变量的线程。至于唤醒哪个线程，取决于线程的优先级与调度策略。\n\n如果想要唤醒特定线程，可使用如下方法：定义一个能唯一表示目标线程的全局变量，在唤醒等待条件变量的线程前先设置该变量为目标线程，再采用广播方式唤醒所有等待条件变量的线程，这些线程被唤醒后都检查该变量以判断被唤醒的是否是自己，如果是就开始执行后续代码，否则返回继续等待。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    cond: 目标条件变量\n    mutex: 用于保护条件变量的互斥锁\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex);\n```\n\npthread_cond_wait函数用于等待目标条件变量。在调用pthread_cond_wait之前，必须确保互斥锁mutex已经加锁；pthread_cond_wait执行时，先将调用线程放入条件变量的等待队列中，再将互斥锁mutex解锁。\n\npthread_cond_wait函数成功返回时mutex将再次上锁。\n","tags":["网络编程"],"categories":["course"]},{"title":"第十章第五节 互斥锁","url":"/course/np-ch10-par5.html","content":"\n互斥锁可以用于保护关键代码段，以确保其独占式地访问。\n\n## 基础API\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    mutex: 指定要操作的互斥锁\n    attr: 指定互斥锁的属性(默认为NULL)\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t * attr);\n```\n\npthread_mutex_init函数用于初始化互斥锁。此外，还能通过如下方式初始化一个互斥锁。\n\n```c\npthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;\n```\n\nPTHREAD_MUTEX_INITIALIZER事实上将互斥锁的各个字段均初始化为0。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    mutex: 指定要操作的互斥锁\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_mutex_destroy(pthread_mutex_t * mutex);\n```\n\npthread_mutex_destroy函数用于销毁互斥锁，以释放其占用的内核资源。销毁一个已经加锁的互斥锁将导致不可预期的后果。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    mutex: 指定要操作的互斥锁\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_mutex_lock(pthread_mutex_t * mutex);\n```\n\npthread_mutex_lock函数以原子操作的方式为一个互斥锁加锁。若目标互斥锁已被锁住，则pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    mutex: 指定要操作的互斥锁\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_mutex_trylock(pthread_mutex_t * mutex);\n```\n\n同理，是pthread_mutex_lock函数的非阻塞版本。若目标互斥锁已被锁住，pthread_mutex_trylock将返回错误码EBUSY。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    mutex: 指定要操作的互斥锁\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_mutex_unlock(pthread_mutex_t * mutex);\n```\n\npthread_mutex_lock函数以原子操作的方式为一个互斥锁解锁，若此时有其他线程在等待该互斥锁，则这些线程中的某个将获得该互斥锁。\n\n## 互斥锁属性\n\npthread_mutexattr_t对象定义了一套完整的互斥锁属性。线程库提供了一系列函数来操作pthread_mutexattr_t对象，以方便应用程序获取和设置互斥锁属性。下面介绍一些重要的函数。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    attr: 指定的互斥锁属性\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_mutexattr_init(pthread_mutexattr_t * attr);\n```\n\n初始化互斥锁属性对象。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    attr: 指定的互斥锁属性\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_mutexattr_destroy(pthread_mutexattr_t * attr);\n```\n\n销毁互斥锁属性对象。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    attr: 指定的互斥锁属性\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_mutexattr_getshared(const pthread_mutexattr_t * attr, int * pshared);\n\nint pthread_mutexattr_setshared(pthread_mutexattr_t * attr, int pshared);\n```\n\n获取和设置互斥锁的pshared属性。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    attr: 指定的互斥锁属性\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_mutexattr_gettype(const pthread_mutexattr_t * attr, int * type);\n\nint pthread_mutexattr_settype(pthread_mutexattr_t * attr, int type);\n```\n\n获取和设置互斥锁的type属性。\n","tags":["网络编程"],"categories":["course"]},{"title":"第十章第四节 POSIX信号量","url":"/course/np-ch10-par4.html","content":"\n与多进程程序一样，多线程程序也需要考虑同步问题。POSIX信号量、互斥锁与条件变量是3种专门用于线程同步的机制。\n\n下面介绍POSIX信号量。\n\n在Linux上，信号量API有两组，一组是System V IPC信号量；另一组是下面介绍的POSIX信号量。\n\n关于信号量的原理不再赘述，常用的POSIX信号量的5个函数如下。\n\n```c\n/*\n    引用方式: #include <semaphore.h>\n    sem: 指定操作的信号量\n    pshared: 指定信号量的类型; 0: 当前进程的局部信号量 || 非零: 信号量可在多进程间共享\n    value: 指定信号量的初始值\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint sem_init(sem_t * sem, int pshared, unsigned int value);\n```\n\nsem_init函数用于初始化一个未命名的信号量。初始化一个已经被初始化的信号量将导致不可预期的结果。\n\n```c\n/*\n    引用方式: #include <semaphore.h>\n    sem: 指定操作的信号量\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint sem_destroy(sem_t * sem);\n```\n\nsem_destroy销毁信号量以释放其占用的资源，销毁一个正被其他线程等待的信号量将导致不可预期的结果。\n\n```c\n/*\n    引用方式: #include <semaphore.h>\n    sem: 指定操作的信号量\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint sem_wait(sem_t * sem);\n```\n\nsem_wait以原子操作的方式将信号量的值减1。若信号量的值为0，则sem_wait将被阻塞直到信号量的值大于0。\n\n```c\n/*\n    引用方式: #include <semaphore.h>\n    sem: 指定操作的信号量\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint sem_trywait(sem_t * sem);\n```\n\nsem_trywait与sem_wait函数的功能类似，不过它总是立即返回，不论被操作的信号量是否具有非0值，即sem_wait的非阻塞版本。若信号量的值非0，sem_trywait以原子操作的方式将信号量的值减1，否则它将返回-1并设置errno为EAGAIN。\n\n```c\n/*\n    引用方式: #include <semaphore.h>\n    sem: 指定操作的信号量\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint sem_post(sem_t * sem);\n```\n\nsem_post以原子操作的方式将信号量的值加1，当信号量的值大于0时其他正在调用sem_wait等待信号量的线程将被唤醒。\n","tags":["网络编程"],"categories":["course"]},{"title":"第十章第三节 线程属性","url":"/course/np-ch10-par3.html","content":"\npthread_attr_t结构体定义了一套完整的线程属性，定义如下。\n\n```c\n/*\n    引用方式: #include <bits/pthreadtypes.h>\n*/\ntypedef union{\n    char __size[36];\n    long int __align;\n} pthread_attr_t;\n```\n\n线程的各种属性均包含在一个字符数组中，线程库定义了一系列函数来操作pthread_attr_t类型的变量，以方便我们获取和设置线程属性。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    pthread_attr_init: 初始化线程属性对象\n    pthread_attr_destroy: 销毁线程属性对象, 被销毁的线程属性对象只有再次初始化才能继续使用\n*/\nint pthread_attr_init(pthread_attr_t * attr);\n\nint pthread_attr_destroy(pthread_attr_t * attr);\n```\n\n下面的函数用于获取和设置线程属性对象的某个属性。\n\n## 线程的脱离状态\n\n```c\nint pthread_attr_getdetachstate(const pthread_attr_t * attr, int * state);\n\nint pthread_attr_setdetachstate(pthread_attr_t * attr, int state);\n```\n\n线程的脱离状态有PTHREAD_CREATE_JOINABLE与PTHREAD_CREATE_DETACH两个可选值。前者指定线程是可回收的，后者使调用线程脱离与进程中其他线程的同步。\n\n## 线程堆栈\n\n```c\nint pthread_attr_getstackaddr(const pthread_attr_t * attr, void * * addr);\n\nint pthread_attr_setstackaddr(pthread_attr_t * attr, void * addr);\n\nint pthread_attr_getstacksize(const pthread_attr_t * attr, size_t * size);\n\nint pthread_attr_setstacksize(pthread_attr_t * attr, size_t size);\n\nint pthread_attr_getstack(const pthread_attr_t * attr, void * * addr, size_t * size);\n\nint pthread_attr_setstack(const pthread_attr_t * attr, void * addr, size_t size);\n```\n\n操作系统默认会管理堆栈，Linux默认为每个线程分配足够的堆栈空间(8MB)，可使用ulimit -s命令来查看与修改该默认值。\n\n## 保护区域\n\n```c\nint pthread_attr_getguardsize(const pthread_attr_t * attr, size_t * size);\n\nint pthread_attr_setguardsize(pthread_attr_t * attr, size_t size);\n```\n\n若保护区域的大小size大于0，则系统创建线程时会在其堆栈的尾部额外分配size字节的空间，作为保护堆栈不被错误覆盖的区域。size为0则不设置保护区域。\n\n此外，若程序使用pthread_attr_setstackaddr或pthread_attr_setstack自行设置线程的堆栈，则guardsize属性将被忽略。\n\n## 线程调度\n\n```c\nint pthread_attr_getschedparam(const pthread_attr_t * attr, struct sched_param * param);\n\nint pthread_attr_setschedparam(pthread_attr_t * attr, const struct sched_param * param);\n```\n\nsched_param是线程的调度参数。该结构体只有一个整型类型的成员——sched_priority，该成员表示线程的运行优先级。\n\n## 线程调度策略\n\n```c\nint pthread_attr_getschedpolicy(const pthread_attr_t * attr, int * policy);\n\nint pthread_attr_setschedpolicy(pthread_attr_t * attr, int policy);\n```\n\npolicy有三种可选值：SCHED_FIFO(先进先出)、SCHED_RR(轮转算法)、SCHED_OTHER(默认)；SCHED_FIFO与SCHED_RR都具备实时调度功能，但只能用于以超级用户身份运行的程序。\n\n## 调度属性的继承\n\n```c\nint pthread_attr_getinheritsched(const pthread_attr_t * attr, int * inherit);\n\nint pthread_attr_setinheritsched(pthread_attr_t * attr, int inherit);\n```\n\ninherit有两个可选值：PTHREAD_INHERIT_SCHED(新线程沿用其创建者的线程调度参数)与PTHREAD_EXPLICIT_SCHED(调用者需明确指定新线程的调度参数)。\n\n## 线程竞争的范围\n\n```c\nint pthread_attr_getscope(const pthread_attr_t * attr, int * scope);\n\nint pthread_attr_setscope(pthread_attr_t * attr, int scope);\n```\n\nscope有两个可选值PTHREAD_SCOPE_SYSTEM(目标线程与系统中所有线程一起竞争CPU)与PTHREAD_SCOPE_PROCESS(目标线程仅与其他隶属于同一进程的线程竞争CPU，Linux未实现)。\n","tags":["网络编程"],"categories":["course"]},{"title":"第十章第二节 线程的创建与结束","url":"/course/np-ch10-par2.html","content":"\n## 创建线程\n\n创建一个线程使用函数pthread_create，其定义如下。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    th: 新线程标识符(pthread_t即整型)\n    attr: 设置新线程的属性(默认为NULL, 即使用默认线程属性\n    func: 指定新线程运行的函数\n    arg: 指定运行的函数参数\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_create(pthread_t th, const pthread_attr_t * attr, void * (* func)(void *), void * arg);\n```\n\n一个用户可打开的线程数量不能超过RLIMIT_NPROC软资源限制；此外，系统上所有用户能创建的线程总数也不能超过/proc/sys/kernal/threads-max内核参数所定义的值。\n\n线程创建好之后，内核将调度内核线程来执行func所指向的函数。\n\n## 结束线程\n\n线程函数在结束时推荐调用pthread_exit，以保证线程安全、干净的退出。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    retval: 指定线程的回收者\n*/\nvoid pthread_exit(void * retval);\n```\n\npthread_exit向线程的回收者传递其退出信息，它执行完后不会返回调用者，永远不会失败。\n\n## 回收线程\n\n一个进程的所有线程都可以调用pthread_join函数来回收其他线程(前提是目标线程可回收)，即等待其他线程结束，pthread_join函数定义如下。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    th: 目标线程标识符\n    retval: 存储目标线程返回的退出信息\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_join(pthread_t th, void * * retval);\n```\n\npthread_join函数会一直阻塞直到被回收的线程结束。\n\npthread_join可能引发如下错误码。\n\n<div style=\"width:90%;margin:auto\">{% asset_img 43.png pic43 %}</div>\n\n## 异常终止\n\n若一个线程希望异常终止另一个线程，即取消线程。可使用pthread_cancel函数实现。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    th: 目标线程标识符\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_cancel(pthread_t th);\n```\n\n接收到取消请求的目标线程可以决定是否允许被取消以及如何取消。分别由如下两个函数实现。\n\n```c\n/*\n    引用方式: #include <pthread.h>\n    state: 设置线程的取消状态; PTHREAD_CANCEL_ENABLE: 允许线程被取消 || PTHREAD_CANCEL_DISABLE: 禁止线程被取消\n    type: 设置线程的取消类型\n        PTHREAD_CANCEL_ASYNCHRONOUS: 线程随时被取消目标线程将立即采取行动\n        PTHREAD_CANCEL_DEFERED: 允许目标线程推迟行动直到它调用取消点函数pthread_testcancle函数\n    old_state: 存储线程之前的取消状态\n    old_type: 存储线程之前的取消类型\n    返回0: 成功 || 返回错误码: 失败\n*/\nint pthread_setcancelstate(int state, int * old_state);\n\nint pthread_setcanceltype(int type, int * old_type);\n```\n","tags":["网络编程"],"categories":["course"]},{"title":"第十章第一节 Linux线程概述","url":"/course/np-ch10-par1.html","content":"\n## 线程模型\n\n说到线程，又会提下老生常谈的一段话：线程是程序中完成一个独立任务的完整执行序列，即一个可调度的实体。根据运行环境与调度者的身份，线程可分为内核线程(运行在内核空间，由内核调度)与用户线程(运行在用户空间，由线程库调度)；\n\n当进程的一个内核线程获得CPU的使用权后，它会加载并运行一个用户线程。可见，内核线程相当于用户线程运行的\"容器\"。一个进程可以拥有M个内核线程与N个用户线程(M<=N)。在一个系统的所有进程中，M与N的比值都是固定的，按照M与N的比值，线程的实现分为3种模式：(1)完全在用户空间实现(N=1)；(2)完全由内核调度(M=N)；(3)双层调度(1<N<M)。\n\n## Linux线程库\n\nLiunx上有名的线程库NPTL采取完全由内核调度的模式。\n\n从Linux内核版本2.6开始，提供真正的内核线程。新的线程库NPTL也应运而生。NPTL的优势如下。\n\n* 内核线程不再是一个进程(避免了很多用进程模拟内核线程导致的语义问题)；\n* 不再使用管理线程；终止线程、回收线程堆栈等工作均由内核完成；同时，由于不再使用管理线程。因此一个进程的线程可以运行在不同的CPU上。从而充分利用了多处理器系统的优势；\n* 线程的同步由内核完成，隶属于不同进程的线程之间也能共享互斥锁，从而实现跨进程的线程同步；\n\n注：内核线程独立运行在内核空间，相比于普通进程，内核线程没有独立的地址空间(mm指针为NULL)；内核线程只在内核空间运行，从来不会切换到用户空间中去；内核线程也能被调用、抢占。\n","tags":["网络编程"],"categories":["course"]},{"title":"第九章第四节 消息队列&其他建议","url":"/course/np-ch9-par4.html","content":"\n## 消息队列\n\n消息队列是在两个进程之间传递二进制块数据的一种简单有效的方式。每个数据块都有一个特定的类型，接收方可以根据类型来有选择地接收数据，而不用像管道那样必须以先进先出的方式接收数据。\n\n### msgget系统调用\n\nmsgget系统调用创建一个消息队列，或者获取一个已有的消息队列。其定义如下。\n\n```c\n/*\n    引用方式: #include <sys/msg.h>\n    key: 键值, 用来标识一个全局唯一的消息队列\n    flags: 指定一组标志, 其低端的9比特为该信号量的权限, 格式含义均与系统调用open的mode参数相同\n    返回一个正整数作为消息队列的标识符: 成功 || 返回-1并设置errno: 失败\n*/\nint msgget(key_t key, int flg);\n```\n\n若msgget用于创建消息队列，则与之关联的内核数据结构msqid_ds将被创建并初始化。msqid_ds结构体的定义如下。\n\n```c\n/*\n    引用方式: #include <sys/msg.h>\n    msg_perm: 消息队列的操作权限\n    msg_stime: 最后一次调用msgsnd的时间\n    msg_rtime: 最后一次调用msgrcv的时间\n    msg_ctime: 最后一次被修改的时间\n    __msg_cbytes: 消息队列中已有的字节数\n    msg_qnum: 消息队列中已有的消息数\n    msg_qbytes: 消息队列允许的最大字节数\n    msg_lspid: 最后执行msgsnd的进程的PID\n    msg_lrpid: 最后执行msgrcv的进程的PID\n*/\nstruct msqid_ds{\n  struct ipc_perm msg_perm;\n  __time_t msg_stime;\n  __time_t msg_rtime;\n  __time_t msg_ctime;\n  __syscall_ulong_t __msg_cbytes;\n  msgqnum_t msg_qnum;\n  msglen_t msg_qbytes;\n  __pid_t msg_lspid;\n  __pid_t msg_lrpid;\n  __syscall_ulong_t __unused4;\n  __syscall_ulong_t __unused5;\n};\n```\n\n### msgsnd系统调用\n\nmsgsnd系统调用将一条消息添加到消息队列中；其定义如下。\n\n```c\n/*\n    引用方式: #include <sys/msg.h>\n    msqid: 指定消息队列的标识符(由msgget系统调用返回)\n    msg_ptr: 指向一个准备发送的消息, 消息格式见下文\n    msg_sz: 消息数据部分的长度(可为0, 代表没有消息数据)\n    flg: 控制msgsnd函数的行为(仅支持IPC_NOWAIT标志)\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint msgsnd(int msqid, const void * msg_ptr, size_t msg_sz, int flg);\n```\n\nmsg_ptr必须按照如下格式。\n\n```c\n/*\n    mtype: 指定消息类型\n    mtext: 消息数据\n*/\nstruct msgbuf{\n    long mtype;\n    char mtext[512];\n}\n```\n\n当消息队列已满，若flg参数指定了IPC_NOWAIT标志时，msgsnd系统调用将立即返回并设置errno为EAGAIN；默认情况下，msgsnd将阻塞。\n\n处于阻塞状态的msgsnd系统调用会被如下两种异常情况中断。\n\n* msqid指定的消息队列被移除，msgsnd函数立即返回并设置errno为EIDRM；\n* 调用进程接收到信号，msgsnd函数立即返回并设置errno为EINTR；\n\nmsgsnd成功时将修改内核数据结构msqid_ds的部分字段。\n\n* msg_qnum加1；\n* 将msg_lspid设置为调用进程的PID；\n* 将msg_stime设置为当前时间；\n\n### msgrcv系统调用\n\nmsgrcv系统调用从消息队列中获取消息，其定义如下。\n\n```c\n/*\n    引用方式: #include <sys/msg.h>\n    msqid: 指定消息队列的标识符(由msgget系统调用返回)\n    msg_ptr: 存储接收的信息\n    msg_sz: 消息数据部分的长度(可为0, 代表没有消息数据)\n    mtype: 指定接收何种类型的消息; mtype=0: 读取消息队列中第一个消息 || mtype>0: 读取消息队列第一个mtype类型的消息(除非flg指定了MSG_EXCEPT) || mtype<0: 读取消息队列中第一个类型值比mtype绝对值小的消息\n    flg: 控制msgrcv函数的行为; 如下标志的按位或\n        IPC_NOWAIT: 若消息队列中无消息, 则msgrcv函数立即返回并设置errno为ENOMSG\n        MSG_EXCEPT: 若mtype>0, 则接收消息队列中第一个非mtype类型的消息\n        MSG_NOERROR: 若消息数据部分的长度超过msg_sz，则将其截断\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint msgrcv(int msqid, void * msg_ptr, size_t msg_sz, long mtype, int flg);\n```\n\n处于阻塞状态的msgrcv系统调用会被如下两种异常情况中断。\n\n* msqid指定的消息队列被移除，msgsnd函数立即返回并设置errno为EIDRM；\n* 调用进程接收到信号，msgsnd函数立即返回并设置errno为EINTR；\n\nmsgsnd成功时将修改内核数据结构msqid_ds的部分字段。\n\n* msg_qnum减1；\n* 将msg_lrpid设置为调用进程的PID；\n* 将msg_rtime设置为当前时间；\n\n### msgctl系统调用\n\nmsgctl系统调用控制消息队列的某些属性。其定义如下。\n\n```c\n/*\n    引用方式: #include <sys/msg.h>\n    msqid: 指定消息队列的标识符(由msgget系统调用返回)\n    command: 指定要执行的命令， 详见下表\n    buf: 存储结果\n    返回值与command有关 || 返回-1并设置errno: 失败\n*/\nint msgctl(int msqid, int command, struct msqid_ds * buf);\n```\n\n<div style=\"width:90%;margin:auto\">{% asset_img 41.png pic41 %}</div>\n\n<div style=\"width:90%;margin:auto\">{% asset_img 42.png pic42 %}</div>\n\n&nbsp;\n\n## 其他建议\n\n### IPC命令\n\nipcs命令输出系统当前拥有的共享资源实例。ipcrm删除遗留在系统中的共享资源。\n\n### 进程间传递文件描述符\n\n在之前提到，父进程创建的管道文件描述符在子进程中仍然打开。注意，父进程向子进程传递的并不是一个文件描述符的值，而是在子进程中创建一个新的文件描述符，之后与父进程中的文件描述符指向内核中相同的文件表项。\n\n那么，两个不相关的进程之间，该怎么传递文件描述符呢？示例详见代码清单13-5。","tags":["网络编程"],"categories":["course"]},{"title":"第九章第三节 共享内存","url":"/course/np-ch9-par3.html","content":"\n共享内存是最高效的IPC机制，因为它不涉及进程之间任何的数据传输。但是这种高效率必须依靠其他辅助手段来同步进程对共享内存的访问，否则会产生竞态条件。因此，共享内存退出需要与其他进程间通信方式一起使用。下面介绍共享内存的4个系统调用。\n\n## shmget系统调用\n\nshmget系统调用创建一段新的共享内存，或者获取一段已经存在的共享内存。其定义如下。\n\n```c\n/*\n    引用方式: #include <sys/shm.h>\n    key: 键值, 标志一段全局唯一的共享内存\n    size: 指定共享内存的大小; 创建新的共享内存: size必须指定 || 获取已有的共享内存: size可设置为0\n    flags: 指定一组标志, 其低端的9比特为该信号量的权限, 格式含义均与系统调用open的mode参数相同, 可与下面标志按位或\n        SHM_CREAT: 创建新的共享内存\n        SHM_EXCL: 确保创建的共享内存唯一(若共享内存已经存在, 则semget返回-1并设置errno为EEXIST)\n        SHM_HUGETAB: 系统将使用大页面来为共享内存分配空间\n        SHM_NORESERVE: 不为共享内存保留交换分区(此时在共享内存不足时, 对该共享内存的写操作将触发SIGSEGV信号)\n    返回共享内存的标识符(正整数): 成功 || 返回-1并设置errno: 失败\n*/\nint shmget(key_t key, size_t size, int shmflg);\n```\n\n使用shmget创建共享内存之后，这段共享内存的所以字节均被初始化为0，与之关联的内核数据结构shmid_ds将被创建并初始化。结构体shmid_ds定义如下。\n\n```c\n/*\n    引用方式: #include <sys/shm.h>\n    shm_perm: 共享内存的操作权限\n    shm_segsz: 共享内存大小\n    shm_atime: 对这段共享内存最后一次调用shmat的时间\n    shm_dtime: 对这段共享内存最后一次调用shmdt的时间\n    shm_ctime: 对这段共享内存最后一次调用shmctl的时间\n    shm_cpid: 创建者的PID\n    shm_lpid: 最后一次执行shmat或shmda操作的进程的PID\n    shm_nattch: 目前关联到此共享内存的进程数量\n*/\nstruct shmid_ds{\n    struct ipc_perm shm_perm;\n    size_t shm_segsz;\n    __time_t shm_atime;\n    __time_t shm_dtime;\n    __time_t shm_ctime;\n    __pid_t shm_cpid;\n    __pid_t shm_lpid;\n    shmatt_t shm_nattch;\n    __syscall_ulong_t __unused4;\n    __syscall_ulong_t __unused5;\n};\n```\n\nshmget对shmid_ds结构体的初始化如下。\n\n* shm_perm.cuid与shm_perm.uid设置为调用进程的有效用户ID；\n* shm_perm.cgid与shm_perm.gid设置为调用进程的有效组ID；\n* shm_perm.mode低9位设置为flags参数的最低9位；\n* shm_segsz设置为size；\n* shm_atime、shm_dtime、shm_lpid、shm_nattch设置为0；\n* shm_ctime设置为当前系统时间；\n\n## shmat与shmdt系统调用\n\n共享内存被创建/获取之后，此时应用程序并不能立即访问它，而是需要先将它关联到进程的地址空间中。使用完共享内存之后，应用程序也要将其从进程的地址空间中分离出来。这两项任务分别由如下两个系统调用实现。\n\n```c\n/*\n    引用方式: #include <sys/shm.h>\n    shm_id: 指定的共享内存标识符(由shmget系统调用返回)\n    shm_addr: 指定共享内存关联的地址; 推荐为NULL, 此时关联的地址由操作系统选择, 可使得代码具有良好的移植性; 对于指定了具体地址的情况, 关联的地址还会受到shmflg的影响\n    shmflg: 可选标志, 详见下文\n        SHM_RDONLY: 进程只能读取共享内存的内容; 若未指定此标志，在共享内存的创建时指定了可写的情况下, 进程可对共享内存进行写操作\n        SHM_REMAP: 若地址shm_addr已被关联到一段共享内存上，则将其重新关联到shm_id指定的共享内存\n        SHM_EXEC: 指定对共享内存的执行权限(等价于读权限)\n    返回共享内存被关联到的地址: 成功 || 返回(void *)(-1)并设置errno: 失败\n*/\nvoid shmat(int shm_id, const void * shm_addr, int shmflg);\n```\n\n* 若shm_addr非空，并且未设置SHM_SND标志，则共享内存被关联到addr指定地址；\n* 若shm_addr非空，并且设置了SHM_SND标志，则被关联的地址为shm_addr-(shm_addr%SHMLBA)，其中SHMLBA为\"段低端边界地址倍数\"。它必须是内存页面大小的整数倍；\n\nshmat成功返回将修改内核数据结构shmid_ds的部分字段。\n\n* shm_nattch置1；\n* shm_lpid置为调用进程的PID；\n* shm_atime置为当前时间；\n\n```c\n/*\n    引用方式: #include <sys/shm.h>\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint shmdt(const void * shm_addr);\n```\n\nshmdt系统调用将关联到shm_addr处的共享内存从进程中分离。shmdt成功返回时将修改内核数据结构shmid_ds的部分字段。\n\n* shm_nattch减1；\n* shm_lpid置为调用进程的PID；\n* shm_dtime置为当前时间；\n\n## shmctl系统调用\n\nshmctl系统调用控制共享内存的某些属性。其定义如下。\n\n```c\n/*\n    引用方式: #include <sys/shm.h>\n    shm_id: 指定的共享内存标识符(由shmget系统调用返回)\n    command: 指定执行的命令, 详见下表\n    返回值取决于command参数 || 返回-1并设置errno: 失败\n*/\nint shmctl(int shm_id, int command, struct shmid_ds * buf);\n```\n\n其中，shmctl支持的命令如下表。\n\n<div style=\"width:90%;margin:auto\">{% asset_img 40.png pic40 %}</div>\n\n&nbsp;\n\n## 共享内存的POSIX方法\n\nLinux提供另一种利用mmap在无关内存之间共享内存的方式，这种方式无须任何文件的支持，但它需要使用如下函数创建/打开一个POSIX共享内存对象。\n\n```c\n/*\n    引用方式: #include <sys/mman.h>\n    #include <sys/stat.h>\n    #include <fcntl.h>\n    name: 指定要创建/打开的共享内存对象(从可移植性的角度考虑, name参数应该是/[a-z][A-Z]{1,255}形式)\n    oflag: 指定创建方式, 如下标志的按位或\n        O_RDONLY: 以只读方式打开共享内存对象\n        O_RDWR: 以可读可写的方式打开共享内存对象\n        O_CREAT: 若共享内存对象不存在，则创建它; 此时mode参数的低9位指定该共享内存对象的访问权限(共享内存对象被创建时, 其初始长度为0)\n        O_EXCL: 与O_CREAT一起使用, 若由name指定的共享内存对象已经存在, 则shm_open调用返回错误, 否则创建一个新的共享内存对象\n        O_TRUNC: 若共享内存对象已存在, 则将其截断, 使其长度为0\n    返回一个文件描述符: 成功 || 返回-1并设置errno: 失败\n*/\nint shm_open(const char * name, int oflag, mode_t mode);\n```\n\nshm_open调用成功返回的文件描述符可用于后续的mmap调用，从而将共享内存关联到调用进程。\n\n一般，shm_open返回的文件描述符会配合ftruncate函数使用，ftruncate函数设置指定文件的大小。其定义如下。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    fd: 指定的文件描述符(该文件必须以写入模式打开)\n    size: 指定的大小(若原来的文件大小比参数size大，则超过的部分会被截断)\n*/\nint ftruncate(int fd, off_t size);\n```\n\n同理，shm_open创建的共享内存对象也需要在使用完释放，使用shm_unlink函数将共享内存对象标记为\"等待删除\"，当所有关联了此共享内存对象的进程都使用munmap函数将共享内存对象从进程的地址空间中分离之后，系统将销毁这个共享内存对象所占据的资源。\n\n```c\n/*\n    引用方式: #include <sys/mman.h>\n    #include <sys/stat.h>\n    #include <fcntl.h>\n    name: 指定共享内存对象\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint shm_unlink(const char * name);\n```\n\n注：使用gcc编译调用了POSIX共享内存函数的代码时，需要加上链接选项-lrt。\n","tags":["网络编程"],"categories":["course"]},{"title":"第九章第二节 管道与信号量","url":"/course/np-ch9-par2.html","content":"\n## 管道\n\n父进程调用pipe创建管道，fork之后管道的两端fd[0]与fd[1]在父子进程中均打开。此时，若要实现父进程向子进程写数据，则需要在父进程关闭fd[0]，在子进程关闭fd[1]。\n\n而若要实现父子进程的双向数据传输，可使用socketpair创建一个双向管道，父子进程各关闭一个，从而实现双向的数据传输。\n\n管道只能用于有关联的进程间通信，对于没有关联的进程间通信，需要使用如下3种System V IPV，它们都使用一个全局唯一的键值来标识一条信道。\n\n## 信号量\n\n### semget系统调用\n\nsemget系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集。\n\n```c\n/*\n    引用方式: #include <sys/sem.h>\n    key: 键值, 用来标识一个全局唯一的信号量集; 两个进程要使用信号量通信, 则需要使用相同的键值来创建/获取该信号量\n    num: 指定要创建/获取的信号量集中信号量的数目; 创建: 必须设置 || 获取: 可设置为0\n    flags: 指定一组标志, 其低端的9比特为该信号量的权限, 格式含义均与系统调用open的mode参数相同, 可与下面标志按位或\n        IPC_CREAT: 创建新的信号量集\n        IPC_EXCL: 确保创建的信号量集唯一(若信号量集已经存在, 则semget返回-1并设置errno为EEXIST)\n    返回一个正整数作为信号量集的标识符: 成功 || 返回-1并设置errno: 失败\n*/\nint semget(key_t key, int num, int flags);\n```\n\n在semget用于创建信号量集后，与之关联的内核数据结构体semid_ds将被创建并初始化。semid_ds结构体定义如下。\n\n```c\n/*\n    引用方式: #include <sys/sem.h>\n    __key: 键值\n    uid: 所有者的有效用户ID\n    gid: 所有者的有效组ID\n    cuid: 创建者的有效用户ID\n    cgid: 创建者的有效用户ID\n    mode: 访问权限\n*/\nstruct ipc_perm{\n    __key_t __key;\n    __uid_t uid;\n    __gid_t gid;\n    __uid_t cuid;\n    __gid_t cgid;\n    unsigned short int mode;\n    unsigned short int __pad1;\n    unsigned short int __seq;\n    unsigned short int __pad2;\n    __syscall_ulong_t __unused1;\n    __syscall_ulong_t __unused2;\n};\n/*\n    引用方式: #include <sys/sem.h>\n    sem_perm: 信号量的操作权限\n    sem_nsems: 信号量集中信号量的数目\n    sem_otime: 最后一次调用semop的时间\n    sem_ctime: 最后一次调用semctl的时间\n*/\nstruct semid_ds{\n  struct ipc_perm sem_perm;\n  __time_t sem_otime;\n  __syscall_ulong_t __unused1;\n  __time_t sem_ctime;\n  __syscall_ulong_t __unused2;\n  __syscall_ulong_t sem_nsems;\n  __syscall_ulong_t __unused3;\n  __syscall_ulong_t __unused4;\n};\n```\n\nsemget对semid_ds结构体的初始化如下。\n\n* sem_perm.cuid与sem_perm.uid设置为调用进程的有效用户ID；\n* sem_perm.cgid与sem_perm.gid设置为调用进程的有效组ID；\n* sem_perm.mode低9位设置为flags参数的最低9位；\n* sem_nsems设置为num；\n* sem_otime设置为0；\n* sem_ctime设置为当前系统时\n\n### semop系统调用\n\n先介绍与每个信号量关联的一些重要的内核变量。\n\n```c\nunsigned short semval; //信号量的值\n\nunsigned short semzcnt; //等待信号值变为0的进程数量\n\nunsigned short semncnt; //等待信号量值增加的进程数量\n\npid_t sempid; //最后一次执行semop操作的进程ID\n```\n\nsemop函数对信号量的操作其实就是对这些内核变量的操作；下面介绍semop函数，其定义如下。\n\n```c\n/*\n    引用方式: #include <sys/sem.h>\n    id: 目标信号量集的标识符(由semget函数返回)\n    sem_ops: 控制semop函数的行为, 详见下文\n    num_sem_ops: 指定要执行的操作个数(即sem_ops数组中元素的个数)\n    返回0: 成功 || 返回-1并设置errno: 失败(此时数组sem_ops中的操作均不被执行)\n*/\nint semop(int id, struct sembuf * sem_ops, size_t num_sem_ops);\n```\n\nsembuf结构体的定义如下。\n\n```c\n/*\n    引用方式: #include <sys/sem.h>\n    sem_num: 信号量在信号量集中的编号\n    sem_op: 指定操作类型, 详见下文; 同时每种类型的操作行为还会受到sem_flg的影响\n    sem_flg: IPC_NOWAIT: semop调用是非阻塞的 || SEM_UNDO: 进程退出时取消正在进行的semop操作\n*/\nstruct sembuf{\n  unsigned short int sem_num;\n  short int sem_op;\n  short int sem_flg;\n};\n```\n\nsem_op与sem_flg搭配会有如下这些效果。\n\n* sem_op大于0，semop将被操作的信号量的值semval增加sem_op(即V操作)，此时要求调用进程对操作的信号量集拥有写权限。此外，若sem_flg设置了SEM_UNDO标志，则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)；\n* sem_op等于0，这表示一个\"等待0\"操作，该操作要求调用进程对操作的信号量集拥有读权限。\n  * 若此时信号量的值为0，则调用立即成功返回；\n  * 否则，调用失败返回或阻塞进程以等待信号量变为0；具体来说：若sem_flg设置了IPC_NOWAIT标志，则semop调用立即返回-1并设置errno为EAGAIN；\n  * 否则，信号量的semzcnt加1，进程被挂起直到以下3个条件之一满足：(1)信号量的semzcnt值为0，此时系统将该信号量的semzcnt减1；(2)被操作信号量所在信号量集被进程移除，此时semop调用失败返回， errno被设置为EIDRM；(3)调用被信号中断，此时semop调用失败返回，errno被设置为EINTR，同时系统将信号量的semzcnt减1；\n* sem_op小于0，semop将被操作的信号量的值semval减去sem_op的绝对值(即P操作)，此时要求调用进程对操作的信号量集具有写权限。此外，若em_flg设置了SEM_UNDO标志，操作系统将更新进程的semadj变量(同样用于跟踪进程对信号量的修改情况)；\n  * 若semval+sem_op大于0，则semop调用成功返回，调用进程立即获得信号量；此外，操作系统将该信号量的值semval重置为semval+sem_op；\n  * 否则，则semop失败返回或阻塞进程以等待信号量可用；具体来说：若sem_flg设置了IPC_NOWAIT标志，semop立即返回-1，并设置errno为EAGAIN；\n  * 否则，则信号量的semncnt加1，进程被挂起直到以下3个条件之一满足：(1)semval+sem_op大于0，此时系统将该信号量的semncnt减1；此外，若sem_flg设置了SEM_UNDO标志，则系统将更新进程的semadj变量；(2)被操作信号量所在信号量集被进程移除，此时semop调用失败返回， errno被设置为EIDRM；(3)调用被信号中断，此时semop调用失败返回，errno被设置为EINTR，同时系统将信号量的semncnt减1；\n\n### semctl系统调用\n\nsemctl系统调用允许调用者对信号量进行直接控制。其定义如下。\n\n```c\n/*\n    引用方式: #include <sys/sem.h>\n    id: 目标信号量集的标识符(由semget函数返回)\n    sem_ind: 被操作的信号量在信号量集中的编号\n    command: 指定执行的命令\n    返回值取决于command || 返回-1并设置errno: 失败\n*/\nint semctl(int id, int sem_ind, int command, ...);\n```\n\n有些命令需要调用者传递第4个参数，参数类型由用户自行定义，但sys/sem.h中给出了推荐的格式。\n\n```c\n/*\n    引用方式: #include <sys/sem.h>\n    semmap: Linux内核未使用\n    semmni: 系统最多可以拥有的信号量集数目\n    semmns: 系统最多可以拥有的信号量数目\n    semmnu: Linux内核未使用\n    semmsl: 一个信号量集最多可以包含的信号量数目\n    semopm: semop一次最多可以执行的sem_op操作数目\n    semume: Linux内核未使用\n    semusz: sem_undo结构体的大小\n    semvmx: 最多允许的信号量值\n    semaem: 最多允许的UNDO次数(带SEM_UNDO标志的sem_op操作的次数)\n*/\nstruct seminfo{\n    int semmap;\n    int semmni;\n    int semmns;\n    int semmnu;\n    int semmsl;\n    int semopm;\n    int semume;\n    int semusz;\n    int semvmx;\n    int semaem;\n};\n\n/*\n    引用方式: 未定义(只是推荐使用)\n    val: 用于SETVAL命令\n    buf: 用于IPC_STAT与IPC_SET命令\n    array: 用于GETALL与SETALL命令\n    __buf: 用于IPC_INFO命令\n*/\nunion semun{\n    int val;\n    struct semid_ds * buf;\n    unsigned short int * array;\n    struct seminfo * __buf;\n};\n```\n\n最后，semctl支持的所以命令如下图所示。\n\n<div style=\"width:90%;margin:auto\">{% asset_img 39.png pic39 %}</div>\n\n&nbsp;\n\n注：GETNCNT、GETPID、GETVAL、GETZCNT、SETVAL命令操作的是单个信号量，它是由标识符sem_id指定的信号量集中的第sem_ind个信号量；其他命令操作整个信号量集，此时sem_ind参数被忽略。\n\n### 特殊键值IPC_PRIVATE\n\nsemget的调用者可以向其key参数传递一个特殊的键值IPC_PRIVATE(值为0)，这样无论该信号量集是否存在，semget都将创建一个新的信号量。其实更应该称为IPC_NEW。\n\n","tags":["网络编程"],"categories":["course"]},{"title":"iPhone与Windows系统互传文件","url":"/config/iPhone-with-Windows.html","content":"\n首先新建一个文件夹用于存放与iPhone互相传文件的文件夹，例如我在\"文档\"中新建一个iPhone文件夹。\n\n<div style=\"width:90%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\n单击选中iPhone文件夹，右键选择\"属性\"，选择共享选项。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\n点击\"共享(S)\"，然后点击框右边的向下箭头。选择\"Everyone\"，然后点击\"添加\"。\n\n<div style=\"width:90%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\n修改Everyone的权限级别为\"读取/写入\"。\n\n<div style=\"width:90%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n然后点击\"共享(H)\"，注意属性的共享选项所说。\"用户需具有此计算机的用户账户与密码，才能访问共享文件夹\"。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n此时，还需要知道电脑在无线局域网内的IPv4地址：Win+R快捷键调出运行，输入cmd然后回车，在命令行输入ipconfig。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n&nbsp;\n\n然后Windows给iPhone开热点：设置(Win+I快捷键)，然后\"网络与Internet\"，移动热点；选择开，下面就会显示网络名称与网络密码，然后iPhone就像连Wifi一样连上热点即可！\n\n<div style=\"width:36%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n&nbsp;\n\n然后在iPhone中，打开\"文件\"，选择右上方的 ···，点击\"连接服务器\"，\n\n<div style=\"width:36%;margin:auto\">{% asset_img 8.jpg pic8jpg %}</div>\n\n&nbsp;\n\n然后输入电脑的IPv4地址作为服务器地址\n\n<div style=\"width:48%;margin:auto\">{% asset_img 9.jpg pic9 %}</div>\n\n然后输入电脑的用户名与密码，若你是使用微软账户登录的，就输入注册微软账户的邮箱。密码自然是电脑的开机密码，也是微软账户的密码。\n\n<div style=\"width:48%;margin:auto\">{% asset_img 10.jpg pic10 %}</div>\n\n&nbsp;\n\n然后我们就能看到在电脑上设置的共享文件夹iPhone了。\n\n<div style=\"width:48%;margin:auto\">{% asset_img 11.jpg pic11 %}</div>\n\n&nbsp;\n\n如果不能从iPhone中复制文件到共享文件夹iPhone，那么打开共享文件夹的属性页的共享选项，点击\"高级共享(D)\"，点击\"权限(P)\"，将Everyone的权限全部打勾。\n\n<div style=\"width:90%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n这下应该没问题了。\n","tags":["iPhone"],"categories":["config"]},{"title":"第九章第一节 fork与exec","url":"/course/np-ch9-par1.html","content":"\n## fork系统调用\n\nLinux下创建新进程的系统调用为fork。\n\n```c\n/*\n    引用方式: #include <sys/types.h>\n    #include <unistd.h>\n    返回-1并设置errno: 失败\n*/\npid_t fork();\n```\n\n该函数的每次调用都返回两次，在父进程中返回子进程的PID，则子进程中返回0。\n\nfork函数复制当前进程的进程管理信息给子进程。子进程的进程管理信息大部分属性与原进程相同，如堆地址、栈地址、标志寄存器等；还要一些属性与父进程不同，如进程的PPID(设置为父进程的PID)、信号位图(所有位置0)。\n\n此外，创建子进程后，父进程中打开的文件描述符默认在子进程中也是打开的，且文件描述符的引用计数加1。并且父进程的用户根目录、当前工作目录等变量的引用计数也会加1。\n\n## exec系列系统调用\n\nexec系统调用将可执行文件替换当前进程映像。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    path: 指定可执行文件的完整路径\n    file: 接受文件名，此时程序会在环境变量PATH中寻找\n    arg: 接受可变参数, 将传递给新进程之main函数\n    argv: 接受参数数组, 将传递给新进程之main函数\n    envp: 设置新进程的环境变量; 若未设置envp参数, 则新进程将使用全局变量environ指定的环境变量\n    返回-1并设置errno: 失败\n*/\nint execl(const char * path, const char * arg, ...);\n\nint execlp(const char * file, const char * arg, ...);\n\nint execle(const char * path, const char * arg, ..., const char * envp[]);\n\nint execv(const char * path, const char * argv[]);\n\nint execvp(const char * file, const char * argv[]);\n\nint execve(const char * path, const char * argv[], const char * envp[]);\n```\n\n若exec系列系统调用执行未出错，则原程序中exec调用之后的代码都不会执行！\n\nexec系列系统调用在运行后不会关闭原进程打开的文件描述符，除非该文件描述符被设置了类似SOCK_CLOEXEC属性。\n\n## 处理僵尸进程\n\n对多进程程序而言，父进程需要跟踪子进程的退出状态；因此，子进程结束运行后，内核不会立即释放该进程的进程管理信息。\n\n在子进程结束运行之后，父进程读取其退出状态之前，子进程处于僵尸状态。\n\n此外，若父进程意外终止，也会使子进程进入僵尸态；此时子进程的PPID被设置为1(父进程为init进程)。之后，init进程接管该子进程并等待它结束。\n\n僵尸进程占用内核资源；为此，Linux系统提供wait/waitpid函数来等待进程结束。\n\n```c\n/*\n    引用方式: #include <sys/types.h>\n    #include <wait.h>\n    stat_loc: 存储子进程的退出状态信息\n    pid: 指定子进程的PID(pid=-1则waitpid等价于wait)\n    opt: 控制waitpid 函数的行为; 常见取值WNOHANG(此时waitpid调用是非阻塞的: 若pid指定的子进程还未结束, waitpid立即返回0)\n    返回结束的子进程的PID: 成功 || 返回-1并设置errno: 失败\n*/\npid_t wait(int * stat_loc);\n\npid_t waitpid(pid_t pid, int * stat_loc, int opt);\n```\n\n* wait函数将阻塞进程直到进程的某个子进程结束；\n* waitpid只等待pid结束；\n\n同样地，只有在事件发生的情况下使用非阻塞调用才能提高程序的效率。而一个进程结束时，它将给它的父进程发送SIGCHLD信号来表明自身的结束。因此，父进程可捕获SIGCHLD信号，然后在信号处理函数中调用waitpid函数。\n\n一种典型处理如下。\n\n```c\nstatic void handle_child(int sig){\n    pid_t pid;\n    int stat;\n    while((pid=waitpid(-1, & stat, WNOHANG))>0){\n        // 对结束的子进程进行善后处理\n    }\n}\n```\n\n","tags":["网络编程"],"categories":["course"]},{"title":"第八章 高性能I/O框架库Libevent","url":"/course/np-ch8.html","content":"\n[第一节 I/O框架库概述](https://KangMing-ux.github.io/course/np-ch8-par1.html)\n\n[第二节 初识libevent](https://KangMing-ux.github.io/course/np-ch8-par2.html)\n\n[第三节 libevent源码组织结构](https://KangMing-ux.github.io/course/np-ch8-par3.html)\n\n[第四节 event结构体](https://KangMing-ux.github.io/course/np-ch8-par4.html)\n\n[第五节 event_add函数](https://KangMing-ux.github.io/course/np-ch8-par5.html)\n\n[第六节 event_base结构体](https://KangMing-ux.github.io/course/np-ch8-par6.html)\n\n","tags":["网络编程"],"categories":["course"]},{"title":"第八章第六节 event_base结构体","url":"/course/np-ch8-par6.html","content":"\n## event_base结构体\n\n```c\n/*\n    引用方式: #include <event.h>\n    evsel: event_base对象选择的I/O复用机制\n    evbase: event_base对象的存储数据地址(通过evsel成员的init函数初始化)\n    changelist: 事件变化队列(考虑一个文件描述符上注册的事件被多次修改, 那么可以使用缓存来避免重复的系统调用, 仅用于事件检测算法的复杂度为O(1)的I/O复用技术)\n    evsigsel: 信号的后端处理机制(目前在signal.c中定义了一种处理机制)\n    sig: 被信号事件处理器使用，其中封装了一个由socketpair创建的管道; 管道用于信号处理函数与事件多路分发器之间的通信, 即统一事件源\n    virtual_event_count: 添加到event_base对象中的虚拟事件数\n    event_count: 添加到event_base对象上所有事件的数量\n    event_count_active: event_base对象上的激活事件数\n    event_gotterm: 是否执行完活动队列上的剩余任务后就退出事件循环\n    event_break: 是否立即退出事件循环，而不论是否还要任务需要处理\n    event_continue: 是否应该启动一个新的事件循环\n    event_running_priority: 目前正在处理的活动事件队列的优先级\n    running_loop: 事件循环是否已经启动\n    activequeues: 活动事件队列数组(索引值越小的队列, 优先级越高, 高优先级中的)\n    common_timeout_queues: 通用定时器队列\n    io: 文件描述符与I/O事件之间的映射关系表\n    sigmap: 信号值与信号事件的映射关系表\n    th_owner_id: 当前运行该event_base的事件循环的线程\n    th_base_lock: 对该event_base的独占锁\n    current_event_cond: 条件变量(用于唤醒正在等待某个事件处理完毕的线程)\n    current_event_waiters: 等待条件变量current_event_cond的线程数\n    flags:  event_base对象的配置参数\n    is_notify_pending: 工作线程是否要唤醒管道\n    th_notify_fd: 工作线程与主线程建立的管道\n*/\nstruct event_base {\n        const struct eventop *evsel;\n        void *evbase;\n        struct event_changelist changelist;\n        const struct eventop *evsigsel;\n        struct evsig_info sig;\n        int virtual_event_count;\n        int virtual_event_count_max;\n        int event_count;\n        int event_count_max;\n        int event_count_active;\n        int event_count_active_max;\n        int event_gotterm;\n        int event_break;\n        int event_continue;\n        int event_running_priority;\n        int running_loop;\n        int n_deferreds_queued;\n        struct evcallback_list *activequeues;\n        int nactivequeues;\n        struct evcallback_list active_later_queue;\n        struct common_timeout_list **common_timeout_queues;\n        int n_common_timeouts;\n        int n_common_timeouts_allocated;\n        struct event_io_map io;\n        struct event_signal_map sigmap;\n        struct min_heap timeheap;\n        struct timeval tv_cache;\n        struct evutil_monotonic_timer monotonic_timer;\n        struct timeval tv_clock_diff;\n        time_t last_updated_clock_diff;\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n        unsigned long th_owner_id;\n        void *th_base_lock;\n        void *current_event_cond;\n        int current_event_waiters;\n#endif\n        struct event_callback *current_event;\n\n#ifdef _WIN32\n        struct event_iocp_port *iocp;\n#endif\n        enum event_base_config_flag flags;\n        struct timeval max_dispatch_time;\n        int max_dispatch_callbacks;\n        int limit_callbacks_after_prio;\n        int is_notify_pending;\n        evutil_socket_t th_notify_fd[2];\n        struct event th_notify;\n        int (*th_notify_fn)(struct event_base *base);\n        struct evutil_weakrand_state weakrand_seed;\n        LIST_HEAD(once_event_list, event_once) once_events;\n};\n```\n\n## 事件循环\n\n事件循环由event_base_loop函数实现。关于event_base_loop函数的分析详见代码清单12-10。\n","tags":["网络编程"],"categories":["course"]},{"title":"第八章第五节 event_add函数","url":"/course/np-ch8-par5.html","content":"\n## event_add函数\n\n创建一个event对象的函数为将event_new封装后的函数evsignal_new、evtimer_new等；event_new的实现比较简单，为event对象分配内存并初始化其部分成员。\n\n创建了event对象后，应用程序调用event_add函数将其添加到注册事件队列中，并将相应的事件注册到事件多路分发器上。\n\nevent_add函数在event.c文件中实现，主要调用内部函数event_add_nolock_，外加调用前后两次加锁。\n\n关于函数event_add_nolock_的分析详见代码清单12-3。\n\n其中调用了几个重要的函数。\n\n* evmap_io_add：将I/O事件添加到事件多路分发器中，并将对应的事件处理器添加到I/O事件队列中，同时建立I/O事件与I/O事件队列之间的映射关系；\n* evmap_signal_add：将信号事件添加到事件多路分发器中，并将对应的事件处理器添加到信号事件队列中，同时建立信号事件与信号事件队列之间的映射关系；\n* event_queue_insert：将事件处理器添加到各种事件队列中，即：将I/O事件处理器与信号事件处理器插入注册事件队列；将定时器插入通用定时器队列或时间堆；将被激活的事件处理器添加到活动事件队列中；\n\n## 向事件多路分发器注册事件\n\n本节具体介绍evmap_io_add与evmap_signal_add这两个函数。在此之前，先介绍要用到的重要的数据结构。这部分详见代码清单12-5。\n\n## eventop结构体\n\neventop结构体封装了I/O复用机制必要的一些操作，如注册事件、等待事件等。它为event_base支持的所有后端I/O复用机制提供了统一的接口。\n\n```c\n/*\n    引用方式: #include <event.h>\n    name: 后端I/O复用技术的名称\n    init: 初始化函数接口\n    add: 注册事件接口\n    del: 删除事件接口\n    dispatch: 等待事件接口\n    dealloc: I/O资源释放接口\n    need_reinit: 程序调用fork后是否需要重新初始化event_base\n    features: I/O复用技术支持的特性; EV_FEATURE_ET: 支持边沿触发事件EV_ET || EV_FEATURE_O1: 事件检测算法的复杂度为O(1) || EV_FEATURE_FDS: 不仅能监听socket文件上的事件, 还能监听其他类型的文件描述符上的事件\n    fdinfo_len: 详见fdinfo_len段\n*/\nstruct eventop {\n        const char *name;\n        void *(*init)(struct event_base *);\n        int (*add)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);\n        int (*del)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);\n        int (*dispatch)(struct event_base *, struct timeval *);\n        void (*dealloc)(struct event_base *);\n        int need_reinit;\n        enum event_method_feature features;\n        size_t fdinfo_len;\n};\n```\n\n### fdinfo_len\n\n有的I/O复用机制需要为每个I/O事件队列与信号事件队列分配额外的内存，以避免同一个文件描述符被重复插入I/O复用机制的事件表中。于是在evmap_io_add/del在调用eventop的add/del方法时，将这段内存的起始地址作为第五个参数传递给add/del方法，fdinfo_len则用来指定这段内存的长度。\n\n### I/O复用技术的优先级\n\nevent ports > kqueue > epoll > /dev/poll > poll > select。\n\n可见，在Linux下libevent默认选择epoll I/O复用技术。\n","tags":["网络编程"],"categories":["course"]},{"title":"第八章第四节 event结构体","url":"/course/np-ch8-par4.html","content":"\nevent结构体封装了句柄、事件类型、回调函数以及其他必要的标志与数据。event结构体定义如下。\n\n```c\n/*\n    引用方式: #include <event.h>\n    evcb_active_next: 详见evcb_active_next段\n    evcb_flags: 详见evcb_flags段\n    evcb_pri: 指定事件处理器优先级(值越小优先级越高)\n    evcb_closure: 详见evcb_closure段\n    evcb_cb_union: 回调函数\n    evcb_arg: 回调函数的参数\n*/\n\nstruct event_callback {\n        TAILQ_ENTRY(event_callback) evcb_active_next;\n        short evcb_flags;\n        ev_uint8_t evcb_pri;    /* smaller numbers are higher priority */\n        ev_uint8_t evcb_closure;\n        /* allows us to adopt for different types of events */\n        union {\n                void (*evcb_callback)(evutil_socket_t, short, void *);\n                void (*evcb_selfcb)(struct event_callback *, void *);\n                void (*evcb_evfinalize)(struct event *, void *);\n                void (*evcb_cbfinalize)(struct event_callback *, void *);\n        } evcb_cb_union;\n        void *evcb_arg;\n};\n\n/*\n    引用方式: #include <event.h>\n    ev_evcallback: 回调函数相关标志与数据(详见结构体event_callback注释)\n    ev_timeout_pos: 详见ev_timeout_pos段\n    ev_fd: 与事件处理器关联的句柄; 对于I/O事件处理器: 文件描述符值 || 对于信号事件处理器: 信号值\n    ev_base: 事件处理器从属的event_base实例\n    ev_: 详见ev_段\n    ev_events: 事件类型; 取值可以是event_new中介绍的各种事件类型的按位或(除了互斥的事件类型，如读写事件与信号事件不能同时设置)\n    ev_res: 记录当前激活事件的类型\n    ev_timeout: 指定定时器的超时值(仅对定时器有效)\n*/\n\nstruct event {\n        struct event_callback ev_evcallback;\n        /* for managing timeouts */\n        union {\n                TAILQ_ENTRY(event) ev_next_with_common_timeout;\n                int min_heap_idx;\n        } ev_timeout_pos;\n        evutil_socket_t ev_fd;\n        struct event_base *ev_base;\n        union {\n                /* used for io events */\n                struct {\n                        LIST_ENTRY (event) ev_io_next;\n                        struct timeval ev_timeout;\n                } ev_io;\n                /* used by signal events */\n                struct {\n                        LIST_ENTRY (event) ev_signal_next;\n                        short ev_ncalls;\n                        /* Allows deletes in callback */\n                        short *ev_pncalls;\n                } ev_signal;\n        } ev_;\n        short ev_events;\n        short ev_res;           /* result passed to event callback */\n        struct timeval ev_timeout;\n};\n```\n\n以下是一些数据结构的详解。\n\n### evcb_active_next\n\n所有被激活的事件处理器通过evcb_active_next成员串联成一个尾队列，即活动事件队列。\n\n活动事件队列不止一个，不同优先级(evcb_pri成员)的事件处理器被激活后将被插入不同的活动事件队列中。\n\n在事件循环中，Reactor将按优先级由高到低遍历所有活动事件队列，并依次处理其中的事件处理器。\n\n### evcb_flags\n\n事件标志。有如下可选值。\n\n* EVLIST_TIMEOUT。事件处理器从属于通用定时器队列/时间堆；\n* EVLIST_INSERTED。事件处理器从属于注册事件队列；\n* EVLIST_SIGNAL。此标志未使用；\n* EVLIST_ACTIVE。事件处理器从属于活动事件队列；\n* EVLIST_INTERNAL。用于内部使用；\n* EVLIST_INIT。事件处理器已被初始化；\n* EVLIST_ACTIVE_LATER。\n* EVLIST_FINALIZING。\n* EVLIST_ALL。定义所有标志；\n\n### evcb_closure\n\n指定event_base执行事件处理器的回调函数时的行为。有如下可选值。\n\n* EV_CLOSURE_EVENT。默认行为，调用evcb_callback回调函数；\n* EV_CLOSURE_EVENT_SIGNAL。执行信号事件处理器的回调函数时，调用ev_signal.ev_ncalls次回调函数；\n* EV_CLOSURE_EVENT_PERSIST。执行完回调函数后，再次将事件处理器加入注册事件队列；\n* EV_CLOSURE_CB_SELF。调用evcb_selfcb回调函数；\n* EV_CLOSURE_CB_FINALIZE。正在完成的回调，使用evcb_cbfinalize回调函数；\n* EV_CLOSURE_EVENT_FINALIZE。正在完成的回调，使用evcb_evfinalize回调函数；\n* EV_CLOSURE_EVENT_FINALIZE_FREE。正在完成的回调，且之后事件处理器将被释放；使用evcb_evfinalize回调函数；\n\n### ev_timeout_pos\n\n定时器通常由时间堆来管理，但一些情况下使用简单的链表来管理效率更高。2.0版本的libevent引入了所谓\"通用定时器\"的概念，这些定时器存储在尾队列中，记为通用定时器队列。\n\n其中ev_next_with_common_timeout成员指定通用定时器情况下该定时器在通用定时器队列中的位置；min_heap_idx成员指定其他定时器情况下该定时器在时间堆中的位置。\n\n一个定时器是否为通用定时器取决于其超时值大小，通过event.c中的is_common_timeout函数判断。\n\n### ev_\n\n所有具有相同文件描述符的I/O事件处理器通过ev_io.ev_io_next成员串联成一个尾队列，即I/O事件队列；所有具有相同信号值的信号事件处理器通过ev_signal.ev_signal_next成员串联成一个尾队列，即信号事件队列。\n\nev_signal.ev_ncalls成员指定信号事件发生后，Reactor需要执行多少次该事件对应的事件处理器中的回调函数。ev_signal.ev_pncalls成员要么指向ev_signal.ev_ncalls，要么为空。\n","tags":["网络编程"],"categories":["course"]},{"title":"第八章第三节 libevent源码组织结构","url":"/course/np-ch8-par3.html","content":"\n* 头文件目录include/event2。该目录自Libevent朱版本升级之2.0之后引入；其中的头文件是提供给应用程序使用的。如event.h提供核心函数、http.h提供HTTP协议相关服务、rpc.h提供远程调用支持。\n\n\n* 源码根目录下的头文件。这些头文件分为两类：一类是对include/event2目录下部分头文件的封装；一类供libevent内部使用，这类头文件都具有`*-internal.h`形式。\n\n\n* 通用数据结构目录cpmpat/sys。该目录下仅有一个头文件queue.h。该文件封装了跨平台的基础数据结构：单向链表、双向链表、队列、尾队列、循环队列。\n\n\n* sample目录。示例程序。\n\n\n* test目录。测试程序。\n\n\n* WIN32-Code目录。Windows平台上的专用代码。\n\n\n* event.c。实现libevent的整体框架。主要是对event与event_base对象的相关操作。\n\n\n* devpoll.c、kqueue.c、evport.c、select.c、win32select.c、poll.c与epoll.c。分别封装了/dev/poll、kqueue、event ports、POSIX select、Windows select、poll、epoll这些I/O复用机制。这些文件的主要内容相似，都是针对结构体eventop所定义的接口函数的实现。\n\n\n* signal.c。提供对信号的支持。其内容也是针对eventop所定义的接口函数的具体实现。\n\n\n* evmap.c。维护句柄与事件处理器之间的映射关系。\n\n\n* event_tagging.c。提供向缓冲区添加标记数据以及从缓冲区中读取标记数据的函数。\n\n\n* event_iocp.c。提供对Windows IOCP的支持。\n\n\n* `buffer*.c`。提供对网络I/O缓冲的控制。包含输入输出数据过滤、传输速率限制、使用SSL协议、零拷贝文件传输。\n\n\n* `evthread*.c`。提供对多线程的支持。\n\n\n* listener.c文件。封装对监听socket的操作，包括监听连接与接收连接。\n\n\n* logs.c文件。libevent的日志系统。\n\n\n* evutil.c、evutil_rand.c、strlcpy.c与arc4random.c文件。提供一些基本操作，如生成随机数、获取socket地址信息、读取文件、设置socket属性等。\n\n\n* evdns.c、http.c与evrpc.c。分别提供对DNS协议、HTTP协议、RPC协议的支持。\n","tags":["网络编程"],"categories":["course"]},{"title":"第八章第二节 初识libevent","url":"/course/np-ch8-par2.html","content":"\n## libevent简介\n\n[Libevent官方网站](https://libevent.org/)\n\n高性能分布式内存对象缓存软件memcached、Google Chromium Linux版等均使用Libevent作为I/O框架库。\n\nlibevent具有的特点：(1)跨平台；(2)统一事件源；(3)线程安全；(4)基于Reactor模式的实现。\n\n基于centos7(建议)安装libevent-2.1.8版本。安装步骤如下。\n\n```bash\ninstall_build_essential(){\n    yum install -y make \n    yum install -y automake\n    yum install -y gcc\n    yum install -y gcc-c++\n    yum install -y kernel-devel\n    yum install -y libtool\n}\n\ninstall_libevent(){\n    tar -zxvf libevent-2.1.8-stable.tar.gz\n    mv libevent-2.1.8-stable /usr/local/lib/libevent-2_1_8-stable\n    /usr/local/lib/libevent-2_1_8-stable/autogen.sh\n    /usr/local/lib/libevent-2_1_8-stable/configure\n    make -I /usr/local/lib/libevent-2_1_8-stable/\n    make install -I /usr/local/lib/libevent-2_1_8-stable/\n    make clean -I /usr/local/lib/libevent-2_1_8-stable/\n    cp /usr/local/lib/libevent-2.1.so.6 /usr/lib64/\n}\n\ninstall_build_essential\ninstall_libevent\n```\n\n注：对于使用了libevent框架库的源代码，使用gcc编译时要加上-levent选项。\n\n## libevent主要函数\n\n### event_init\n\n创建event_base对象；一个event_base对象可视为一个Reactor实例；\n\n### ev*_new系列函数\n创建相应事件的事件处理器；evsignal_new创建信号事件处理器；evtimer_new创建定时事件处理器；ev*_new系列函数定义在libevent源码的include/event2/event.h文件中。\n\n```c\n#define evsignal_new(b, x, cb, arg)                             \\\n         event_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))\n\n #define evtimer_new(b, cb, arg)        event_new((b), -1, 0, (cb), (arg))\n```\n\n由此可知，ev*_new系列函数统一调用event_new函数，而event_new函数即用来创建通用事件处理器。event_new函数定义如下。\n\n```c\n/*\n    引用方式: #include <event.h>\n    base: 创建的事件处理器从属的Reactor\n    fd: 与该事件处理器关联的句柄; 对I/O事件: 文件描述符 || 对信号事件: 信号值 || 对定时事件: -1\n    events: 指定事件类型; EV_TIMEOUT: 定时事件 || EV_READ: 可读事件 || EV_WRITE: 可写事件 || EV_SIGNAL: 信号事件 || EV_PERSIST: 永久事件 || EV_ET: 边沿触发事件\n    cb: 回调函数\n    arg: 传递给cb函数的参数\n    返回值: event对象(即事件处理器)\n*/\nstruct event * event_new(struct event_base * base, int fd, short events, event_callback_fn cb, void * arg);\n```\n\n事件由多路分发器管理，事件处理器则由事件队列管理。事件队列有多种：event_base中的注册事件队列、活动事件队列、通用定时器队列、evmap中的I/O事件队列、信号事件队列。\n\n### event_add函数\n\n将事件处理器添加到注册事件队列中，并将该事件处理器对应的事件添加到事件多路分发器中。\n\n### event_base_dispatch函数\n\n执行事件循环。\n\n### event*_free系列函数\n\nevent_free释放event对象；event_base_free释放event_base对象。\n","tags":["网络编程"],"categories":["course"]},{"title":"第八章第一节 I/O框架库概述","url":"/course/np-ch8-par1.html","content":"\n## 前言\n\n前面三章详细地介绍了Linux服务器程序必须处理的三类事件：I/O事件、信号、定时事件；在处理这三类事件时网络程序要考虑如下三个问题。\n\n* 统一事件源。\n* 可移植性。不同的操作系统具有不同的I/O复用方式；Solaris采用/dev/poll文件、FreeBSD采用kqueue机制、Linux采用epoll系列系统调用；\n* 并发。在多进程/线程环境下，网络程序需要考虑各执行实体如何协同处理客户连接、信号与定时器；\n\n开源社区提供了诸多优秀的I/O框架库——ACE、ASIO与Libevent。下面介绍相对轻量级的Libevent框架库。\n\n## I/O框架库概述\n\nI/O框架库一库函数的形式，封装了较为底层的系统调用，想应用程序提供一组更便于使用的接口。这些库函数经受住了真实网络环境下的高压测试，以及时间的考验。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 37.png pic37 %}</div>\n\n&nbsp;\n\n### 句柄Handle\n\nI/O框架库处理的对象(I/O事件，信号与定时事件)统一称为事件源。一个事件源绑定一个句柄；例如，在Linux环境下，I/O事件对应的句柄是文件描述符，信号事件对应的句柄是信号值。\n\n### 事件多路分发器\n\nI/O框架库将系统支持的各种I/O复用系统调用封装成统一的接口——事件多路分发器EventDemultiplexer。事件多路分发器的demultiplex方法是等待事件的核心函数，其内部调用的是select、poll、epoll_wait等函数。\n\n此外，事件多路分发器还需要实现register_event与remove_event方法，以便应用程序向事件多路分发器添加事件与删除事件。\n\n### (具体)事件处理器\n\n事件处理器执行事件对应的业务逻辑，它通常包含一个或多个handle_event回调函数。I/O框架库提供的事件处理器只是一个接口，应用程序需要继承该接口来实现具体的事件处理器，即具体事件处理器。\n\n此外，事件处理器还提供get_handle方法，它返回与该事件处理器关联的句柄。\n\n### Reactor\n\nReactor是I/O框架库的核心。它提供如下几个方法。\n\n* handle_events。handle_events方法执行事件循环，重复如下过程：等待事件，然后依次处理所有就绪事件对应的事件处理器；\n* register_handler。register_handler方法调用事件多路分发器的register_event方法来向事件多路分发器中注册一个事件；\n* remove_handler。remove_handler方法调用事件多路分发器的remove_event方法来删除事件多路分发器中的一个事件；\n\n## 小结\n\nI/O框架库的工作时序图如下。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 38.png pic38 %}</div>\n","tags":["网络编程"],"categories":["course"]},{"title":"第七章 定时器","url":"/course/np-ch7.html","content":"\n[第一节 定时器基础](https://KangMing-ux.github.io/course/np-ch7-par1.html)\n\n[第二节 时间轮与时间堆](https://KangMing-ux.github.io/course/np-ch7-par2.html)\n\n","tags":["网络编程"],"categories":["course"]},{"title":"第七章第二节 时间轮与时间堆","url":"/course/np-ch7-par2.html","content":"\n## 时间轮\n\n一层的简单时间轮如下图所示。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 35.png pic35 %}</div>\n\n&nbsp;\n\n实线指针指向轮子上的一个槽，，它以恒定的速度顺时针转动，每隔si时间转动一槽。记时间轮的槽数为N，则指针运转一周的时间为`N·si`。每个槽指向一个定时器链表，每个链表上的定时器的定时时间在模`N·si`下一致。\n\n因此，如果需要添加一个(相对)定时时间为ti的定时器，而此时指针指向槽cs，则该定时器将被插入槽`(cs+(ti/si)) mod N`对应的链表中。\n\n时间轮采用了哈希表的思想，将定时器散列到不同的链表上，使得不同链表上的定时器数量均很少，从而定时器的插入操作更快。\n\n可以看出，si值越小，定时精度越高；N值越大，执行效率越高。\n\n### 分层时间轮\n\n在设计时间轮时，如果遇到不同周期触发的定时事件，只使用一个时间轮的话会导致很多槽对应的定时器链表为空，从而降低时间轮的效率，更好的办法是采用分层时间轮。\n\n分层时间轮是这样一种思想：(1)凡是任务列表中应该被执行的，全部取出来执行；(2)每个时间粒度对应一个时间轮，多个时间轮之间进行级联协作。\n\n**下面举例说明**\n\n任务一：每天2点；任务二：每周二8点；任务三：每月12日10点；各任务的时间粒度分别为天、周、月，因此设计三个时间轮——天轮、周轮、月轮；如下图所示。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 36.png pic36 %}</div>\n\n&nbsp;\n\n初始添加任务时，将任务一添加到天轮、任务二添加到周轮、任务三添加到月轮；\n\n那么，当周轮的指针转到2时，将任务二复制到天轮，天轮接管该任务，当指针转到8时执行(执行后要删除该任务)；当月轮的指针转到12时，将任务三复制到天轮，天轮接管该任务，当指针转到10时执行(执行后要删除该任务)；\n\n## 时间堆\n\n时间堆的思路是：将所有定时器中定时最近的定时器的超时值作为超时时间。一旦超时，必然是超时时间最小的定时器到期，从而处理该定时器的超时事件。\n\n然后，再从剩余的定时器中找出定时最近的定时器，将其超时值作为超时时间；最小堆正是对这种定时方案的最佳工具。\n\n最小堆是一种完全二叉树，因此可使用数组来组织；对于节点i，其左右子节点分别为2i+1、2i+2，其父节点为[(i-1)/2]。\n\n**参考链接**\n\n[分层时间轮](https://blog.csdn.net/xinzhongtianxia/article/details/86221241)\n","tags":["网络编程"],"categories":["course"]},{"title":"第七章第一节 定时器基础","url":"/course/np-ch7-par1.html","content":"\n## 前言\n\n服务器程序通常管理着众多的定时事件，服务器程序需要有效地组织这些事件，使之能在预期的时间点被触发且不影响服务器的主要逻辑。\n\n为此，服务器程序将每个定时事件封装成定时器，并使用某种容器类数据结构(如链表、排序链表、时间轮)将所有的定时器串联起来以实现对定时事件的统一管理。\n\nLinux提供了三种定时方法：(1)socket选项SO_RCVTIMEO与SO_SNDTIMEO；(2)SIGALRM信号；(3)I/O复用系统调用的超时参数。\n\n## SO_RCVTIMEO与SO_SNDTIMEO选项\n\n其中，SO_RCVTIMEO选项仅对recv、recvmsg、accept这些数据接收系统调用有效；SO_SNDTIMEO选项仅对send、sendmsg、connect这些数据发送系统调用有效。\n\n所有这些数据发送/接收系统调用(除connect)超时后的行为是：返回-1并设置errno为EAGAIN或EWOULDBLOCK；connect超时后的行为是：返回-1并设置errno为EINPROGRESS。\n\n## SIGALRM信号\n\n由alarm/setitimer函数设置的实时闹钟一旦超时，将触发SIGALRM信号。从而可以利用SIGALRM信号的信号处理函数来处理定时任务。若要处理多个定时任务，则要在程序中不断触发SIGALRM信号，然后在SIGALRM的信号处理函数中执行到期的任务。\n\n通常，SIGALRM信号按照固定周期T触发，因此，如果在每次SIGALRM信号触发后去处理到期的事件，那么该事件的实际处理时间与理想处理时间(即事件到期后立即处理)会存在误差，而这个误差不会超过T。可见定时周期T也反映了定时处理的精度。\n\n## I/O复用系统调用的超时参数\n\n三组I/O复用系统调用的超时参数也能用于处理定时事件。由于I/O事件的到来也会导致I/O复用系统调用返回，而此时超时时间可能并未到期，因此程序需要不断更新定时参数以反映剩余的时间。\n","tags":["网络编程"],"categories":["course"]},{"title":"第六章 信号","url":"/course/np-ch6.html","content":"\n[第一节 Linux信号概述](https://KangMing-ux.github.io/course/np-ch6-par1.html)\n\n[第二节 信号函数](https://KangMing-ux.github.io/course/np-ch6-par2.html)\n\n[第三节 信号集](https://KangMing-ux.github.io/course/np-ch6-par3.html)\n\n[第四节 网络编程相关信号](https://KangMing-ux.github.io/course/np-ch6-par4.html)\n\n","tags":["网络编程"],"categories":["course"]},{"title":"第六章第四节 网络编程相关信号","url":"/course/np-ch6-par4.html","content":"\n## SIGHUP\n\n当挂起进程的控制终端时，SIGHUP信号将被触发。对于没有控制终端的网络后台程序而言，它们通常利用SIGHUP信号来强制服务器重读配置文件。\n\n以xinetd为例，xinetd程序在接收到SIGHUP信号之后将调用hard_reconfig函数；它循环读取/etc/xinetd.d目录下所有的子配置文件，并检测其变化。\n\n具体来说，若某个正在运行的子服务的配置文件被修改以停止服务，则xinetd主进程将向该子服务进程发送SIGTERM信号来结束该子服务；若某个正在运行的子服务的配置文件被修改以开启服务，则xinetd主进程将开启新的socket并将其绑定到该子服务对应的端口上。\n\n## SIGPIPE\n\n默认情况下，向一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号。由于程序接收到SIGPIPE信号的默认行为是结束进程，因此必须在程序中捕获并处理SIGPIPE信号，即使只是忽略它。\n\n首先，程序应该禁止写操作触发SIGPIPE信号(send函数的flag设置为MSG_NOSIGNAL)，然后再使用send函数反馈的errno的值是否为EPIPE来判断管道或者socket连接的读端是否已经关闭。\n\n此外，程序还可以通过I/O复用系统调用来检测管道或socket连接的读端是否已经关闭。如使用poll系统调用监听时，当管道的读端关闭时，写端文件描述符上的POLLHUP事件将被触发；当socket连接被对方关闭时，socket上的POLLRDHUP事件将被触发。\n\n## SIGURG\n\n在Linux环境下，内核通知应用程序带外数据到达主要有两种方法：(1)使用I/O复用技术，select系统调用在接收带外数据时将返回，并向应用程序报告socket上的异常事件；(2)使用SIGURG信号。\n","tags":["网络编程"],"categories":["course"]},{"title":"第六章第三节 信号集","url":"/course/np-ch6-par3.html","content":"\n## 信号集函数\n\n__sigset_t类型定义如下。\n\n```c\n/*\n    引用方式: #include <bits/sigset.h>\n*/\ntypedef struct{\n    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];\n}__sigset_t;\n```\n\n__sigset_t实际是一个长整型数组，其中每个元素的每一位表示一个信号。Linux提供了一组函数来设置、修改、删除与查询信号集。\n\n```c\n/*\n    引用方式: #include <signal.h>\n    sigemptyset: 清空信号集\n    sigfillset: 在信号集中设置所有信号\n    sigaddset: 将信号signo添加到信号集中\n    sigdelset: 将信号signo从信号集中删除\n    sigismember: 测试signo是否在信号集中\n*/\nint sigemptyset(__sigset_t * set);\n\nint sigfillset(__sigset_t * set);\n\nint sigaddset(__sigset_t * set, int signo);\n\nint sigdelset(__sigset_t * set, int signo);\n\nint sigismember(const __sigset_t * set, int signo);\n```\n\n## 进程信号掩码\n\n若要单独设置进程的信号掩码，使用sigprocmask函数(也能查看进程的信号掩码)；\n\n```c\n/*\n    引用方式: #include <signal.h>\n    how: 指定设置进程信号掩码的方式(详见下表)\n    set: 指定新的信号掩码\n    oset: 存放进程原有信号掩码\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint sigprocmask(int how, const __sigset_t * set, __sigset_t * oset);\n```\n\n<div style=\"width:80%;margin:auto\">{% asset_img 34.png pic34 %}</div>\n\n## 被挂起的信号\n\n若其他进程向本进程发送一个被本进程屏蔽的信号，则操作系统将该信号设置为本进程的一个被挂起的信号。当本进程取消对被挂起信号的屏蔽后，它会立即被本进程接收，使用sigpending函数获得本进程当前被挂起的信号集。\n\n```c\n/*\n    引用方式: #include <signal.h>\n    set: 存放被挂起的信号集(即使某个信号向进程发送了多次，sigpending也只能反应一次, 相应的信号处理函数也只会触发一次)\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint sigpending(__sigset_t * set);\n```\n\n注：编写网络程序时，不能设想新创建的进程/线程具有与父进程完全相同的信号特征；如fork调用产生的子进程将继承父进程的信号掩码，但子进程的挂起信号集为空！\n\n## 统一事件源\n\n信号作为一种异步事件，使得信号处理函数与网络程序的主循环是两条不同的执行路线。为避免信号在信号处理函数执行过程中被屏蔽太久，一种典型的解决方案是：将信号的主要处理逻辑放到网络程序的主循环中，被触发的信号处理函数只是简单地通知主循环程序接收的信号；主循环程序再根据接收到的信号值执行信号对应的逻辑代码。\n\n信号处理函数通常使用管道将信号通知给主循环，主循环使用I/O复用系统调用进行监听管道读端文件的可读事件。\n\n由于这种处理方式使得信号事件能够和其他I/O事件一样被处理，因此称为统一事件源。\n","tags":["网络编程"],"categories":["course"]},{"title":"第六章第二节 信号函数","url":"/course/np-ch6-par2.html","content":"\n## signal系统调用\n\n使用signal函数为一个信号设置处理函数。\n\n```c\n/*\n    引用方式: #include <signal.h>\n    sig: 指定要捕获的信号类型\n    _handler: 指定信号sig的处理函数\n    返回_sighandler_t类型的函数指针或sig信号对应的默认处理函数指针SIG_DEF: 成功 || 返回SIG_ERR并设置errno: 失败\n*/\n_sighandler_t signal(int sig, _sighandler_t _handler);\n```\n\n## sigaction系统调用\n\n设置信号处理函数的更健壮的接口是sigaction系统调用。\n\n```c\n/*\n    引用方式: #include <signal.h>\n    sig: 指定要捕获的信号类型\n    act: 指定新的信号处理方式\n    oact: 存入之前信号的处理方式\n*/\nint sigaction(int sig, const struct sigaction * act, struct sigaction * oact);\n```\n\nsigaction结构体描述信号处理的细节，其定义如下。\n\n```c\nstruct sigaction{\n    union{\n        __sighandler_t sa_handler;\n        void (*sa_sigaction) (int, siginfo_t *, void *);\n    }__sigaction_handler;\n    __sigset_t sa_mask;\n    int sa_flags;\n    void (*sa_restorer) (void);\n};\n```\n\n* sa_handler。指定信号处理函数；\n* sa_mask。信号集类型参数(详见下一节)；设置进程的信号掩码(在进程原有信号掩码的基础上增加)，以指定哪些信号不能发送给本进程；\n* sa_flags。设置程序收到信号时的行为；可选值如下表所示。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 33.png pic33 %}</div>\n","tags":["网络编程"],"categories":["course"]},{"title":"第六章第一节 Linux信号概述","url":"/course/np-ch6-par1.html","content":"\n信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。Linux信号可在如下情形产生。\n\n* 对于前台进程，用户可通过输入特殊的终端字符来向其发送信号；\n* 系统异常(浮点异常，非法内存段访问等)；\n* 系统状态变化(如alarm定时器到期将引起SIGALRM信号)；\n* 运行kill命令或调用kill函数；\n\n## 发送信号\n\n在Linux系统中，一个进程向其他进程发送信号的API为kill函数。\n\n```c\n/*\n    引用方式: #include <signal.h>\n    返回0: 成功 || 返回-1并设置errno: 失败; EINVAL: 无效的信号 || EPERM: 该进程没有权限发信号给任何一个目标进程 || ESRCH: 目标进程或进程组不存在\n*/\nint kill(pid_t pid, int sig);\n```\n\n目标进程由pid参数指定，它可能的取值及其含义如下表。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 29.png pic29 %}</div>\n\n&nbsp;\n\nLinux定义的信号值都大于0，如果sig取值为0，则kill函数不发送任何信号，但将sig设置为0可以用来检测目标进程或进程组是否存在。不过这种检测方式不可靠：(1)由于进程PID的回绕，可能导致被检测的PID不是我们期望的进程的PID；(2)这种检测方法不是原子操作。\n\n## 信号处理方式\n\n目标进程需要定义相应的信号处理函数以便在接收到信号后作出相应的处理。信号处理函数的原型如下。\n\n```c\n/*\n    引用方式: #include <signal.h>\n    int参数: 指定信号类型\n*/\ntypedef void (* __sighandle_t)(int);\n```\n\n信号处理函数必须可重入，因此信号处理函数严禁调用不安全的函数。\n\nbits/signum.h还定义了信号的两种其他处理方式：SIG_IGN(忽略目标信号)与SIG_DFL(信号的默认处理方式)。信号的默认处理方式有几种：Term(结束进程)、Ign(忽略信号)、Core(结束进程并生成核心转储文件)、Stop(暂停进程)与Cont(继续进程)。\n\n## Linux信号\n\nLinux的可用信号都定义在bits/signum.h中，其中包括标准信号与POSIX实时信号。Linux标准信号如下表。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 30.png pic30 %}</div>\n\n<div style=\"width:80%;margin:auto\">{% asset_img 31.png pic31 %}</div>\n\n<div style=\"width:80%;margin:auto\">{% asset_img 32.png pic32 %}</div>\n\n&nbsp;\n\n**重点关注**：SIGHUP(控制终端挂起)、SIGPIPE(向读端被关闭的管道或socket连接中写数据)、SIGURG(socket连接上接收到紧急数据)、SIGALRM(由alarm、settimer设置的实时闹钟超时引起)、SIGCHLD(子进程状态发生变化，退出或暂停)。\n\n## 关于中断系统调用\n\n若程序在执行处于阻塞状态的系统调用时接收到信号，并且我们为信号设置了信号处理函数，则默认情况下系统调用将被中断，并将errno设置为EINTR。程序可以使用sigaction函数为信号设置SA_RESTART标志自动重启被中断的系统调用。\n\n对于默认行为是暂停进程的信号(SIGSTOP、SIGTTIN)，若程序未设置相应的信号处理函数，这些信号仍然可以中断一些系统调用(connect、epoll_wait)。这是Linux所特有的。\n","tags":["网络编程"],"categories":["course"]},{"title":"第五章 I/O复用","url":"/course/np-ch5.html","content":"\n[第一节 select系统调用](https://KangMing-ux.github.io/course/np-ch5-par1.html)\n\n[第二节 poll系统调用](https://KangMing-ux.github.io/course/np-ch5-par2.html)\n\n[第三节 epoll系列系统调用](https://KangMing-ux.github.io/course/np-ch5-par3.html)\n\n[第四节 三组I/O复用函数的比较](https://KangMing-ux.github.io/course/np-ch5-par4.html)\n\n[第五节 I/O复用高级应用](https://KangMing-ux.github.io/course/np-ch5-par5.html)\n\n[第六节 超级服务xinetd](https://KangMing-ux.github.io/course/np-ch5-par6.html)\n\n","tags":["网络编程"],"categories":["course"]},{"title":"第五章第六节 超级服务xinetd","url":"/course/np-ch5-par6.html","content":"\nLinux因特网服务inetd是超级服务，它同时管理多个子服务，即监听多个端口。现在的Linux系统使用其升级版本xinetd，相对于inetd增加了一些控制选项，并提高了安全性。\n\n## xinetd配置文件\n\n主配置文件：/etc/xinetd.conf，各服务的子配置文件：/etc/xinetd.d/目录的相应子目录下；主配置文件包含通用选项、这些选项被所有的子配置文件继承。不过子配置文件可以覆盖这些选项，如下是telnet服务的配置文件内容示例。\n\n```bash\nservice telnet\n{\n        disable         = no\n        user            = root\n        id              = daytime-stream\n        wait            = no\n        socket_type     = stream\n        server          = /usr/sbin/in.telnetd\n        log_on_failure  += USERID\n}\n```\n\n其中，wait指定服务是采用单线程(yes)还是多线程(no)，单线程表示xinetd只接收第一次连接，此后将由子服务进程来接收新连接；多线程表示xinetd一直负责接收连接，而子服务进程仅处理连接socket上的数据读写。\n\nlog_on_failure指定当服务不能启动时输出日志的参数。\n\n## xinetd工作流程\n\n以上述xinetd配置为例，xinetd的工作流程如下所示。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 28.png pic28 %}</div>\n\n&nbsp;\n","tags":["网络编程"],"categories":["course"]},{"title":"第五章第五节 I/O复用高级应用","url":"/course/np-ch5-par5.html","content":"\n## 非阻塞connect\n\nconnect出错时会出现的一种errno值：EINPROGRESS；这种错误发生在对非阻塞的socket调用connect，而连接又没有立即建立时。\n\n此时，网络程序可以调用select、poll函数来监听这个连接失败的socket上的可写事件。当I/O复用函数返回后，再利用getsockopt来读取并清除该socket的错误；若错误的值为0，表示连接成功；否则，连接失败。\n\n## 聊天室\n\n一些网络服务如ssh需要同时处理网络连接与用户输入，这可以使用I/O复用来实现。\n\n对于聊天室服务，由两部分组成：客户端与服务器；客户端负责：(1)从标准输入终端读入用户数据，并将用户数据发送到服务器；(2)将服务器发送过来的数据打印到标准输出终端；服务器则负责接收用户数据，并将该数据发送给除数据发送者之外的所有在线客户端。\n\n### 客户端\n\n客户端使用poll同时监听用户输入与网络连接，并利用splice函数将用户输入内容直接定向到网络连接然后将其发送(数据零拷贝，提高程序执行效率)。\n\n### 服务器\n\n服务器使用poll同时管理监听socket与连接socket。\n\n`计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决`\n\n## 同时处理TCP与UDP服务\n\n创建一个流socket(TCP服务)与数据包socket(UDP服务)，均绑定到某一端口。使用I/O复用技术，就能同时监听该端口的TCP服务与UDP服务。\n","tags":["网络编程"],"categories":["course"]},{"title":"第五章第四节 三组I/O复用函数的比较","url":"/course/np-ch5-par4.html","content":"\n## 事件集\n\nselect的事件集由3个fd_set数组指定；fd_set数组在调用select时传入，select调用返回后被内核修改。\n\npoll的事件集由pollfd结构体数组指定，它绑定了文件描述符与事件；pollfd结构体的event成员传入网络程序关注的事件，poll调用返回后修改pollfd结构体的revent成员。\n\nepoll的事件通过epoll_ctl函数进行添加、修改与删除，epoll_wait调用返回的事件存入event数组。\n\n## 最大支持文件描述符数\n\npoll与epoll_wait函数最多可监听65535个文件描述符；而select最多可监听1024个文件描述符。\n\n## 工作模式\n\nselect与poll只能工作在相对低效的LT模式；而epoll则可以工作在ET高效模式，且epoll还支持EPOLLONESHOT事件，该事件可进一步减少可读/可写/异常事件被触发的次数。\n\n## 具体实现\n\nselect与poll均采用轮询的实现方式，每次调用都要扫描整个注册文件描述符集合；\n\n而epoll_wait采用回调的方式，内核检测到就绪的文件描述符后触发回调函数，回调函数将该文件描述符上对应事件插入内核就绪事件队列，内核最后在合适的时机将该就绪事件队列中的内容拷贝到用户空间。\n\n然而，在活动连接较多时，epoll_wait将会频繁触发回调函数，此时epoll_wait的效率不一定比select/poll高。可见epoll_wait适用于连接数量多，但活动连接少的情形。\n\n## 小结\n\n这3组I/O复用系统调用的区别如下表总结。\n\n<div style=\"width:72%;margin:auto\">{% asset_img 27.png pic27 %}</div>\n","tags":["网络编程"],"categories":["course"]},{"title":"第五章第三节 epoll系列系统调用","url":"/course/np-ch5-par3.html","content":"\n## 内核事件表\n\nepoll是Linux特有的I/O复用函数，epoll使用一组函数来完成任务。epoll将用户关心的文件描述符上的事件放在内核的事件表中，此时epoll需要使用一个额外的文件描述符来唯一标识内核中的这个事件表。该文件描述符由epoll_create函数来创建。\n\n```c\n/*\n    引用方式: #include <sys/epoll.h>\n    size: 告知内核事件表需要多大\n    返回文件描述符: 成功 || 返回-1并设置errno: 失败\n*/\nint epoll_create(int size);\n```\n\n此函数返回的文件描述符用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表。\n\n下面的函数来操作epoll的内核事件表。\n\n```c\n/*\n    引用方式: #include <sys/epoll.h>\n    op: 指定操作类型; EPOLL_CTL_ADD(向事件表中注册fd上的事件) || EPOLL_CTL_MOD(修改fd上的注册事件) || EPOLL_CTL_DEL(删除fd上的注册事件)\n    fd: 要操作的文件描述符\n    event: 指定事件\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event * event);\n```\n\n其中，epoll_event结构体定义如下。\n\n```c\nstruct epoll_event{\n  uint32_t events;\n  epoll_data_t data;\n};\n```\n\n* events成员指定事件类型；epoll支持的事件类型与poll基本相同，表示epoll事件类型的宏是在poll对应的宏前面加\"E\"，如epoll的可读事件类型的宏为EPOLLIN。此外，epoll有两个额外事件类型：EPOLLET与EPOLLONESHOT(它们对epoll的高效运作非常关键，将在之后详细介绍)。\n* data存储用户数据；epoll_data_t结构体的定义如下。\n\n```c\ntypedef union epoll_data{\n  void *ptr;\n  int fd;\n  uint32_t u32;\n  uint64_t u64;\n} epoll_data_t;\n```\n\nepoll_data_t结构体是一个联合体。如果使用fd，则指定事件所从属的文件描述符；如果使用ptr，则指定与fd有关的用户数据。若要同时使用ptr与fd，可考虑在ptr指定的用户数据内包含fd。\n\n## epoll_wait函数\n\nepoll_wait函数在一段超时时间内等待一组文件描述符上的事件。\n\n```c\n/*\n    引用方式: #include <sys/epoll.h>\n    events: 用于存放内核事件表中的就绪事件\n    maxevents: 指定监听事件的数目最大值\n    timeout: 以毫秒为单位的超时值, timeout=-1: epoll_wait调用一直阻塞直到某个事件发生 || timeout=0: epoll_wait调用立即返回\n    返回就绪文件描述符总数: 成功 || 返回-1并设置errno: 失败\n*/\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n```\n\n由于epoll在内核中维护一个事件表，每次epoll_wait调用都直接从内核事件表中取得用户注册的事件，而无需反复从用户空间读入这些事件；同时epoll_wait函数仅将事件就绪的文件描述符存入events数组中，从而网络程序索引就绪的文件描述符的时间复杂度为O(1)。\n\n## LT与ET模式\n\nepoll对文件描述符的操作有两种模式：LT(电平触发)模式与ET(边沿触发)模式。\n\nLT模式是默认的工作模式，LT模式下的epoll相当于一个效率较高的poll。\n\n注：很多时候网络程序调用完select/poll/epoll_wait都会处理就绪的文件描述符，这时使用select/poll的网络程序需要遍历所有的文件描述符再进行相应的判断操作(对于select：使用FD_ISSET函数；对于poll，将`(fds+i)->revents`与POLLIN按位与)，而epoll_wait可以直接遍历就绪的文件描述符。\n\n网络程序向epoll内核事件表注册一个文件描述符上的EPOLLET事件后，epoll将以ET模式来操作该文件描述符。ET模式是epoll的高效工作模式。\n\n### LT模式\n\n对于采用LT模式的文件描述符，当epoll_wait函数检测到该文件描述符上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件；当应用程序下次调用epoll_wait时，epoll_wait还会再次向应用程序通知此事件，直到此事件被处理。\n\n### ET模式\n\nET模式只支持非阻塞的socket文件。\n\n注：如果文件描述符是阻塞的，那么读或写操作将会因为没有后续事件而一直处于阻塞状态\n\n当epoll_wait函数检测到该文件描述符上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件！\n\n注：在这个套接字中新的事件到来之前，网络程序都无法再从epoll_wait中获取该事件。因此这次必须处理完该事件。\n\nET模式在很多程度上降低了一个epoll事件被重复触发的次数，因此效率要高于LT模式。\n\n## EPOLLONESHOT事件\n\n若希望一个socket连接在任一时刻最多被一个线程处理，可向socket文件描述符注册EPOLLONESHOT事件。\n\n对于注册了EPOLLONESHOT事件的socket文件描述符，操作系统最多触发该文件描述符上注册的一个可读/可写/异常事件，且只触发一次，除非网络程序使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件。因此，一个线程处理完注册了EPOLLONESHOT事件的socket文件描述符后，需要重置该文件描述符上注册的EPOLLONESHOT事件。\n","tags":["网络编程"],"categories":["course"]},{"title":"第五章第二节 poll系统调用","url":"/course/np-ch5-par2.html","content":"\npoll系统调用与select系统调用类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。\n\n```c\n/*\n    引用方式: #include <poll.h>\n    fds: pollfd结构体数组, 指定程序感兴趣的所有文件描述符上发生的可读/可写/异常事件\n    nfds: 指定fds有效长度\n    timeout: 以毫秒为单位的超时值; timeout=-1: poll调用一直阻塞直到某个事件发生 || timeout=0: poll调用立即返回\n    返回就绪文件描述符总数: 成功 || 返回-1并设置errno: 失败\n*/\nint poll(struct pollfd * fds, nfds_t nfds, int timeout);\n```\n\n其中，pollfd结构体的定义如下。\n\n```c\nstruct pollfd{\n    int fd;\n    short int events;\n    short int revents;\n};\n```\n\n其中，fd指定文件描述符，events成员告知poll需要监听fd上哪些事件，它是一系列事件的按位或。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 25.png pic25 %}</div>\n\n<div style=\"width:80%;margin:auto\">{% asset_img 26.png pic26 %}</div>\n\n&nbsp;\n\nrevents成员由内核修改，以通知应用程序fd上实际发生了哪些事件。\n\n自Linux2.6.17内核之后，GNU为poll系统调用增加了一个POLLRDHUP事件，它在socket接收到对方关闭连接的请求后触发，从而区分socket上接收到的数据是有效数据还是对方关闭连接的请求。使用POLLRDHUP事件需要在代码最开始处`#define _GNU_SOURCE`。\n","tags":["网络编程"],"categories":["course"]},{"title":"第五章第一节 select系统调用","url":"/course/np-ch5-par1.html","content":"\n## 前言\n\nI/O复用使得程序同时监听多个文件描述符。通常，网络程序在下列情形下需要使用I/O复用技术。\n\n* 客户端要同时处理多个socket；\n* 客户端要同时处理用户输入与网络连接；\n* TCP服务器要同时处理监听socket与连接socket；\n* 服务器要同时处理TCP请求与UDP请求；\n* 服务器要同时监听多个端口，或处理多个服务；\n\nI/O复用虽然同时监听多个文件描述符，但它本身是阻塞的。\n\n## select系统调用\n\n在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写与异常等事件。select系统调用原型如下。\n\n```c\n/*\n    引用方式: #include <sys/select.h>\n    nfds: 被监听的文件描述符总数\n    rfds: 调用select时指定网络程序关注可读事件的文件描述符; select返回时内核将其修改以通知网络程序可读事件就绪的文件描述符\n    wfds: 调用select时指定网络程序关注可写事件的文件描述符; select返回时内核将其修改以通知网络程序可写事件就绪的文件描述符\n    efds: 调用select时指定网络程序关注异常事件的文件描述符; select返回时内核将其修改以通知网络程序异常事件就绪的文件描述符\n    timeout: 调用select函数前设置超时时间 => select返回后由内核设置select函数的超时时间\n    返回就绪文件描述符总数: 成功 || 返回-1并设置errno: 失败\n*/\nint select(int nfds, fd_set * rfds, fd_set * wfds, fd_set * efds, struct timeval * timeout);\n```\n\n其中，fd_set结构体定义如下。\n\n```c\ntypedef struct{\n    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];\n} fd_set;\n```\n\nfd_set是一个__fd_mask数组，数组中每个元素的每一位标记一个文件描述符，因此select能同时处理的文件描述符的总量不能超过1024。可使用如下宏来访问fd_set结构体的位。\n\n```c\n/*\n    #include <sys/select.h>\n    FD_ZERO: 清除fdset所有位\n    FD_SET: 设置fdset的位fd\n    FD_CLR: 清除fdset的位fd\n    FD_ISSET: 测试fdset的fd位是否被设置\n*/\nFD_ZERO(fd_set * fdset);\n\nFD_SET(int fd, fd_set * fdset);\n\nFD_CLR(int fd, fd_set * fdset);\n\nint FD_ISSET(int fd, fd_set * fdset);\n```\n\n此外，timeval结构体定义如下。\n\n```c\nstruct timeval{\n    __time_t tv_sec;/* 秒数 */\n    __suseconds_t tv_usec;/* 微秒数 */\n};\n```\n\n注意：在select调用失败时，timeout的值是不确定的。\n\nselect给我们提供了一个微妙级的定时方式，若向timeout变量的tv_sec成员与tv_usec成员传递0，则select将立即返回。若timeout设置为NULL，则select将一直阻塞直到某个文件描述符就绪。\n\n若程序在select等待期间接收到信号，则select立即返回-1，并设置errno为EINTR。\n\n由于内核修改了3个fd_set，因此网络程序下次调用select之前需要重置这3个fd_set。\n\n### 文件描述符就绪条件\n\n网络编程中，如下情况socket可读。\n\n* socket内核接收缓冲区中的字节数大于等于其低水位标记SO_RCVLOWAT，此时程序可无阻塞地读这个socket，读操作返回的字节数大于0；\n* socket通信的对方关闭连接，对socket的读操作返回0；\n* 监听socket上有新的连接请求；\n* socket上有未处理的错误，调用getsockopt来读取错误；\n\n如下情况socket可写。\n\n* socket内核发送缓冲区中的空闲字节数大于等于其低水位标记SO_SNDLOWAT，此时程序可无阻塞地写这个socket，写操作返回的字节数大于0；\n* socket写操作被关闭(对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号)；\n* socket使用非阻塞connect连接成功或失败(超时)后；\n* socket上有未处理的错误，调用getsockopt来清除错误；\n\nsocket能处理的异常情况只有一种：socket上接收了带外数据。\n\n### 处理带外数据\n\nsocket接收到普通数据与带外数据都将使select返回，但socket处于不同的就绪状态：前者处于可读状态(FD_ISSET(fd, rfds)为1)、后者处于异常状态(FD_ISSET(fd, efds)为1)。\n","tags":["网络编程"],"categories":["course"]},{"title":"第四章 高性能服务器程序框架","url":"/course/np-ch4.html","content":"\n[第一节 服务器模型](https://KangMing-ux.github.io/course/np-ch4-par1.html)\n\n[第二节 服务器编程框架与I/O模型](https://KangMing-ux.github.io/course/np-ch4-par2.html)\n\n[第三节 高效事件处理模式](https://KangMing-ux.github.io/course/np-ch4-par3.html)\n\n[第四节 高效并发模式](https://KangMing-ux.github.io/course/np-ch4-par4.html)\n\n[第五节 有限状态机与其他建议](https://KangMing-ux.github.io/course/np-ch4-par5.html)\n\n","tags":["网络编程"],"categories":["course"]},{"title":"第四章第五节 有限状态机与其他建议","url":"/course/np-ch4-par5.html","content":"\n## 有限状态机\n\n有限状态机是逻辑单元内部的一种高效编程方法。\n\n以\"HTTP请求的读取与分析\"来说明有限状态机的使用。\n\n### 背景\n\n很多网络协议的头部都是固定格式再加上位于末尾的选项字段，通过头部中的长度字段就可以完全地解析头部数据；但是，HTTP协议的头部长度变化非常大，并且头部中没有长度字段，这时就需要借助有限状态机来解析HTTP报文。解析程序使用两个有限状态机(主状态机与从属状态机)来完成HTTP报文的解析工作。\n\n### 从属状态机\n\n从属状态机的工作是解析一行的内容，从属状态机的状态转移图如下所示。\n\n<div style=\"width:48%;margin:auto\">{% asset_img 23.png pic23 %}</div>\n\n&nbsp;\n\n### 主状态机\n\n主状态机调用从属状态机与两个解析器来解析HTTP报文，主状态机的状态转移图如下所示。\n\n<div style=\"width:36%;margin:auto\">{% asset_img 24.png pic24 %}</div>\n\n&nbsp;\n\n## 提高服务器性能的几条建议\n\n### 池\n\n以空间换时间，“浪费”服务器的硬件资源以换取其运行效率。池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。服务器进入运行状态后，如果它需要相应的资源，就直接从池中获取，无需动态分配。\n\n常见的池有内存池、进程池、线程池、连接池。其中，连接池用于服务器或服务器机群的内部永久连接。比如，服务器预先与数据库程序建立的连接放到连接池中，当服务器的逻辑单元需要访问数据库时，它可以直接从连接池中取得一个连接的实体来使用。完成数据库的访问之后，再归还该连接。\n\n### 数据复制\n\n高性能服务器要避免不必要的数据复制，尤其当数据复制发生在用户空间与内核空间之间时。比如内核可直接处理从socket或文件读入的数据时，则应用程序无需将这些数据从内核缓冲区复制到应用程序缓冲区。\n\n此外，用户空间之间的数据复制也可以避免：使用共享内存而避免使用管道/消息队列。\n\n### 上下文切换与锁\n\n进程/线程切换要耗费大量CPU时间，最好不要为每个客户连接都创建一个工作线程；高效的半同步/半异步工作模式要比半同步/半异步工作模式的效率高。多线程服务器的一个优点是不同线程可运行在不同CPU上，当线程数目小于CPU数目时，就不存在上下文切换的问题。\n\n服务器如果有更好的选择，应避免使用锁。\n","tags":["网络编程"],"categories":["course"]},{"title":"第四章第四节 高效并发模式","url":"/course/np-ch4-par4.html","content":"\n并发模式是指I/O处理单元与多个逻辑单元之间协调完成任务的方法。\n\n## 半同步/半异步模式\n\n在并发模式中，\"同步\"指程序完全按照代码序列的顺序执行，\"异步\"指程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。\n\n在半同步/半异步模式中，同步线程用于处理客户逻辑，异步线程用于处理I/O事件。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中；请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。\n\n半同步/半异步工作流程图如下。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 19.png pic19 %}</div>\n\n&nbsp;\n\n综合考虑两种事件模式与多种I/O模型，半同步/半异步模式就存在多种变体。\n\n### 半同步/半反应堆\n\n半同步/半反应堆模式图如下，采用Reactor模式。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 20.png pic20 %}</div>\n\n&nbsp;\n\n只有一个异步线程，即主线程；主线程负责监听所有socket上的事件，若监听socket上有可读事件发生(即新的连接请求到来)，主线程将其接受从而得到新的连接socket，再向epoll内核事件表中注册该socket上的读写事件。\n\n若连接socket上有读写事件发生(即有新的客户请求到来或有数据发送到客户端)，主线程就将该连接socket插入请求队列；所有工作线程都睡眠在请求队列上，当有任务到来时，它们通过竞争获得任务的接管权；这种竞争机制使得只有空闲的工作线程才有机会来处理新任务。\n\n半同步/半反应堆具有如下缺点：\n\n* 由于主线程与工作线程共享请求队列，因此在主线程向请求队列中添加任务或工作线程从请求队列中取出任务时都需要对请求队列进行加锁保护，从而浪费CPU时间；\n* 每个工作线程在同一时间只能处理一个客户请求。在客户数量很多时将使得服务器的响应速度变慢；而增加工作线程导致的线程切换又会耗费大量的CPU时间；\n\n### 高效的半同步/半异步模式\n\n为避免半同步/半反应堆的缺点，如下的高效半同步/半异步模式让每个工作线程都能同时处理多个客户连接。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 21.png pic21 %}</div>\n\n&nbsp;\n\n其中，主线程只管监听socket，而连接socket的工作由工作线程来完成。当有新的连接到来时，主线程就将其接受并将新返回的连接socket分配给某个工作线程，此后该socket上的所有I/O操作均由工作线程来完成，直到客户端关闭连接。\n\n主线程向工作线程分配socket最简单的方式为主线程向它与工作线程之间的管道中写数据；工作线程检测到管道中有数据可读时，就分析是否为一个新的客户连接请求，如果是就将此新的socket上的读写事件注册到自己的epoll内核事件表中。\n\n因此，这种高效的半同步/半异步模式中，所有的线程都工作在异步模式。\n\n## 领导者/追随者模式\n\n领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分配并处理事件的一种模式。\n\n在任意时刻，服务器都只有一个领导者线程，它负责监听I/O事件；其他线程均为追随者，它们忙于处理I/O事件或休眠在线程池中等待成为新的领导者。\n\n当前领导者检测到I/O事件后从线程池中推选出新的领导者线程，然后它去处理I/O事件；以此来实现并发。\n\n要实现领导者/追随者模式需要如下组件：句柄集(HandleSet)，线程集(ThreadSet)，事件处理器(EventHandle)以及具体的事件处理器(ConcreteEventHandle)。\n\n### 句柄集\n\n句柄(Handle)表示I/O资源，句柄集管理众多句柄，它使用wait_for_event方法来监听这些句柄上的I/O事件，并将其中的就绪事件通知给领导者线程。领导者调用绑定到Handle上的事件处理器来处理事件。Handle与事件处理器的绑定是通过调用句柄集中的register_handle方法实现的。\n\n### 线程集\n\n线程集是所有工作线程的管理者。它负责各线程之间的同步，以及新领导者线程的推选。线程集中的线程必处于如下三种状态之一：\n\n* Leader：领导者线程，负责等待句柄集上的I/O事件；\n* Processing：线程正在处理事件；领导者检测到I/O事件后，可以转移到Processing状态来处理该事件，并调用promote_new_leader方法推选新的领导者，也可以指定其他追随者来处理事件，此时领导者地位不变；处于processing状态的线程处理完事件之后，若当前线程集中没有领导者，该线程将成为领导者，否则成为追随者；\n* Follower：线程当前处于追随者身份，通过调用线程集的join方法等待成为新的领导者，也可能被当前的领导者指定来处理新的任务；\n\n注意到领导者线程推选出新的领导者和追随者等待成为新领导者这两个操作都将修改线程集，因此线程集提供一个成员Synchronizer来同步这两个操作，以避免竞态条件。\n\n### 事件处理器与具体的事件处理器\n\n事件处理器通常包含一个或多个回调函数handle_event，这些回调函数用于处理事件对应的业务逻辑。事件处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器中的回调函数。具体的事件处理器是事件处理器的派生类，它需要重新实现基类的handle_event方法，以处理特定的任务。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 22.png pic22 %}</div>\n\n&nbsp;\n\n领导者线程自己监听I/O事件并处理客户请求，因此领导者/追随者模式不需要在线程之间传递任何额外的数据，也无需像半同步/半反应堆模式那样在线程之间同步对请求队列的访问。\n\n但是领导者/追随者模式只支持一个事件源集合，无法让每个工作线程独立地管理多个客户连接。","tags":["网络编程"],"categories":["course"]},{"title":"第四章第三节 高效事件处理模式","url":"/course/np-ch4-par3.html","content":"\n## Reactor模式\n\n主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，检测到事件后立即将该事件通知工作线程(逻辑单元)；读写数据、接受新的连接、处理客户请求均在工作线程(逻辑单元)中完成。\n\n以epoll_wait为例，说明使用同步I/O模型实现的Reactor模式。\n\n* 主线程向epoll内核事件表中注册socket读就绪事件；\n* 主线程调用epoll_wait等待socket上有数据可读；\n* 当socket上有数据可读时，epoll_wait通知主线程。主线程将socket可读事件放入请求队列；\n* 睡眠在请求队列上的某个工作线程被唤醒，它从socket中读取数据，并处理客户请求，再向epoll内核事件表中注册该socket上的写就绪事件；\n* 主线程调用epoll_wait等待socket可写；\n* 当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列；\n* 睡眠在请求队列上的某个工作线程被唤醒，它往socket中写入服务器处理客户请求的结果；\n\nReactor模式工作流程图如下。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n## Proactor模式\n\nProactor模式将所有I/O操作都交给主线程与内核来处理，工作线程仅仅负责业务逻辑。\n\n以aio_read与aio_write为例，说明使用异步I/O模型实现的Proactor模式。\n\n* 主线程继续处理其他逻辑；\n* 当socket中的数据被读入用户缓冲区时，内核将向应用程序发送一个信号，以通知应用程序数据已经可用；\n* (主线程运行)应用程序预先定义好的信号处理函数来选择一个工作线程处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket写完成事件，并告知内核写缓冲区的位置，以及写操作完成时如何通知应用程序；\n* 主线程继续处理其他逻辑；\n* 当用户缓冲区中的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕；\n* (主线程运行)应用程序预先定义好的信号处理函数来选择一个工作线程完成善后处理；\n\nProactor模式工作流程图如下。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n## 模拟Proactor模式\n\n主线程执行数据读写操作，读写完成后，主线程向工作线程通知这一完成事件。从工作线程的角度看，他们直接获得了数据读写的结果，只需要对读写的结果进行逻辑处理。\n\n以epoll_wait为例，使用同步I/O模型模拟Proactor模式。\n\n* 主线程向epoll事件表中注册socket读就绪事件；\n* 主线程调用epoll_wait等待socket上有数据可读；\n* 当socket上有数据可读时，epoll_wait通知主线程；主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列；\n* 睡眠在请求队列上的某个工作线程被唤醒，它从socket中读取数据，并处理客户请求，再向epoll内核事件表中注册该socket上的写就绪事件；\n* 主线程调用epoll_wait等待socket可写；\n* 当socket可写时，epoll_wait通知主线程；主线程向socket写入服务器处理客户请求的结果；\n\n使用同步I/O模型模拟Proactor模式的流程图如下。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 18.png pic18 %}</div>","tags":["网络编程"],"categories":["course"]},{"title":"第四章第二节 服务器编程框架与I/O模型","url":"/course/np-ch4-par2.html","content":"\n## 服务器编程框架\n\n服务器的基本框架如下图。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n各个模块的功能描述如下表。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n<div style=\"width:80%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\n请求队列通常被实现为池的一部分。对于服务器机群而言，请求队列是各台服务器之间预先建立的、静态的、永久的TCP连接。这种TCP连接能够提高服务器之间交换数据的效率，因为它避免了动态建立TCP连接而导致的额外系统开销。\n\n## I/O模型\n\n(非)阻塞的文件描述符为(非)阻塞I/O。socket的基础API中，可能被阻塞的系统调用包括accept、send、recv、connect。\n\n针对非阻塞I/O执行的系统调用总是立即返回，而不论事件是否已经发生。若事件没有立即发生，系统调用返回-1，这与出错情况一样。因此，需要根据errno来区分这两种情况。对accept、send、recv而言，事件未发生时errno通常被设置为EAGAIN或EWOULDBLOCK；对connect而言，errno则被设置为EINPROGRESS。\n\n**显然，只有在事件已经发生的情况下操作非阻塞I/O，才能提高程序的效率**。因此，非阻塞I/O通常要与其他I/O通知机制一起使用，如I/O复用与SIGIO信号。\n\n### I/O复用\n\nI/O复用是最常使用的I/O通知机制。应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数将其中就绪的事件通知给应用程序。\n\nLinux上常用的I/O复用函数有select、poll、epoll_wait；\n\n**I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力**。\n\n### SIGIO信号\n\nSIGIO信号也可以用来报告I/O事件。为目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号。于是，当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发，我们也就可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作。\n\n**阻塞I/O、I/O复用与信号驱动I/O都是I/O同步模型。I/O的读写操作均发生在I/O事件之后，由应用程序来完成**。\n\n### 异步I/O\n\n异步I/O的读写操作总是立即返回(不论I/O是否阻塞)，真正的读写操作已经由内核接管。\n\n**同步I/O向应用程序通知的是I/O就绪事件，而异步I/O向应用程序通知的是I/O完成事件**。\n\n### 小结\n\n上面讨论的几种I/O模型的差异如下表。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 15.png pic15 %}</div>","tags":["网络编程"],"categories":["course"]},{"title":"第四章第一节 服务器模型","url":"/course/np-ch4-par1.html","content":"\n## C/S模型\n\n服务器启动后，首先创建一个或多个监听socket，并调用bind函数将其绑定到服务器感兴趣的端口，再调用listen函数等待客户连接。\n\n服务器稳定运行之后，客户端就可以调用connect函数向服务器发起连接；而客户连接请求是随机到达的异步事件，需要某种I/O模型来监听这一事件。\n\n服务器使用的是I/O复用技术之一select系统调用。当监听到连接请求后，服务器调用accept函数接收它，并分配一个逻辑单元为新的连接服务。逻辑单元可以是新创建的子进程、子线程或其他。\n\n逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。客户端收到请求之后，可以继续发送请求，也可以关闭连接。\n\n如下图是TCP服务器与TCP客户端的一般工作流程。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 10.png pic10 %}</div>\n\n&nbsp;\n\n## P2P模型\n\nP2P模型使每台主机在消耗服务的同时也给别的主机提供服务。为了使主机之间便于发现，实际使用的P2P模型通常带有一个专门的发现服务器。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 11.png pic11 %}</div>","tags":["网络编程"],"categories":["course"]},{"title":"第三章 Linux服务器程序规范","url":"/course/np-ch3.html","content":"\n[第一节 日志](https://KangMing-ux.github.io/course/np-ch3-par1.html)\n\n[第二节 用户信息](https://KangMing-ux.github.io/course/np-ch3-par2.html)\n\n[第三节 进程间关系](https://KangMing-ux.github.io/course/np-ch3-par3.html)\n\n[第四节 服务器程序配置](https://KangMing-ux.github.io/course/np-ch3-par4.html)\n\n","tags":["网络编程"],"categories":["course"]},{"title":"第三章第四节 服务器程序配置","url":"/course/np-ch3-par4.html","content":"\n## 系统资源限制\n\n运行的程序必定会受到系统资源的限制，如物理设备的限制(CPU数量、内存大小等)、系统策略限制(CPU时间)、以及具体实现的限制(文件名的最大长度)。\n\n```c\n/*\n    引用方式: #include <sys/resource.h>\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint getrlimit(int re, struct rlimit * rlim);\n\nint setrlimit(int re, const struct rlimit * rlim);\n```\n\n其中结构体rlimit的定义如下。\n\n```c\nstruct rlimit{\n    rlim_t rlim_cur;//rlim_t可以看作int\n    rlim_t rlim_max;\n}\n```\n\nrlim_cur指定资源的软限制，rlim_max指定资源的硬限制。软限制是一个建议性的、最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其运行。而硬限制一般是软限制的上限，普通程序可以减小硬限制，只有以root身份运行的程序才能增加硬限制。\n\nre参数指定资源限制类型，比较重要的资源限制类型见下表。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n&nbsp;\n\n## 改变工作目录与根目录\n\n获取进程当前目录的函数为getcwd。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    buf: 存储进程当前工作目录的绝对路径名\n    size: 指定buf地址处内存的大小\n    返回指向目标存储区的指针: 成功 || 返回NULL并设置errno\n*/\nchar * getcwd(char * buf, size_t size);\n```\n\n* 若buf=NULL且size=0。则getcwd会在内部使用malloc动态分配内存，并将进程的当前目录存储在其中，然后返回动态分配的内存地址。注意要自己释放这段内存。\n* 若当前工作目录的绝对路径名加一个字符串结束符'\\0'的长度大于size，则getcwd返回NULL，并设置errno为ERANGE。\n\n改变进程工作目录的函数为chdir。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    path: 指定要切换的目标目录\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint chdir(const char * path);\n```\n\n改变进程根目录的函数为chroot。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    path: 指定要切换到的目标根目录\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint chroot(const char * path);\n```\n\nchroot并不改变进程的当前目录，因此调用chroot后，还是需要使用chdir(\"/\")来将工作目录切换到新的根目录。\n\n只有特权进程才能改变根目录。\n\n改变进程根目录之后，可能无法访问类似/dev的文件，但是进程原先打开的文件描述符依然有效。因此可以使用调用chroot函数之前的文件描述符来访问调用chroot函数之后无法访问的文件。\n\n## 服务器程序后台化\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    nochdir: 指定是否改变工作目录(0代表设置工作目录为根目录)\n    noclose为0: 标准输入, 标准输出, 标准错误输出都被重定向到/dev/null; 否则仍然使用原来的设备\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint daemon(int nochdir, int noclose);\n```","tags":["网络编程"],"categories":["course"]},{"title":"第三章第三节 进程间关系","url":"/course/np-ch3-par3.html","content":"\n## 进程组\n\nLinux下每个进程都隶属于一个进程组，其进程组ID——PGID；使用getpgid函数可获取指定进程的PGID。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    返回进程pid所属进程组的PGID: 成功 || 返回-1并设置errno: 失败\n*/\npid_t getpgid(pid_t pid);\n```\n\n每个进程组都有一个首领进程，其PGID与PID相同；进程组将一直存在，直到其中所有进程均退出，或加入其他进程组。\n\n使用setpgid可设置PGID。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint setpgid(pid_t pid, pid_t pgid);\n```\n\n* 若pid=pgid。进程pid为进程组pgid的首领；\n* 若pid=0。设置当前进程的PGID为pgid；\n* 若pgid=0。设置pid为进程pid的PGID；\n\n一个进程只能设置自己或其子进程的PGID；而当子进程调用exec系列函数后，我们也不能再在父进程中对它设置PGID。\n\n## 会话\n\n一些有关联的进程组将形成一个会话session。下面的函数用于创建一个会话。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    返回新的进程组的PGID: 成功 || 返回-1并设置errno: 失败\n*/\npid_t setsid(void);\n```\n\n进程组的首领进程不能调用setsid，否则会产生一个错误。对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果。\n\n* 调用进程成为会话的首领，此时该进程是新会话的唯一成员；\n* 新建一个进程组，其PGID就是调用进程的PID，调用进程成为这个进程组的首领；\n* 调用进程将甩开终端；\n\n一个会话的会话ID被认为是会话首领所在进程组的PGID。使用getsid函数得到会话ID。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n*/\npid_t getsid(pid_t pid);\n```","tags":["网络编程"],"categories":["course"]},{"title":"第三章第二节 用户信息","url":"/course/np-ch3-par2.html","content":"\n## 各种ID\n\n真实用户ID——UID；有效用户ID——EUID；真实组ID——GID；有效组ID——EGID。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n*/\nuid_t getuid();\n\nuid_t geteuid();\n\ngid_t getgid();\n\ngid_t getegid();\n\nint setuid(uid_t uid);\n\nint seteuid(uid_t uid);\n\nint setgid(gid_t gid);\n\nint setegid(gid_t gid);\n```\n\nEUID的存在是为了方便资源访问，它使得运行程序的用户拥有该有效用户的权限。有效用户为root的进程为特权进程。","tags":["网络编程"],"categories":["course"]},{"title":"第三章第一节 日志","url":"/course/np-ch3-par1.html","content":"\n## Linux系统日志\n\nLinux现在提供守护进程rsyslogd来处理系统日志。rsyslogd守护进程既能接收用户进程输出的日志，也能接收内核日志。\n\n用户进程通过调用syslog函数生成系统日志；syslog函数将日志输出到一个UNIX本地域socket类型(AF_UNIX)的文件/dev/log；rsyslogd则监听/dev/log文件以获取用户进程的日志输出。\n\n内核日志由printk等函数打印至内核的环状缓存(ring buffer)中；环状缓存中的内容直接映射到/proc/kmsg文件中；rsyslogd通过读取/proc/kmsg文件获得内核日志。\n\nrsyslogd在接收到用户进程或内核输入的日志后，会将他们输出至某些特定的日志文件；默认情况下，调试信息保存在/var/log/debug，普通信息保存在/var/log/messages，内核消息则保存在/var/log/kernel.log；\n\nLinux系统的日志体系如下图。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n&nbsp;\n\n### rsyslogd的配置文件\n\nrsyslogd的主配置文件为/etc/rsyslog.conf，其中主要可以设置的项包括：内核日志输入路径、是否接收UDP日志及其监听端口、日志文件的权限、包含哪些子配置文件(如/etc/rsyslog.d/*.conf)；而rsyslogd的子配置文件则指定各类日志的目标存储文件。\n\n## syslog函数\n\n应用程序可使用syslog函数与rsyslogd守护进程通信。\n\n```c\n/*\n    引用方式: #include <syslog.h>\n    priority: 设施值与日志级别的按位或\n        设施值: 默认为LOG_USER\n        日志级别\n            0: 系统不可用\n            1: 报警, 需立即采取行动\n            2: 非常严重的情况\n            3: 错误\n            4: 警告\n            5: 通知\n            6: 信息\n            7: 调试\n    mes: 日志信息\n*/\nvoid syslog(int priority, const char * mes);\n```\n\nopenlog函数可进一步改变syslog的默认输出方式，进一步结构化日志内容。\n\n```c\n/*\n    引用方式: #include <syslog.h>\n    ident: 此处字符串会被添加到日志消息的日期与时间之后(通常为程序名)\n    logopt: 对后续syslog的行为进行配置, 取如下值的按位或\n        LOG_PID        0x01    在日志消息中包含程序PID\n        LOG_CONS       0x02    若消息不能记录到日志文件, 则打印至终端\n        LOG_ODELAY     0x04    延迟打开日志功能直到第一次调用syslog\n        LOG_NDELAY     0x08    不延迟打开日志功能\n    fac: 修改syslog函数中的默认设施值\n*/\nvoid openlog(const char * ident, int logopt, int fac);\n```\n\n### 日志的过滤\n\n在程序开发过程中，可能需要输出很多调试信息；而程序发布后，我们需要将这些调试信息关闭；这通过设置日志掩码来实现：使日志级别大于日志掩码的日志信息被系统忽略。setlogmask函数用于设置syslog的日志掩码。\n\n```c\n/*\n    引用方式: #include <syslog.h>\n    mask: 日志掩码值\n    函数始终会成功, 返回调用进程先前的日志掩码值\n*/\nint setlogmask(int mask);\n```\n\n### 关闭日志功能\n\n使用closelog函数关闭日志功能。\n\n```c\n/*\n    引用方式: #include <syslog.h>\n*/\nvoid closelog();\n```","tags":["网络编程"],"categories":["course"]},{"title":"Ubuntu18.04给手机开热点","url":"/config/coming-to-Redmi.html","content":"\n在电脑连上网线时，是可以给手机开热点的。下面详细介绍配置过程。\n\n打开终端，进入root用户；输入如下命令。\n\n```bash\nnm-connection-editor\n```\n\n就会看到下图。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\n点击左下角的'+'号，选择Wi-Fi。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\n然后对此连接做如下配置(没有展示的就算使用默认配置)。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n<div style=\"width:45%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n<div style=\"width:45%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n然后打开设置->Wi-Fi，再点击右上角的选择链接打开隐藏的网络。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n<div style=\"width:45%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n然后在手机上就能看到热点，不过热点的名字不是上面Wi-Fi的名字，而是Ubuntu系统的用户名；输入密码即可连接到此Wi-Fi。","tags":["Ubuntu"],"categories":["config"]},{"title":"第二章 高级I/O函数","url":"/course/np-ch2.html","content":"\n[第一节 创建文件描述符函数](https://KangMing-ux.github.io/course/np-ch2-par1.html)\n\n[第二节 读写数据函数](https://KangMing-ux.github.io/course/np-ch2-par2.html)\n\n[第三节 控制I/O行为与属性函数](https://KangMing-ux.github.io/course/np-ch2-par3.html)\n\n","tags":["网络编程"],"categories":["course"]},{"title":"第二章第三节 控制I/O行为与属性函数","url":"/course/np-ch2-par3.html","content":"\n## fcntl函数\n\nfcntl函数提供对文件描述符的各种控制操作。\n\n```c\n/*\n    引用方式: #include <fcntl.h>\n    cmd: 指定执行哪种类型的操作\n    返回值根据操作与arg的不同而不同, 若失败返回-1并设置errno\n*/\nint fcntl(int fd, int cmd,...);\n```\n\n根据操作类型的不同，fcntl函数可能还需要第三个可选参数arg。fcntl函数支持的常用操作及其参数见下表。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n<div style=\"width:75%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n在网络编程中，fcntl函数通常用来将一个文件描述符设置为非阻塞的。基本框架如下。\n\n```c\nint setnonblocking( int fd ){\n    int old_option, new_option;\n    if((old_option=fcntl( fd, F_GETFL ))<0){\n        printf(\"fcntl error: %s\\n\", strerror(errno));\n        return -1;\n    }\n    new_option = old_option | O_NONBLOCK;\n    if((fcntl( fd, F_SETFL, new_option ))<0){\n        printf(\"fcntl error: %s\\n\", strerror(errno));\n        return -1;\n    }\n    return old_option;\n}\n```","tags":["网络编程"],"categories":["course"]},{"title":"第二章第二节 读写数据函数","url":"/course/np-ch2-par2.html","content":"\n## readv与writev函数\n\nreadv函数将数据从文件描述符读到分散的内存块，即分散读；writev函数将多块分散的内存数据一并写入文件描述符，即集中写。\n\n```c\n/*\n    引用方式: #include <sys/uio.h>\n    cnt: vec数组的长度\n    返回读出/写入的字节数: 成功 || 返回-1并设置errno: 失败\n*/\nsszize_t readv(int fd, const struct iovec * vec, int cnt);\n\nsszize_t writev(int fd, const struct iovec * vec, int cnt);\n```\n\n根据HTTP响应报文格式，状态行、多个头部字段、1个空行与文档内容，文档内容通常与前面的内容是分开的；因此，可以使用writev函数将它们同时写出。\n\n## sendfile函数\n\nsendfile函数在两个文件描述符之间直接传递数据(完全在内核中操作)，从而避免了内核缓冲区与用户缓冲区之间的数据拷贝，效率很高，这称为零拷贝。\n\n```c\n/*\n    引用方式: #include <sys/sendfile.h>\n    offset: 指定从读入文件流的哪个位置开始读; 为空则从读入文件流默认的起始位置开始\n    cnt: 指定传输的字节数\n    返回传输的字节数: 成功 || 返回-1并设置errno: 失败\n*/\nssize_t sendfile(int out, int fd, off_t * offset, size_t cnt);\n```\n\n`man 2 sendfile`明确指出：fd必须是支持mmap函数的文件描述符，必须指向真实的文件，不能是socket或管道；而out必须是一个socket。\n\n## mmap与munmap函数\n\nmmap函数用于申请一段内存空间，这段内存可以用于进程间通信，也可以用于映射文件。munmap释放由mmap创建的内存空间。\n\n```c\n/*\n    引用方式: #include <sys/mman.h>\n    start: 指定分配的内存的起始地址; 若设置为NULL则由系统自动分配\n    prot: 设置内存段的访问权限; PROT_READ: 可读 || PROT_WRITE: 可写 ||PROT_EXEC: 可执行 || PROT_NONE: 内存不可访问; prot可取几个值的按位或\n    flags: 控制内存被修改后程序的行为, 详见下表\n    fd: 被映射文件的文件描述符(一般由open获得)\n    返回目标内存区域的指针: 成功 || 返回MAP_FAILED((void *)-1)并设置errno: 失败\n*/\nvoid * mmap(void * start, size_t len, int prot, int flags, int fd, off_t offset);\n```\n\n<div style=\"width:75%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\nflags参数取某些值的按位或(除了MAR_SHARED与MAR_PRIVATE互斥外)。\n\n```c\n/*\n    引用方式: #include <sys/mman.h>\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint munmap(void * start, size_t len);\n```\n\n## splice函数\n\nsplice函数用于在两个文件描述符之间移动数据，也是零拷贝操作。\n\n```c\n/*\n    引用方式: #include <fcntl.h>\n    in: 待输入数据的文件描述符\n    off_in: 在in不是一个管道文件描述符时, 指定从输入数据流的何处偏移开始读取数据, 置NULL表示从数据流的当前偏移开始读入\n    out: 接收管道输出数据的文件描述符\n    off_out: 在out不是一个管道文件描述符时, 指定从输出数据流的何处偏移开始接收数据, 置NULL表示从数据流的当前偏移开始接收\n    len: 传输数据的长度上限\n    flags: 控制数据如何移动, 详见下表\n    返回传输字节长度(可能为0): 成功 || 返回-1并设置errno: 失败\n*/\nssize_t splice(int in, loff_t * off_in, int out, loff_t * off_out, size_t len, unsigned int flags);\n```\n\n文件描述符in与out必须至少有一个是管道文件描述符。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n## tee函数\n\ntee函数在两个管道文件描述符之间复制数据，也是零拷贝操作。它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操作。\n\n```c\n/*\n    引用方式: #include <fcntl.h>\n    返回传输字节长度(可能为0): 成功 || 返回-1并设置errno: 失败\n*/\nssize_t tee(int in, int out, size_t len, unsigned int flags);\n```","tags":["网络编程"],"categories":["course"]},{"title":"第二章第一节 创建文件描述符函数","url":"/course/np-ch2-par1.html","content":"\n## pipe函数\n\npipe函数创建一个管道，以实现进程间通信。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    fd: 存放管道两端的文件描述符; fd[0]只能从管道读数据, fd[1]只能向管道写数据\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint pipe(int fd[2]);\n```\n\n因此，若要实现进程间双向数据传输，则要使用两个管道。默认情况下，这两个文件描述符都是阻塞的；即若使用read系统调用来读一个空的管道，则read会被阻塞；同理，使用write系统调用来写一个满的管道也会陷入阻塞。\n\nfd[1]的引用计数归0，则使用read读该管道将返回0；fd[0]的引用计数归0，则使用write写该管道将失败，并触发SIGPIPE信号。\n\n管道容量大小默认为65536字节，可使用fcntl函数修改管道容量。\n\n此外，socket基础API提供socketpair函数创建双向管道。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    domain: 指定底层协议族; 此时只能是AF_UNIX\n    type: 指定服务类型; SOCK_STREAM: 流服务 || SOCK_UGRAM: 数据报服务;\n    protocol: 在前面两个参数的基础上更具体的选择一个协议, 一般设置为0, 表示使用默认协议\n    fd: 存放管道两端的文件描述符\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint socketpair(int domain, int type, int protocol, int fd[2]);\n```\n\n## dup函数与dup2函数\n\n`dup*`函数可复制文件描述符。从而实现输入/输出的重定向。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    bottom: 返回的第一个不小于bottom文件描述符\n    返回新创建的文件描述符, 它与fd指向同一文件/管道/网络连接(dup返回的文件描述符总是取当前可用的最小整数值)\n*/\nint dup(int fd);\n\nint dup2(int fd, int bottom);\n```\n\n简要说明代码6-1输出重定向的原理。关闭标准输出文件描述符STDOUT_FILENO(值为1)，然后复制socket文件描述符connfd。由于dup总是返回操作系统中最小的可用文件描述符，因此dup函数返回1。因此，printf实际上会打印到socket文件描述符connfd中。\n\n**以上就是CGI服务器的基本工作原理**","tags":["网络编程"],"categories":["course"]},{"title":"第一章 Linux网络编程基础API","url":"/course/np-ch1.html","content":"\n[第一节 socket地址API](https://KangMing-ux.github.io/course/np-ch1-par1.html)\n\n[第二节 socket基础API](https://KangMing-ux.github.io/course/np-ch1-par2.html)\n\n[第三节 socket信息交互API](https://KangMing-ux.github.io/course/np-ch1-par3.html)\n\n[第四节 socket选项](https://KangMing-ux.github.io/course/np-ch1-par4.html)\n\n[第五节 网络信息API](https://KangMing-ux.github.io/course/np-ch1-par5.html)\n\n","tags":["网络编程"],"categories":["course"]},{"title":"第一章第五节 网络信息API","url":"/course/np-ch1-par5.html","content":"\n## 域名解析\n\nLinux提供gethostbyname函数对域名进行解析。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    doname: 域名\n    返回hostent结构体指针: 成功 || 返回NULL并设置h_errno: 失败\n*/\nstruct hostent * gethostbyname(const char * doname);\n```\n\n其中，结构体hostent定义如下。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n如果想通过IP地址查到主机信息，使用gethostbyaddr函数。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    addr: 目标主机的IP地址(结构体in_addr或结构体in6_addr的指针)\n    len: IP地址长度(sizeof(* addr))\n    type: IP地址类型; AF_INET || AF_INET6\n    返回hostent结构体指针: 成功 || 返回NULL并设置h_errno: 失败\n*/\nstruct hostent * gethostbyaddr(const void * addr, size_t len, int type);\n```\n\n上述两个函数不可重入。\n\n## 服务解析\n\ngetservbyname函数根据服务名称获取某个服务的完整信息。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    name: 服务名称\n    proto: 服务类型; \"tcp\"表示流服务 || \"udp\"表示数据报服务 || NULL: 获取所有类型的服务\n    返回servent结构体指针: 成功 || 返回NULL: 失败\n*/\nstruct servent * getservbyname(const char * name, const char * proto);\n```\n\n其中，结构体servent的定义如下。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    s_name: 服务名称\n    s_aliases: 服务别名数组\n    s_port: 端口号\n    s_proto: 服务类型\n*/\nstruct servent{\n  char *s_name;\n  char **s_aliases;\n  int s_port;\n  char *s_proto;\n};\n```\n\n也可以通过端口获得服务的完整信息，使用getservbyport函数。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    port: 端口号\n    proto: 服务类型; \"tcp\"表示流服务 || \"udp\"表示数据报服务 || NULL: 获取所有类型的服务\n*/\nstruct servent * getservbyport(int port, const char * proto);\n```\n\n上述两个函数不可重入。Linux提供了这些函数可重入版本，在函数名尾部加上_r；\n\n## getaddrinfo\n\ngetaddrinfo函数既能通过主机名获得IP地址，也能通过服务名获得端口号。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    name: 主机名 || 字符串表示的IP地址\n    service: 服务名 || 端口号\n    hints: 对输出进行一些控制; 默认设置为NULL\n    result: result指向一个链表, 用于存储输出结果\n    返回0: 成功 || 返回错误码: 调用const char * gai_strerror(int ret); 查看具体错误信息\n*/\nint getaddrinfo(const char * name, const char * service, const struct addrinfo * hints, struct addrinfo * * result);\n```\n\n其中，结构体addrinfo的定义如下。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    ai_flags: 详见下表\n    ai_family: 地址族\n    ai_socktype: 服务类型; SOCK_STREAM || SOCK_DGRAM\n    ai_protocol: 一般设置为0, 表示使用默认协议\n    ai_addrlen: socket地址ai_addr的长度\n    ai_addr: socket地址\n    ai_canonname: 主机别名\n    ai_next: 指向下一个结构体addrinfo\n*/\nstruct addrinfo{\n  int ai_flags;\n  int ai_family;\n  int ai_socktype;\n  int ai_protocol;\n  socklen_t ai_addrlen;\n  struct sockaddr *ai_addr;\n  char *ai_canonname;\n  struct addrinfo *ai_next;\n};\n```\n\n<div style=\"width:75%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\ngetaddrinfo将隐式分配堆内存，使用配对函数freeaddrinfo来释放这段内存。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n*/\nvoid freeaddrinfo(struct addrinfo * result);\n```\n\n## getnameinfo\n\ngetnameinfo能通过socket地址同时获得以字符串表示的主机名与服务名。\n\n```c\n/*\n    引用方式: #include <netdb.h>\n    host: 存放主机名的地址\n    hostlen: host这段内存的长度\n    serv: 存放服务名\n    servlen: serv这段内存的长度\n    flags: 详见下表\n    返回0: 成功 || 返回错误码: 调用const char * gai_strerror(int ret); 查看具体错误信息\n*/\nint getnameinfo(const struct sockadrr * addr, socklen_t addrlen, char * host, socklen_t hostlen, char * serv, socklen_t servlen, int flags);\n```\n\n<div style=\"width:75%;margin:auto\">{% asset_img 3.png pic3 %}</div>","tags":["网络编程"],"categories":["course"]},{"title":"第一章第四节 socket选项","url":"/course/np-ch1-par4.html","content":"\n## socket选项简介\n\n下面两个函数专门用来读取与设置socket文件描述符属性。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    level: 指定协议类型\n    opt_name: 指定选项\n    opt_val: 存放选项的值的地址\n    len: 存放选项的值的地址的长度\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint getsockopt(int sockfd, int level, int opt_name, void * opt_val, socklen_t * len);\n\nint setsockopt(int sockfd, int level, int opt_name, const void * opt_val, socklen_t len);\n```\n\n如下表是一些常用的socket选项。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\n对服务器来说，有些socket选项只能在调用listen函数前针对监听socket设置才有效。对于这些监听socket，只能由accept函数返回。而此时接受的连接至少已经完成TCP三次握手的前两次步骤，但有些选项需要在TCP同步报文段中设置，因此这些选项必须在调用listen函数前针对监听socket设置，然后连接的socket将其继承，这些选项包括SO_DEBUG | SO_DONTROUTE | SO_KEEPALIVE | SO_LINGER | SO_OOBINLINE | SO_RCVBUF | SO_RCVLOWAT | SO_SNDBUF | SO_SNDLOWAT |TCP_MAXSEG | TCP_NODELAY。\n\n而对于客户端来说，这些socket选项应该在调用connect函数之前设置。\n\n下面讨论几个重要的socket选项。\n\n## SO_REUSEADDR选项\n\n服务器设置socket的SO_REUSEADDR选项来强制使用被处于TIME_WAIT状态的连接占用的socket地址。此外，设置内核参数/proc/sys/net/ipv4/tcp_tw_reuse来快速回收被关闭的socket地址\n\n## SO_RCVBUF与SO_SNDBUF\n\nSO_RCVBUF与SO_SNDBUF选项分别表示TCP接收缓冲区与发送缓冲区的大小。而事实上，操作系统会将设置的缓冲区大小加倍再作为缓冲区大小，而且不得小于某个最小值(TCP接收缓冲区最小值为256字节，发送缓冲区最小值为2048字节)。此外，可以设置/proc/sys/net/ipv4/tcp_rmem与/proc/sys/net/ipv4/tcp_wmem来使TCP接收/发送缓冲区没有大小限制。\n\n## SO_RCVLOWAT与SO_SNDLOWAT\n\n当TCP接收缓冲区中可读数据的总数大于其低水位标记SO_RCVLOWAT时，I/O复用系统调用将通知应用程序可从对应的socket上读取数据。\n\n当TCP发送缓冲区中空闲空间的大小大于其低水位标记SO_SNDLOWAT时，I/O复用系统调用将通知应用程序可向对应的socket上写入数据。\n\nSO_RCVLOWAT与SO_SNDLOWAT均默认为1字节。\n\n## SO_LINGER选项\n\nSO_LINGER选项控制close函数在关闭TCP连接时的行为。默认情况下，close函数关闭socket后，close立即返回，TCP模块负责将socket对应的TCP发送缓冲区中残留的数据发送给对方。\n\n设置SO_LINGER选项时，需要在setsockopt函数中传递一个linger结构体。定义如下。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    l_onoff: 开启(非0)还是关闭(0)该选项\n    l_linger: 滞留时间\n*/\nstruct linger{\n    int l_onoff;\n    int l_linger;\n};\n```\n\n根据l_onoff与l_linger的值，close函数有3种处理方式。\n\n* l_onoff为0。close采用默认处理方式；\n* l_onoff为1，l_linger为0。close函数立即返回，TCP模块丢弃被关闭的socket对应的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文；可见这给服务器提供了异常终止连接的方法；\n* l_onoff为1，l_linger大于0。若socket是非阻塞的，close将立即返回；若socket是阻塞的，则close将等待l_linger时间，若在这期间TCP模块发送完发送缓冲区残留的数据并收到对方的确认，close返回0，否则返回-1并设置errno为EWOULDBLOCK。","tags":["网络编程"],"categories":["course"]},{"title":"第一章第三节 socket信息交互API","url":"/course/np-ch1-par3.html","content":"\n## 数据读写\n\n### TCP数据读写\n\nsocket编程接口提供了专门用于socket数据读写的函数，它们增加对数据读写的控制。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    buf: 读/写缓冲区的地址\n    len: 读/写缓冲区的大小\n    flags: 为数据收发提供相应控制\n        MSG_CONFIRM: 指示数据链路层协议持续监听对方的回应, 直到得到回复; 仅能用于SOCK_DGRAM/SOCK_RAW类型的socket; 只能用于send函数\n        MSG_DONTROUTE: 不查看路由表, 直接将数据发送给本地局域网内的主机; 只能用于send函数\n        MSG_DONTWAIT: 对该socket的此次操作是非阻塞的\n        MSG_MORE: 告知内核应用程序还有更多数据要发送, 内核将超时等待新的数据写入TCP发送缓冲区后一并发送; 只能用于send函数\n        MSG_WAITALL: 读操作仅在读取到指定数量的字节后才返回; 只能用于recv函数\n        MSG_PEEK: 窥探读缓存的数据, 此次读操作不会导致这些数据被清除; 只能用于recv函数\n        MSG_OOB: 发送或接收紧急数据\n        MSG_NOSIGNAL: 向读端关闭的管道或socket连接中写数据时不引发SIGPIPE信号\n    返回实际读取/写入的数据: 成功 || 返回-1并设置errno: 失败\n*/\nssize_t recv(int sockfd, void * buf, size_t len, int flags);\n\nssize_t send(int sockfd, const void * buf, size_t len, int flags);\n```\n\n### UDP数据读写\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    buf: 读/写缓冲区的地址\n    len: 读/写缓冲区的大小\n    flags: 为数据收发提供相应控制, 选项与意义与send/recv的flags相同\n    addr: 发送/接收端的socket地址\n    addr_len: 发送/接收端的socket地址长度\n    返回实际读取/写入的数据: 成功 || 返回-1并设置errno: 失败\n*/\nssize_t recvfrom(int sockfd, void * buf, size_t len, int flags, struct sockaddr * addr, socklen_t * addr_len);\n\nssize_t sendto(int sockfd, const void * buf, size_t len, int flags, const struct sockaddr * addr, socklen_t addr_len);\n```\n\n若将参数addr与addr_len置为NULL，则recvfrom/sendto也可用于面向连接的socket数据读写。\n\n### 通用数据读写\n\nsocket编程接口提供一对通用的数据读写系统调用。既可用于TCP流数据，又可以用于UDP数据报。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    返回实际读取/写入的数据: 成功 || 返回-1并设置errno: 失败\n*/\nssize_t recvmsg(int sockfd, struct msghdr * msg, int flags);\n\nssize_t sendmsg(int sockfd, struct msghdr * msg, int flags);\n```\n\n其中，结构体msghdr的定义如下。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    msg_name: socket地址(同样对于TCP连接, 此项设置为NULL)\n    msg_namelen: socket地址长度\n    msg_iov: 分散的内存块\n    msg_iovlen: 分散的内存块的数量\n    msg_control: 辅助数据的起始地址\n    msg_controllen: 辅助数据的大小\n    msg_flags: 复制函数中的flags参数, 并在调用过程中更新\n*/\nstruct msghdr{\n    void *msg_name;\n    socklen_t msg_namelen;\n    struct iovec *msg_iov;\n    size_t msg_iovlen;\n    void *msg_control;\n    size_t msg_controllen;\n    int msg_flags;\n};\n```\n\n其中，结构体iovec的定义如下。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    iov_base: 内存起始地址\n    iov_len: 这段内存长度\n*/\nstruct iovec{\n    void *iov_base;\n    size_t iov_len;\n};\n```\n\n## 接收带外标记\n\n在recv函数的flags中设置MSG_OOB选项可以接收带外数据，但是实际应用中程序无法预期带外数据何时到来；因此，Linux提供sockatmark函数来判断sockfd是否处于带外标记，即下一个被读取的数据是否为带外数据；如果是，sockatmark函数返回1。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n*/\nint sockatmark(int sockfd);\n```\n\n## 地址信息函数\n\n想知道一个连接socket的本端socket地址与远端socket地址，Linux提供如下两个函数。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    sockfd: 要查询本端/远端socket地址的连接socket\n    addr: 存放查询结果的地址\n    len: 存放查询结果的长度, 可使用sizeof(struct sockaddr)\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint getsockname(int sockfd, struct sockaddr * addr, socklen_t len);\n\nint getpeername(int sockfd, struct sockaddr * addr, socklen_t len);\n```","tags":["网络编程"],"categories":["course"]},{"title":"第一章第二节 socket基础API","url":"/course/np-ch1-par2.html","content":"\n## 创建socket\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    domain: 指定底层协议族; PF_INET: IPv4 || PF_INET6: IPv6\n    type: 指定服务类型; SOCK_STREAM: 流服务 || SOCK_UGRAM: 数据报服务; 对TCP/IP协议族来说，分别表示传输层使用TCP/UDP协议\n    protocol: 在前面两个参数的基础上更具体的选择一个协议, 一般设置为0, 表示使用默认协议\n    返回socket文件描述符: 成功 || 返回-1: 失败\n*/\nint socket (int domain, int type, int protocol);\n```\n\n## 命名socket\n\n创建socket时，只给出了地址族，但是并未指定使用的具体socket地址，将一个socket与socket地址绑定称为socket命名。命名socket通常用在服务器端，这样客户端才知道该怎么连接该socket。而客户端通常不需要命名socket，采用匿名方式，即使用操作系统自动分配的socket地址。命名socket使用bind函数。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    fd: 用于绑定的socket(文件描述符)\n    addr: 用于绑定的socket地址\n    len: socket地址长度, 可使用sizeof(* addr)\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint bind (int fd, const struct sockaddr * addr, socklen_t len);\n```\n\n常见的errno有两种：EACCES(被绑定的地址是受保护地址，仅超级用户可以访问。如普通用户将socket绑定到0-1023端口)与EADDRINUSE(被绑定的端口正在使用，如将socket绑定到处于TIME_WAIT状态的socket地址)。\n\n## 监听socket\n\nsocket被命名后，还不能马上接受客户连接，需要使用listen函数来创建一个监听队列以存放待处理的客户连接。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    sockfd: 要监听的socket\n    backlog: 内核监听队列的最大长度, 典型值为5\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint listen (int sockfd, int backlog);\n```\n\n在Ubuntu18.04上测试，连接socket的连接最多可以有(backlog+1)个。\n\n## 接受连接\n\naccept函数从listen监听队列中接受一个连接。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    sockfd: 处于listen状态的socket\n    addr: 用于存放接收连接的socket地址\n    len: socket地址长度, 可使用sizeof(* addr)\n    返回新的连接socket: 成功 || 返回-1并设置errno: 失败\n*/\nint accept (int sockfd, struct sockaddr * addr, socklen_t len);\n```\n\n通过实验可知：accept只是从监听队列中取出连接，而不论连接处于哪种状态，更不关心网络状况的变化。\n\n## 发起连接\n\n客户端需要使用connect函数来主动连接服务器端的socket。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    local_sockfd: 本地用来连接服务端socket的socket文件描述符\n    serv_addr: 要连接的socket地址\n    len: socket地址长度, 可使用sizeof(* serv_addr)\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint connect (int local_sockfd, const struct sockaddr * serv_addr, socklen_t len);\n```\n\n常见的errno有两种：ECONNREFUSED(目标端口不存在)与ETIMEDOUT(连接超时)。\n\n## 关闭连接\n\nsocket也是文件，因此也可以通过close函数关闭。事实上，close并非总是立即关闭一个连接，而是将socket的引用计数减1；只有当socket的引用计数为0时，才真的关闭连接。\n\n```c\n/*\n    引用方式: #include <unistd.h>\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint close(int fd);\n```\n\n如果要立即终止连接，使用shutdown函数，它是专门为网络编程设计的。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    howto: 指定shutdown关闭连接的方式;\n        SHUT_RD: sockfd不可再被读, sockfd接收缓冲区中的数据全部被丢弃;\n        SHUT_WR: sockfd不可再被写, sockfd发送缓冲区中的数据会在真正关闭前全部发送出去, 连接处于半关闭状态;\n        SHUT_RDWR: 同时关闭sockfd的读与写;\n    返回0: 成功 || 返回-1并设置errno: 失败\n*/\nint shutdown(int sockfd, int howto);\n```","tags":["网络编程"],"categories":["course"]},{"title":"第一章第一节 socket地址API","url":"/course/np-ch1-par1.html","content":"\n## 通用socket地址\n\n表示socket地址的结构体sockaddr。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n    sa_family: 地址族类型变量. AF_UNIX/PF_UNIX表示UNIX本地域协议族 || AF_INET/PF_INET表示TCP/IPv4协议族 || AF_INET6/PF_INET6表示TCP/IPv6协议族\n    sa_data: 存放socket地址值. sa_data表示路径名(AF_UNIX类型) || sa_data包含2字节的端口号与4字节IPv4地址(AF_INET类型) || sa_data包含2字节端口号, 4字节流标识, 16字节IPv6地址, 4字节范围ID共26字节(AF_INTE6类型)\n*/\nstruct sockaddr{\n    sa_family_t sa_family;\n    char sa_data[14];\n};\n```\n\n14字节的sa_data无法容纳所有协议族的地址值；因此，Linux定义了如下新的通用socket地址结构体sockaddr_storage。\n\n```c\n/*\n    引用方式: #include <sys/socket.h>\n*/\nstruct sockaddr_storage{\n    sa_family_t ss_family;\n    char __ss_padding[(128 - (sizeof (unsigned short int)) - sizeof (unsigned long int))];\n    unsigned long int __ss_align;\n};\n```\n\n## 专用socket地址\n\n上述通用socket结构体不易操作，Linux专门提供如下专用socket地址结构体。\n\n```c\n/*\n    引用方式: #include <sys/un.h>\n    UNIX本地域协议族\n*/\nstruct sockaddr_un{\n    sa_family_t sun_family;\n    char sun_path[108];\n};\n/*\n    引用方式: #include <netinet/in.h>\n    TCP/IPv4协议族\n    sin_port: 使用网络字节序\n*/\nstruct sockaddr_in{\n    sa_family_t sin_family;\n    in_port_t sin_port;\n    struct in_addr sin_addr;\n    unsigned char sin_zero[sizeof (struct sockaddr) -\n      (sizeof (unsigned short int)) -\n      sizeof (in_port_t) -\n      sizeof (struct in_addr)];\n};\n\nstruct in_addr{\n    in_addr_t s_addr;// IPv4地址; 使用网络字节序\n};\n/*\n    引用方式: #include <netinet/in.h>\n    TCP/IPv6协议族\n    sin_port6: 使用网络字节序\n*/\nstruct sockaddr_in6{\n    sa_family_t sin6_family;\n    in_port_t sin6_port;\n    uint32_t sin6_flowinfo;\n    struct in6_addr sin6_addr;\n    uint32_t sin6_scope_id;\n};\n\nstruct in6_addr{\n    union{\n uint8_t __u6_addr8[16];\n uint16_t __u6_addr16[8];\n uint32_t __u6_addr32[4];\n      } __in6_u;// IPv6地址; 使用网络字节序\n};\n```\n\n所有专用socket地址类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr。\n\n## IP地址转换\n\n点分十进制字符串转结构体in_addr。\n\n```c\n/*\n    引用方式: #include <arpa/inet.h>\n    inp: 转换的结构体存放地址\n    返回1: 成功 || 返回0: 失败\n*/\nint inet_aton(const char * cp, struct in_addr * inp);\n```\n\n结构体in_addr转点分十进制字符串。\n\n```c\n/*\n    引用方式: #include <arpa/inet.h>\n*/\nchar * inet_ntoa(struct in_addr in);\n```\n\n**上述两个函数不可重入**\n\n还有同时适用于IPv4与IPv6地址转换的一对函数。\n\n点分十进制字符串(IPv4地址)或冒号分16进制字符串(IPv6)转对应结构体，即结构体in_addr或结构体in6_addr；由`__af`参数指定协议族，一般取宏AF_INET或AF_INET6。\n\n```c\n/*\n    引用方式: #include <arpa/inet.h>\n    af: 指定地址族; AF_INET: IPv4 || AF_INET6: IPv6\n    buf: 转换的结构体存放地址\n*/\nint inet_pton (int __af, const char * cp, void * buf);\n```\n\n结构体in_addr或结构体in6_addr转换为对应的字符串表示。\n\n```c\n/*\n    引用方式: #include <arpa/inet.h>\n    af: 指定地址族; AF_INET: IPv4 || AF_INET6: IPv6\n    buf: 字符串存储地址\n    len一般取两个宏INET_ADDRSTRLEN与INET6_ADDRSTRLEN; \n    返回目标存储地址: 成功 || 返回NULL并设置erno: 失败\n*/\nconst char * inet_ntop (int af, const void * cp, char * buf, socklen_t len);\n```","tags":["网络编程"],"categories":["course"]},{"title":"Answers for chapter one","url":"/course/sp-ch11.html","content":"\n## Answers\n\n(1)程序为什么要被编译器编译之后才能运行？\n\n解：程序的源代码属于高级语言，而能让计算机理解执行的只有机器语言；因此，编译器的编译就是做将高级语言转换为机器语言的工作的。\n\n&nbsp;\n\n(2)编译器是如何将C语言程序转化成可执行的机器码的？\n\n解：经4个步骤：预处理、编译、汇编、链接。详见[编译与链接](https://KangMing-ux.github.io/course/sp-ch2.html)\n\n&nbsp;\n\n(3)可执行文件中有哪些内容，它们是如何组织的？\n\n解：一个动态链接的可执行文件具有如下的段。\n\n```bash\nSections:\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .interp       0000001c  0000000000000238  0000000000000238  00000238  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  1 .note.ABI-tag 00000020  0000000000000254  0000000000000254  00000254  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  2 .note.gnu.build-id 00000024  0000000000000274  0000000000000274  00000274  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  3 .gnu.hash     0000001c  0000000000000298  0000000000000298  00000298  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  4 .dynsym       000000a8  00000000000002b8  00000000000002b8  000002b8  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  5 .dynstr       00000084  0000000000000360  0000000000000360  00000360  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  6 .gnu.version  0000000e  00000000000003e4  00000000000003e4  000003e4  2**1\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  7 .gnu.version_r 00000020  00000000000003f8  00000000000003f8  000003f8  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  8 .rela.dyn     000000c0  0000000000000418  0000000000000418  00000418  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  9 .rela.plt     00000018  00000000000004d8  00000000000004d8  000004d8  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n 10 .init         00000017  00000000000004f0  00000000000004f0  000004f0  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n 11 .plt          00000020  0000000000000510  0000000000000510  00000510  2**4\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n 12 .plt.got      00000008  0000000000000530  0000000000000530  00000530  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n 13 .text         000001f2  0000000000000540  0000000000000540  00000540  2**4\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n 14 .fini         00000009  0000000000000734  0000000000000734  00000734  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n 15 .rodata       0000001e  0000000000000740  0000000000000740  00000740  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n 16 .eh_frame_hdr 00000044  0000000000000760  0000000000000760  00000760  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n 17 .eh_frame     00000128  00000000000007a8  00000000000007a8  000007a8  2**3\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n 18 .init_array   00000008  0000000000200db8  0000000000200db8  00000db8  2**3\n                  CONTENTS, ALLOC, LOAD, DATA\n 19 .fini_array   00000008  0000000000200dc0  0000000000200dc0  00000dc0  2**3\n                  CONTENTS, ALLOC, LOAD, DATA\n 20 .dynamic      000001f0  0000000000200dc8  0000000000200dc8  00000dc8  2**3\n                  CONTENTS, ALLOC, LOAD, DATA\n 21 .got          00000048  0000000000200fb8  0000000000200fb8  00000fb8  2**3\n                  CONTENTS, ALLOC, LOAD, DATA\n 22 .data         00000014  0000000000201000  0000000000201000  00001000  2**3\n                  CONTENTS, ALLOC, LOAD, DATA\n 23 .bss          0000000c  0000000000201014  0000000000201014  00001014  2**2\n                  ALLOC\n 24 .comment      00000029  0000000000000000  0000000000000000  00001014  2**0\n                  CONTENTS, READONLY\n```\n\n可执行文件主要包含\n\n* .text代码段(存放执行指令)；\n* .data数据段(已初始化的全局变量与局部静态变量)；\n* .rodata只读数据段(存放只读数据)；\n* .bss段(未初始化的全局变量与局部静态变量)；\n* .interp段(指出程序所需动态链接器版本)；\n* .dynamic段(动态链接的基本信息)；\n* .dynsym段(保存动态链接的共享模块间符号的导入导出关系)；\n* .dynstr段(保存.dynsym段中符号的名称)；\n* .got段(全局偏移表)；\n* .rela.dyn段(用来修正.got段中全局变量和.data段中符号的地址)；\n* .plt段(程序链接表，用于实现延迟绑定)；\n* .rela.plt段(用来修正.got段中外部函数的地址)；\n* .init段(程序初始化)、fini段(程序退出清理)；\n\n&nbsp;\n\n(4)解释`#include<stdio.h>`的作用，C语言库是什么？要如何实现？\n\n解：包含处理标准输入输出的C语言标准库。C语言库是支撑C语言程序可以正常运行的代码集合。\n\n&nbsp;\n\n(5)不同的编译器、硬件平台以及操作系统，编译同一源代码的结果是否相同？为什么？\n\n解：不相同。不同的编译器在编译过程中所做的优化不同，不同的硬件平台所支持的汇编指令集不同，不同的操作系统对C语言标准库中函数的具体实现不同；因此，即使编译同一源代码，所得结果也不会相同。\n\n&nbsp;\n\n(7)一个程序在没有操作系统的机器上如何才能运行？\n\n解：略。\n\n&nbsp;\n\n(8)printf函数是如何实现的？\n\n解：要实现printf函数有两点，一个是使用write系统调用向屏幕写数据、一个是支持变长参数；在printf函数内部定义va_list类型的变量ap，先用宏函数va_start将其初始化\n\n```c\nva_start(ap, lastarg);//lastarg为printf函数的最后一个具名参数\n```\n\n接下来，可以通过va_arg宏函数来获取下一个不定参数；\n\n```c\ntype next=va_arg(ap, type);//type为下一个不定参数的类型\n```\n\n在调用完write系统调用之后，用宏函数va_end来清理现场。\n\n&nbsp;\n\n(9)程序在运行时，它在内存中的组成？\n\n解：程序在运行时，它在内存中的组成包括Linux内核、堆栈、动态装载库、数据段、代码段以及保留部分。这些部分的组织如下图。\n\n<div style=\"width:35%;margin:auto\">{% asset_img 13.png pic13 %}</div>","tags":["系统编程"],"categories":["course"]},{"title":"第十章 系统调用","url":"/course/sp-ch10.html","content":"\n## 系统调用简介\n\nLinux系统在x86架构下的系统调用由int 0x80中断完成，各通用寄存器用于传递参数，其中eax寄存器存储系统调用的调用号，常用的调用号如下表。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n<div style=\"width:64%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n&nbsp;\n\n可使用`man 2 read`查看read系统调用的详细说明。\n\n但是，不同操作系统之间系统调用不兼容，为此，运行库对这些系统调用封装成统一的接口，使得相同的代码在不同操作系统下都可以被编译并产生一致的效果。\n\n## 系统调用原理\n\n以基于int的Linux经典系统调用为例。如下是调用fork系统调用的示意图。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 18.png pic18 %}</div>\n\n&nbsp;\n\n### 触发中断\n\nfork函数是对系统调用fork的封装，由如下宏代码定义。\n\n```c\n_syscall0(pid_t, fork);\n```\n\n其中，`_syscall0`是一个宏函数，用于定义一个没有参数的系统调用的封装。i386版本的`_syscall0`定义如下。\n\n```c\n#define _syscall0(type, name)\\\ntype name(void)\\\n{\\\nlong __res;\\\n__asm__ volatile (\"int $0x80\"\\ \n    : \"=a\" (__res)\\\n    : \"0\" (__NR_##name));\\\n__syscall_return(type,__res);\\\n}\n```\n\n对于`_syscall0(type, name)`，上述宏会展开为如下代码。\n\n```c\npid_t fork(void)\n{\nlong __res;\n__asm__ volatile (\"int $0x80\"\n    : \"=a\" (__res)\n    : \"0\" (__NR_fork));\n__syscall_return(type,__res);\n}\n```\n\n其中，`__NR_fork`是一个宏，表示fork系统调用的调用号；0指示编译器选择与输出相同的寄存器来传递参数，而=a表示将返回值存放在eax寄存器，于是eax寄存器也用来传递参数`__NR_fork`，而中断服务程序正好从eax处取得系统调用号。\n\n而如果调用的系统调用需要传递参数(x86架构下Linux支持的系统调用参数个数最多6个)，分别使用6个寄存器(ebx、ecx、edx、esi、edi、ebp)来传送。\n\n当CPU执行到int $0x80时，会保存现场以便恢复，然后将特权状态从用户态切换到内核态，然后CPU查找中断向量表第0x80号元素。\n\n### 切换堆栈\n\nint指令执行的第一步就是切换堆栈(进程拥有内核栈与用户栈)，由于中断会让进程从用户态进入内核态，因此进程的当前栈也应该从用户栈切换为内核栈。具体的切换方法为：\n\n* 将寄存器esp、ss压入内核栈；\n* 将内核栈顶地址存入esp寄存器，将内核栈所在页的地址存入ss寄存器；\n\n切换堆栈之后，int指令执行的下一步是将eflags、cs、eip寄存器压入内核栈。与之对应的，当进程从内核态返回用户态时，使用iret指令，它会从内核栈中弹出ss、esp、eflags、cs、eip的值。","tags":["系统编程"],"categories":["course"]},{"title":"第九章 运行库","url":"/course/sp-ch9.html","content":"\n## 入口函数\n\n一个程序完整的运行过程应该如下。\n\n* 操作系统创建进程后，将控制权交给程序的入口处，入口处是运行库中的入口函数；\n* 入口函数对运行库与程序运行环境进行初始化，包括堆、I/O、线程、全局变量构造等；\n* 入口函数在完成初始化之后调用main函数，开始执行程序主体部分；\n* main函数返回后，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭I/O等；\n\n## C&C++运行库\n\n### C语言运行库\n\n一个C语言运行库大致包含如下功能。\n\n* 启动与退出：包括入口函数与入口函数所依赖的函数；\n* 标准函数：由C语言标准规定的C语言标准库所包含的函数实现；\n* I/O：I/O功能的封装与实现；\n* 堆：堆的封装与实现；\n* 语言实现：语言中一些特殊功能的实现；\n* 调试：实现调试功能的代码；\n\n其中，以C语言标准库占主要部分。\n\n### C语言标准库\n\nANSI C的标准库由24个C头文件组成，包含数学函数、字符/字符串处理、I/O等基本方面。\n\n* 标准输入输出(stdio.h)；\n* 文件操作(stdio.h)；\n* 字符操作(ctype.h)；\n* 字符串操作(string.h)；\n* 数学函数(math.h)；\n* 资源管理(stdlib.h)；\n* 格式转换(stdlib.h)；\n* 时间与日期(time.h)；\n* 断言(assert.h)；\n* 各种类型的常数(limits.h、float.h)；\n\n除此之外，C语言标准库还有实现了一些扩展功能。\n\n* 变长参数(stdarg.h)；\n* 非局部跳转(setjmp.h)；\n\n比如标准库中的printf函数就是变长参数。\n\n关于非局部跳转，如下是一个示例。\n\n```c\n#include <stdio.h>\n#include <setjmp.h>\n\njmp_buf b;\n\nvoid f(){\n    longjmp(b,1);\n}\n\nint main()\n{\n    if(setjmp(b)){\n        printf(\"World!\\n\");\n    }\n    else{\n        printf(\"Hello, \");\n        f();\n    }\n}\n```\n\n程序的输出结果是\n\n```bash\nHello, World!\n```\n\n### glibc与GCC\n\n**glibc简介**\n\nglibc的发布版本由两部分组成——头文件(/usr/include/stdio.h、/usr/include/stdlib.h等)与二进制文件(动态标准库/lib/x86_64-linux-gnu/libc.so.6、静态标准库/usr/lib/x86_64-linux-gnu/libc.a)，除了这些标准库以外，glibc还有几个辅助程序运行的运行库/usr/lib/x86_64-linux-gnu/crt1.o、/usr/lib/x86_64-linux-gnu/crti.o、/usr/lib/x86_64-linux-gnu/crtn.o。\n\n程序的入口函数_start就包含于crt1.o，而crti.o与crtn.o是分别用来辅助.init段与.finit段中指令的执行。crt1.o为了支持.init段与.finit段，它会向`__libc_start_main`传递两个函数指针`__libc_csu_init`与`__libc_csu_fini`，这两个函数指针指向函数`_init()`与`_finit()`。事实上，最终的输出文件的.init段与.finit段分别包含的就是`_init()`与`_finit()`，其中crti.o与crtn.o中的代码作为这两个函数的开始与结尾部分。\n\n.init段与.finit段正好在main函数执行前后被执行，正好可以用来实现C++全局构造与析构。.init段与.finit段中分别有对一个执行所有构造/析构函数的函数的调用。具体执行所有构造/析构函数的工作由编译器完成。于是就要介绍下面的**GCC平台相关目标文件**。\n\n**GCC平台相关目标文件**\n\n在静态链接生成ELF可执行文件时用到如下GCC平台相关目标文件(均在/usr/lib/gcc目录下)。\n\n* x86_64-linux-gnu/7/crtbeginT.o；具体实现C++全局构造。\n* x86_64-linux-gnu/7/crtend.o；具体实现C++析构；\n* x86_64-linux-gnu/7/libgcc.a；抹除不同平台的差异性，支持GCC的跨平台特性；对应的动态链接版本为libgcc_s.so。\n* x86_64-linux-gnu/7/libgcc_eh.a；支持C++的异常处理；\n\n综上，.init段与.finit段只是提供了一个在main函数执行前后执行的机制，具体的C++全局构造与析构分别由crtbeginT.o与crtend.o实现。在\"C++全局构造与析构\"这一节介绍。\n\n\n## 运行库与多线程\n\n&nbsp;\n\n## C++全局构造与析构\n\n### _GLOBAL__I_Hw\n\n对每个编译单元(cpp文件)，GCC编译器会遍历其中所有的全局对象，生成一个特殊函数`_GLOBAL__I_Hw`(对所在编译单元的所有全局对象进行初始化)，然后将此函数的地址放在目标文件的.ctors段。\n\n这样，在链接器链接这些目标文件时，根据\"相同段合并原则\"，链接器会把所有目标文件的.ctors段合并为输出文件的.ctors段；同样地，crtbeginT.o的.ctors段放在输出文件的.ctors段的开头，它并没有指向哪个`_GLOBAL__I_Hw`，链接器会将后面构造函数的个数存放到这个位置，链接器将.ctors段的起始地址定义成符号`__CTOR_LIST__`；crtbeginT.o的.ctors段放在输出文件的.ctors段的结尾，这个段的值为0，链接器将.ctors段的结尾地址定义为符号`__CTOR_END__`。\n\n### C++全局构造\n\n如下是全局构造的调用链。\n\n```bash\n_start->__libc_start_main->__libc_csu_init->_init->_do_global_ctors_aux\n```\n\n在`_do_global_ctors_aux`函数中具体实现了C++全局构造，关键代码如下。\n\n```c\nvoid __do_global_ctors_aux(void){\n    /* Call constructor functions */\n    unsigned long nptrs=(unsigned long)__CTOR_LIST__[0];\n    unsigned long i;\n    for(i=nptrs;i>=1;i--)\n        __CTOR_LIST__[i]();\n}\n```\n\n### 析构\n\n全局对象的析构与构造的工作类似，如.init变成.finit、`_do_global_ctors_aux`变成`_do_global_dtor_aux`、`__CTOR_LIST__`对应`__DTOR_LIST__`；但是注意，析构函数的调用顺序与构造函数的调用顺序相反。","tags":["系统编程"],"categories":["course"]},{"title":"第八章 内存","url":"/course/sp-ch8.html","content":"\n## 程序的内存布局\n\n结合上一章介绍的动态链接，再来看看进程的32位内存地址空间的布局。\n\n<div style=\"width:35%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n&nbsp;\n\n## 栈与调用惯例\n\n### 栈\n\n栈用于维护函数调用的上下文，栈通常从用户空间最高地址开始，栈从高地址向低地址增长。\n\n在x86架构下，esp寄存器始终指向栈顶。栈保存了每个函数调用所需要维护的信息，维护的每个函数调用的信息称为一个活动记录。ebp寄存器指向当前活动记录的一个固定位置。如下是一个典型的活动记录示意图。\n\n<div style=\"width:35%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\nebp寄存器始终指向当前活动记录的old EBP，ebp-4是函数的返回地址、ebp-8、ebp-12等等是函数的参数的地址。\n\nx86架构下标准的函数从进入到退出序列如下。\n\n```assembly\npush ebp\nmov ebp, esp\nsub esp, x\npush reg1\n...\npush regn\n[Function instructions]\npop regn\n...\npop reg1\nmov esp, ebp\npop ebp\nret\n```\n\n### 调用惯例\n\n函数调用者传递的参数需要被函数正确地理解，如使用寄存器还是栈传参、参数压栈顺序为从左到右还是从右到左。为此，函数的调用方与与其自身需要有一个明确的约定，只有双方同时遵守同样的约定，函数才能正确的执行。这样的约定称为**调用惯例**。\n\n调用惯例通常会规定如下几个方面的内容。\n\n* 参数的传递顺序与方式；\n* 栈的维护方式；被压入栈中的参数被函数弹出还是被函数调用者弹出；\n* 名字修饰策略；如在函数名前下划线；\n\nC语言默认使用cdecl调用惯例：从右到左的顺序压参数入栈、栈由函数调用者维护、函数名修饰为在函数名前加下划线。\n\n### 函数返回值的传递\n\n一般来说，函数将其返回值存入eax寄存器，函数调用者访问eax寄存器获取调用的函数的返回值。但是在x86架构下，eax只有4个字节，如果返回值多余4个字节，但是没有超过8个字节，则使用eax与edx联合返回；那么，如果返回值特别长，远远大于8字节，该怎么传递返回值。\n\n解决办法是(被调用)函数在栈上为返回值开辟一段空间，然后将返回值复制到栈上，然后返回返回值的地址，调用者再根据返回的地址复制返回值到其内部的变量。此时，一个大尺寸的返回值会被复制两次，因此在程序编写过程中极其不建议返回大尺寸的值。\n\n## 堆与内存管理\n\n### 堆\n\n用来容纳应用程序动态分配的内存区域，程序使用malloc或new分配的内存就来自堆。进程申请内存空间需要使用系统调用，而如果程序对堆的操作比较频繁，那么就要频繁地调用开销很大的系统调用，为此，进程会向操作系统申请一块适当大小的内存作为堆空间，然后由进程自行管理这块内存空间，具体来说，是由程序的运行库向操作系统申请堆空间并管理堆空间的分配。\n\n### Linux进程堆管理\n\nLinux系统提供了两种堆空间的申请方式，即两个系统调用：brk与mmap；brk的功能是设置进程数据段的结束地址Program break；\n\n<div style=\"width:56%;margin:auto\">{% asset_img 15.png pic15 %}</div>\n\n&nbsp;\n\nProgram break向高地址移动，扩大的内存空间作为堆空间。mmap的功能是向操作系统申请一段虚拟地址空间。\n\n### 堆分配算法\n\n堆分配问题其实就是如何管理一大块连续的内存空间，可以按照需求分配、释放其中的空间。\n\n**空闲链表**：将堆中的空闲空间使用双向链表组织起来；当用户请求空间时，遍历整个链表，直到找到合适大小的空闲块并将其拆分。当用户释放空间时将其加入链表或链表的某个空闲块中。这种堆分配算法实现简单，但是不稳定。\n\n**位图**：将整个堆空间划分为大量的块，当用户请求内存时，算法会分配整数个块给用户，分配的第一个块称为头，其余的称为主体；可以使用一个数组来记录块的分配情况——空闲/主体/头，因此每2比特就可以表示一个块的状态。因此叫做位图。位图具有速度块、稳定性好的特点；但是容易产生内碎片。\n\n**对象池**：由于在某些情况下，用户会频繁地申请几个较为固定长度的内存，针对这种情况，堆分配算法可以将这些固定长度的内存作为单位，每次用户申请这些固定长度的内存时只需要找到一个对应长度的单位即可。对象池的管理可以使用空闲链表，也可以使用位图。\n\n实际应用的堆分配算法是上述多种分配算法的组合。","tags":["系统编程"],"categories":["course"]},{"title":"第七章 Linux共享库的组织","url":"/course/sp-ch7.html","content":"\n## 共享库版本\n\n### 共享库的兼容性\n\n在共享库升级时有如下4种修改会导致C语言的共享库二进制接口发生改变。\n\n* 导出函数的行为发生改变；\n* 导出函数被删除；\n* 导出数据的结构发生变化；\n* 导出函数的接口发生变化，如函数的返回值、参数变化；\n\n### 共享库版本命名\n\n共享库升级导致的不兼容是不可避免的，为此，只有对共享库进行版本命名：x.y.z；其中x为主版本号，y为次版本号，z为发布版本号；主版本号表示共享库的重大升级，不同主版本号的共享库之间不兼容；次版本号表示共享库的增量升级，主版本号相同时，次版本号高的共享库可兼容次版本号低的共享库。发布版本号表示库中错误的修正、函数性能的提升等，既不添加新的接口，也不对接口进行修改；相同主、次版本号的共享库完全兼容。\n\n### SO-NAME\n\n在ELF文件中用SO-NAME来命名一个依赖的共享库，具体做法为去掉共享库名称中的次、发布版本号；如ELF依赖共享库libfoo.so.2.6.1，则这个共享库对应的SO-NAME为libfoo.so.2。在Linux系统中，系统会为每个共享库在其所在目录创建一个以其SO-NAME为名的软链接指向其自身。通过软链接可以定向到相同主版本号中最新版本的共享库。这是因为在Linux系统安装或更新一个共享库时，会运行ldconfig工具，该工具会遍历所有的默认共享库目录，如/lib、/usr/lib，并更新所有的软链接，将其指向最新版本的共享库。\n\n### 链接名\n\n需要链接一个libXXX.so.x.y.z的共享库，只需要在GCC编译时加上-lXXX选项即可！其中，XXX也被称为链接名。\n\n## 符号版本\n\n如果一个ELF可执行文件所依赖的共享库的次版本号高于系统中该共享库的次版本号(主版本号相等)，SO-NAME机制也解决不了此时有可能发生的不兼容问题。为此，现在的操作系统使用一种更加精巧的机制——符号版本。\n\n符号版本的基本思路是：对共享库中每个导入&导出的符号关联一个版本号，每次共享库升级时，给那些新添加/修改的符号关联升级后的共享库版本命名。\n\n## 共享库系统路径\n\n目前包括Linux在内的大部分开源操作系统都遵守FHS标准，这个标准规定了一个系统中的系统文件该如何存放，以及每个目录的组织与作用，共享库作为系统中重要的文件，也是如此。FHS规定：一个系统中主要有两个存放共享库的位置——/lib与/usr/lib，以及一个存放第三方程序共享库的位置/usr/local/lib。\n\n* /lib。存放系统中最关键的共享库，如动态链接器、C语言运行库、数学库等，这些库主要被/bin与/sbin下的程序用到，以及系统启动所需；\n* /usr/lib。存放开发时会用到的共享库；\n* /usr/local/lib。存放第三方应用程序所需的共享库；\n\n## 共享库的查找\n\n一个动态链接的可执行文件所依赖的共享库的路径保存在.dynamic段中，由DT_NEED类型的项表示；保存的路径可以是绝对路径或相对路径，考虑到程序的可移植性，一般使用相对路径。\n\n为加快共享库的查找速度，ldconfig会建立SO-NAME缓存存放在/etc/ld.so.cache，/etc/ld.so.cache的特殊结构极其利于查找。若动态链接器未在/etc/ld.so.cache找到共享库，才会去遍历/lib与/usr/lib这两个目录。如果仍然没有找到，则会返回错误信息。\n\n## 环境变量\n\n* LD_LIBRARY_PATH。临时改变某个应用程序的共享库查找路径；因此更准确地说，动态链接器最先去LD_LIBRARY_PATH指定的路径下查找共享库；\n* LD_PRELOAD。指定预先装载的共享库或目标文件，LD_PRELOAD指定的文件会在动态链接器按照既定规则搜索共享库进行装载之前被装载，无论程序是否依赖它们。\n* LD_DEBUG。设置该环境变量之后，动态链接器会在运行时打印各种有用的信息。\n\n<div style=\"width:32%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n<div style=\"width:35%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n## 共享库的创建与安装\n\n### 创建共享库\n\n在GCC编译时，加上`-shared`与`-fPIC`两个选项，就可以输出共享库；此外，还可以加上`-WI`选项，该选项可以将指定的参数传递给链接器，如`-WI, -soname, my_soname`就是将`-soname my_soname`传递给链接器，用来指定生成的共享库的SO-NAME。如下是一个GCC编译出共享库的例子。\n\n```bash\ngcc -shared -fPIC -Wl,-soname,libfoo.so.1 -o libfoo.so.1.0.0 libfoo1.c libfoo2.c -lbar1 -lbar2\n```\n\n在链接器输出可执行文件时，只会将那些在链接时被其他共享模块引用到的符号放到动态符号表，则动态加载模块在被加载时无法引用主模块在链接时未被其他共享模块引用的符号，即**反向引用**失败。为避免上述问题，ld链接器提供了-export-dynamic参数，该参数指定ld链接器在输出可执行文件时将所有全局符号导出到全局符号表。\n\n### 清除符号信息\n\nstrip工具可清除共享库/可执行文件的所有符号与调试信息。\n\n### 安装共享库\n\n安装共享库最简便的方法是将其复制到某个标准的共享库目录，再运行ldconfig。需要root权限。\n\n### 共享库构造与析构函数\n\nGCC提供了为共享库定义构造/析构函数的方法：在函数声明时加上`__attribute__((constructor))`或`__attribute__((destructor))`修饰。同时，GCC还支持为构造/析构函数指定优先级，如`__attribute__((constructor(5)))`，对于构造函数，优先级越小越先于其他构造函数执行，而对于析构函数与之相反。\n\n### 共享库脚本\n\n事实上，共享库除了是ELF共享对象文件外，还可以是链接脚本，例如将C运行库与数学库结合起来的共享库libfoo.so文件的内容可以是\n\n```bash\nGROUP( /lib/libc.so.6 /lib/libm.so.2)\n```","tags":["系统编程"],"categories":["course"]},{"title":"第六章第二节 动态链接的实现与显式运行时链接","url":"/course/sp-ch6-par2.html","content":"\n## 动态链接的实现\n\n### 动态链接器自举\n\n动态链接器是一个特殊的共享对象！首先，动态链接器本身不能依赖于其他任何共享对象；其次，共享对象本身所需要的全局&静态变量&函数地址的重定位工作由它自身完成。为了完成第二个目标，动态链接器必须使用一段非常精巧的代码，这段启动代码便称为**自举**。\n\n自举代码在动态链接器入口处，自举代码首先找到自身的GOT，而GOT的第一项为.dynamic段，自举代码便可以通过.dynamic段的信息获得动态链接器本身的重定位表与符号表等，从而得到动态链接器本身的重定位入口，将重定位表中所有项重定位。从这一步开始，动态链接器的代码中才能使用自己的全局&静态变量以及调用函数。\n\n### 装载共享对象\n\n动态链接器完成自举之后，动态链接器将可执行文件与自身的符号表合并到一个符号表中——全局符号表。然后链接器根据.dynamic段的内容开始寻找可执行文件所依赖的共享对象，如果依赖的共享对象还依赖其他共享对象，同样将其装载到进程的地址空间。具体的装载算法可使用深度优先或广度优先。\n\n在装载共享对象时存在一个**全局符号介入**的问题，当一个符号需要被加入到全局符号表中时，如果相同的符号名已经存在，则后加入的符号会被忽略。\n\n由于编译器在编译时将模块内部的函数当作模块外部函数处理，因此，若希望加快函数调用速度，可以对函数加上static修饰，将函数作为编译单元私有函数，使用第一种地址引用方式。\n\n### 重定位与初始化\n\n有了全局符号表，链接器遍历可执行文件与每个共享对象的重定位表，将GOT&PLT中每个需要重定位的位置进行修正。重定位的操作与静态链接的重定位操作相同。重定位之后，如果共享对象有.init段，则动态链接器会执行.init段中的代码；相应地，共享对象还会有.finit段，当进程退出时会执行.finit段中的代码。接下来，动态链接器将控制权交给可执行文件。\n\n动态链接器作为共享对象，也可以作为可执行文件运行。动态链接器是静态链接的。\n\n## 显式运行时链接\n\n显式运行时链接是一种比动态链接更加灵活的模块加载方式，它让程序在运行时自己控制加载指定的模块，并在不需要某模块时将其卸载。此时的模块称为动态装载库，它与共享对象并无差别。\n\n动态链接由动态链接器完成，而显式运行时链接需要由程序来完成，因此动态链接器提供了一系列API来支持程序完成动态装载库的装载。\n\n* dlopen：打开一个动态库，并将其加载到进程的地址空间；\n* dlsym：找到动态装载库的符号，并返回符号的值；\n* dlerror：每次调用dlopen、dlsym、dlclose之后，都需要调用dlerror来判断上一次调用是否成功；\n* dlclose：卸载加载的模块，事实上，操作系统会为每个模块维护一个计数器，每有一个进程调用dlopen加载该模块，该模块对应的计数器加1；每有一个进程调用dlclose卸载该模块，该模块对应的计数器减1；只有当模块对应的计数器为0时才会真的被卸载，动态链接器首先执行.finit段中的代码，然后从进程的全局符号表中删除该模块中的符号，取消进程地址空间与模块的映射关系，最后关闭模块文件。","tags":["系统编程"],"categories":["course"]},{"title":"第六章第一节 动态链接基础","url":"/course/sp-ch6-par1.html","content":"\n## 动态链接的意义\n\n**静态链接的不足**：浪费计算机内存与磁盘空间(许多公用库函数在内存&可执行文件中有多份，这是没有必要的)；极大降低程序开发的效率(一旦程序中有任一模块更新，整个程序就要重新链接，然后发布给用户)。\n\n为了避免这些不足，出现了动态链接——将程序需要的模块相互分割开，等运行时再进行链接。使得程序具有可扩展性，在运行时可以动态地选择加载各种程序模块。\n\nELF动态链接文件以.so为扩展名，在Windows系统中动态链接库以.dll为扩展名。\n\n## 地址无关代码\n\n显然，动态链接必然要求共享对象在被装载前无法得知其装载地址。与链接时重定位不同，由于指令是多个进程之间共享的，共享对象映射到每个进程的地址空间中的虚拟地址是不同的，从而指令中对绝对地址的引用也是不同的，这就导致指令部分无法在多进程之间共享。\n\n解决办法是将指令中会因装载地址改变而改变的部分分离出来，与数据部分放在一起。于是多个进程可以共享指令部分，而数据部分每个进程都有一个副本。这就是地址无关代码。\n\n那么编译器如何编写地址无关的代码，先考虑在源代码中有哪些地址引用方式。按照是否跨模块与指令引用OR数据访问分成如下。\n\n* 模块内部的函数调用、跳转；\n* 模块内部的数据访问；\n* 模块外部的函数调用、跳转；\n* 模块外部的数据访问；\n\n**对于第一种地址引用方式** 被调用函数与调用指令的相对位置固定，可使用相对地址调用或基于寄存器的相对调用，对于这种指令无需重定位。\n\n**对于第二种地址引用方式** 被访问变量与访问指令的相对位置固定，但是，现代的计算机体系结构中没有相对于当前指令地址的寻址数据方式，因此在ELF文件中用如下巧妙的方式来得到当前指令地址；\n\n在需要知道当前指令地址的指令前调用`__i686.get_pc_thunk.cx`函数如下所示；\n\n```assembly\n00000494 <__i686.get_pc_thunk.cx>:\n 494:   8b 0c 24               mov (%esp), %ecx\n 497:   c3                     ret\n```\n\n这时因为CPU执行call指令时会将下一指令的地址压栈，而esp寄存器始终指向栈顶，因此`__i686.get_pc_thunk.cx`函数的作用就是将需要知道的指令地址存入ecx寄存器。之后加上偏移得到数据的绝对地址即可访问变量。\n\n**对于第四种地址引用方式** 被访问变量所在模块的装载地址在装载前不确定，因此被访问变量的绝对地址在装载前也不确定。为保证代码的地址无关性，ELF在数据段建立一个指向这些变量的指针数组——全局偏移表GOT，代码通过GOT中对应项间接访问变量。链接器在装载模块时会查找每个变量所在地址，并填充.got表中各项。而访问.got表中对应项即第二种地址引用方式。\n\n**对于第三种地址引用方式** 为加快程序的启动速度，ELF对于模块外部的函数采用**延迟绑定**——当函数第一次被调用时将其绑定。ELF将GOT拆分为.got与.got.plt两个表，分别保存全局变量的地址与外部函数的地址；其中，.got.plt的前三项分别为.dynamic段的地址、本模块的ID、_dl_runtime_resolve函数的地址，之后就是外部函数的地址。不同的是，链接器在装载模块时并不会将外部函数进行绑定。\n\n使用readelf查看所有段的信息。\n\n```bash\nobjdump -s -d Lib.so\n```\n\n### 延迟绑定的实现\n\n为了实现延迟绑定，ELF在间接访问外部函数的过程中增加了一次间接跳转，调用外部函数gfun时先跳转到外部函数在.plt表中对应项gfun@plt，gfun@plt的实现如下。\n\n```assembly\ngfun@plt:\njmp *(gfun@got) #gfun@got为gfun在.got表中对应项，即gfun的地址，为实现延迟绑定，gfun@got最初存放的是下面push n指令的地址\npush n #n为gfun这个符号在重定位表.rel.plt中的下标\njmp PLT0\n```\n\n其中，PLT0为.plt表中第一项，它的实现为\n\n```assembly\npush *(GOT+4) #GOT为.got.plt表的地址，而根据.got.plt表的前三项内容可知，该指令是将本模块的ID压栈\njmp *(GOT+8) #同理，该指令跳转到_dl_runtime_resolve函数处执行，该函数用来绑定gfun函数，前面的压栈是模拟函数的参数进栈\nnopl #.plt表中每一项为16字节\n```\n\n要使gcc编译时产生地址无关代码，加上-fPIC选项即可。要想判断一个so文件是否是地址无关代码，可使用如下命令。\n\n```bash\nreadelf -d lib.so | grep TEXTREL\n```\n\n### 共享对象的全局变量\n\n由于共享对象的全局变量可能在模块外部修改，因此编译器在编译共享对象时，默认将模块内部的全局变量当作模块外部的全局变量。采用上述第四种地址引用方式访问全局变量。共享对象被装载时，对其中的全局变量var：若var在可执行文件中被分配了空间，则var在GOT中的地址指向可执行文件中的var(若var在共享对象中被初始化，还需要将初始化的值复制到可执行文件的var)；否则，var在GOT中的地址指向共享对象内的var。\n\n## 动态链接相关结构\n\n### .interp段\n\n.interp段中保存可执行文件所需动态链接器的路径。通常为/lib64/ld-linux-x86-64.so.2，这是一个软链接，从而动态链接器更新版本时只需要将/lib64/ld-linux-x86-64.so.2指向新的动态链接器，而不用改动可执行文件的.interp段。\n\n### .dynamic段\n\n.dynamic段保存动态链接器所需的基本信息(依赖的共享对象、动态链接符号表地址、动态链接重定位表地址，共享对象初始化代码地址等)。.dynamic段就是一个结构体数组，结构体定义如下。\n\n```c\ntypedef struct{\n    Elf32_Sword d_tag;\n    union{\n        Elf32_Word d_val;\n        Elf32_Addr d_ptr;\n    }d_un;\n}Elf32_Dyn;\n```\n\nd_tag代表后面的d_un的含义，常见的d_tag类型及其含义如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n&nbsp;\n\n使用readelf工具可查看.dynamic段的内容。\n\n```bash\nreadelf -d Lib.so\n```\n\n### 动态符号表\n\n保存动态链接的共享模块间符号的导入导出关系。动态符号表在可执行文件中为.dynsym段。\n\n### 动态链接重定位表\n\n.rel.dyn段修正的地址位于.got段与数据段，.rel.plt修正的地址位于.got.plt(也存在.got未被拆分的情况，此时.rel.plt修正的符号也位于.got)。使用readelf工具可查看可执行文件的重定位表。\n\n```bash\nreadelf -r Lib.so\n```\n\n其中有如下三种类型的重定位入口：R_386_RELATIVE、R_386_GLOB_DAT、R_386_JUMP_SLOT。R_386_GLOB_DAT与R_386_JUMP_SLOT。被修正位置只需要直接填入符号的地址即可；R_386_RELATIVE入口的重定位方式为基址重置，这是由于编译器在编译共享对象时，为其分配的地址空间从0开始，假设一个静态变量的地址为B，则对此静态变量的地址重定位时，再加上共享对象的装载地址A，即A+B。\n\n### 进程堆栈初始化\n\n同样地，操作系统在将控制权交给动态链接器之前，会在进程的堆栈中保存动态链接器所需信息，以辅助信息结构体数组的形式存放，结构体定义如下。\n\n```c\ntypedef struct{\n    uint32_t a_type;\n    union{\n        uint32_t a_val;\n    }a_un;\n}Elf32_auxv_t;\n```\n\n该结构体定义与.dynamic段的结构体定义类似，a_type为类型值，a_val为数值，常见的类型及其含义如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n<div style=\"width:60%;margin:auto\">{% asset_img 10.png pic10 %}</div>\n\n&nbsp;\n\n辅助信息数组存放在环境变量指针之后。","tags":["系统编程"],"categories":["course"]},{"title":"第五章 可执行文件的装载与进程","url":"/course/sp-ch5.html","content":"\n## 可执行文件的装载\n\n### 进程的建立\n\n* 创建虚拟地址空间。事实上只需要分配一个页目录表。其中的内容等到发生缺页中断再填写。\n* 读取可执行文件头，建立虚拟地址空间与可执行文件的映射关系。以便在发生缺页中断时定位到该缺页在可执行文件中的位置。\n* 将可执行文件入口地址写入CPU指令寄存器，CPU开始运行。\n\n## 进程的虚拟空间分布\n\n### Segment & Section\n\n在操作系统装载可执行文件时，对每个段只区分其权限(可读可执行、可读可写、只读)。为了提高内存的利用效率，可将相同权限的段合并，这时用Segment表示相同权限的段的合并。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\nSegment的信息保存在ELF可执行文件的程序头表中。\n\n### 堆与栈\n\n常见的进程的虚拟地址空间如下。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n&nbsp;\n\n堆与栈共用同一内存区域，统称堆栈。堆从区域底部向上增长，栈从区域顶部向下增长，可用如下程序验证。\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nunsigned int stack_inc_dir(unsigned int * pid){\n\tunsigned int id=0x42;\n\tif(pid){\n\t\tid++;\n\t\tprintf(\"Stack increase from %p to %p\\n\", pid, & id);\n\t\treturn id;\n\t}\n\telse\n\t\treturn stack_inc_dir(& id);\n}\n\nunsigned int heap_inc_dir(){\n\tunsigned int * ip1, * ip2;\n\tif(!(ip1=(unsigned int *)malloc(16))||\n\t\t\t!(ip2=(unsigned int *)malloc(64)))\n\t\treturn -1;\n\tprintf(\"Heap increase from %p to %p\\n\", ip1, ip2);\n\treturn 0;\n}\n\nint main()\n{\n\treturn stack_inc_dir(NULL)|heap_inc_dir();\n}\n//gcc stack_heap.c -o stack_heap\n```\n\n### 多段共享\n\n由于页是(虚拟地址与物理地址)映射的最小单位。因此每一段的起始地址都要是4K的整数倍，这样会产生大量的内部碎片，从而极大降低了内存的利用效率。为此，Unix让各段相接部分共享同一物理页面，具体做法如下例。\n\nELF文件的起始虚拟地址为0x08048000，第一个虚拟内存区域VMA0的长度为0x709e5，因此第一个虚拟内存区域VMA0的结束地址为0x080b89e5。VMA0并未将以0x080b8000为起始地址的虚拟页对应的物理页面用完，于是VMA0要与下一段共享以0x080b8000为起始地址的虚拟页对应的物理页面。又因为段的起始地址必须是4字节的倍数，因此下一段从下一虚拟页的0x9e8偏移处开始，即0x080b99e8。\n\n### 进程栈的初始化\n\n进程在刚开始启动时，需要知道一些进程运行的环境参数，常见的做法是操作系统在进程启动前将这些信息保存到进程的虚拟地址空间的堆栈上。在bash上以`prog 123`命令运行的进程的栈的初始化状态如下图所示。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n栈顶指针esp指向栈顶(堆栈区域的最低地址)，首4字节存放命令行参数的数目。接下来的两个4字节为指向两个参数的指针，然后一个值为0的4字节，作为分隔标记。接下来的两个4字节存放环境变量的指针。然后一个值为0的4字节，作为分隔标记。然后是命令行参数与环境变量。\n\n## ELF可执行文件的装载\n\n宏观层面来说，Linux调用exec来装载可执行文件到内存。而exec调用sys_execve，sys_execve进行一些参数的检查复制后，调用do_execve，do_execve首先查找被执行的文件，如果找到，则读取其前128字节(这是因为Linux支持的可执行文件不止一种，因此需要通过文件最开始的128字节来判断文件格式)，对于ELF可执行文件，do_execve确定其文件格式后，调用load_elf_binary来装载ELF可执行文件。load_elf_binary处理流程如下。\n\n* 检查ELF可执行文件格式的有效性。\n* 寻找动态链接的`.interp`段，设置动态链接器路径。\n* 根据程序头表建立虚拟地址空间与可执行文件的映射。\n* 初始化进程的运行环境。\n* 修改系统调用的返回地址为ELF可执行文件的入口地址(对于静态链接的ELF文件，程序入口地址为ELF文件头中e_entry所指地址；对于动态链接的ELF文件，程序入口地址为动态链接器地址)。","tags":["系统编程"],"categories":["course"]},{"title":"第四章 静态链接","url":"/course/sp-ch4.html","content":"\n## 空间与地址分配\n\n链接器获得所有输入目标文件的段长度，将每种段合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。\n\n## 符号解析与重定位\n\n链接器将目标文件合并后，根据合并文件中的段的数据、重定位信息进行符号解析与重定位，调整代码中的地址。\n\n### 重定位\n\n目标文件中每个需要重定位的段都有一个对应的重定位段。例如，如果代码段需要重定位，则目标文件中会有一个.rela.text段，重定位表是所有重定位段的统称。使用objdump工具来查看目标文件的重定位表。\n\n```bash\nobjdump -r simple_section.o\n```\n\n重定位表的每一项的结构定义如下。\n\n```c\ntypedef struct {\n    Elf32_Addr r_offset;\n    Elf32_Word r_info;\n}\n```\n\n* r_offset。重定位入口的偏移。对于可重定位文件来说，r_offset为该重定位入口所要修正的位置的第一个字节相对于段起始的偏移。对于可执行文件或共享对象来说，r_offset是该重定位入口所要修正的位置的第一个字节的虚拟地址。\n* r_info。重定位入口的类型与符号。低8位表示重定位入口的类型，高24位表示重定位入口的符号在符号表中的下标。\n\n### 指令修正方式\n\n重定位入口的类型有两种：绝对近址32位寻址与相对近址32位寻址，不同的重定位入口类型的指令修正方式也不同。记\n\nA为保存在修正位置的值\n\nP为被修正的位置\n\nS为符号的实际地址\n\n则绝对近址32位寻址的修正方法为S+A，相对近址32位寻址的修正方法为S+A-P。\n\n## BFD库\n\n不同的软硬件平台导致了不同的目标文件格式不同，为了使编译器能够统一地处理这些目标文件，BFD库提供一个统一的接口来处理不同的目标文件格式。","tags":["系统编程"],"categories":["course"]},{"title":"第三章 目标文件","url":"/course/sp-ch3.html","content":"\n## 目标文件的格式\n\n不仅是目标文件(.o与.obj)按照可执行文件(.elf与.exe)格式存储，动态链接库(.so与.dll)与静态链接库(.a与.lib)也按照可执行文件格式存储。对于静态链接库，稍有不同的是它将多个目标文件拼在一起，再加上一些索引形成一个文件。ELF文件标准将系统中采用的ELF格式的文件分为如下4类。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n<div style=\"width:70%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\n在Ubuntu上可使用file命令查看一个文件的格式。\n\n## 目标文件的内容\n\n可执行文件主要有.text代码段(存放执行指令)，.data数据段(已初始化的全局变量与局部静态变量)，.bss段(未初始化的全局变量与局部静态变量)。.bss段为未初始化的全局变量与局部静态变量预留位置，在文件中不占据空间。\n\nQ：分段的好处？\n\nA：安全性(数据段可读，代码段可执行)，共享(当系统运行程序的多个副本，内存中只需要保存一份程序的指令部分，即代码段)，良好的局部性。\n\n### 整体结构\n\n使用objdump工具来查看目标文件的结构与内容。\n\n```bash\n# -c参数指定只编译，不链接\ngcc -c simple_section.c\n# -h参数指定只打印各个段的基本信息\nobjdump -h simple_section.o\n```\n\n其中simple_section.c内容如下。\n\n```c\n#include <stdio.h>\n\nunsigned int global_init_var=84;\n\nunsigned int global_uninit_var;\n\nint func(unsigned int);\n\nint func(unsigned int N){\n\tunsigned int X,Y;\n\tX=N;\n\tY=N+1;\n\twhile(X){\n\t\tY+=X;\n\t\tX--;\n\t}\n\treturn Y;\n}\n\nint main(char * * argv, int argc){\n\tunsigned int ret;\n\tret=func(global_init_var);\n\tprintf(\"func(global_init_var)=%d\\n\", ret);\n\treturn 0;\n}\n```\n\n分析结果如下。\n\n```bash\nsimple_section.o:     file format elf64-x86-64\n\nSections:\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .text         00000069  0000000000000000  0000000000000000  00000040  2**0\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE\n  1 .data         00000004  0000000000000000  0000000000000000  000000ac  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  2 .bss          00000000  0000000000000000  0000000000000000  000000b0  2**0\n                  ALLOC\n  3 .rodata       0000001a  0000000000000000  0000000000000000  000000b0  2**0\n                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n  4 .comment      0000002a  0000000000000000  0000000000000000  000000ca  2**0\n                  CONTENTS, READONLY\n  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000f4  2**0\n                  CONTENTS, READONLY\n  6 .eh_frame     00000058  0000000000000000  0000000000000000  000000f8  2**3\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA\n```\n\n可以看到simple_section.o有如下段：.text、.data、.bss、.rodata、.comment、.note.GNU-stack、.eh_frame。各段的分布大致如下。\n\n```bash\n      |        |\n      |--------|0xf4\n      |        |\n0x2a  |.comment|\n      |        |\n      |        |\n      |--------|0xca\n      |        |\n0x1a  |.rodata |\n      |        |\n      |--------|0xb0\n0x04  |.data   |\n      |------- |0xac\n      |------- |0xa9\n      |        |\n      |        |\n0x69  |        |\n      |.text   |\n      |        |\n      |        |\n      |--------|0x40\n```\n\n此外，readelf工具可对ELF格式文件进行分析。\n\n### 代码段\n\n使用objdump也可以查看代码段。\n\n```bash\n#-s 参数指定以16进制打印数据，-d 参数将指令部分反汇编\nobjdump -s -d simple_section.o\n```\n\n### 只读数据段\n\n在.rodata段中存放只读数据，一般是程序中的字符串常量与const修饰的变量。\n\n### 数据段\n\n数据段信息如下。\n\n```bash\nContents of section .data:\n 0000 54000000                             T...            \n```\n\n从这里可以看出：x86架构的CPU使用的小端字节序(高位字节存放在高地址，低位字节存放在低地址)，与之对应的还有大端字节序(网络设备传输字节使用大端字节序，高位字节存放在低地址，最先传输)。\n\n### 其他段\n\n其他段的说明如下。\n\n<div style=\"width:70%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\nGCC提供扩展机制使程序编写者可指定变量所处段：`__attribute__((section(\"name\")))`。\n\n## ELF文件结构\n\n<div style=\"width:35%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n### 文件头\n\n使用readelf工具来查看ELF的文件头。\n\n```bash\nreadelf -h simple_section.o\n```\n\n### 段表\n\n段表描述ELF文件各个段的信息，包括每个段的名称、长度、偏移、读写权限等。\n\n用readelf工具来查看段表的内容。\n\n```bash\nreadelf -S simple_section.o\n```\n\n段表中的元素是`段描述符`，第一个元素为NULL，无效的段描述符。\n\n### 重定位表\n\n链接器在链接目标文件时，需要对来自其他模块的变量或函数进行重定位。需要重定位的变量或函数以及重定位所需的信息保存在重定位表中。\n\n### 字符串表\n\n由于字符串的长度不固定，为了用固定的长度表示字符串，常见的做法为：将字符串集中存放到一个字符串表，然后使用字符串在表中偏移来引用字符串。\n\n## 符号\n\n在链接时，函数与变量统称为符号，函数名或变量名即为符号名。目标文件中都有一个符号表，记录了目标文件中所有符号及其相关信息(符号名、符号值、符号大小、符号类型与绑定信息、符号所在段)。链接器重点关注每个目标文件中的定义全局符号与被引用的全局符号。\n\n### 符号表结构\n\n符号表在目标文件中通常作为一个段——.symtab，使用readelf工具来查看目标文件的符号表。\n\n```bash\nreadelf -s simple_section.o\n```\n\n### 特殊符号\n\n链接器在链接目标文件时会定义很多特殊符号，虽然未在源代码中定义，但是可以直接声明并引用它们。这就是特殊符号。如下例。\n\n```c\n#include <stdio.h>\n\nextern char __executable_start[];\nextern char etext[], _etext[], __etext[];\nextern char edata[], _edata[];\nextern char end[], _end[];\n\nint main()\n{\n\tprintf(\"Executable start %X\\n\", __executable_start);\n\tprintf(\"Text end %X %X %X\\n\", etext, _etext, __etext);\n\tprintf(\"Data end %X %X\\n\", edata, _edata);\n\tprintf(\"Executable end %X %X\\n\", end, _end);\n\treturn 0;\n}\n```\n\n### 符号修饰与函数签名\n\n为了防止符号名冲突，Unix下C语言规定：源代码中所有全局变量与函数经过编译后在符号名前加\"_\"。C++为支持重载，编译器增加了符号修饰机制。修饰后的名称因函数名、参数类型、所在类与名称空间等性质的不同而不同。\n\n### extern \"C\"\n\nC++编译器会将`extern \"C\"`的大括号内部的代码当作C语言处理。相应地，若C++源代码中要包含C语言库，就存在符号修饰不一致的问题，为解决这个问题，借助宏`__cplusplus`，C++编译器在编译C++源代码时会定义这个宏，于是可以通过这个宏是否被定义判断当前编译的语言是C语言还是C++。而如果是C++，则包含C语言库的语句要用`extern \"C\"`括号包含。\n\n### 弱符号与强符号\n\n对C语言与C++，编译器默认函数与初始化了的全局变量为强符号，未初始化的全局变量为弱符号。使用`__attribute__((weak))`在GCC编译时将强符号修饰为弱符号。\n\n在链接时，强符号不允许被多次定义；若一个符号在某个目标文件中是强符号，而在其他文件中是弱符号，链接器选择链接强符号；若一个符号在所有目标文件中均为弱符号，链接器选择链接占用空间最大的那个。\n\n**弱引用与强引用**：对一个强引用的符号，若链接器在链接时找不到该符号的定义，则会报符号未定义错误，而对于弱引用符号，则不会报错。使用`__attribute__((weakref))`可将对一个函数的引用声明为弱引用。","tags":["系统编程"],"categories":["course"]},{"title":"第二章 编译与链接","url":"/course/sp-ch2.html","content":"\n## 预处理\n\n预处理主要处理源代码文件中以`#`开头的预处理指令，预处理的工作如下：\n\n* 删除所有`#define`，展开所有宏定义；\n* 处理所有条件预处理指令(如`#if`、`#endif`、`#elif`、`#else`、`#endif`)；\n* 处理`#include`预处理指令，将被包含的文件插入预处理指令的位置。\n* 删除所有的注释；\n* 添加行号与文件名标识；\n* 保留所有`#pragma`编译器指令；\n\ngcc使用如下命令进行预处理。\n\n```bash\ngcc -E hello.c -o hello.i\n```\n\n## 编译\n\n* 词法分析：使用一种类似于有限自动机的算法将源代码的字符序列分割为一系列的记号。在Ubuntu上有一个flex的程序可实现词法分析。\n* 语法分析：使用上下文无关语法对词法扫描的记号进行语法分析，生成语法树。在Ubuntu是有一个bison的程序可实现语法分析。\n* 语义分析：静态语义分析包括声明、类型的匹配与转换。\n* 中间优化：源代码优化器将语法树转换成中间代码，然后对中间代码进行优化。中间代码使得编译器被分成前端与后端，前端负责产生与机器无关的中间代码，后端将中间代码转换成目标机器代码。这样，跨平台的编译器只需要一个前端，而针对不同的目标机器设计不同的后端。\n* 目标代码生成与优化：后端包括代码生成器与目标代码优化器。\n\n经过上述步骤得到的目标代码还有一个问题没有解决——定义在其他模块的变量与函数的地址怎么确定？这需要借助链接器！\n\n## 汇编\n\n将汇编代码转换为机器语言。\n\n## 链接\n\n链接包括地址与空间分配、符号绑定与重定位(链接器在链接时修正跨模块函数、变量的地址)。","tags":["系统编程"],"categories":["course"]},{"title":"第一章 前言","url":"/course/sp-ch1.html","content":"\n## Questions\n\n(1)程序为什么要被编译器编译之后才能运行？\n\n(2)编译器是如何将C语言程序转化成可执行的机器码的？\n\n(3)可执行文件中有哪些内容，它们是如何组织的？\n\n(4)解释`#include<stdio.h>`的作用，C语言库是什么？要如何实现？\n\n(5)不同的编译器、硬件平台以及操作系统，编译同一源代码的结果是否相同？为什么？\n\n(6)一个程序是如何运行的？(如何装载、从哪里执行、到哪里结束、结束之后又会发生什么)\n\n(7)一个程序在没有操作系统的机器上如何才能运行？\n\n(8)printf函数是如何实现的？\n\n(9)程序在运行时，它在内存中的组成？\n\n在学习完《程序员的自我修养》之后，对上述问题的[回答](http://localhost:4000/course/sp-ch11.html)。\n\n## 线程\n\n### 线程基础\n\n**可抢占线程与不可抢占线程**：线程在时间片用尽之后，被操作系统剥夺继续执行的权利而进入就绪状态，这个过程称为抢占。在早期的操作系统中，线程是不可抢占的，只有运行的线程主动发出放弃执行的命令，才能让其他就绪态线程获得CPU。\n\n### 线程安全\n\n**信号量、互斥量、临界区**：信号量可以跨进程使用，允许一个或多个线程访问共享资源，可以被任意线程申请与释放；互斥量可以跨进程使用，资源在任何时刻最多被一个线程占用，但是只有获取了互斥量的线程可以释放互斥量；临界区作用于进程内部，临界区中的资源在任何时刻最多被一个线程占用。\n\n**可重入**：一个函数在未执行完的情况下，由于外部因素或内部调用，又一次进入自身执行。一个函数称为可重入的，即该函数被重入后不会产生任何不良后果。需满足如下条件：\n\n* 不使用任何(局部)静态或全局的非const变量；\n* 不返回任何(局部)静态或全局的非const变量的指针；\n* 仅依赖于调用方提供的参数；\n* 不依赖任何单个资源的锁；\n* 不调用任何不可重入的函数；\n\n**过度优化**：编译器在优化时，为了提高效率而交换两条互不相关的指令的执行顺序。CPU的动态调度技术，在执行程序时为提高效率而交换两条指令的执行顺序。\n\n为解决这些优化而导致的多线程错误。在代码中加入volatile关键字阻止过度优化，它可以做到两件事：(1)阻止编译器为了提高运行速度将一个变量缓存到寄存器而不写回；(2)阻止编译器调整volatile变量的指令顺序。\n\nCPU提供barrier指令，一条barrier指令指令阻止CPU将该指令之前的指令交换到barrier，反之亦然。","tags":["系统编程"],"categories":["course"]},{"title":"第五章 常见网络攻击","url":"/course/cn-ch5.html","content":"\n[第一节 ARP欺骗与泛洪](https://KangMing-ux.github.io/course/cn-ch5-par1.html)\n\n[第二节 拒绝服务攻击](https://KangMing-ux.github.io/course/cn-ch5-par2.html)\n\n[第三节 XSS攻击](https://www.cnblogs.com/tugenhua0707/p/10909284.html)","tags":["计算机网络"],"categories":["course"]},{"title":"第五章第二节 拒绝服务攻击","url":"/course/cn-ch5-par2.html","content":"\n## 拒绝服务攻击简介\n\n拒绝服务是一种耗尽CPU、内存、带宽、磁盘资源等系统资源，来阻止或削弱对网络、系统或应用程序的授权使用的行为。\n\n拒绝服务攻击使用到洪泛法、源地址欺骗、SYN欺骗等方法。下面介绍经典的拒绝服务攻击。\n\n## 洪泛攻击\n\n洪泛攻击利用大量的恶意数据包来充斥整个网络，由于这种网络阻塞，在到达目标服务器的路径上很多数据包被丢弃，合法的流量很难在\n\n洪泛攻击中存活下来，使得服务器对网络上连接请求的响应能力急剧下降。可使用ICMP、UDP、TCP SYN数据包进行洪泛攻击。\n\n### 分布式拒绝服务攻击\n\n攻击者首先入侵多台主机使其被控制，然后控制这些主机一起发送恶意数据包。\n\n### 反射攻击\n\n反射攻击，是利用网络服务系统中的正常功能，向网络服务系统发送请求(源地址为目标系统的IP地址)让其对目标系统进行响应，网络服务系统向目标系统返回大量的响应数据包来占用目标系统大量资源，从而完成攻击。反射攻击一般要求利用的网络服务能够由较少数据的请求产生较大数据的响应，如Chargen,NDS,SNMP或ISAKMP服务等。\n\n## TCP SYN Flood\n\n### 攻击原理\n\n与洪泛攻击不同(攻击带宽)，还有一类拒绝服务攻击，它是通过大量占用系统资源来导致服务器无法对其他正常的网络请求作出响应。著名的就是TCP SYN Flood。其攻击原理如下。\n\n由TCP三次握手的步骤，客户端首先发送SYN请求，服务器返回SYN+ACK响应，而如果SYN请求是伪造的，报文中的源IP并未发起TCP请求，于是当服务器返回SYN+ACK响应返回给源IP主机时，此主机不会作出回应。而服务器如果没有收到回应，会重试3-5次并等待一个SYN Time。\n\n攻击者只需发送一定量的伪造SYN请求至目标主机，就可以使服务器消耗大量系统资源来保留TCP半连接，当服务器的TCP连接表被占完，就会使得服务器无暇顾及合法的TCP请求连接。\n\n### 防御策略\n\n**Cookie源认证**：当服务器收到第一个SYN请求报文时，让Dos防护系统来响应，同样返回一个SYN+ACK响应(但这不是TCP组件响应的，而是Dos防护系统)，若SYN请求报文不是伪造的，请求主机会返回ACK字段为seq+1的ACK报文，而如果SYN报文是伪造的，所谓的请求主机并不会返回ACK字段为seq+1的ACK报文。\n\n**首包丢弃**：根据TCP可靠重传特性，服务器在首次收到SYN请求报文后，并不作回应，如果是正常请求，源主机在一段时间内没有收到SYN+ACK响应时会再次发送SYN请求。","tags":["计算机网络"],"categories":["course"]},{"title":"第五章第一节 ARP欺骗与泛洪","url":"/course/cn-ch5-par1.html","content":"\n## 常见ARP攻击\n\n(1)ARP欺骗；攻击者发送伪造的ARP应答报文来恶意修改网关或网络中其他主机的ARP表项，造成用户或网络的报文转发异常。\n\n(2)ARP泛洪；攻击者向网络中发送大量目的IP地址无法解析的ARP请求报文，造成网络设备上ARP表项溢出，无法缓存正常用户的ARP表项。\n\n## 防御策略\n\n### 防御ARP欺骗\n\n设备收到ARP应答报文后，对其MAC头部的源、目的MAC地址与ARP报文数据段中的源、目的MAC地址进行一致性检查，若不一致，则丢弃此ARP报文。\n\n### 防御ARP泛洪\n\n禁止接口学习ARP表项的功能或配置ARP表项严格学习(只学习自己请求的ARP应答报文、限制接口可以学习的ARP表项的总数目、或限制一定时间内可以学习的ARP表项的数目，即限速，等等)\n\n<div style=\"width:100%;margin:auto\">{% asset_img 56.png pic56 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第四章 应用层","url":"/course/cn-ch4.html","content":"\n[第一节 域名系统DNS](https://KangMing-ux.github.io/course/cn-ch4-par1.html)\n\n[第二节 文件传送协议](https://KangMing-ux.github.io/course/cn-ch4-par2.html)\n\n[第三节 万维网](https://KangMing-ux.github.io/course/cn-ch4-par3.html)\n\n[第四节 动态主机配置协议](https://KangMing-ux.github.io/course/cn-ch4-par4.html)","tags":["计算机网络"],"categories":["course"]},{"title":"第四章第四节 动态主机配置协议","url":"/course/cn-ch4-par4.html","content":"\n连接到互联网中的计算机需要配置一些信息比如IP地址、子网掩码、默认路由器的IP地址、域名服务器的IP地址等。互联网广泛采用动态主机配置协议DHCP，它提供一种机制——即插即用连网。\n\nDHCP基于UDP。需要IP地址的主机在启动时向DHCP服务器广播DHCP发现报文(目的IP为255.255.255.255，源IP为0.0.0.0)，只有DHCP服务器才会回复此广播报文，DHCP服务器先在其数据库中查找此计算机的配置信息，若无，则从IP地址池中取一个地址分配给该计算机。\n\n事实上，并非每个网络上都有一个DHCP服务器，如果没有，则会有一个DHCP代理，当它收到DHCP发现报文后，转发给DHCP服务器并等待其回复，然后将回复报文返回客户主机。\n\nDHCP分配给主机的IP地址只是临时的，DHCP客户使用68端口、服务器使用69端口。DHCP协议工作过程如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 53.png pic53 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第四章第三节 万维网","url":"/course/cn-ch4-par3.html","content":"\n## 统一资源定位符URL\n\nURL一般格式为：<协议>://<主机>:<端口>/<路径>。\n\n## 超文本传送协议HTTP\n\nHTTP协议基于TCP协议。HTTP协议的端口号为80。HTTP是无连接的、无状态的。\n\n### HTTP的操作过程\n\n如下是一个建立HTTP请求到收到HTTP响应的过程示意图。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 46.png pic46 %}</div>\n\n&nbsp;\n\n可以看到，整个从建立HTTP请求到收到HTTP响应所花的时间=2RTT+服务器处理时间。而HTTP1.0规定服务器发送完响应消息后，要主动执行断开操作，而HTML文档与图片被视为独立的对象，因此要获取一个有多个图片的网页的全部内容时就需要多次HTTP请求与释放，这使得获取数据的效率很低。于是，HTTP1.1采用持续连接，即服务器在发送响应后的一段时间仍然保持这条连接。\n\n### 代理服务器\n\n代理服务器可减轻网络上的负载。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 47.png pic47 %}</div>\n\n&nbsp;\n\n### HTTP报文结构\n\nHTTP有两类报文：HTTP请求报文与HTTP响应报文。区别在于开始行不同。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 48.png pic48 %}</div>\n\n&nbsp;\n\nHTTP请求报文中的一些方法如下。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 49.png pic49 %}</div>\n\n&nbsp;\n\nHTTP请求报文中的一些首部字段如下。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 50.png pic50 %}</div>\n\n&nbsp;\n\nHTTP响应报文中的一些首部字段如下。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 51.png pic51 %}</div>\n\n&nbsp;\n\n实体中用到的一些字段如下。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 52.png pic52 %}</div>\n\n&nbsp;\n\n状态码是一个3位数，分为5大类。\n\n1XX表示通知信息；2XX表示成功；3XX表示重定向；4XX表示客户的差错；5XX表示服务器的差错。\n\n### Cookie\n\n当用户A浏览某个使用Cookie的网站时，网站的服务器为A产生一个唯一的识别码，并以此为索引在服务器后端数据库中产生一个项目。\n\n接着在给A的响应报文中添加一个Set-cookie的首部行(如Set-cookie: 31d4d96e407aad42)；\n\n当A收到响应后，其浏览器就在它管理的特定Cookie文件中添加一行，其中包括服务器的主机名及其给出的识别码；\n\n当A继续浏览网站时，每发送一个HTTP请求报文，浏览器均会从Cookie文件中取出此网站的识别码，并放到HTTP请求报文的首部行(Cookie: 31d4d96e407aad42)。\n\n于是，这个网站就能跟踪用户A在该网站的活动。\n\n## HTTPS\n\n### TLS握手\n\nHTTPS相对于HTTP，在建立TCP连接后，还需要进行TLS握手来协商出加密的参数。TLS握手示意图如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 54.png pic54 %}</div>\n\n&nbsp;\n\n(1)客户端向服务器发送Hello报文，其中包含客户端生成的随机数C、客户端的TLS版本号、支持的密码套件列表以及扩展列表。\n\n(2)服务器回复ACK报文；服务器向客户端发送Hello报文(选择了用来协商密钥的非对称加密算法后，自己计算出一对公私钥)，其中包含服务器生成的随机数S、对TLS版本号的确认、选择使用的密码套件(非对称加密算法与对称加密算法)、本服务器的证书，公钥与私钥的签名。\n\n(3)客户端回复ACK报文；然后验证证书与签名，确认无误后，自己计算出一对公私钥，并发送自己的公钥给服务器；客户端根据C、S与协商出来的密钥pre_master计算出主密钥master_secret，这将用来派生出对称加密密钥。同时，服务器按照相同的方式计算出主密钥master_secret。\n\n(4)此时客户端与服务器都能知道所有派生出的密钥，注意双方对称加密的密钥是不同的，这主要是为了进一步提高安全性，但是双方都可以解密出对方加密的密文。\n\n(5)客户端发送Change Cipher spec报文表明之后使用对称加密进行通信，并且发送对所有握手数据的摘要的加密密文(Finish报文)供服务器验证。\n\n(6)服务器回复ACK报文；不等服务器向客户端发送Change Cipher spec报文与Finish报文，客户端就开始向服务器发送加密的HTTP请求报文，这就是False start。\n\n(7)服务器回复ACK报文；服务器向客户端发送Change Cipher spec报文与Finish报文。\n\n(8)客户端回复ACK报文；之后双方进入HTTP加密通信。\n\n### HTTPS优化\n\n通常所说\"HTTPS连接慢\"就是指刚开始建立时相对于HTTP增加了TLS握手。而在对称加密通信过程中，对称加密算法的软硬件优化已经做得很好。对于HTTPS，有如下方面可以优化。\n\n* HSTS重定向技术。启用HSTS后，保证浏览器始终连接到网站的HTTPS加密版本，省去301跳转的出现，缩短访问时间。\n* TLS握手优化。使用ECDHE椭圆曲线密码套件，可以节约带宽与计算量，还能实现False start。\n* 会话标识符复用。\n  * 服务器为每次会话生成并记录一个ID号，发送给客户端；\n  * 若客户端重新发起连接，则要向服务器发送此ID号；\n  * 服务器收到客户端发来的ID号，查找自己的会话记录，匹配ID后，双方就可以重新使用之前协商好的密钥进行加密通信；\n* 开启OSCP装订。服务器主动获取OSCP查询结果与证书一起发送给客户端，客户端可直接验证证书，省去浏览器的在线验证过程；\n* 完全前向加密。采用ECDHE算法，每次握手都会生成一对临时的公私钥，每次通信的密钥对均不同，即使之前的密钥被泄露，目前进行的加密通信也是安全的。\n\n参考链接\n\n* [TLS握手](https://www.cnblogs.com/wxcx/p/12775311.html)\n* [HTTPS](https://blog.csdn.net/qq_35642036/article/details/82788421)","tags":["计算机网络"],"categories":["course"]},{"title":"第四章第二节 文件传送协议","url":"/course/cn-ch4-par2.html","content":"\n## FTP概述\n\n文件传送协议FTP提供交互式访问，允许客户指明文件的类型与格式，并允许文件具有存取权限，它屏蔽了各计算机系统的细节，适于异构网络中任意计算机之间的文件传输。\n\nFTP协议规定：若要存取文件，则必须在本地获得一个文件副本；若要修改文件，只能对文件的副本进行修改，修改完再将文件的副本复制回去。\n\nFTP与数据库系统不同的是：FTP由操作系统的文件系统提供对共享文件的透明存取。\n\n## FTP的工作原理\n\nFTP使用客户服务器方式，一个FTP服务器进程可同时为多个客户进程提供服务。FTP服务器进程由两类组成：主进程(负责接受新的请求)与从属进程(负责处理单个请求)。主进程的工作步骤如下：\n\n* 打开计算机的21端口；\n* 等待客户进程发起连接请求；\n* 启动一个从属进程处理客户进程发来的请求，然后自己回到(2)；\n\n在进行文件传输时，FTP的客户与服务器之间要建立两条并行的TCP连接——控制连接与数据连接，控制连接用来传输建立连接的信息，数据连接用来传输数据。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 45.png pic45 %}</div>\n\n## 简单文件传送协议TFTP\n\nTFTP协议基于UDP，因此有它自己的差错改正措施，它只支持文件传输而不支持文件交互。TFTP的工作类似停止等待协议；发送完一个文件块就等待对方的确认，确认时需指明确认的块编号，若在规定时间内没有收到确认，需要重新发送文件块，接收方若在规定时间内没有收到下一文件块，也会重新发送确认。\n\nTFTP每次传送的文件块为512字节(最后一次可能少于512字节)，若文件的长度恰为512字节的整数倍，则文件传送完毕后还需要发送一个只有头部而无数据的报文，表明文件传送完毕。","tags":["计算机网络"],"categories":["course"]},{"title":"第四章第一节 域名系统DNS","url":"/course/cn-ch4-par1.html","content":"\n## 域名系统概述\n\n域名系统DNS用来将计算机的域名解析为计算机的IP地址。DNS报文格式如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 58.png pic58 %}</div>\n\n&nbsp;\n\n* 16位标识字段用于标记一对DNS查询与应答；\n* 16位标志字段用于协商具体的通信方式与反馈通信状态，该字段细节如下图；\n  * QR：查询/应答标志。0表示查询，1表示应答；\n  * opcode：定义查询与应答的类型。0表示标准查询，1表示反向查询(由IP地址获取主机域名)，2表示请求服务器状态；\n  * AA：授权应答标志。仅由应答报文使用，1表示域名服务器是授权服务器；\n  * TC：截断标志。仅当DNS报文使用UDP协议时使用。由于UDP数据报有长度限制，因此过长的DNS报文将被截断。1表示DNS报文超过512字节并被截断；\n  * RD：递归查询标志。1表示执行递归查询，0表示执行迭代查询；\n  * RA：允许递归标志。仅由应答报文使用，1表示DNS服务器支持递归查询；\n  * zero：未使用；\n  * rcode：4位返回码。0：无错误，3：域名不存在；\n\n<div style=\"width:60%;margin:auto\">{% asset_img 59.png pic59 %}</div>\n\n&nbsp;\n\n* 之后4个字段分别指出DNS报文最后4个字段的资源记录数目。\n* 查询问题格式如下。\n  * 查询名：以一定格式封装要查询的主机域名；\n  * 查询类型：如何执行查询操作。类型A(值为1)：获取目标主机的IP地址，类型CNAME(值为5)：获得目标主机别名，类型PTR(值为12)：方向查询；\n  * 查询类：通常为1，指获取因特网地址；\n\n<div style=\"width:60%;margin:auto\">{% asset_img 60.png pic60 %}</div>\n\n&nbsp;\n\n\n\n* 其他三个字段都使用资源记录格式。其格式如下图。\n  * 32位域名、16位类型、16位类与对应查询问题的查询名、查询类型、查询类内容一致；\n  * 32位生存时间：该查询记录的结果可被客户端缓存多长时间，以秒为单位；\n\n<div style=\"width:60%;margin:auto\">{% asset_img 61.png pic61 %}</div>\n\n&nbsp;\n\n## 互联网的域名结构\n\n互联网的域名命名采用层次结构。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 44.png pic44 %}</div>\n\n## 域名服务器\n\n一个DNS服务器所负责管辖的范围称为区。这个DNS服务器就是这个区的权限域名服务器，它保存区中所有主机的域名到IP地址的映射。区包含于一个域。\n\n互联网中的DNS服务器同样以层次结构组织。\n\n* 根域名服务器。本地域名服务器在遇到自己无法解析的域名时，统一求助根域名服务器；\n* 顶级域名服务器。管理在顶级域名下注册的所有二级域名。\n* 权限域名服务器。\n* 本地域名服务器。一台主机发出DNS查询请求时，查询报文首先发送到本地域名服务器。\n\n可使用host命令访问DNS服务器。\n\n```bash\nhost -t A www.baidu.com\n```\n\n### 域名解析\n\n**递归查询**：若主机请求解析的域名在本地域名服务器中不存在，则本地域名服务器以DNS客户的身份，向根域名服务器发送查询请求。\n\n**迭代查询**：根域名服务器收到本地域名服务器的查询请求后，要么给出要查询的IP地址，要么给出下一个查询请求对象的IP地址。本地域名服务器就这样进行迭代查询直到得知域名的IP地址或查询失败。\n\n本地域名服务器将查询结果(IP地址或查询失败)返回给主机，并且将查询结果缓存，以便下次查询此域名能够快速响应。","tags":["计算机网络"],"categories":["course"]},{"title":"第三章 传输层","url":"/course/cn-ch3.html","content":"\n[第一节 传输层协议概述](https://KangMing-ux.github.io/course/cn-ch3-par1.html)\n\n[第二节 用户数据报协议UDP](https://KangMing-ux.github.io/course/cn-ch3-par2.html)\n\n[第三节 传输控制协议TCP概述](https://KangMing-ux.github.io/course/cn-ch3-par3.html)\n\n[第四节 可靠传输的工作原理](https://KangMing-ux.github.io/course/cn-ch3-par4.html)\n\n[第五节 TCP流量与拥塞控制](https://KangMing-ux.github.io/course/cn-ch3-par5.html)\n\n[第六节 TCP的传输连接管理](https://KangMing-ux.github.io/course/cn-ch3-par6.html)","tags":["计算机网络"],"categories":["course"]},{"title":"第三章第六节 TCP的传输连接管理","url":"/course/cn-ch3-par6.html","content":"\n## 三次握手\n\n<div style=\"width:56%;margin:auto\">{% asset_img 41.png pic41 %}</div>\n\n&nbsp;\n\nQ：为什么需要第三次握手?\n\nA：TCP作为可靠传输，收到报文后都要向发送方回复ACK回执。根据这个机制，TCP建立连接应该需要4次握手：\n\n(1)客户端向服务器端发送请求连接的SYN报文；\n\n(2)服务器端向客户端回复确认接收的ACK报文；\n\n(3)服务器端向客户端发送允许连接的SYN报文；\n\n(4)客户端向服务器端回复确认接收的ACK报文；\n\n然而，第(2)次握手与第(3)次握手可以合并到一个报文中，于是形成了熟知的三次握手。\n\n## 四次挥手\n\n<div style=\"width:60%;margin:auto\">{% asset_img 42.png pic42 %}</div>\n\n&nbsp;\n\nQ：为什么第(2)次挥手与第(3)次挥手不能合并?\n\nA：服务器端收到客户端请求释放连接的报文后，可能还需要处理一些工作，因此只能先发送确认收到报文，然后等工作处理完之后，向客户端发送允许释放连接的报文，客户端收到此报文后回复确认收到的报文后即可释放此TCP连接，服务器端收到客户端确认收到的回复报文后，释放此TCP连接，进入LISTEN状态。\n\n&nbsp;\n\nQ：为什么在TCP释放连接时发起方返回ACK报文后还要等待2MSL时间?\n\nA：MSL为报文最大生存时间，它是任何报文在网络上存在的最长时间。若释放连接的发起方返回的ACK报文未被另一方接收，则另一方会在超时后重传允许释放连接报文，释放连接的发起方就会在返回ACK报文后的2MSL时间内收到这个重传的报文，然后重新发送ACK报文。而如果直接退出，那么释放连接的发起方就不会重新发送ACK报文，另一方将无法按照正常的步骤进入CLOSED状态。\n\n此外，经过2MSL时间后，此次TCP连接中传送的所有报文均在网络中消失，可以使通信双方下一次建立的TCP连接与此次TCP连接完全地分离开，即不会出现此次TCP连接中传送的报文出现在下一次建立的TCP连接中的情况。\n\n## 复位报文\n\n在一些特殊情况下，TCP连接的一端会向另一端发送携带RST标志的报文，即复位报文，以通知对方关闭连接或重新打开连接。有如下3种产生复位报文的情况。\n\n* 访问了不存在的端口；当客户端访问一个不存在的端口，目标主机将向它发送一个复位报文；\n* 异常终止连接；TCP提供了异常终止一个连接的方法——向对方发送一个复位报文，一旦发送了复位报文，TCP发送缓冲区中的数据都将被丢弃；\n* 处理半打开连接；TCP连接一方关闭或异常终止了TCP连接，但是对方没有收到结束/复位报文，于是对方仍然维持着TCP连接，这种状态称为半连接；如果对方这时发送报文，就会收到复位报文；\n\n## TCP的有限状态机\n\n<div style=\"width:56%;margin:auto\">{% asset_img 43.png pic43 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第三章第五节 TCP流量与拥塞控制","url":"/course/cn-ch3-par5.html","content":"\n## 流量控制\n\n利用滑动窗口实现流量控制\n\n<div style=\"width:56%;margin:auto\">{% asset_img 39.png pic39 %}</div>\n\n## TCP拥塞控制\n\n### TCP拥塞控制的手段\n\n* 慢开始。TCP连接刚刚建立时，由小到大逐渐增大发送窗口。\n* 拥塞避免。当拥塞窗口增大到一定程度时，将其增速放缓。\n* 快重传。收到数据后立即发送已按顺序收到的报文的确认。若发送方连续收到3个重复确认，则要对确认报文之后的报文进行重传。\n* 快恢复。调整慢开始门限为拥塞窗口大小/2，拥塞窗口大小为慢开始门限，然后执行拥塞避免算法。\n\n### TCP拥塞控制流程\n\nTCP使用上述四种手段实现拥塞控制的流程图如下。\n\n<div style=\"width:68%;margin:auto\">{% asset_img 40.png pic40 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第三章第四节 可靠传输的工作原理及其TCP实现","url":"/course/cn-ch3-par4.html","content":"\n## 可靠传输的工作原理\n\n### 停止等待协议\n\n顾名思义，在发送分组后等待确认收到，之后再发送下一分组。如果设定时间内没有收到确认，则将此分组重传。因此TCP在发送完一个分组后，必须保留此分组的副本直到收到确认。由于没有收到确认有两种可能：(1)发送分组丢失或出错；(2)对方收到分组，且确认无误，但是发送的确认丢失；(3)由于网络阻塞，收到确认迟到了；不管是哪种可能，发送方都会重传分组。对于(1)，接收方会接收分组并发送确认；而对于(2)，接收方直接丢弃这个重复分组，但是仍然发送确认分组。对于(3)，发送方收到重复的确认后直接丢弃。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 37.png pic37 %}</div>\n\n&nbsp;\n\n然而，停止等待协议的信道利用率极其低，下面介绍连续ARQ协议与滑动窗口协议。\n\n### 连续ARQ协议\n\n**发送**：位于窗口内的分组可以全部发送出去而不用等待前一组的接收确认。\n\n**累积确认**：接收方不需要对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送接收确认，这就代表到这个分组为止的所有分组均已收到。\n\n**窗口滑动**：发送方收到确认后，将窗口滑动到确认分组的下一分组。\n\n连续ARQ协议工作例子如下。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 38.png pic38 %}</div>\n\n## TCP可靠传输的实现\n\n### 以字节为单位的滑动窗口\n\n&nbsp;\n\n### 超时重传时间的选择\n\nTCP采用一种自适应算法，它记录一个报文段发出的时间，以及收到相应确认的时间。这两者之差为该报文段的往返时间RTT，TCP保留一个加权平均往返时间RTTS<-(1-a)×RTTS+a×RTT。a建议为1/8。超时重传时间RTO=RTTS+4×RTTD，RTTD为RTT偏差的加权平均值。而重传的报文，其往返时间无法准确计算，于是Karn提出：重传报文的RTT不加入RTTS的计算，而这种方法又不能及时应对网络阻塞的变化(如果网络阻塞，导致RTT变大，而重传报文的RTT不加入RTTS的计算，于是超时重传时间得不到及时更新)，于是Karn算法修正为报文段每重传一次，就将超时重传时间增加一倍。","tags":["计算机网络"],"categories":["course"]},{"title":"第三章第三节 传输控制协议TCP概述","url":"/course/cn-ch3-par3.html","content":"\n## TCP主要特点\n\n* TCP是面向连接的传输层协议，即应用程序在使用TCP协议前，必须先建立TCP连接；\n* TCP连接只能是一对一；\n* TCP提供可靠交付。通过TCP协议传送的数据，可无差错、不丢失、不重复、按序到达；\n* TCP提供全双工通信。运行通信双方的应用进程在(建立连接之后，释放连接以前的)任何时候都可以发送数据，通信双方既是发送方也是接收方，TCP连接的两端都设有发送缓存与接收缓存；\n* 面向字节流。TCP将应用程序交付下来的数据仅仅看作一连串无结构的字节流。\n\n## TCP连接\n\nTCP连接有两个端点，这个端点就是套接字socket，可使用`IP:Port`唯一区分。\n\nsocket是操作系统提供的网络编程接口，因为数据链路层、网络层、传输层协议均在内核中实现，而应用层基本上在用户空间，因此操作系统必须提供一组系统调用使应用层可以使用数据链路层、网络层、传输层提供的服务。\n\nsocket主要提供两种功能：(1)将应用程序数据从用户缓冲区复制到TCP/UDP内核发送缓冲区、或从TCP/UDP内核接收缓冲区复制数据到用户缓冲区；(2)应用程序可通过socket提供的接口修改内核中各层协议的控制信息，从而精确地调整底层通信的行为。\n\n## TCP头部\n\nTCP头部格式如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 36.png pic36 %}</div>\n\n&nbsp;\n\n* 确认号。若确认号为N，则表明从起始序号到N-1的TCP字节流已经按顺序收到。\n* 数据偏移。以4字节为单位，即若数据偏移为5，则TCP头部长20字节。\n* 确认ACK。仅当确认ACK为1时确认号字段才有效，TCP规定：在连接建立后，所有传送的报文段都必须将ACK置1。\n* 复位RST。RST为1表明TCP连接出现严重差错，必须立即释放连接。\n* SYN位。在连接建立时用来同步序号，SYN=1且ACK=0用来请求连接，SYN=1且ACK=1表明接受连接；SYN位置1标志建立连接阶段的报文。\n* FIN位。FIN位置1表明向对方提出终止连接。\n* 窗口。用来告知通信另一方，自本报文段头部的确认号算起，允许其发送的数据量(以字节为单位)。\n* 选项。长度可变，包括最大报文段长度、窗口扩大选项、时间戳、选择确认等。","tags":["计算机网络"],"categories":["course"]},{"title":"第三章第二节 用户数据报协议UDP","url":"/course/cn-ch3-par2.html","content":"\n## UDP概述\n\nUDP只在IP协议上增加了复用/分用与差错检测功能。UDP具有无连接、尽最大努力交付、面向报文(应用层交给UDP多长的报文，UDP就照样发送)、无拥塞控制(即使网络出现拥塞，源主机发送数据的速率不变)、支持一/多对一/多、头部开销小的特点。\n\n## UDP头部\n\nUDP头部格式如下图。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 35.png pic35 %}</div>\n\n&nbsp;\n\n若接收方UDP发现收到的报文目的端口号不正确，则丢弃该报文，并且向源主机发送ICMP端口不可达差错报文。UDP的校验和是将首部与数据部分一起校验。","tags":["计算机网络"],"categories":["course"]},{"title":"第三章第一节 传输层协议概述","url":"/course/cn-ch3-par1.html","content":"\n## 进程间通信\n\n传输层是向应用进程间提供端到端的逻辑通信。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 32.png pic32 %}</div>\n\n## 传输层两个主要协议\n\n传输层的两个主要协议：用户数据报协议UDP与传输控制协议TCP。下表是使用TCP或UDP的应用层协议。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 33.png pic33 %}</div>\n\n## 传输层的端口\n\n标志本计算机应用层的各个进程与传输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。传输层的端口号分为下面两类。\n\n**服务端使用的端口号**：分为熟知端口号与登记端口号。熟知端口号(0-1023)可在`www.iana.org`查到。如下表是一些常用的熟知端口号。\n\n<div style=\"width:72%;margin:auto\">{% asset_img 34.png pic34 %}</div>\n\n&nbsp;\n\n登记端口号(1024-49151)被没有熟知端口号的应用程序使用，使用前需在IANA登记。\n\n**客户端使用的端口号**：仅在客户进程运行时才动态选择(49152-65535)。","tags":["计算机网络"],"categories":["course"]},{"title":"第二章 网络层","url":"/course/cn-ch2.html","content":"\n[第一节 网际协议IP](https://KangMing-ux.github.io/course/cn-ch2-par1.html)\n\n[第二节 划分子网与构造超网](https://KangMing-ux.github.io/course/cn-ch2-par2.html)\n\n[第三节 网际控制报文协议ICMP](https://KangMing-ux.github.io/course/cn-ch2-par3.html)\n\n[第四节 互联网的路由选择协议](https://KangMing-ux.github.io/course/cn-ch2-par4.html)\n\n[第五节 IPv6](https://KangMing-ux.github.io/course/cn-ch2-par5.html)\n\n[第六节 IP多播](https://KangMing-ux.github.io/course/cn-ch2-par6.html)\n\n[第七节 VPN与NAT](https://KangMing-ux.github.io/course/cn-ch2-par7.html)\n\n[第八节 多协议标记交换MPLS](https://KangMing-ux.github.io/course/cn-ch2-par8.html)","tags":["计算机网络"],"categories":["course"]},{"title":"超椭圆曲线(九)超椭圆曲线密码系统的实现","url":"/crypto/Hyper-ch9.html","content":"\nDiffie-Hellman密钥交换[10]是一个协议，两个实体$A$和$B$可以通过公共通道上的一系列传输，就一个秘密的加密密钥达成一致。方法如下。$A$和$B$首先选择一个(乘式写)有限Abel群$G$和某个元素$\\alpha\\in G$。然后$A$选择一个随机整数$a$且将$\\alpha^{a}$传输给$B$，$B$反过来选择一个随机整数$b$且将$\\alpha^{b}$传输给$A$。这样$A,B$均能确定$\\alpha^{ab}$，作为他们的共享密钥。\n\n窃听者$C$监控$A$与$B$之间的传输将会得到$G,\\alpha,\\alpha^{a},\\alpha^{b}$，选择参数$G$和$\\alpha$，使$C$确定$\\alpha^{ab}$在计算上是不可行的。事实上，若$C$可以计算$a$或者$b$，则$C$可以确定$\\alpha^{ab}$。给定$\\alpha,\\beta=\\alpha^{a}$确定$a$的问题称为离散对数问题。当限制在$[0,order(\\alpha)-1]$范围内$a$是唯一的，称为以$\\alpha$为底，$\\beta$的对数。确定$\\alpha^{ab}$与计算$G$上的离散对数问题是否等价还没有定论，在其他安全依赖于离散对数问题的加密协议中，有ElGamal公钥加密和数字签名方案[12]，以及最近采用的美国数字签名标准[29]。\n\n最好的算法以解决离散对数问题在任意$G$组指数平方根攻击(见McCurley[24]),有一个运行时间的平方根成比例最大的质数因子$l$, $l$是$\\alpha$的阶。因此，如果选择$G$和$\\alpha$，使$l$有一个大的素数因子，那么这些攻击就可以避免。\n\n令$F_{q}$代表阶为$q$的有限域，再令$q=p^{m}$其中$p$是$F_{q}$的特征，Diffie与Hellman最初提议$G=F_{q}^{*}$，$F_{q}$的乘法群，作为实现Diffie-Hellman密钥交换协议的候选。有一些已知的随机次指数时间算法可用于计算$F_{q}$中的对数。关于$q$为质数的情形，请参见Coppersmith，Odlyzko和Schroeppel [9]和Gordon [17]，对于$p=2$的情况，请参见Odlyzko [30]，有关一般情况，请参见Adleman和DeMarrais [1]。这些算法是对上一段中提到的通用算法的渐进改进。 出于加密目的，我们对相应离散对数问题的次指数算法未知的群感兴趣。另外，为了有效和实际地实施，群操作应该相对容易地应用。 对于这样的群，在有限域上定义的超椭圆曲线的雅可比行列式就是一种可能性。\n\n为了使用超椭圆曲线实现离散对数密码系统，必须选择合适的曲线$C$和有限域$K$。 所选曲线和域的理想属性包括：\n\n* 底层有限域K中的算术应该有效地实现； 特征2的有限域似乎是最有吸引力的选择；\n* $C$的行列式$J(K)$的阶，表示为$\\sharp J(K)$，应该能被大素数整除。给定当前的计算技术，一个安全的要求为$\\sharp J(K)$可被至少45位的十进制素数$r$整除。另外，为了避免约化攻击Frey and Ruck [13]，它将$J(K)$中的离散对数问题简化为扩展域$K=F_{q}$中的离散对数问题。对所有的$F_{q^{k}}$中的离散对数可解的小整数$k$，$r$应无法整除$q^{k}-1$($1\\leq k\\leq 2000/(\\log_{2}q)$满足)。\n\n接下来描述一种用于选择超椭圆曲线并计算$\\sharp J(K)$的技术。令$J$为定义在$F_{q}$上的超椭圆曲线$C$的雅可比行列式，由方程$v^{2}+h(u)v=f(u)$给定，令$F_{q^{n}}$代表$F_{q}$的$n$次扩展，且令$N_{n}$代表有限Abel群$J(F_{q^{n}})$的阶，$C$上的$F_{q^{n}}$-有理点的个数定义为$M_{n}$。与$C$关联的是zeta函数，定义如下：\n\n**定义53**(zeta函数)令$J$为定义在$F_{q}$上的超椭圆曲线$C$的雅可比行列式，再令$M_{r}=\\sharp C(F_{q^{r}}),r\\geq 1$，$C$的zeta函数是幂级数：\n$$\nZ_{C}(t)=exp\\left(\\sum_{r\\geq 1}M_{r}\\frac {r} {t^{r}}\\right)\n$$\n以下是有关zeta函数的一些众所周知的事实(例如，参见[23])。\n\n**定理54**(zeta函数的性质)令$C$为定义在$F_{q}$上类为$g$的超椭圆曲线，令$Z_{C}(t)$为$C$的zeta函数。\n\n$\\textrm{(i)}\\ Z_{C}(t)\\in Z(t)$。更确切地说，我们有：\n$$\nZ_{C}(t)=\\frac {P(t)} {(1-t)(1-qt)}\\tag{9}\n$$\n其中$P(t)$为次数为$2g$的整系数多项式；此外，$P(t)$有如下形式：\n$$\nP(t)=1+a_{1}t+\\cdots+a_{g}t^{g}+qa_{g-1}t^{g+1}+q^{2}a_{g-2}t^{g+2}+\\cdots+q^{g-1}a_{1}t^{2g-1}+q^{g}t^{2g}\\tag{10}\n$$\n$\\textrm{(ii)}\\ P(t)$分解为：\n$$\nP(t)=\\prod_{i=1}^{g}(1-\\alpha_{i}t)(1-\\bar\\alpha_{i}t)\\tag{11}\n$$\n\n其中每个$\\alpha_{i}=\\sqrt{q}$，$\\bar\\alpha_{i}$为$\\alpha_{i}$的共轭。\n\n$\\textrm{(iii)}\\ N_{n}=\\sharp J(F_{q^{n}})$满足：\n$$\nN_{n}=\\prod_{i=1}^{g}|1-\\alpha_{i}^{n}|^{2}\\tag{12}\n$$\n为了计算$N_{n}$，由它满足$\\textrm{(i)}$确定$P(t)$的系数$a_{1},\\cdots,a_{g}$，从而确定$P(t)$；$\\textrm{(ii)}$分解$P(t)$因此可以确定$\\alpha_{i}$；$\\textrm{(iii)}$通过等式$(12)$计算$N_{n}$。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 31.png pic31 %}</div>\n\n&nbsp;\n\n**推论55** 令$C$为定义在$F_{q}$上类为$g$的超椭圆曲线，令$N_{n}=\\sharp J(F_{q^{n}})$，则$(q^{n/2}-1)^{2g}\\leq N_{n}\\leq (q^{n/2}+1)^{2g}$；从而$N_{n}\\approx q^{ng}$。\n\n[原文链接](http://www.math.uwaterloo.ca/~ajmeneze/publications/hyperelliptic.pdf)\n\n翻译不当之处还请批评指正，另外文中有些证明等我看明白了再翻译...","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(八)约化因数相加","url":"/crypto/Hyper-ch8.html","content":"\n令$C$是定义在有限域$K$上属性为$g$的一个超椭圆曲线，令$J$是$C$的雅克比行列式，令$P(x,y)\\in C$，令$\\sigma$是$\\bar K$到$K$的一个自同构，则$P^{\\sigma}=(x^{\\sigma},y^{\\sigma})$同样是$C$上的一个点。\n\n**定义48**(因数的定义域)若一个因数$D=\\sum m_{P}P$有$D^{\\sigma}=\\sum m_{P}P^{\\sigma}$能对任意$\\bar K$到$K$的自同构$\\sigma$均与$D$相等。\n\n注意到如果$D$定义在$K$上，这并不代表$D$的支撑集中的每个点均为$K$有理点，一个主因数定义在$K$上当且仅当它是一个有$K$中系数的有理函数的因数，$J$中所有除数类的集合$J(K)$有一个定义在$K$上的代表，是$J$的一个子群。$J(K)$的每个元素都有一个唯一的表示形式，即约化因数$div(a, b)$，其中$a,b\\in K[u],deg(a)\\leq g,deg(b)<deg(a)$，因此$J(K)$事实上是一个有限Abel群。本节介绍一种在该组中元素相加的有效算法。\n\n令$D_{1}=\\textrm{div}(a_{1},b_{1}),D_{2}=\\textrm{div}(a_{2},b_{2})$为两个在$K$上定义的约化因数(则$a_{1},b_{1},a_{2},b_{2}\\in K[u]$)。算法1寻找一个半约化因数$D=\\textrm{div}(a,b),a,b\\in K[u]$使得$D\\sim D_{1}+D_{2}$。算法2将$D$约化为等价的约化因数$D^{'}$。\n\n算法1,2由Koblitz [20]实现，其推广了Cantor[5]的早期算法—假定$h(u)=0$且$char(K)\\neq 2$。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 21.png pic21 %}</div>\n\n&nbsp;\n\n**定理49**(算法1的有效性)令$D_{1}=\\textrm{div}(a_{1},b_{1}),D_{2}=\\textrm{div}(a_{2},b_{2})$为两个半约化因数，令$a,b$如式$(4),(5)$定义，则$D=\\textrm{div}(a,b)$是一个半约化因数且$D\\sim D_{1}+D_{2}$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 22.png pic22 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 23.png pic23 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 24.png pic24 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 25.png pic25 %}</div>\n\n算法2：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 26.png pic26 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:56%;margin:auto\">{% asset_img 27.png pic27 %}</div>\n\n&nbsp;\n\n**定理51**(算法2的有效性)令$D=\\textrm{div}(a,b)$是一个半约化因数，则由算法2返回的因数$D^{'}=\\textrm{div}(a^{'},b^{'})$是约化的且$D^{'}\\sim D$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 28.png pic28 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 31.png pic31 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 30.png pic30 %}</div>\n\n&nbsp;\n\n注意，算法1和算法2中的所有计算都发生在域$K$本身(而不是$K$的任何适当扩展)。在算法1中，若$deg(a_{1})\\leq g,deg(a_{2})\\leq g$则$deg(a)\\leq 2g$。此时，算法2对步骤1的迭代次数最多为$[g/2]$。","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(七)约化因数","url":"/crypto/Hyper-ch7.html","content":"\n本节定义了约化因数的概念，并证明了商群的每个陪集$\\bf{J=D^{0}/P}$只有一个约化因数，因此，我们可以用它的约化因数来识别每个陪集。\n\n**定义44**(约化因数)令$D=\\sum m_{i}P_{i}-(\\sum m_{i})\\infty$是一个半约化因数，若$\\sum m_{i}\\leq g$($g$是$C$的属性)，则$D$称为一个约化因数。\n\n**定义45**(因数的范数)令$D=\\sum_{P\\in C}m_{P}P$是一个因数，$D$的范数定义为：$|D|=\\sum_{P\\in C\\setminus {\\infty}}m_{P}$。\n\n注意到给定一个因数$D\\in \\bf{D^{0}}$，在引理39的证明中所描述的操作会产生一个半约化因数$D_{1}$使得$D_{1}\\sim D$且$D_{1}\\leq D$。\n\n**引理46** 令$R\\in \\bar K(C)^{*}$，若$R$没有有限的极点，则$R$是一个多形式函数。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 18.png pic18 %}</div>\n\n&nbsp;\n\n**定理47 **对任一因数$D\\in \\bf{D^{0}}$存在一个唯一的约化因数$D_{1}$使得$D_{1}\\sim D$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 19.png pic19 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 20.png pic20 %}</div>","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(六)半约化因数的表示","url":"/crypto/Hyper-ch6.html","content":"\n本节描述雅可比矩阵半约化因子的多项式表示。它引出了一个有效的算法来添加雅可比矩阵的元素。\n\n**引理40** 令$P(x,y)$是$C$上一个平凡点，再令$R\\in \\bar K(C)$是一个在$P$处没有极点的有理函数，则对任意的$k\\geq 0$，存在唯一的元素$c_{0},\\cdots,c_{k}\\in\\bar K$与$R_{k}\\in \\bar K(C)$使得$R=\\sum_{i=0}^{k} c_{i}(u-x)^{i}+(u-x)^{k+1}R_{k}$，其中$R_{k}$在$P$处没有极点。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\n**引理41** 令$P(x,y)$是$C$上一个平凡点，则对任一$k\\geq 1$，存在唯一的多项式$b_{k}(u)\\in \\bar K[u]$使得：\n\n$\\textrm{(i)}\\ deg_{u} b_{k}<k$；\n\n$\\textrm{(ii)}\\ b_{k}(x)=y$且$b_{k}^{2}(u)+b_{k}(u)h(u)\\equiv f(u)\\ \\textrm{mod}\\ (u-x)^{k}$；\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 15.png pic15 %}</div>\n\n&nbsp;\n\n下面的定理说明了半约化因数如何可以表示为两个多项式函数的因数的最大公约数。\n\n**定理42** 令$D=\\sum m_{i}P_{i}-(\\sum m_{i})\\infty$是一个半约化因数，其中$P_{i}(x_{i},y_{i})$，令$a(u)=\\prod (u-x_{i})^{m_{i}}$。令$b(u)$是唯一满足如下条件的多项式：\n$\\textrm{(i)}\\ deg(b)<deg(a)$；\n\n$\\textrm{(ii)}$对所有$m_{i}\\neq 0$的$i$都有$b(x_{i})=y_{i}$；\n\n$\\textrm{(iii)}\\ a(u)|[b^{2}(u)+b(u)h(u)-f(u)]$，则$D=\\textrm{gcd}(div(a(u)),div(b(u)-v))$。\n\n注：$\\textrm{gcd}(div(a(u)),div(b(u)-v))$通常缩写为$div(a(u),b(u)-v)$或者，更简单：$div(a,b)$。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n&nbsp;\n\n注意到零因数表示为$div(1,0)$，下一个结果来自定理42的证明。\n\n**引理43** 令$a(u),b(u)\\in \\bar K[u]$使得$deg(b)<deg(a)$，若$a|(b^{2}+bh-f)$则$div(a,b)$是半约化的。","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(五)因数","url":"/crypto/Hyper-ch5.html","content":"\n本节介绍因数的基本性质及超椭圆曲线的雅可比矩阵。\n\n**定义31**(因数 , 次数 , 阶数)因数D是C中的点的形式和：$D=\\sum_{P\\in C}m_{P}P ,m_{P}\\in Z$，其中只有有限的$m_{P}$是非零的。D的次数，记为$degD$，是$\\sum_{P\\in C}m_{P}$。$D$在$P$处的阶数$m_{P}$，记$ord_{P}(D)=m_{P}$。\n所有因数的集合记为D，在加法规则下形成一个可加群：$\\sum_{P\\in C}m_{P}P+\\sum_{P\\in C}n_{P}P=\\sum_{P\\in C}(m_{P}+n_{P})P$。\n所有次数为$0$的因数组成的集合，记为$\\bf{D^{0}}$，是$D$的子群。\n\n**定义32**(因数的公约数)令$D_{1}=\\sum_{P\\in C}m_{P}P , D_{2}=\\sum_{P\\in C}n_{P}P$为两个因子，$D_{1}$与$D_{2}$的最大公约数定义为：$gcd(D_{1},D_{2})=\\sum_{P\\in C}\\textrm{min}(m_{P},n_{P})P-(\\sum_{P\\in C}\\textrm{min}(m_{P},n_{P}))\\infty$(注意到$gcd(D_{1},D_{2})\\in \\bf{D^{0}}$)。\n\n**定义33**(有理函数的因数)令$R\\in \\bar K(C)^{*}$。$R$的因数是$div(R)=\\sum_{P\\in C}(ord_{P}R)P$，注意到若$R=G/H$则$div(R)=div(G)-div(H)$。定理29表明有理函数的因数确实是一个有限形式和并且次数为0。\n\n**例34**若$P(x,y)$是$C$上的一个平凡点，则$div(u-x)=P+\\bar P-2\\infty$，若$P(x,y)$是$C$上的一个特殊点，则$div(u-x)=2P-2\\infty$。\n\n**引理35**令$G\\in \\bar K[C]^{*} , div(G)=\\sum_{P\\in C}m_{P}P$，则$div(\\bar G)=\\sum_{P\\in C}m_{P}\\bar P$。\n\n证明：由引理28易得。\n\n若$R_{1} , R_{2}\\in \\bar K(C)^{*}$则由引理25可得$div(R_{1}R_{2})=div(R_{1})+div(R_{2})$。\n\n**定义36**若对某些有理函数$R\\in \\bar K(C)^{*}$，$D=div(R)$，则因数$D\\in \\bf{D^{0}}$称为主因数。所有主因数组成的集合，记为$\\bf{P}$，是$\\bf{D^{0}}$的子群；商群$J=\\bf{D^{0}/P}$称为曲线$C$的雅可比矩阵。若$D_{1} , D_{2}\\in \\bf{D^{0}}$，当$D_{1}-D_{2}\\in \\bf{P}$时我们记为$D_{1}\\sim D_{2}$，$D_{1}$与$D_{2}$被称为等价因数。\n\n**定义37**(因数的支持)令$D=\\sum_{P\\in C}m_{P}P$是一个因数，$D$的支持是集合$\\textrm{supp}(D)=\\{P\\in C|m_{P}\\neq 0\\}$。\n\n**定义38**(半约化因数)半约化因数是形如$D=\\sum m_{i}P_{i}-(\\sum m_{i})\\infty$，其中每个$m_{i}\\geq 0$且$P_{i}$均为有限点使得当$P_{i}\\in \\textrm{supp}(D)$则$\\bar P_{i}\\notin \\textrm{supp}(D)$，除非$P_{i}=\\bar P_{i}$，此时$m_{i}=1$。\n\n**引理39**对每个因数$D\\in\\bf{D^{0}}$存在一个半约化因数$D_{1}(D_{1}\\in\\bf{D^{0}})$使得$D\\sim D_{1}$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(四)零点与极点","url":"/crypto/Hyper-ch4.html","content":"\n本节介绍单值化参数的概念，以及有理函数的零点和极点的阶数。\n\n**定义18**(零点，极点)令$R\\in \\bar K(C)^{*},P\\in C$。若$R(P)=0$则记为$R$在$P$有一个零点。若$R$在$P$处没有定义则记为$R$在$P$处有一个极点，此时我们记为$R(P)=\\infty$。\n\n**引理19**令$G\\in \\bar K(C)^{*},P\\in C$，若$G(P)=0$，则$\\bar G(\\bar P)=0$。\n\n证明：套定义算就行，过程略。\n\n定理23中使用引理20、21和22，证明了单值化参数的存在性。\n\n**引理20** 令$P(x,y)$是$C$上一个点。假定$G(u,v)=a(u)-b(u)v\\in \\bar K[C]^{*}$在$P$处有一个零点，且$x$不是$a(u),b(u)$的根。则$\\bar G(P)=0$当且仅当$P$是一个特殊点。\n\n证明：式子一列就看出来了。\n\n**引理21** 令$P(x,y)$是$C$上一个平凡点，$G=a(u)-b(u)v\\in \\bar K(C)^{*}$。若$G(P)=0$，且$x$不是$a(u),b(u)$的根。则$G$能被写为$(u-x)^{s}S$的形式，其中$s$是$(u-x)$能够整除$N(G)$的最高次数。$S\\in \\bar K(C)$在$P$处既无零点也无极点。\n\n证明：$G=N(G)/\\bar G$，由引理20，$\\bar G(P)\\neq 0\\Rightarrow N(G)(x)=0$，因此$N(G)$可被表示为$(u-x)^{s}d(u)$的形式。再令$S=d(u)/\\bar G$，则$G$能被写为$(u-x)^{s}S$的形式。由$s$的定义可知$S(P)\\neq 0$且$S(P)\\neq \\infty$。\n\n**引理22** 令$P(x,y)$是一个在$C$上的特殊点。则$(u-x)$可被写为$(v-y)^{2}\\cdot S(u,v)$，其中$S(u,v)\\in \\bar K(C)$在$P$处既无零点也无极点。\n\n证明：记$H(u,v)=(v-y)^{2} , s(u)=H(u,y)$，显然$s(x)=0 , s^{'}(u)=f^{'}(u)-h^{'}(u)y$，由于$C$是超椭圆曲线，无奇异点，而$P(x,y)$是特殊点，因此$2y+h(u)=0$，因此必有$f^{'}(x)-h^{'}(x)y\\neq 0$，即$s^{'}(x)\\neq 0$；综上，$(u-x)|H(u,v)$且$(u-x)^{2}\\nmid H(u,v)$，可得$S(x,y)\\neq 0,\\infty$。\n\n**引理23**(单值化参数的存在性)令$P\\in C$，则存在一个函数$U\\in\\bar K(C) , U(P)=0$使下列性质成立：对于每个多项式函数$G\\in \\bar K[C]^{*}$，存在整数$d$与函数$S\\in\\bar K(C)$，使得$S(P)\\neq 0,\\infty$且$G=U^{d}S$；此外，$d$与$U$的选择无关。$U$称为关于$P$的单值化参数。\n\n证明：太麻烦了，自己看吧！\n\n<div style=\"width:80%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n-------------------------------------------------------------------------\n\n<div style=\"width:80%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n&nbsp;\n\n下面利用单值化参数的概念来定义多项式函数在某一点上的阶数。定义26给出了[20]的另一种定义，它更便于用于计算目的。引理27证明这两个定义实际上是等价的。\n\n**定义24**(多项式函数在一点的阶数的通常定义)令$G\\in \\bar K[C]^{*} , P\\in C , U\\in \\bar K(C)$是关于$P$的单值化参数，记$G=U^{d}S$，其中$S\\in \\bar K(C) , S(P)\\neq 0,\\infty$。$G$的阶在$P$处定义为$ord_{P}(G)=d$。\n\n**引理25** 令$G_{1} , G_{2}\\in \\bar K[C]^{*} , P\\in C$，记$ord_{P}(G_{1})=r_{1} , ord_{P}(G_{2})=r_{2}$。\n\n$\\textrm{(i)}\\ ord_{P}(G_{1}G_{2})=ord_{P}(G_{1})+ord_{P}(G_{2})$\n\n$\\textrm{(ii)}$若$G_{1}\\neq -G_{2}$。若$r_{1}\\neq r_{2}$，则$ord_{P}(G_{1}+G_{2})=\\textrm{min}(r_{1},r_{2})$，若$r_{1}=r_{2}$则$ord_{P}(G_{1}+G_{2})\\geq\\textrm{min}(r_{1},r_{2})$\n\n证明：由定义24易证！\n\n**定义26**(多项式函数在一点的阶数的另一种定义) $G=a-bv\\in \\bar K[C]^{*} , P\\in C$，$G$在$P$处的定义记为$ord_{P}(G)$，定义如下：\n\n$\\textrm{(i)}$若$P(x,y)$是有限点，则令$r$为$u-x$能够同时整除$a(u),b(u)$的最高次数，记$G(u,v)=(u-x)^{r}[a_{0}(u)-b_{0}(u)v]$，若$a_{0}(x)-b_{0}(x)y\\neq 0$，则令$s=0$；否则，令$s$为$u-x$能整除$N(a_{0}(u)-b_{0}(u)v)=a_{0}^{2}+a_{0}b_{0}h-b_{0}f$。若$P$是一个平凡点，则定义$ord_{P}(G)=r+s$，若$P$是一个特殊点，则定义$ord_{P}(G)=2r+s$。\n\n$\\textrm{(ii)}$若$P=\\infty$，则$ord_{P}(G)=-max[2deg(a),2g+1+2deg(b)]$。\n\n**引理27** 定义24与定义26等价。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 10.png pic10 %}</div>\n\n&nbsp;\n\n**引理28** 令$G\\in \\bar K[C]^{*} , P\\in C$。则$ord_{P}(G)=ord_{\\bar P}(\\bar G)$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\n**定理29**$G\\in \\bar K[C]^{*}$。则$G$存在有限个零点与极点；此外，$\\sum _{P\\in C}ord_{P}(G)=0$。\n\n证明：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n**定义30**(有理函数在一点上的阶数)令$R=G/H\\in \\bar K(C)^{*} , P\\in C$，$R$在$P$处的阶数定义为$ord_{P}(R)=ord_{P}(G)-ord_{P}(H)$。\n\n不难证明ordP (R)不依赖于G和H的选择，引理25和定理29对于非零有理函数也成立。","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(三)多项式与有理函数","url":"/crypto/Hyper-ch3.html","content":"\n本节介绍多项式和有理函数的基本性质，这些性质是将它们视为超椭圆曲线上的函数而产生的。\n\n**定义8**(坐标环，多项式函数)$K$上$C$的坐标环，定义为$K[C]$，是商环\n$$\nK[C]=K[u,v]/(v^{2}+h(u)v-f(u))\n$$\n其中$(v^{2}+h(u)v-f(u))$定义为由多项式$v^{2}+h(u)v-f(u)$生成的$K[u,v]$的理想。类似地，$\\bar K$上$C$的坐标环定义为\n$$\n\\bar K[C]=\\bar K[u,v]/(v^{2}+h(u)v-f(u))\n$$\n$\\bar K[C]$的一个元素称为$C$上的多项式函数。\n\n**引理9** $\\bar K$上的多项式$r(u,v)=v^{2}+h(u)v-f(u)$不可约，从而$\\bar K[C]$是一个整环。\n\n证明：\n\n若$r(u,v)$在$\\bar K$可约，那么它将被分解为$(v-a(u))(v-b(u)),a,b\\in \\bar K[u]$。然而，此时$deg(a\\cdot b)=deg(f)=2g+1,deg(a+b)=deg(h)=g$，这是不可能的！\n\n注意到对每个$G(u,v)\\in \\bar K[C]$，我们可以重复地用$f(u)-h(u)v$替换$v^{2}$直到最终得到如下表示：\n$$\nG(u,v)=a(u)-b(u)v,a(u),b(u)\\in \\bar K[u]\n$$\n显然这种表示是唯一的。\n\n**定义10**(共轭)令$G(u,v)=a(u)-b(u)v$是$\\bar K[C]$的一个多项式函数。$G(u,v)$的共轭被定义为$\\bar G(u,v)=a(u)+b(u)[v+h(u)]$。\n\n**定义11**(范数)令$G(u,v)=a(u)-b(u)v$是$\\bar K[C]$的一个多项式函数。$G$的范数为多项式函数$N(G)=G\\cdot \\bar G$。\n\n范数函数在把关于双变量多项式函数的问题转化为关于单变量多项式的简单问题时非常有用。\n\n**引理12**(范数的性质)令$G,H\\in \\bar K[C]$为多项式函数。\n\n$\\textrm{(i)}\\ N(G)$是$\\bar K[u]$的一个多项式；\n\n$\\textrm{(ii)}\\ N(\\bar G)=N(G)$；\n\n$\\textrm{(iii)}\\ N(GH)=N(G)N(H)$；\n\n证明：$N(G)=a^{2}(u)-b^{2}(u)f(u)+a(u)b(u)h(u)$...基本就是套定义，没有什么思路的难度。\n\n**定义13**(函数域，有理函数)$K$上$C$的函数域$K(C)$是$K[C]$的分数域。同理，$\\bar K$上$C$的函数域$\\bar K(C)$是$\\bar K[C]$的分数域。$\\bar K(C)$的元素被称为$C$上的有理函数。\n\n注意到$\\bar K[C]$是$\\bar K(C)$的子环，即每个多项式函数也是有理函数。\n\n**定义14**(有理函数在有限点处的值)令$R\\in \\bar K(C),P\\in C,P\\neq \\infty$。如果存在多项式函数$G,H\\in \\bar K[C]$，使得$R=G/H$且$H(P)\\neq 0$，则称$R$在$P$处有定义。如果没有这样的$G,H\\in \\bar K[C]$存在，则$R$在$P$处没有定义。如果$R$在$P$处有定义，则$R$在$P$处的值定义为$R(P)=G(P)/H(P)$。\n\n显然值$R(P)$是定义明确的，即它不取决于$G,H$的选择，下面的定义介绍了多项式函数的次数的概念。\n\n**定义15**(多项式函数的次数)令$G(u,v)=a(u)-b(u)v$为$\\bar K[C]$中非零多项式函数，$G$的次数定义为：\n$$\ndeg(G)=max[2deg(a),2g+1+2deg(b)]\n$$\n**引理16**(次数的性质)令$G,H\\in \\bar K[C]$。\n\n$\\textrm{(i)}\\ deg(G)=deg(N(G))$；\n\n$\\textrm{(ii)}\\ deg(GH)=deg(G)+deg(H)$；\n\n$\\textrm{(iii)}\\ deg(G)=deg(\\bar G)$；\n\n证明：\n\n$\\textrm{(i)}N(G)=a^{2}-b^{2}f+abh,deg(N(G))=max[deg(G),deg(a)+deg(b)+g]$，因此只需证$deg(a)+deg(b)+g$必小于$2deg(a)$与$2g+1+2deg(b)$其中一个。\n\n$\\textrm{(ii)}$结合$\\textrm{(i)}$与引理$12\\ \\textrm{(iii)}$的结论，$deg(GH)=deg(N(GH))=deg(N(G)N(H))=deg(N(G))+deg(N(H))=deg(G)+deg(H)$\n\n$\\textrm{(iii)}$结合$\\textrm{(i)}$与引理$12\\ \\textrm{(ii)}$的结论...\n\n**定义17**(有理函数在$\\infty$处的值)令$R=G/H\\in \\bar K(C)$是一个有理函数。\n\n$\\textrm{(i)}$若$deg(G)<deg(H)$则$R$在$\\infty$处的值被定义为$R(\\infty)=0$；\n\n$\\textrm{(ii)}$若$deg(G)>deg(H)$则$R$在$\\infty$处的无定义；\n\n$\\textrm{(iii)}$若$deg(G)=deg(H)$则$R(\\infty)$被定义为$G$与$H$的首项系数的比值。","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(二)基本定义与属性","url":"/crypto/Hyper-ch2.html","content":"\n**定义1(超椭圆曲线)**设$K$是一个域，$\\bar K$是$K$的代数闭包。$K$上类为$g$的超椭圆曲线定义为如下等式：\n$$\nC: v^{2}+h(u)v=f(u)\\ \\textrm{in}\\ K[u,v] \\tag{1}\n$$\n其中$h(u)\\in K[u]$是次数不超过$g$的多项式，$f(u)\\in K[u]$是次数为$2g+1$的首项系数为$1$多项式，并且不存在解$(u,v)\\in \\bar K\\times\\bar K$同时满足方程$v^{2}+h(u)v=f(u)\\ \\textrm{in}\\ K[u,v]$与两个偏微分方程$2v+h(u)=0,h^{'}(u)v-f^{'}(u)=0$。\n\n所谓$C$上的奇异点是一个解$(u,v)\\in \\bar K\\times\\bar K$同时满足上述三个方程。定义$1$表明超椭圆曲线没有任何奇异点。\n\n对于本文的其余部分，假设域$K$和曲线$C$已经固定。\n\n\n\n**引理1** 令$C$是$K$上如式$(1)$定义的超椭圆曲线；\n\n$(\\textrm{i})$ 若$h(u)=0$，则$char(K)\\neq 2$；\n\n$(\\textrm{ii})$ 若$char(K)\\neq 2$，则变量替换$u\\rightarrow u,v\\rightarrow (v-h(u)/2)$将$C$转换为形式$v^{2}=f(u)$，其中$f$的次数为$2g+1$；\n\n$(\\textrm{iii})$ 令$C$是形如$(1)$的等式且$h(u)=0,char(K)\\neq 2$，则$C$是超椭圆曲线当且仅当$f(u)$在$\\bar K$上没有重根；\n\n证明：\n\n$(\\textrm{i})$假设$char(K)=2$，则任意的$x\\in K , 2x=0$，因此要成为曲线$C$上的奇异点只需要满足如下两个等式即可：\n$$\n\\begin{cases}\nv^{2}=f(u)\\\\\n\\\\\nf^{'}(u)=0\n\\end{cases}\n$$\n\n先求满足$f^{'}(u)=0$的根$u_{0}$，再求满足$v^{2}=f(u_{0})$的根$v_{0}$，从而得到曲线$C$的奇异点$(u_{1},v_{0})$；这与$C$是超椭圆曲线矛盾。\n\n$(\\textrm{ii})$经变量替换，$C$的形式为：$(v-\\frac {h(u)} {2})^{2}=f(u)\\Rightarrow v^{2}=f(u)-\\frac {h^{2}(u)} {4}$，而$deg(h)\\leq g\\Rightarrow deg(f(u)-\\frac {h^{2}(u)} {4})=2g+1$。\n\n$(\\textrm{iii}) 当h(u)=0,char(K)\\neq 2$时，$C$有奇异点等价于存在$(u,v)\\in \\bar K\\times\\bar K$，满足：\n$$\n\\begin{cases}\nv^{2}=f(u)\\\\\n\\\\\n2v=0\\\\\n\\\\\nf^{'}(u)=0\n\\end{cases}\n$$\n等价于：\n$$\n\\begin{cases}\nf(u)=0\\\\\n\\\\\nf^{'}(u)=0\\\\\n\\\\\nv=0\n\\end{cases}\n$$\n因此，$C$有奇异点等价于存在$u\\in \\bar K$，满足：\n$$\n\\begin{cases}\nf(u)=0\\\\\n\\\\\nf^{'}(u)=0\n\\end{cases}\n$$\n即$f$有重根；因此，$C$是超椭圆曲线等价于$f$无重根。\n\n**定义3**(有理点，无限点，有限点)设$L$是$K$的扩展域。$C$上$L$有理点的集合，记为$C(L)$，是满足曲线$C$的等式$(1)$的所有点$P(x,y)\\in L\\times L$连同一个在无穷远处的特殊点(记为$\\infty$)，点集$C(\\bar K)$简单地被$C$定义，$C$上异于$\\infty$的点称为有限点。\n\n\n\n**例4**(实数域上的超椭圆曲线)如下是实数域上的超椭圆曲线的三个例子，每条曲线类$g=2$且$h(u)=0$。\n\n$(\\textrm{i})\\ C_{1}:\\ v^{2}=u^{5}+u^{4}+4u^{3}+4u^{2}+3u+3=(u+1)(u^{2}+1)(u^{2}+3)$，$C_{1}$在实平面的图像如图$1$所示；\n\n<div style=\"width:80%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\n$(\\textrm{ii})\\ C_{2}:\\ v^{2}=u^{5}+u^{4}-u^{2}-u=u(u-1)(u+1)(u^{2}+u+1)$，$C_{2}$在实平面的图像如图$2$所示；\n\n<div style=\"width:80%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\n$(\\textrm{iii})\\ C_{3}:\\ v^{2}=u^{5}-5u^{3}-u^{2}+4u=u(u-1)(u+1)(u-2)(u+2)$，$C_{3}$在实平面的图像如图$3$所示；\n\n<div style=\"width:80%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\n\n\n**定义5**(相反点、特殊点和平凡点)令$P(x,y)$是曲线$C$上的一个有限点。$P$的相反点是$\\bar P(x,-y-h(x))$。(注意到$\\bar P$确实在$C$上。)我们同样定义$\\infty$的相反点$\\bar \\infty=\\infty$为他的本身。若一个有限点$P$满足$P=\\bar P$，则该点被称为特殊的；否则，该点被称为平凡的。\n\n\n\n**例6**($Z_{7}$上的超椭圆曲线)考虑有限域$Z_{7}$上的曲线$C:v^{2}+uv=u^{5}+5u^{4}+6u^{2}+u+3$。这里，$h(u)=u,f(u)=u^{5}+5u^{4}+6u^{2}+u+3$且$g=2$，可以证明$C$没有奇异点(除了$\\infty$)，因此$C$确实是一个超椭圆曲线。$C$上的$Z_{7}$有理点为$C(Z_{7})={\\infty,(1,1),(1,5),(2,2),(2,3),(5,3),(5,6),(6,4)}$，点$(6,4)$是一个特殊点。\n\n\n\n**例7**($F_{2^{5}}$上的超椭圆曲线)考虑有限域$F_{2^{5}}=F_{2}[x]/(x^{5}+x^{2}+1)$，并且令$\\alpha$是本原多项式$x^{5}+x^{2}+1$在$F_{2^{5}}$的根。$\\alpha$的指数如表$1$所示。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n考虑有限域$F_{2^{5}}$上类$g=2$曲线$C: v^{2}+(u^{2}+u)v=u^{5}+u^{3}+1$，这里$h(u)=u^{2}+u,f(u)=u^{5}+u^{3}+1$，可以证明$C$没有奇异点(除了$\\infty$)，因此$C$实际上是一个超椭圆曲线。$C(F_{2^{5}})$中的有限点如下：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n其中，点$(0,1),(1,1)$是特殊的。","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"超椭圆曲线(一)简介","url":"/crypto/Hyper-ch1.html","content":"\n**前言**：本文对具有密码相关性的任意特征的有限域上的超椭圆曲线的一些理论作了初步的介绍。给出了在超椭圆曲线雅可比矩阵中求解的康托算法，并证明了该算法的正确性。\n\n\n超椭圆曲线是一类特殊的代数曲线，可以看作是椭圆曲线的推广。对每类$g\\geq1$的超椭圆曲线，当$g=1$时超椭圆曲线退化为椭圆曲线。一百多年来，人们对椭圆曲线进行了广泛的研究，并有大量的相关文献;例如，参见西尔弗曼[34,35]的著作。最初研究椭圆曲线主要是出于纯粹的审美原因，最近已成为几个重要应用领域的必要工具，包括编码理论(如Driencourt和Michon[11]和van der Geer [15])；伪随机数生成(如Kaliski [18]);数论算法(如Goldwasser and Kilian[16]和Lenstra [21]);和公开密钥密码学(见Koblitz [19]， Miller[27]和Menezes [25])。\n\n另一方面，超椭圆曲线理论还没有得到学术界足够的重视。在代数几何文献中出现的关于超椭圆曲线的大多数结果都是用非常一般的术语表达的。例如，在有关超椭圆曲线的论文中，一个常见的来源是芒福德的书[28]。然而，非专业人士很难将本书中的结果专门研究(更不用说发现)到超椭圆曲线的特殊情况。另一个困难是，这些书中的理论通常仅限于复数上的超椭圆曲线(如芒福德的书)，或特征不等于$2$的代数闭域。最近的Cassels和Flynn[6]的书是关于类为$2$曲线的广泛记述。(与他们的书相比，我们的方法绝对是“低级的”。)近年来，超椭圆曲线在代数几何以外的领域得到了应用。超椭圆曲线是Adleman和Huang关于证明[3]的质数的随机多项式时间算法的关键组成部分。在纠错码[4]、整数分解算法[22]和公钥密码[20]的设计中也考虑了超椭圆曲线。对于实现这些代码和密码系统，在特征为$2$的有限域上的超椭圆曲线是特别有趣的。\n\nCharlap和Robbins[7,8]对椭圆曲线进行了初步的介绍。目的是为有限域上计算椭圆曲线上的点的Schoof算法[33]的一些基本理论提供基本的自成证明。讨论仅限于不等于2或3的特征域。然而，在实际应用中，椭圆曲线和超椭圆曲线在两个特征域上特别具有吸引力。本文与Charlap和Robbins的思想相似，对具有密码相关性的任意特征有限域上的超椭圆曲线的一些理论作了初步的介绍。关于代数曲线理论的一般介绍，请参阅富尔顿的著作[14]。","tags":["密码学知识","超椭圆曲线"],"categories":["crypto"]},{"title":"第二章第八节 多协议标记交换MPLS","url":"/course/cn-ch2-par8.html","content":"\n## MPLS的工作原理\n\nMPLS工作原理图如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 30.png pic30 %}</div>\n\n&nbsp;\n\n一个标记仅仅在一对标记交换路由器LSR之间才有意义，MPLS数据包每经过一个LSR，LSR需要做两件事：更换标记与转发。划分为同一转发等价类的数据包被设置同样的标记，转发等价类也可用于负载均衡。\n\n## MPLS头部\n\nMPLS头部格式如下。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 31.png pic31 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第二章第七节 VPN与NAT","url":"/course/cn-ch2-par7.html","content":"\n## 虚拟专用网VPN\n\n由于IP地址的紧缺，如果一个主机只需要与其所在机构内的其他主机通信，那么只需为其分配一个在机构内唯一的IP地址即可。为避免与互联网上的IP地址冲突，RFC 1918规定：以下3个地址块为机构内通信的专用地址。\n\n* 10.0.0.0至10.255.255.255；\n* 172.16.0.0至172.31.255.255；\n* 192.168.0.0至192.168.255.255；\n\n利用公用互联网作为机构各专用网之间的通信载体，这样的专用网称为虚拟专用网VPN。下图用例子说明如何用IP隧道技术实现虚拟专用网。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 26.png pic26 %}</div>\n\n## 网络地址转换NAT\n\nNAT方法需要专用网上路由器有NAT组件，所有使用专用地址与外界通信的主机，都要在NAT路由器上将源IP地址转换为NAT路由器的IP地址，才能发送到互联网中。NAT的工作原理如下图所示。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 27.png pic27 %}</div>\n\n&nbsp;\n\n而数据包出入时源IP地址/目的IP地址的转换就通过NAT地址转换表进行。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 28.png pic28 %}</div>\n\n&nbsp;\n\n由此可见，如果NAT路由器有n个全球IP地址，则专用网内最多可有n台主机接入互联网。\n\n为更充分利用NAT路由器的IP地址，目前的NAT转换表将传输层的端口号也利用上，这也称为网络地址与端口号转换。此时的NAT地址转换表如下。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 29.png pic29 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第二章第六节 IP多播","url":"/course/cn-ch2-par6.html","content":"\n## 网际组管理协议IGMP\n\nIGMP协议基于IP协议。IGMP的工作大体分为两类。\n\n* 有主机要加入某一多播组时，主机向该多播组的多播地址发送一个IGMP报文，声明加入该组。本地的多播路由器收到IGMP报文后，需利用多播路由选择协议将这种组成员关系转发给互联网上的其他多播路由器；\n* 本地多播路由器需周期性探询本地局域网上的主机，以便知道这些主机是否仍然为组成员。只要有一台组内的主机响应，那么本地的多播路由器就认为该组活跃，否则，本地的多播路由器认为局域网中所有主机离开该组，不再将这个组的成员关系转发给其他多播路由器；\n\n为减少网络开销，IGMP协议具有以下特点。\n\n* 主机与多播路由器间的所有通信均为IP多播；\n* 多播路由器在探询组成员关系时，只需要对所有组发送一个请求信息的询问报文；\n* 同一组内每台主机都要监听响应，若本组的其他主机先发送了响应，则自己不用再发送响应；\n\n## 多播路由选择协议\n\n多播路由选择就是要找出以源主机为根节点的多播转发树，多播路由选择协议尚未标准化，下面介绍多播路由选择的3种方法。\n\n### 洪泛与剪除\n\n开始，路由器使用洪泛法转发多播数据报，每个路由器在收到一个数据包后，检查数据包是否是从源点经最短路径传送来的(计算从路由器到源点的最短路径，判断刚刚转发数据包的路由器是否为最短路径上的第一个路由器)。若是，则向所有其他方向转发此多播数据包，否则丢弃而不转发。如下是一个例子。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 25.png pic25 %}</div>\n\n&nbsp;\n\n若多播转发树上的某个路由器的下游树枝已无该多播组的成员，则将该路由器与其下游树枝一起剪除。\n\n### 隧道技术\n\n适用于多播组的位置在地理上分散的情形。在多播数据包进入单播网络时，将多播数据包封装上普通IP头部，到达多播网络后再去除普通IP头部。多播数据包如同在隧道中通过单播网络。\n\n### 基于核心的发现技术\n\n对每个多播组G指定一个核心路由器q，给出q的IP单播地址。q按照洪泛与剪除法创建G的转发树。发送到核心路由器的数据包会被沿途所有路由器检查内容，到达q后，若数据包是多播数据包，则q向G中所有成员转发数据包。若数据包是请求加入G，q就会将源路由器加入G，然后用隧道技术向刚刚加入的路由器转发每个多播数据报的副本。","tags":["计算机网络"],"categories":["course"]},{"title":"第二章第五节 IPv6","url":"/course/cn-ch2-par5.html","content":"\n## IPv6基本首部\n\nIPv6数据报大体分两部分：基本头部与有效载荷，有效载荷中可写入多个扩展头部(非必需)。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 21.png pic21 %}</div>\n\n&nbsp;\n\nIPv6基本头部格式如下。\n\n<div style=\"width:54%;margin:auto\">{% asset_img 22.png pic22 %}</div>\n\n&nbsp;\n\n其中，流标号是基于IPv6所提出的流概念，\"流\"是互联网上从某一源点到某一终点的一系列数据包，这个\"流\"经过的路由器都保证指明的服务质量。\n\n## IPv6地址\n\n每个地址占128位，采用冒号16进制记法。IPv6地址分类如下。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 23.png pic23 %}</div>\n\n## 从IPv4向IPv6过渡\n\n(1)双协议栈；(2)隧道技术：在IPv6数据报要进入IPv4网络时，将其封装为IPv4数据报。示意图如下。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 24.png pic24 %}</div>\n\n&nbsp;\n\n## ICMPv6\n\n与IPv4一样，IPv6也不保证数据的可靠交付，因此IPv6也需要使用类似ICMP的协议来反馈差错信息——ICMPv6，它还将地址解析协议ARP、网际组管理协议IGMP合并进自身。","tags":["计算机网络"],"categories":["course"]},{"title":"第二章第四节 互联网的路由选择协议","url":"/course/cn-ch2-par4.html","content":"\n## 基本概念\n\n理想的路由算法应具有如下特点：(1)算法必须正确、完整；(2)算法易于计算；(3)算法具有自适应性，即能适应通信量与网络拓扑的变化；(4)稳定性；(5)公平性；(6)算法应是最优的。实际的路由算法应尽可能接近理想的路由算法。\n\n### 分层的路由选择协议\n\n互联网采用分层次的路由选择协议，整个互联网被划分为许多较小的自治系统AS。于是，路由选择协议分为两类：(1)内部网关协议IGP：自治系统内部使用的路由选择协议，如RIP、OSPF协议；(2)外部网关协议：各自治系统间使用的路由选择协议，如BGP-4。\n\n## 内部网关协议RIP\n\n### 工作原理\n\nRIP协议要求网络中的每个路由器均维护一个从自身到所有其他网络的距离，即跳数。RIP协议有如下特点：\n\n* 只与相邻路由器交换信息。\n* 路由器无保留地交换信息。\n* 路由器按固定的时间间隔交换信息。\n\n路由表中的主要信息为：(1)到某个网络的最短距离；(2)下一跳的地址；路由器更新要做的就是刷新到各个网络的最短距离及其应该经过的下一跳地址。即RIP协议所使用的距离向量算法。\n\n### 距离向量算法\n\n对每一相邻路由器发来的RIP报文，路由器根据此报文更新路由表：\n\n(1)对地址为X的相邻路由器发来的RIP报文中的路由表，将路由表中的所有路由的下一跳项改为X、距离项的值加1；\n\n(2)对修改后的每一路由r：若路由器的路由表中没有到r中目的网络y的路由，则将此路由添加到路由器的路由表中。否则，记路由器的路由表中到目的网络y的路由为s，(i)若s的下一跳地址为X，则将r替换s；(ii)s的下一跳地址非X，若r的距离小于s的距离，则将r替换s。\n\n(3)若3分钟未收到相邻路由器的路由表，则将此相邻路由器标记为不可达。\n\n### RIP协议的报文格式\n\n<div style=\"width:56%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\n其中路由标记填入自治系统号ASN。RIP实现简单、开销小，存在的问题是传递故障信息的速度很慢，适用于小规模网络。\n\n## 内部网关协议OSPF\n\n### 工作原理\n\nOSPF为分布式链路状态协议，具有以下3个特点：\n\n* 采用洪泛法向所有相邻的路由器发送信息；\n* 发送的信息为与自身相邻的所有路由器的链路状态，链路状态包含费用、距离、时延、带宽等等；\n* 只有链路状态发生变化时，发生变化的路由器才使用洪泛法向所有相邻的路由器发送信息；\n\n各路由器之间频繁交换链路状态信息，最终所有的路由器都能建立一个链路状态数据库，即全网的拓扑结构图。每个路由器根据拓扑结构图使用Dijkstra算法计算到各路由器的路由。\n\n### 划分区域\n\nOSPF为适应大规模的自治系统，将其划分为若干个小范围——区域，每一区域有一个32位的标识符。此时再使用洪泛法发送信息时就只在区域内传递。为使得区域间能发送消息，OSPF会定义一个主干区域，其他区域均为边界区域。主干区域的标识符为0.0.0.0，它连接所有的边界区域，来自其他区域的信息先汇集到该区域的边界路由器，进入主干区域后流入目的区域。如下是一个例子。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 15.png pic15 %}</div>\n\n&nbsp;\n\n### OSPF协议报文格式\n\nOSPF使用IP数据报传递信息，OSPF分组使用如下图的24字节固定长度头部，如下图为OSPF协议报文格式。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n&nbsp;\n\nOSPF报文共有5种类型。其中路由器标识符标志发送此报文的路由器接口IP地址。OSPF具有以下特点：\n\n* OSPF允许管理员给每条路由指派不同的代价；\n* 若到目的网络存在多条代价相同的路由，OSPF可将通信量分配到多条路径，达到多路由间的负载均衡；\n* 所有使用OSPF协议的路由器在交换时都会进行鉴别，确保仅在可信赖的路由器间交换链路状态信息；\n* OSPF支持可变长度的子网划分与无分类的编址CIDR；\n* 由于网络中的链路状态经常变化，因此OSPF让每一个链路状态带有一个32位的序号，每次链路状态改变序号加1，且OSPF协议规定增长的速率不超过次/5s；\n\n### 5类OSPF报文\n\n* 问候报文。发现与维持相邻路由器的可达性；\n* 数据库描述报文。向相邻路由器发送自身链路状态数据库中所有链路状态项目的摘要信息；\n* 链路状态请求报文。向目的路由器请求其发送某些链路状态项目的详细信息；\n* 链路状态更新报文。使用洪泛法向全网更新链路状态；\n* 链路状态确认报文。对链路更新分组进行确认；\n\n除问候报文外，其余四类报文均用来进行链路状态数据库的同步。一个刚刚工作的路由器先通过问候报文得知有哪些路由器与之物理相邻。每个路由器向相邻路由器发送数据库描述报文，路由器再根据这些数据库描述报文向对应路由器发送链路状态请求报文。通过一系列交互，建立起全网同步的链路数据库。上述同步的示意图如下。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n## 外部网关协议BGP\n\n### 工作原理\n\n在配置BGP时，每个自治系统的管理员至少选择一个路由器作为\"BGP发言人\"，BGP发言人使用TCP连接交换路由信息。BGP发言人与自治系统AS之间的关系如下图。各BGP发言人之间交换的信息就是达到某个网络需经过的自治系统。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 18.png pic18 %}</div>\n\n&nbsp;\n\nBGP协议支持无分类域间路由选择CIDR，因此使用BGP协议的路由器的每条路由应包含目的网络前缀、下一跳IP地址、到达目的网络需经过的自治系统序列。若某个BGP发言人收到其他BGP发言人的路径通知，它需要检查自身是否在通知的路径中，若在，则不能采用此路径，避免形成回路。\n\n路由器运行稳定后，路由器只需要在自治系统发生变化时发送BGP报文。\n\n### 4类BGP报文\n\n* OPEN报文。与相邻的BGP发言人建立关系，初始化通信；\n* UPDATE报文。告知某一路由的信息(不能增加多条)，以及列出要撤销的多条路由；\n* KEEPALIVE报文。周期性地证实连接的连通性。\n* NOTIFICATION报文。发送检测到的差错。\n\n### BGP报文格式\n\n4类BGP报文具有同样的通用BGP头部，如下图所示。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 19.png pic19 %}</div>\n\n&nbsp;\n\nKEEPALIVE报文只有BGP头部，共19字节。OPEN报文主体有6个字段：版本、本自治系统号、保持时间、BGP标识符、可选参数长度、可选参数；UPDATE报文主体有5个字段：不可行路由长度、撤销路由列表、路径属性总长度、路径属性、网络层可达信息。NOTIFICATION报文有3个字段：差错代码、差错子代码、差错数据。\n\n## 路由器简介\n\n典型的路由器结构如下。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 20.png pic20 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第二章第三节 网际控制报文协议ICMP","url":"/course/cn-ch2-par3.html","content":"\n## 概述\n\n为更有效地转发IP数据报，在网络层使用网际控制报文协议ICMP。ICMP允许路由器或主机报告IP数据报的差错情况。ICMP报文格式如下：\n\n<div style=\"width:45%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\nICMP报文分两种：ICMP差错报告报文与ICMP询问报文。ICMP报文前4字节是包含3个字段(类型、代码、校验和)的固定格式，接下来4个字节的内容与ICMP的类型有关。最后的数据字段取决于ICMP的类型。下表给出常用的ICMP报文类型。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n下面具体介绍。\n\n## ICMP差错报告报文\n\nICMP差错报告报文主要有以下4种：\n\n* 终点不可达。路由器或主机无法交付数据报。\n* 时间超过。路由器收到生存时间为0的数据报，丢弃该数据报，并向数据报的源点发送时间超过ICMP报文。\n* 参数问题。路由器或目的主机收到的数据报头部有不正确字段，则丢弃该数据报，向源点发送参数问题报文。\n* 改变路由(重定向)。路由器将改变路由报文发送给主机，告知主机下次将报文发送给另外的路由器。\n\n对于需要进行差错报告的IP数据报，路由器或主机会将IP头部与IP数据字段的前8字节取出，作为ICMP报文的数据字段，再填写ICMP头部得到ICMP报文。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n&nbsp;\n\n对于以下几种情形，均不发送ICMP差错报文。\n\n* 对ICMP报文，它也是IP数据报，但是对于它的差错情况无需发送ICMP差错报文；\n* 一个IP数据包出错，路由器发送ICMP差错报文后，同属于这一数据报的数据包的差错情况不用再发ICMP差错报文；\n* 对具有多播地址或特殊地址(127.0.0.0、0.0.0.0)的数据报，均不发送ICMP差错报文；\n\n## ICMP询问报文\n\n(1)回送请求与回答；ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问，收到此报文的主机必须给查询方回复ICMP回送回答报文。这类报文用来测试目的站是否可达以及了解其相关状态。\n\n(2)时间戳请求与回答；ICMP时间戳请求报文向目的主机或路由器查询当前日期与时间，这类报文用于时钟同步与时间测量。\n\n## ICMP应用举例\n\nunix/Linux上的应用traceroute可以显示一个数据报从源点到终点的路径，此工具的原理如下。\n\ntraceroute从源主机向目的主机发送UDP数据报，第一个数据报P1的生存时间TTL设为1，那么当P1到达路径上第一个路由器R1时，R1将其接收，并将P1的TTL减1，于是TTL等于0，R1便将P1丢弃并向源主机发送一个ICMP时间超过差错报告报文，于是traceroute就得到了路径上的第一个路由器的IP地址；\n\n第二个数据报P2的生存时间TTL设为2从而得到路径上的第二个路由器的IP地址；以此类推，直到UDP数据报恰能到达目的主机，但是由于UDP报文中的目的端口不正确(不存在对应于该端口号的应用进程)，目的主机就会丢弃该报文，并向源主机发送ICMP终点不可达差错报告报文。","tags":["计算机网络"],"categories":["course"]},{"title":"第二章第二节 划分子网与构造超网","url":"/course/cn-ch2-par2.html","content":"\n## 划分子网\n\n基本思路如下：\n\n* 一个拥有多个物理网络的单位，将所属的物理网络划分为若干子网，但该单位对外仍表现为一个网络。\n* 从网络的主机号借用若干位作为子网号，两级IP地址在本单位内部变成三级IP地址{<网络号><子网号><主机号>}。\n* 发送给本单位某台主机的网络包到达本单位网络上的路由器后，路由器根据目的网络号与子网号找到目的子网，再将网络包发送给目的子网。\n\n## 子网掩码\n\n<div style=\"width:50%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n&nbsp;\n\n目的IP与子网掩码按位与得到子网地址。网络的默认子网掩码中1的位置与网络中主机IP地址的网络号字段对应。\n\n## 使用子网时的分组转发\n\n在划分子网的情形下，路由表的每条路由主要包含三项：目的网络地址、子网掩码、下一跳IP地址，分组转发算法也要做出相应改变。\n\n* 路由器从网络包的IP头部提取目的IP；将目的IP与各子网掩码按位与，若计算结果等于路由器所在子网地址，则路由器直接将网络包交付目的主机；否则，执行下一步。\n* 若路由器的路由表中有目的IP的特定路由，则路由器将网络包发给路由表所指明的下一跳路由器。否则，执行下一步。\n* 对路由表的每一行<目的网络地址, 子网掩码, 下一跳IP地址>，用其子网掩码与网络包的目的IP按位与，若计算结果等于其目的网络地址，则将数据传递给该路由的下一跳IP地址。否则，执行下一步。\n* 若路由器中有一个默认路由，则路由器将网络包发给路由表所指明的默认路由器。否则，执行下一步。\n* 报告分组转发出错。\n\n## 无分类编址CIDR\n\n### 网络前缀\n\n无分类域间路由选择。CIDR将32位的IP地址划分为前后两个部分，前面部分指明网络，后面部分指明主机。消除了传统的A类、B类、C类地址与划分子网概念。如下是一个CIDR地址划分的例子。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n&nbsp;\n\n### 最长前缀匹配\n\n根据上节的例子可以看到，在查找路由表时可能会得到不止一个匹配结果，此时应该选择匹配长度最长的路由。这称为最长前缀匹配。\n\n### 二叉线索查找路由\n\n为进行有效查找，无分类编址的路由表存放在二叉线索树中。在查找前，找出对应每个IP地址在表中的唯一前缀，接下来以这些前缀构造二叉线索，查找时，只要可以与唯一前缀匹配即可。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 10.png pic10 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第二章第一节 网际协议IP","url":"/course/cn-ch2-par1.html","content":"\n## 虚拟互连网络\n\n许多计算机网络通过路由器互连，参加互连的计算机网络都使用相同的网际协议IP，因此可以把互连以后的计算机网络看成如下图所示的一个虚拟互连网络。互连起来的各种物理网络的异构性是客观存在的，但是使用IP协议就可以使这些性能各异的网络在网络层看起来如同一个统一的网络。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\n## 分类的IP地址\n\n将IP地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，第一个字段称为网络号，第二个字段称为主机号。组成的IP地址在整个互联网范围内是唯一的。这种两级IP地址记为{<网络号><主机号>}。如下图是各种类型的IP地址：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n## IP地址与硬件地址\n\n(1)设计IP地址的目的。(有了MAC地址为什么还要IP地址)\n\n随着网络中设备的逐渐增多，人们发现路由(寻址数据包从发送端到接收端的路径)越来越困难。于是有人提出将网络划分成很多的子网，在路由时就可以将其他子网看成一个整体，路由器只需要考虑将数据包发送到接收端所在子网即可(剩下工作由子网内部解决)。这样找到的路由接近最优路由但大大减少了计算量。于是，需要有一种地域相关的地址，而IP地址就是！位于同一子网上的网络设备，其IP地址的前缀一致。从而在路由时通过IP地址找到较优路由。\n\n(2)设计MAC地址的目的。(有了IP地址为什么还要MAC地址)\n\nMAC地址是网卡地址，网卡才是真正能够做通讯的设备，IP只是上层的软件，负责将不同的网络连接在一起。\n\n&nbsp;\n\nIP地址用在网络层及以上，MAC地址用在数据链路层及以下。如下图，三个局域网用两个路由器连接起来，由于路由器R1、R2同时连接在两个局域网上，因此R1、R2都有两个MAC地址。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n## 地址解析协议ARP\n\n### ARP报文格式\n\n<div style=\"width:60%;margin:auto\">{% asset_img 55.jpg pic55 %}</div>\n\n&nbsp;\n\n* 硬件地址：表示ARP报文可在哪种类型的网络上传输，1表示以太网；\n* 上层协议类型：表示硬件地址要映射的地址协议类型。映射IP地址时为0x0800；\n* MAC地址长度：6；\n* IP协议地址长度：4；\n* 操作类型：1表示请求报文，2表示应答报文；\n\nARP报文加上MAC头部发送到网络上。\n\n### ARP工作原理\n\n根据IP地址，解析出同一局域网上设备的MAC地址。每台主机上都设置一个ARP高速缓存，存放着本局域网上各主机与路由器的IP地址到MAC地址的映射表。显然，如果主机查询的IP地址在主机的ARP高速缓存中存在，即可读取出IP地址对应的MAC地址，否则，按如下步骤找出IP地址对应的MAC地址。\n\n* 查询主机的ARP进程在本局域网上广播发送一个ARP请求分组用于查询IP地址对应的MAC地址；\n* 本局域网上所有主机运行的ARP进程都收到此ARP请求分组；\n* IP地址与请求分组中查询MAC地址的IP地址不一致的主机忽略此请求，否则，(IP地址与请求分组中查询MAC地址的IP地址一致的主机)向查询主机发送ARP响应分组，其中包含自身的MAC地址。同时在自身的ARP高速缓存中写入查询主机的IP : MAC映射；在Linux上可使用`arp -a`查看当前的ARP高速缓存。\n* 查询主机收到响应分组后，在其ARP缓存中添加这组IP : MAC映射；\n\n<div style=\"width:60%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n&nbsp;\n\n## IP数据报的格式\n\n<div style=\"width:60%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n* 首部长度。以4字节为单位，即若首部长度为5，则表示IP首部的长度为20字节；\n* 标识。IP软件维持一个计数器，每产生一个数据报，计数器加1，并将计数器的值赋给标识字段。这个标识并不是序号(IP是无连接的)，这是因为当数据报很长需要分组传输时，每个分组的数据包的标识字段都是一样的。相同标识字段的数据包意味着数据包来自同一数据报；\n* 总长度。整个IP数据包的长度，以字节为单位；该字段占16位，故IP数据包的长度最大为65535字节；\n* 标志。该字段最低位记为MF位，MF位为1表示该数据报还有分组，MF位为0表示这是数据报中最后一个分组；该字段中间位记为DF位，DF为0表示允许IP数据报分组，否则不允许IP数据报分组；\n* 片偏移。较长的数据报在分组后，某分组在原数据报中的相对位置，片偏移以8字节为偏移单位，即每个分组的长度必为8字节的整数倍；\n* 生存时间(TTL)。占8位，IP数据包每经过一个路由器，路由器就会将IP数据包的TTL减1，若IP数据包的TTL为0，则丢弃该IP数据包；\n* 协议。指明该IP数据报携带的数据使用的哪种协议，常见的TCP协议为6、UDP协议为17、IPv6协议为41；\n\n<div style=\"width:66%;margin:auto\">{% asset_img 57.png pic57 %}</div>\n\n&nbsp;\n\n\n\n## IP数据报的分组转发\n\n在路由表中，最主要的路由包含(目的IP地址, 下一跳IP地址)。网络包每次到达路由器，路由器都根据目的IP地址确定下一跳路由器的IP地址，然后将IP数据包送交数据链路层的网络接口，网络接口将下一跳的IP地址借助ARP协议转换为MAC地址，它将作为MAC头部的目的地址，然后路由器将网络包发送到下一跳路由器。归纳如下分组转发算法。\n\n* 路由器从网络包的IP头部提取目的IP；若目的IP与路由器在同一网络，则路由器直接将网络包交付目的主机；否则，执行下一步。\n* 若路由器的路由表中有目的IP的特定路由，则路由器将网络包发给路由表所指明的下一跳路由器。否则，执行下一步。\n* 若路由表有到达目的主机所在网络的路由，则路由器将网络包发给路由表所指明的下一跳路由器。否则，执行下一步。\n* 若路由器中有一个默认路由，则路由器将网络包发给路由表所指明的默认路由器。否则，执行下一步。\n* 报告分组转发出错。","tags":["计算机网络"],"categories":["course"]},{"title":"第一章 计算机网络体系结构","url":"/course/cn-ch1.html","content":"\n## 分层的好处\n\n分层的好处：(1)各层之间相互独立；(2)灵活；(3)易于实现与维护；(4)促进标准化。通常各层要完成以下功能：\n\n* 差错控制：保证相应层次对等方的通信可靠；\n* 流量控制：发送的数据要让接收端来得及接收；\n* 分段与重装：发送端将要发送的数据划分为一定长度的数据块，接收端要将接收的数据块还原；\n* 复用与分用：发送端的多个高层应用复用一条低层的连接，而接收端的低层将收到的信息分别交付高层的多个应用；\n* 连接建立与释放：通信开始前建立连接，通信结束断开连接；\n\n## 五层协议模型\n\n<div style=\"width:56%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\n**应用层**\n\n通过应用进程间的交互来完成特定网络应用。应用层协议定义应用进程间通信与交互的规则。如域名系统DNS、HTTP协议、SMTP电子邮件协议。\n\n**传输层**\n\n向两台主机中进程之间的通信提供通用的数据传输服务。传输层主要有TCP协议与UDP协议：\n\n* 传输控制协议TCP：提供面向连接、可靠的数据传输服务；\n* 用户数据报协议UDP：提供无连接的、尽最大努力的数据传输服务；\n\n**网络层**\n\n为分组交互网上的不同主机提供通信服务。网络层主要使用IP协议。\n\n## TCP/IP协议族\n\n将TCP/IP协议族按层次描述如下图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 2.png pic2 %}</div>","tags":["计算机网络"],"categories":["course"]},{"title":"第十九章 I/O子系统","url":"/course/os-ch19.html","content":"\n## I/O特点\n\nI/O设备有三种常见类型：字符设备(键盘、鼠标等)，块设备(磁盘驱动器、光驱等)，网络设备(无线网卡、蓝牙等)。不同类型的设备访问特征不同。\n\n* 字符设备：以字节为单位顺序访问，访问使用get()、put()函数；\n* 块设备：读写以一个数据块为单位，访问既可以使用get()、put()函数，也可以使用文件系统接口，或者将文件映射到内存；\n* 网络设备：交互复杂，接收格式化的网络报文，访问使用专门的网络报文收发接口——send/receive；\n\n## I/O结构\n\n如下是整个计算机系统的结构：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 77.png pic77 %}</div>\n\n&nbsp;\n\nI/O的结构层次如下：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 78.png pic78 %}</div>\n\n&nbsp;\n\n下面考虑一个完整的I/O请求的生命周期：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 79.png pic79 %}</div>\n\n## I/O数据传输\n\n访问设备的数据可通过CPU指令(in/out)实现，这种方式便于实现但是消耗CPU(时间与数据量成正比)。或者直接通过内存访问，只需要在传输数据的开始和结束使用CPU，传输数据过程不影响CPU，在高吞吐量的I/O设备中使用该方式。\n\n处理设备请求有两种方式：轮询与设备中断；设备中断效率高，设备中断的I/O处理流程如下：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 80.png pic80 %}</div>\n\n&nbsp;\n\n## Linux I/O子系统\n\nLinux I/O系统结构如下图所示：\n\n<div style=\"width:38%;margin:auto\">{% asset_img 81.png pic81 %}</div>","tags":["操作系统"],"categories":["course"]},{"title":"第十八章 文件系统实例","url":"/course/os-ch18.html","content":"\n## FAT文件系统\n\nFAT文件系统的结构如下：\n\n```basic\n---------------------------------------------------------------------------------------\n| 启动扇区 |   文件分配表   |  文件分配表副本  |  根目录项  |           其他文件           |\n---------------------------------------------------------------------------------------\n```\n\n## EXT4文件系统\n\n支持大容量存储，可快速恢复异常状态。\n\n### 大容量存储\n\n<div style=\"width:68%;margin:auto\">{% asset_img 68.png pic68 %}</div>\n\n&nbsp;\n\n索引块采用\"段机制\"，对于大文件(一般连续)，只需要一次访问。\n\n### 异常恢复\n\nEXT4文件系统框架示意图如下：\n\n<div style=\"width:40%;margin:auto\">{% asset_img 71.png pic71 %}</div>\n\n&nbsp;\n\n其中Group的结构如下图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 69.png pic69 %}</div>\n\n&nbsp;\n\n其中，Bitmaps标志每个文件数据块是否被占用，文件数据块有两种——索引数据块与存储数据块；\n\n当系统出现断电或者系统崩溃，有些在缓存中的数据还未写入文件，这时就出现缓存与文件的数据不一致。EXT4文件系统使用日志来恢复异常(现代的文件系统都是日志文件系统)。日志的组成如下：\n\n<div style=\"width:40%;margin:auto\">{% asset_img 70.png pic70 %}</div>\n\n其中，TxB与TxE分配标志一个日志的开始与结束，中间是日志的内容：\n\n* I[v2]：对更改的存储数据块对应的索引数据块的改变；\n* B[v2]：对更改的存储数据块对应的Bitmaps位的改变；\n* Db：更改的存储数据块；\n\n日志文件系统先将对应日志写入日志数据块，再将缓存数据写入文件。为保证TxE的正确性，先写入TxB、I[v2]、B[v2]，再写入TxE。\n\n为提高数据写入文件的速度，可采用批处理；此外，通过循环日志的方式，缩小日志数据的规模。\n\n为了进一步提高数据写入文件的速度，metadata日志省略了在日志数据块中写入Db，但此时要调整数据写入顺序：Db写入文件->metadata写入日志数据块->metadata写入文件系统。通过强制首先写入数据，保证指针永远不会指向垃圾数据。\n\n## ZFS文件系统\n\n### 概述\n\nZFS是一种新型的文件系统，它提供了简单的管理、事务语义、端到端数据完整性与极大的可扩展性。ZFS文件系统框架如下图：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 72.png pic72 %}</div>\n\n* ZPL：封装的处理文件的接口；\n* DMU：数据管理单元，提供基于对象的事务操作的支持；\n* ARC：(类似内存的)缓存与替换算法；\n* ZIO：对实际的I/O处理做抽象，向ARC层提供支持；\n* VDEV：虚拟设备，内置了各种RAID；\n\nZFS文件系统使用存储池作为存储设备。取消了文件卷，采用分配与回收机制，分配的空间易于调整；\n\n<div style=\"width:40%;margin:auto\">{% asset_img 73.png pic73 %}</div>\n\n&nbsp;\n\n### 数据完整性\n\n**写时复制**：对数据进行修改时，先复制数据的一个副本，在副本上修改完再写回数据的位置(提交)。\n\n读数据时，采用分层校验，即ZFS校验树，每级目录都有校验和；\n\n<div style=\"width:30%;margin:auto\">{% asset_img 74.png pic74 %}</div>\n\n&nbsp;\n\n在读数据时，如果数据未能通过校验，则读取数据副本，并将副本写入数据位置。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 75.png pic75 %}</div>\n\n&nbsp;\n\nZFS采用动态条带宽，不同对象校验数据块的的个数也不同，根据所需安全性来选择合适的校验数据块个数；\n\n<div style=\"width:30%;margin:auto\">{% asset_img 76.png pic76 %}</div>\n\n&nbsp;","tags":["操作系统"],"categories":["course"]},{"title":"第十七章 文件系统概念","url":"/course/os-ch17.html","content":"\n## 文件系统与文件\n\n文件系统是操作系统中管理持久性数据的子系统，提供数据存储与访问功能。文件是具有符号名，由字节序列构成的数据项集合。文件是文件系统的基本数据单位，文件名是文件的标识符号。\n\n**文件系统的功能**\n\n* 分配文件磁盘空间：管理文件数据块、管理空闲空间、分配存储区域；\n* 管理文件集合：文件定位、文件命名、文件系统结构——文件的组织；\n* 数据可靠与安全：安全(多层次保护数据安全)、可靠(持久保存数据，避免系统崩溃、媒体错误、攻击等等)；\n\n**文件属性**\n\n文件属性包括名称、类型、位置、大小、保护、创建者、创建时间、最近修改时间等等。\n\n**文件头**\n\n文件系统元数据中的文件信息。其中包括文件属性以及文件的存储位置与顺序。\n\n## 文件描述符\n\n操作系统维护的打开的文件的状态与信息。包括文件指针、文件打开次数、文件在磁盘上的位置、访问权限等等。\n\n## 目录 文件别名 文件系统种类\n\n目录是一种特殊的文件，用来表示其他文件的信息，目录的内容为文件索引表(每个索引项为<文件名, 指向文件的指针>)。\n\n**日志文件系统**：文件系统的所有修改，都会记录。\n\n## 虚拟文件系统\n\n对所有不同文件系统的抽象。主要实现以下四个功能：\n\n* 提供相同的文件与文件系统接口；\n* 管理所有文件和文件系统关联的数据结构；\n* 高效的查询；\n* 与特定文件系统模块的交互；\n\n### 文件系统基本数据结构\n\n* 文件卷控制块；一个文件系统有一个文件卷控制块，包含文件系统详细信息(块大小、空余块、计数/指针等)。\n* 文件控制块；一个文件有一个文件控制块，包含文件详细信息(访问权限、所有者、大小、数据块位置等)。\n* 目录项；一个文件有一个目录项，将目录项数据结构及树型布局编码成树型数据结构(指向文件控制块、父目录、子目录等)。\n\n整个文件系统的组织视图如下：\n\n<div style=\"width:42%;margin:auto\">{% asset_img 56.png pic56 %}</div>\n\n## 文件缓存与打开文件\n\n### 文件缓存\n\n在计算机系统中存在多处缓存：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 57.png pic57 %}</div>\n\n&nbsp;\n\n数据块有两种缓存方式：数据块缓存与页缓存(将数据块与内存页缓存起来)。\n\n* 数据块缓存：虚拟页对换与文件读写分开。最终合并为数据块缓存。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 58.png pic58 %}</div>\n\n&nbsp;\n\n* 页缓存：在虚拟地址空间中虚拟页面可映射到本地外存文件中。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 59.png pic59 %}</div>\n\n&nbsp;\n\n其中文件数据块被映射为页，文件的读/写操作被转换成对内存的访问。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 60.png pic60 %}</div>\n\n### 打开文件\n\n每个打开的文件都有一个文件描述符，记录文件的状态信息，包括目录项、当前文件指针、文件操作设置等；\n\n每个进程有一个打开文件表，记录进程单独打开的文件描述符；\n\n同时操作系统还有一个打开文件表，其中记录的文件描述符由多个进程共享；\n\n<div style=\"width:60%;margin:auto\">{% asset_img 61.png pic61 %}</div>\n\n&nbsp;\n\n一些文件系统提供文件锁，用于协调多进程的文件访问；文件系统有两个处理方式：强制与劝告。\n\n* 强制：根据锁的状态与访问请求确定是否拒绝访问；\n* 劝告：进程查看锁的状态，由进程决定下一步操作；\n\n## 文件分配\n\n本质为如何表示分配给一个文件数据块的位置与顺序。与内存分配类似，文件分配也有连续、链式、索引分配。所谓索引分配，就是用存储文件数据块的指针来表示分配给一个文件数据块的位置与顺序(这个存储文件数据块的指针的数据块称为索引数据块)。这3种分配方式各有优缺点，实际的文件分配方案会将这三种分配方式结合起来，下面介绍UFS文件系统的文件分配方案。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 62.png pic62 %}</div>\n\n&nbsp;\n\n文件头包含13个指针，前10个指针(直接)指向文件数据块、第11个指针指向索引块、第12个指针指向2级索引块、第13个指针指向3级索引块；对于小文件：这种文件分配退化为连续分配，对于大文件：这种文件分配就是多级索引分配。\n\n## 冗余磁盘阵列\n\n使用多磁盘可改善吞吐量(并行)，增加可靠性(冗余)。\n\n### RAID-0\n\n磁盘条带化技术。将数据分成多个子块，存储在独立的磁盘中。增加了读写的磁盘带宽，读写数据的性能提升。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 63.png pic63 %}</div>\n\n&nbsp;\n\n### RAID-1\n\n向两个磁盘写入，从任何一个读取。增加了可靠性与读数据的性能。\n\n<div style=\"width:40%;margin:auto\">{% asset_img 64.png pic64 %}</div>\n\n&nbsp;\n\n### RAID-4\n\n带校验的磁盘条带化——数据块级别的磁盘条带化加专用奇偶校验磁盘。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 65.png pic65 %}</div>\n\n### RAID-5\n\n带分布式校验的磁盘条带化。减小了带校验和磁盘的读写压力。\n\n<div style=\"width:66%;margin:auto\">{% asset_img 66.png pic66 %}</div>\n\n&nbsp;\n\n此外，这些RAID技术还可以嵌套使用。比如RAID-0与RAID-1的嵌套：\n\n<div style=\"width:45%;margin:auto\">{% asset_img 67.png pic67 %}</div>","tags":["操作系统"],"categories":["course"]},{"title":"第十六章 进程通信","url":"/course/os-ch16.html","content":"\n## 进程通信基本概念\n\n进程通信，简称IPC，是进程进行通信与同步的机制；IPC提供2个基本操作——send(发送操作)与receive(接收操作)；进程通信的流程为：(1)在通信进程间建立通信链路，(2)通过send/receive交互消息；\n\n### 直接通信与间接通信\n\n**直接通信**：send(P,mes)<->receive(Q,mes)，进程在直接通信时必须指明发送/接收的对象是谁。\n\n**间接通信**：通过操作系统维护的消息队列(内核中)实现进程间消息的接收与发送。每个消息队列都有一个唯一的标识，只有共享了相同消息队列的进程才可以通信。\n\n### 阻塞通信与非阻塞通信\n\n阻塞通信\n\n* 发送：发送进程在发送消息后进入等待，直到接收进程成功接收。\n* 接收：接收进程在请求消息后进入等待，直到接收到消息。\n\n非阻塞通信\n\n* 发送：发送进程在发送完消息后不用等待，可继续进行其他操作。\n* 接收：接收进程在请求消息后如果没有收到消息不用等待，可继续进行其他操作。\n\n## 信号与管道\n\n### 信号\n\n进程间软件中断通知与处理机制。信号机制的实现如下图。\n\n<div style=\"width:42%;margin:auto\">{% asset_img 54.png pic54 %}</div>\n\n### 管道\n\n进程间基于内存文件的通信机制。是一种间接通信机制。\n\n* 创建管道：pipe(rgfd)；rgfd是两个文件描述符组成的数组，其中rgfd[0]是读文件描述符、rgfd[1]是写文件描述符。\n* 读管道：系统调用read(fd, buffer, n)\n* 写管道：系统调用write(fd, buffer, n)\n\n## 消息队列与共享内存\n\n### 消息队列\n\n操作系统维护的以字节序列为基本单位的间接通信机制。\n\n### 共享内存\n\n操作系统通过将同一物理内存区域映射到多个进程的地址空间来实现进程通信。需要额外的同步互斥机制。是进程间最快速的通信机制。\n\n## D-bus机制\n\n&nbsp;\n\n## Binder机制\n\n### 一次拷贝\n\n<div style=\"width:68%;margin:auto\">{% asset_img 55.png pic55 %}</div>\n\n当进程A向进程B拷贝数据时，首先将进程A的数据从用户空间拷贝到内核空间，再将内核空间中的数据所在内存区域映射到进程B的用户空间，这样使用一次拷贝即可传递进程A的数据到进程B，之所以没有使用共享内存是为了避免同步互斥的开销。","tags":["操作系统"],"categories":["course"]},{"title":"第十五章 死锁与并发错误检测","url":"/course/os-ch15.html","content":"\n## 死锁的概念\n\n多个进程各自占用部分资源，形成循环等待的现象。\n\n死锁的必要条件：\n\n* 互斥：任何时刻只能有一个进程使用该资源；\n* 持有并等待：进程占用着一个资源，并且还需要等待另外的资源；\n* 非抢占：资源只能由进程使用后自愿释放；\n* 出现了循环等待；\n\n## 死锁处理方法\n\n对死锁的处理采用\"纵深防御\"的思路——死锁预防、死锁避免、死锁检测与恢复；死锁通常由应用程序处理，操作系统层面不考虑死锁。\n\n### 死锁预防\n\n限制并发进程对资源的请求，使操作系统在任何时刻不满足死锁的必要条件；但资源的利用效率低。\n\n### 死锁避免\n\n**安全进程序列**：对一列进程$\\{\\rm{P_1}, \\cdots , \\rm{P_n}\\}$，$\\rm{P_i}$未来需要的资源量(声明所需资源的最大量减去已占用的资源量)<=当前可用资源量+所有$\\rm{P_j(j<i)}$的资源量对所有的$\\rm{i}$均成立，则这个进程序列称为安全进程序列。\n\n系统处于安全状态，即对所有占用资源的进程，存在一个安全进程序列。\n\n于是当进程请求资源时，操作系统判断分配资源之后是否还处于安全状态，如果是，则分配进程申请的资源。\n\n### 死锁检测\n\n检测操作系统是否出现死锁，根据占用资源的进程是否存在一个安全进程序列，如果不存在，操作系统就会出现死锁。","tags":["操作系统"],"categories":["course"]},{"title":"第十四章 信号量与管程","url":"/course/os-ch14.html","content":"\n## 信号量\n\n信号量是操作系统提供的一种协调共享资源访问的方法。信号量是一种抽象的数据类型，由一个整型变量与两个原子操作(P操作——申请资源，V操作——释放资源)组成：\n\n```c++\nclass Semaphore{\n    int sem;\n    WaitQuene q;//等待队列q\n}\n\nSemaphore::__init__(flag){\n    sem=flag;\n    q=NULL;\n}\n\nSemaphore::P(){\n    sem--;\n    if(sem<0){\n        q.add(current);//当前进程\n        block(current);\n    }\n}\n\nSemaphore::V(){\n    sem++;\n    if(sem<=0){\n        next=q.remove();\n        wakeup(next);\n    }\n}\n```\n\nP、V操作由操作系统实现，执行过程中不会被打断，从而保证其原子性。借助P、V操作的原子性，可以更简单地实现同步互斥。下面介绍信号量的使用。\n\n### 信号量的使用\n\n实现互斥的伪代码如下：\n\n```c++\nmutex= Semaphore(1);\n```\n\n对于需要互斥访问的临界区代码：\n\n```c++\nmutex->P(t);\n//Critical Section\nmutex->V();\n```\n\n注意：必须按照先P操作后V操作的顺序使用，且P操作与V操作必须成对使用。\n\n实现条件同步的伪代码如下：\n\n```c++\ncondition=Semaphore(0);\n```\n\n例如：必须等线程B执行完X，线程A才能执行N；这样使用信号量：\n\n对线程A：在N之前插入P操作，对线程B：在X后插入V操作，即：\n\n```c++\n//线程A\n----------------\n|     M        |\n----------------\ncondition->P();\n----------------\n|     N        |\n----------------\n//线程A\n\n//线程B\n----------------\n|     X        |\n----------------\ncondition->V();\n----------------\n|     Y        |\n----------------\n//线程B\n```\n\n### 用信号量解决生产者-消费者问题\n\n问题分析：\n\n* 任何时刻只能有一个线程操作缓冲区(互斥访问)；\n* 缓冲区空则消费者必须等待生产者(条件同步)；\n* 缓冲区满则生产者必须等待消费者(条件同步)；\n\n每个约束条件对应一个信号量：(二进制)信号量mutex、(资源)信号量fullBuffers与(资源)信号量emptyBuffers。将有界缓冲区定义为如下类，Deposit方法向有界缓冲区写入一个字节，Remove方法从有界缓冲区中移出一个字节。\n\n```c++\nclass BoundedBuffer{\n    Semaphore mutex;\n    Semaphore fullBuffers;\n    Semaphore emptyBuffers;\n    char data[n];//n为缓冲区大小\n}\n\nBounderBuffer::__init__(){\n    mutex=Semaphore(1);\n    fullBuffers=Semaphore(0);\n    emptyBuffers=Semaphore(n);\n}\n\nBounderBuffer::Deposit(c){\n    emptyBuffers->P();\n    mutex->P();\n    write(data, c);\n    mutex->V();\n    fullBuffers->V();\n}\n\nBounderBuffer::Remove(){\n    fullBuffers->P();\n    mutex->P();\n    move(data, c);\n    mutex->V();\n    emptyBuffers->V();\n}\n```\n\n从上面的运用中可以看出，使用信号量来解决同步互斥问题时要求P、V操作必须成对出现，编写容易出错。一旦没有考虑周全，就会导致死锁。\n\n## 管程\n\n管程是一种用于多线程互斥访问共享资源的程序结构。它采用面向对象的编程方法，将对共享资源的P、V操作成对地写入对共享资源的操作。与临界区不同的是，正在管程中的线程可以放弃对管程的互斥访问，等待事件出现时恢复(与临界区的不同点：线程在临界区中执行时，只能在临界区执行完后退出临界区)。\n\n利用管程来定义访问数据的方法，从而不用程序编写者考虑访问时的P、V操作。管程包括锁与条件变量(可选)：\n\n* 锁用于控制管程代码的互斥访问，因此在管程外会有一个等待队列；\n* 每个条件变量对应一种等待原因，都有一个等待队列(在管程内部)；另外，条件变量有两种操作——Wait操作与Signal操作；对条件变量的定义如下：\n\n```c++\nclass Condition{\n    int numWaiting;\n    WaitQuene q;\n}\n\nCondition::__init__(){\n    numWaiting=0;\n    q=NULL;\n}\n\nCondition::Wait(lock){\n    numWaiting++;\n    //自身阻塞在条件变量的等待队列中\n    q.add(current);\n    //释放管程的互斥访问\n    lock.Release();\n    //去唤醒其他线程\n    schedule();\n    //条件满足后重新获取锁\n    lock.Acquire();\n}\n\nCondition::Signal(){\n    if(numWaiting>0){\n        t=q.remove();//从q中选择一个进程将其唤醒\n        wakeup(t);\n        numWaiting--;\n    }\n}\n```\n\n### 用管程解决生产者-消费者问题\n\n```c++\nclass BoundedBuffer{\n    Lock lock;\n    int count;\n    Condition notFull, notEmpty;\n    char data[n];//n为缓冲区大小\n}\n\nBoundedBuffer::__init__(){\n    lock=Lock();\n    count=0;\n    notFull=Condition();\n    notEmpty=Condition();\n}\n\nBoundedBuffer::Deposit(c){\n    lock.Acquire();\n    //检查是否还有空闲区，如果缓存写满了就等待，直到notFull的条件满足。\n    while(count==n)\n        notFull.Wait(lock);\n    write(data, c);\n    count++;\n    notEmpty.Signal();\n    lock.Realease();\n}\n\nBoundedBuffer::Remove(c){\n    lock.Acquire();\n    //检查缓冲区是否有数据，如果缓冲区为空则等待，直到notEmpty的条件满足。\n    while(count==0)\n        notEmpty.Wait(lock);\n    move(data, c);\n    count--;\n    notFull.Signal();\n    lock->Release();\n}\n```\n\n### 条件变量释放后的处理\n\n根据条件变量释放后处理的不同，管程分为Hansen管程与Hoare管程；Hansen管程会等到当前线程执行完之后再去执行条件变量唤醒的线程，而Hoare管程会立即切换到条件变量唤醒的线程执行。在实际操作系统中，使用Hansen管程因为其效率更高、且易于实现。若操作系统使用了Hansen管程，等到被唤醒的线程被调度时可能所需条件又不满足，因此需要用while循环再次检查；但如果操作系统使用的是Hoare管程。那么CPU会立即执行被唤醒的线程，因此使用if控制流。\n\n### 用管程解决读者-写者问题\n\n读者-写者问题约束如下：\n\n* 同一时刻，允许多个读者同时读；\n* 读写互斥；\n* 写写互斥；\n\n定义两个基本方法——Read与Write，4个条件变量；\n\n```c++\nclass Database{\n    int AR;//active reader\n    int AW;//active writer\n    int WR;//waiting reader\n    int WW;//waiting writer\n    Lock lock;\n    Condition okToRead, okToWrite;\n    char * data;\n}\n\nDatabase::Read(){\n    while (AW+WW);//wait until no writers.\n    StartRead();\n    read(data);\n    //check out: wake up waiting writers.\n    DoneRead();\n}\n\nDatabase::StartRead(){\n    lock.Acquire();\n    while((AW+WW)>0){\n        WR++;\n        okToRead.wait(lock);\n        WR--;\n    }\n    AR++;\n    lock.Release();\n}\n\nDatabase::DoneRead(){\n    lock.Acquire();\n    AR--;\n    if(AR==0 && WW>0)\n        okToWrite.Signal();\n    lock.Release();\n}\n\nDatabase::Write(){\n    while (AR+WR);//wait until no reader.\n    StartWrite();\n    write(data);\n    //check out: wake up wating reader.\n    DoneWrite();\n}\n\nDatabase::StartWrite(){\n    lock.Acquire();\n    while((AW+AR)){\n        WW++;\n        okToWrite.wait(lock);\n        WW--;\n    }\n    AW++;\n    lock.Release();\n}\n\nDatabase::DoneWrite(){\n    lock.Acquire();\n    AW--;\n    if(WW>0)\n        okToWrite.Signal();\n    else if(WR>0)\n        okToRead.broadcast();//使所有在该条件上等待的进程都被释放并进入队列(读读不互斥)\n    lock.Release();\n}\n```","tags":["操作系统"],"categories":["course"]},{"title":"第十三章 同步互斥","url":"/course/os-ch13.html","content":"\n## 同步互斥的背景\n\n同步互斥是操作系统中协调进程协作与相互关系的一种机制。对于并发的进程，存在多个进程共享资源的情形，那么这时进程执行就会存在不确定性与不可重现性；然而，进程并发执行具有节约资源(共享)、高速等优点，因此为了使并发的进程能够正确运行，操作系统使用了同步互斥机制。\n\n### 原子操作\n\n一次不存在任何中断与失败的操作。\n\n操作系统需要利用同步互斥机制在并发执行的同时，保证一些操作是原子操作。\n\n实现同步互斥机制最简单有效的方案为利用两个原子操作实现一个锁：\n\n* Lock.Acquire()：在锁释放前请求锁的进程一直处于等待状态；如果多于一个进程都在等待同一个锁，在锁释放之后，只有一个进程能够获得锁。\n* Lock.Release()：解锁并唤醒一个等待中的进程。\n\n事实上，这就是用两个原子操作的锁放在一段需要是原子操作的代码两端，使这段代码的执行是原子操作。开头的锁操作称为进入临界区，代码后的解锁操作称为退出临界区。\n\n### 进程的交互关系\n\n根据进程相互感知程度的不同，进程之间的交互分为3种关系，如下表所示：\n\n|             相互感知的程度             |     交互关系     |             进程间的影响             |\n| :------------------------------------: | :--------------: | :----------------------------------: |\n|  相互不感知(完全不了解其他进程的存在)  |       独立       |         进程间的操作互不影响         |\n| 间接感知(双方与第三方交互，如共享资源) | 通过共享进行协作 |    进程的结果依赖于共享资源的状态    |\n|     直接感知(双方直接交互，如通信)     | 通过通信进行协作 | 进程的结果依赖于从其他进程获取的信息 |\n\n此时进程间会出现如下三种状态。\n\n* 互斥：一个进程占用资源，其他的进程不能使用该资源；\n* 死锁：多个进程各自占用部分资源，形成循环等待；\n* 饥饿：进程一直得不到资源。\n\n## 同步方法\n\n为了保证只有一个进程进入临界区执行，需要在进入临界区之前检查进程是否能够进入临界区，若可以进入，接下来设置相应\"进入临界区\"的标志。进程使用完资源之后，退出临界区，去除相应\"进入临界区\"的标志。\n\n综上，临界区的访问规则为空闲则入、忙则等待、有限等待与让权等待(可选)。\n\n### 禁用硬件中断\n\n没有中断，没有上下文切换，因此没有并发。\n\n* 硬件将中断处理延迟到中断被启用之后；\n* 现代计算机体系结构都提供指令来实现禁用中断；\n\n因此，进入临界区就是禁用所有中断并保存标志位；退出临界区就是启用所有中断并恢复标志位。禁用硬件中断可有效实现同步互斥，但是也有如下局限性：\n\n* 禁用中断后，进程无法被停止；会使整个操作系统暂停，导致其他进程处于饥饿状态；\n* 临界区执行时间可能很长；\n\n因此，禁用硬件中断的方法须小心使用。\n\n### 基于软件的同步\n\n复杂(需要两个进程间的共享数据项)，是一个忙等待(浪费CPU时间)。\n\n### 高级抽象的同步方法\n\n原子操作指令1：测试与置位指令(TS指令)——从内存单元读取值并返回，期间将内存单元置1；\n\n该指令的伪代码操作如下：\n\n```c\nbool TestAndSet(bool * target)\n{\n    bool * rv= target;\n    * target=true;\n    return rv;\n}\n```\n\n\n\n原子操作指令2：交换指令(exchange)，顾名思义，交互内存中的两个值。\n\n基于上述两个原子操作指令，来实现锁。\n\n**使用TS指令实现锁**：\n\n```c++\nclass Lock{\n    bool value;\n}\n\nLock::__init__(){\n    value=false;\n}\n\nLock::Acquire(){\n    while (TS(& value)){\n        //run\n    }\n}\n\nLock::Release(){\n    value=false;\n}\n```\n\n但是上述实现是一种忙等待，改进如下：\n\n```c++\n//增加一个等待队列\nclass Lock{\n    bool value;\n    WaitQuene q;\n}\n\nLock::__init__(){\n    value=false;\n    q=NULL;\n}\n\n//当进程申请不到资源时，进入等待队列，执行进程调度\nLock::Acquire(){\n    while (TS(& value)){\n        q.add(current);\n        schedule();\n    }\n}\n\n//当占用资源的进程使用完资源后，释放锁，并且将某个等待的进程从等待队列中移除并将其唤醒\nLock::Release(){\n    value=false;\n    current=q.remove();\n    wakeup(current);\n}\n```","tags":["操作系统"],"categories":["course"]},{"title":"第四步 Web服务器处理请求","url":"/course/cn-step4.html","content":"\n## 服务器程序的结构\n\n为保证服务器同时与多个客户端进行通信，服务器启动多个服务器程序一对一地与客户端交互。服务器程序的结构如下图所示：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 20.png pic20 %}</div>\n\n&nbsp;\n\n服务器程序分为两个模块：等待连接模块与通信模块；在服务器启动并完成初始化操作后，它就会运行等待连接模块；等待连接模块创建套接字，然后进入等待连接的暂停状态，直到客户端发起连接；等待连接模块恢复运行并接受连接，启动客户端通信模块，传递套接字的副本给通信模块；\n\n通信模块使用已连接的套接字与客户端通信。由于在服务器上，一个端口可能与多个客户端建立通信，因此会有多个套接字的端口号相同，于是不能只通过端口号来指定套接字(在客户端可以这样做)，还需要加上源IP，因为各个客户端的IP肯定是不同，每个套接字与客户端一一对应，这样就能准确指定套接字。\n\n## 服务器的接收操作\n\n数据经网卡、MAC层、IP层到达TCP层(对于HTTP消息来说)，TCP的数据收发详见第二章，只剩下TCP的断开操作还未介绍；TCP断开操作称为四次挥手，示意图如下：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 21.jpg pic21 %}</div>\n\n&nbsp;\n\nHTTP协议规定服务器返回响应消息后主动断开连接，于是服务器端执行TCP断开操作；服务器端发送FIN位置1的TCP头部(表面自己已经没有要发送的消息)，客户端收到后返回确认接收的TCP头部，客户端仍然可以给服务器端发送消息，等客户端处理完数据可以结束与服务器端的连接时，客户端发送FIN位置1的TCP头部，处于等待状态的服务器返回确认接收的TCP头部，到此TCP连接彻底断开。\n\n## 服务器解析请求消息并作出响应\n\nWeb服务器公开的目录并不是磁盘上的实际目录，而是如下图所示的虚拟目录：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 22.png pic22 %}</div>\n\n&nbsp;\n\nWeb服务器根据请求消息中的源IP、用户名&密码、客户端域名进行访问控制；只有满足条件的请求消息才会对请求消息作出响应。\n\n对于运行访问的请求消息，若URL指定HTML文件或图片，直接将文件内容作为响应消息返回客户端即可；若URL指定的是一个程序，则服务器要从消息中获取运行程序所需参数(方法为GET，参数在URL之后；方法为POST，参数在消息体中)并运行程序然后将输出结果作为响应消息返回客户端。\n\n接下来Web服务器将响应消息委托给协议栈发送给客户端。\n\n## 浏览器接收响应并显示内容\n\n&nbsp;","tags":["计算机网络"],"categories":["course"]},{"title":"第三步 服务器端的局域网","url":"/course/cn-step3.html","content":"\n## 防火墙的结构与原理\n\n防火墙的基本思路：只允许发往特定服务器的特定应用程序的网络包通过，屏蔽其他的网络包。其中最主流的方式为包过滤，它根据源IP与目的IP、源端口与目的端口、控制位等信息来判断是否允许网络包通过。\n\n## 负载均衡\n\n若对服务器的访问量上升，则需要多台服务器来分担负载，即分布式架构。要采用这种方法，需要一种机制将客户端发送的请求分发到不同的服务器上，最简单的方式是通过DNS服务器来分配——由于客户端访问Web服务器时需要先向DNS服务器查询Web服务器的IP地址，这时在DNS服务器中对Web服务器的域名填写多个IP地址，则每次查询时DNS服务器都会按顺序(循环地)返回不同的IP地址，即轮询。但是，DNS服务器不能确认某个IP地址对应的Web服务器是否正常工作，因此，如果某台Web服务器出现故障，DNS仍然会给客户端返回这台Web服务器的IP地址，那么客户端发送的请求就无法被处理。\n\n另外，由于一些操作需要发送多次HTTP请求，这就导致需要在一个Web服务器上完成这多个请求，然而轮询会把这些HTTP请求分发到不同的Web服务器上。\n\n为避免上述问题，需要使用名为负载均衡器的设备，对于相关HTTP请求消息，客户端发送HTTP请求消息时在表单里面加上表示关联的信息，或者对HTTP规格进行扩展，在HTTP头部字段加上用来判断相关性的信息。若请求消息相关，负载均衡器将不考虑Web服务器的负载而是必须将相关的请求发送到同一Web服务器。\n\n同样地，要使用负载均衡器，要将Web服务器域名对应的IP在DNS服务器中设置为负载均衡器的IP。\n\n## 缓存服务器\n\nWeb服务器需要检查网址与访问权限，还有一些在页面填充数据的操作，因此将页面返回客户端的时间较长；相对地，缓存服务器只需要将保存在磁盘上的数据读取出来发送给客户端即可。使用缓存服务器既减轻了Web服务器的负担，又缩短了请求响应的时间。\n\n### 缓存服务器的工作过程\n\n与负载均衡器相同，缓存服务器也需要代替Web服务器被注册到DNS服务器上；因此，对于使用了缓存服务器的Web服务器，客户端的请求会到达缓存服务器，缓存服务器接收请求消息，接收操作下一章介绍；然后，缓存服务器会检查请求消息的内容，判断请求的数据是否已经在缓存中；\n\n* 不在缓存中。缓存服务器在HTTP请求消息头部添加一个Via字段，表示这个消息经过缓存服务器转发，然后将消息转发给Web服务器(如果有多台Web服务器，可根据请求消息中URL的目录名来判断)，示意图如下：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 16.png pic16 %}</div>\n\n&nbsp;\n\n缓存服务器转发请求消息时，缓存服务器相当于客户端，会创建套接字并连接Web服务器的套接字，然后转发请求消息并接收Web服务器的响应消息，然后在响应消息中加上Via字段表示响应消息是经缓存服务器中转的；最后，响应消息会保存在缓存服务器中，并记录保存的时间。\n\n* 在缓存中。缓存服务器在HTTP请求头部添加一个If-Modified-Since字段(内容为缓存数据被保存的时间)并将请求转发给Web服务器，Web服务器比较请求数据最后的更新时间与缓存数据被保存的时间来判断Web服务器上的请求的数据与缓存服务器上保存的请求的数据是否一致。\n  * 若一致。缓存服务器将请求的数据返回给客户端，同样加上Via字段；示意图如下。\n  * 若不一致。Web服务器返回最新的请求数据，缓存服务器加上Via字段转发给客户端。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 17.png pic17 %}</div>\n\n&nbsp;\n\n这种在Web服务器端缓存数据的代理机制，称为反向代理。\n\n**透明代理**：缓存服务器在判断转发的目标Web服务器时，还可以查看请求消息头部，从而可以将消息转发给任一Web服务器。\n\n## 内容分发服务\n\n缓存服务器放在Web服务器端虽然可以减轻Web服务器的负载，但无法减少互联网中的流量。从这一点来看，将缓存服务器放在客户端更有效，但是Web服务器的运营者无法控制客户端的缓存服务器。于是出现了内容分发服务，一些专门从事相关服务的厂商来部署缓存服务器，并租借给Web服务器运营者。\n\n而互联网中有很多缓存服务器，需要找到离客户端最近的一个。\n\n* 一种方法是DNS服务器使用路由表的路由信息计算大致距离，并向客户端返回距离(收到客户端查询请求的DNS服务器)最近的缓存服务器的IP地址。这种计算比较粗略；\n\n<div style=\"width:80%;margin:auto\">{% asset_img 18.png pic18 %}</div>\n\n* 另一种方法是使用重定向服务器分配访问目标；当使用重定向告知客户端最近的缓存服务器时，首先需要将重定向服务器注册到DNS服务器上。于是，客户端会将HTTP请求消息发送到重定向服务器上。重定向服务器和刚才一种方法中的DNS服务器一样，收集了来自各个路由器的路由信息，并根据这些信息找到离客户端最近的缓存服务器，然后将缓存服务器的地址放到Location字段中返回响应。这样，客户端就会重新去访问指定的缓存服务器了。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 19.png pic19 %}</div>\n\n同时，每次客户端发送请求时缓存服务器都需要询问Web服务器缓存的数据是否一致，而更好的方法是每次Web服务器中数据发生改变时主动联系缓存服务器，使缓存服务器上的内容时刻保持最新。","tags":["计算机网络"],"categories":["course"]},{"title":"第十二章 CPU多核调度","url":"/course/os-ch12.html","content":"\n## CPU多核调度概述\n\n### 单队列多核调度\n\n* 缺乏可扩展性：多个CPU核均对一个就绪队列进行读写操作；\n* 缺乏缓存亲和性：CPU核对进程的缓存不能得到有效利用；\n\n如下图，4个CPU核对5个进程的调度：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 46.png pic46 %}</div>\n\n为了提高调度算法的缓存亲和性，尽量让进程在同一个CPU核上运行(在保持对该进程的缓存亲和性时，可能会牺牲其他进程的缓存亲和性)；如下图所示：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 47.png pic47 %}</div>\n\n### 多队列多核调度\n\n* 每个CPU核维护一个就绪队列，各CPU核之间的调度相互独立；\n* 会出现负载不均衡；\n\n如下图，开始给进程A、C分配CPU核0，给进程B、D分配CPU核1；\n\n<div style=\"width:64%;margin:auto\">{% asset_img 48.png pic48 %}</div>\n\n一段时间之后，进程C结束，进程A独占CPU核0；\n\n<div style=\"width:64%;margin:auto\">{% asset_img 49.png pic49 %}</div>\n\n一段时间之后，进程A结束，CPU核0处于空闲状态，而CPU核1还在运行着两个进程，此时就出现了负载不均衡；\n\n<div style=\"width:64%;margin:auto\">{% asset_img 50.png pic50 %}</div>\n\n为了解决出现的负载不均衡问题，就要将繁忙的CPU核上的进程迁移到空闲的CPU核上去；比如上幅图，可以将进程B移到CPU核0上，然后系统负载均衡；而对于进程A独占CPU核0的情形，调度就比较复杂，此时操作系统该如何决定发起迁移？\n\n一般采用一种叫做\"工作窃取\"的技术；让执行的进程数目少的CPU核\"不定期\"地查看其他CPU核的就绪队列，从那些长的就绪队列中\"拉取\"一个或多个进程，从而实现负载均衡。而这个查看的时刻一般选在CPU核的进程进行切换的时候。\n\n## O1调度器\n\nLinux系统中进程有140种优先级，使用长140的比特数组来记录优先级；每个(优先级)比特对应该优先级的FIFO进程队列(若一个优先级下有进程队列，则这个优先级对应的bit位置1)，其中run比特数组管理还未运行的就绪态进程，expired比特数组管理运行过的进程；给每个CPU核维护上述两个数组。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 51.png pic51 %}</div>\n\n对于调度时对数组进行的3种基本操作：访问(最高优先级就绪态进程)、(在expired比特数组对应的优先级队列中)插入(刚刚运行过的进程)、(在expired比特数组对应的优先级队列中)删除(刚刚运行过的进程)；分析这些操作的复杂度：\n\n* 访问：在切换进程时，会寻找最高优先级的就绪态进程，而这等价于寻找一个比特数组中为1的最高位比特，CPU可在O(1)时间内找出一个字节中为1的最高位比特；因此，随机访问的复杂度为O(1)；\n* 插入：在队尾插入，复杂度O(1)；如果插入前在expired数组的该优先级下没有进程队列，则将expired数组的该优先级对应的比特置1；\n* 删除：在队头删除，复杂度O(1)；如果删除后在run数组的该优先级下没有进程队列，则将run数组的该优先级对应的比特置0；如果run数组所有比特均为0，则交换run数组与expired数组；并且，每个CPU核不定期检查自己的负载，如果自己负载较其他CPU核轻，则\"拉取\"其他CPU核上的就绪态进程；\n\n## CFS调度\n\n完全公平的调度。通过进程消耗的CPU时间(标准化之后的虚拟CPU时间)来确定调度哪个进程；\n\n分配给进程的运行时间=调度周期×进程权重/所有进程权重之和；但是调度周期一直处于动态变化中，通过这个式子确定分配给进程的运行时间比较麻烦，因此引入虚拟运行时间vruntime=实际运行时间×1024/进程权重；这样既考虑到分配CPU运行时间较少的进程(对它给予一定补偿)，有考虑到高优先级的进程。\n\nLinux系统(每个CPU核)采用红黑树来维护进程的vruntime，需要调度时，从红黑树中选取vruntime最小的进程投入CPU中执行。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 52.png pic52 %}</div>\n\n为避免已经运行一段时间的进程在新的进程进入后出现\"饥饿\"现象=>不能将新进程的vruntime设置为0，而应该设置为红黑树中就绪态进程的最小vruntime。\n\n对于休眠了一段时间的进程，由于其他进程的vruntime一直增加而休眠进程的vruntime并未增加，因此在休眠进程被唤醒后可能会长时间抢占其他进程的CPU资源=>在休眠进程被唤醒后应该以红黑树中就绪态进程的最小vruntime为基准重新设置其vruntime值。\n\n在负载轻的CPU核\"拉取\"负载重的CPU核上的就绪态进程时，它的vruntime需要进行调整以\"适应新的环境\"=>记进程的vruntime为vrt，它所在CPU核的红黑树中就绪态进程的最小vruntime记为min_vrt_1，\"拉取\"此进程的CPU核的红黑树中就绪态进程的最小vruntime记为min_vrt_2，则此进程新的vruntime=vrt-min_vrt_1+min_vrt_2；\n\n由计算vruntime的式子可以看到，CPU的运行时间长了之后，各进程的实际运行时间也会很长，这是算出的vruntime值可能会产生溢出，考虑到vruntime的作用是作为调度的依据——选择最小vruntime的进程=>填在红黑树中的节点值实际上是每个进程的vrt-min_vrt；\n\n## BFS调度算法\n\nBFS调度算法是时间片轮转算法的变种。大致形式如下图：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 53.png pic53 %}</div>\n\nBFS算法在多核CPU的情形下使用单就绪队列(链表)，增加了队列互斥访问的开销，但减少了维护负载均衡的开销。\n\nBFS算法设定了103个优先级(100个静态的实时优先级与3个普通的优先级)，每个优先级维护一个就绪进程队列。每个CPU核计算进程的虚拟截止时间时，对于进程上一次执行的CPU核，会适当减小其虚拟截止时间。","tags":["操作系统"],"categories":["course"]},{"title":"第十一章 CPU调度","url":"/course/os-ch11.html","content":"\n## CPU调度概念\n\nCPU的调度要考虑以下几个问题：\n\n* 调度的时机；\n* 从就绪队列中挑选下一个占用CPU运行的进程；\n* 从多个可用CPU里面挑选就绪进程可使用的CPU资源。\n\n操作系统通过调度程序来完成CPU的调度，操作系统运行调度程序的条件：\n\n* 进程从运行状态切换到等待状态；\n* 进程退出；\n\n对非抢占系统：只有当进程主动放弃CPU时，操作系统才能运行调度程序；\n\n对抢占系统：如果分配给进程的时间片用完或者优先级更高的等待进程切换到就绪状态，那么在抢占系统中，操作系统就会运行调度程序；\n\n## 调度准则\n\n响应时间指标；\n\n* 减少响应时间：及时处理用户的输入请求，尽快将输出反馈给用户。\n* 减少平均响应时间的波动；\n\n吞吐量指标；\n\n* 增加吞吐量；\n* 减少等待时间；\n\n公平性指标；\n\n* 保证每个进程占用相同的CPU时间；\n* 保证每个进程的等待时间相同；\n\n## 调度算法\n\n### 先来先服务算法\n\n&nbsp;\n\n### 短进程优先算法\n\n&nbsp;\n\n### 最高响应比优先算法\n\n响应比R=(w+s)/s，其中w为等待时间、s为执行的时间，然后选择就绪队列中响应比R值最高的进程。该调度算法不可抢占、关注进程的等待时间从而防止执行时间长的进程出现长时间等待的情况(\"饥饿\")。\n\n### 时间片轮转算法\n\n时间片：分配CPU资源的基本时间单元；\n\n给每个进程分配一个时间片占用CPU，一个时间片结束之后，按照先来先服务算法切换到下一个就绪进程。该调度算法存在额外的上下文切换造成的开销，需要选择一个合适的时间片长度(一般是10ms，能够保证上下文切换的开销占CPU处理的1%)\n\n### 多级反馈队列算法\n\n由于没有一个调度算法能够满足所有的需求(有的希望响应迅速，有的希望处理时间短)；为解决这个问题，操作系统使用多个队列，不同需求的就绪进程放到不同的就绪队列，根据需求的不同选择合适的调度算法，各队列按照一定的比例分配CPU处理时间；\n\n进一步改进，让各个队列之间存在交流，这就是多级反馈队列。\n\n* 时间片大小随优先级的增加而增加；\n* 若进程在当前的时间片内没有完成，则降到下一(优先)级就绪队列；\n\n算法执行过程如下图所示：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 44.png pic44 %}</div>\n\n&nbsp;\n\n### 公平共享调度算法\n\n强调资源访问的公平，将用户与进程分组，更重要的用户的进程分配更长的运行时间；同时保证不重要的组无法垄断资源；未使用的资源安装比例分配，没有使用完所分配资源的组获得更高的优先级。\n\n## 进程切换中的调度\n\n调度程序在进程切换时被调用，具体的使用时机见下图：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 45.png pic45 %}</div>\n\n## 实时调度\n\n对于实时操作系统，它的正确性依赖于时间与功能两方面。实时操作系统的性能主要考虑时间约束的及时性，而速度与平均性能相对不重要。因此，实时操作系统要求时间约束的可预测性。\n\n时间约束分为硬时限与软时限；硬时限：错过任务时限会导致严重后果，必须验证操作系统在最坏情况下能够满足时限；软时限：通常能满足任务时限，若有时不能满足，则降低要求。\n\n关于实时调度的调度算法，有以下两个：速率单调调度算法与最早截止时间优先算法。\n\n速率单调调度算法：先执行周期最短的任务；\n\n最早截止时间优先算法：先执行截止时间最早的任务；\n\n## 多核CPU的进程分配\n\n对于多个处理器的CPU，有下面两种方式来分配进程：\n\n* 静态进程分配：进程从开始到结束都在一个固定的处理器上运行，每个处理器有自己的队列，此时调度的开销很小；\n* 动态进程分配：进程在执行过程中可分配到任一空闲处理器上运行，所有处理器共享一个就绪队列，由于进程会在不同的处理器间切换，因此调度开销较大，然而这种进程分配能够保证各处理机是负载均衡的。\n\n## 优先级反置\n\n低优先级的进程占着高优先级申请的资源使得高优先级的进程进入等待状态，而这时优先级处于前面两个优先级之间的进程抢占了低优先级的进程；这一现象称为优先级反置。解决优先级反置有下面两种处理方法：\n\n**优先级继承**：占用资源的低优先级进程在被抢占时继承申请资源的高优先级进程的优先级，并在释放资源后，优先级将为原来低的优先级；\n\n**优先级天花板协议**：占用资源进程的优先级与所有可能申请该资源的进程的最高优先级相同；","tags":["操作系统"],"categories":["course"]},{"title":"第十章 进程与线程控制","url":"/course/os-ch10.html","content":"\n## 进程创建\n\n对于unix类系统，创建进程采用fork()与exec()两个系统调用来完成；\n\n* fork()将一个进程复制为两个进程；被复制的进程称为父进程，复制得到的进程称为子进程；复制的信息包括父进程的管理结构，线性地址空间与除eax(eax置0)外所有寄存器的值；\n* exec()用新程序来重写当前进程；\n\nQ：在linux系统中，如果任何一个创建的进程都必须(在用户态)通过复制其他进程得到，那么第一个进程是怎么来的呢？\n\nA：第一个进程由操作系统的设计者写好，这个进程就是进程0。\n\n### 进程的地址空间\n\n在介绍fork创建进程之前，先说明Linux是怎么表示一个进程的——task_struct结构体，在Linux2.2.0的源码中，task_struct的定义如下。\n\n```c\nstruct task_struct {\n/* these are hardcoded - don't touch */\n\tvolatile long state;\t/* -1 unrunnable, 0 runnable, >0 stopped */\n\tunsigned long flags;\t/* per process flags, defined below */\n\tint sigpending;\n\tmm_segment_t addr_limit;\t/* thread address space:\n\t\t\t\t\t \t0-0xBFFFFFFF for user-thead\n\t\t\t\t\t\t0-0xFFFFFFFF for kernel-thread\n\t\t\t\t\t */\n\tstruct exec_domain *exec_domain;\n\tlong need_resched;\n/* various fields */\n\tlong counter;\n\tlong priority;\n\tcycles_t avg_slice;\n/* SMP and runqueue state */\n\tint has_cpu;\n\tint processor;\n\tint last_processor;\n\tint lock_depth;\t\t/* Lock depth. We can context switch in and out of holding a syscall kernel lock... */\t\n\tstruct task_struct *next_task, *prev_task;\n\tstruct task_struct *next_run,  *prev_run;\n/* task state */\n\tstruct linux_binfmt *binfmt;\n\tint exit_code, exit_signal;\n\tint pdeath_signal;  /*  The signal sent when the parent dies  */\n\t/* ??? */\n\tunsigned long personality;\n\tint dumpable:1;\n\tint did_exec:1;\n\tpid_t pid;\n\tpid_t pgrp;\n\tpid_t tty_old_pgrp;\n\tpid_t session;\n\t/* boolean value for session group leader */\n\tint leader;\n\t/* \n\t * pointers to (original) parent process, youngest child, younger sibling,\n\t * older sibling, respectively.  (p->father can be replaced with \n\t * p->p_pptr->pid)\n\t */\n\tstruct task_struct *p_opptr, *p_pptr, *p_cptr, *p_ysptr, *p_osptr;\n\t/* PID hash table linkage. */\n\tstruct task_struct *pidhash_next;\n\tstruct task_struct **pidhash_pprev;\n\t/* Pointer to task[] array linkage. */\n\tstruct task_struct **tarray_ptr;\n\tstruct wait_queue *wait_chldexit;\t/* for wait4() */\n\tstruct semaphore *vfork_sem;\t\t/* for vfork() */\n\tunsigned long policy, rt_priority;\n\tunsigned long it_real_value, it_prof_value, it_virt_value;\n\tunsigned long it_real_incr, it_prof_incr, it_virt_incr;\n\tstruct timer_list real_timer;\n\tstruct tms times;\n\tunsigned long start_time;\n\tlong per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS];\n/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */\n\tunsigned long min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;\n\tint swappable:1;\n\tunsigned long swap_address;\n\tunsigned long swap_cnt;\t\t/* number of pages to swap on next pass */\n/* process credentials */\n\tuid_t uid,euid,suid,fsuid;\n\tgid_t gid,egid,sgid,fsgid;\n\tint ngroups;\n\tgid_t\tgroups[NGROUPS];\n        kernel_cap_t   cap_effective, cap_inheritable, cap_permitted;\n\tstruct user_struct *user;\n/* limits */\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\tunsigned short used_math;\n\tchar comm[16];\n/* file system info */\n\tint link_count;\n\tstruct tty_struct *tty; /* NULL if no tty */\n/* ipc stuff */\n\tstruct sem_undo *semundo;\n\tstruct sem_queue *semsleeping;\n/* tss for this task */\n\tstruct thread_struct tss;\n/* filesystem information */\n\tstruct fs_struct *fs;\n/* open file information */\n\tstruct files_struct *files;\n/* memory management info */\n\tstruct mm_struct *mm;\n/* signal handlers */\n\tspinlock_t sigmask_lock;\t/* Protects signal and blocked */\n\tstruct signal_struct *sig;\n\tsigset_t signal, blocked;\n\tstruct signal_queue *sigqueue, **sigqueue_tail;\n\tunsigned long sas_ss_sp;\n\tsize_t sas_ss_size;\n};\n```\n\n其中，结构体mm_struct用来描述一个进程的虚拟地址空间。mm_struct的定义如下。\n\n```c\nstruct mm_struct {\n\tstruct vm_area_struct *mmap;\t\t/* list of VMAs */\n\tstruct vm_area_struct *mmap_avl;\t/* tree of VMAs */\n\tstruct vm_area_struct *mmap_cache;\t/* last find_vma result */\n\tpgd_t * pgd;\n\tatomic_t count;\n\tint map_count;\t\t\t\t/* number of VMAs */\n\tstruct semaphore mmap_sem;\n\tunsigned long context;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long start_brk, brk, start_stack;\n\tunsigned long arg_start, arg_end, env_start, env_end;\n\tunsigned long rss, total_vm, locked_vm;\n\tunsigned long def_flags;\n\tunsigned long cpu_vm_mask;\n\t/*\n\t * This is an architecture-specific pointer: the portable\n\t * part of Linux does not know about any segments.\n\t */\n\tvoid * segments;\n};\n```\n\n其中vm_area_struct用来描述一个虚拟内存区域VMA，一个进程的地址空间由多个虚拟内存区域组成，各虚拟内存区域由链表组织。操作系统将每个内存区域作为一个单独的内存对象管理，每个内存区域都有一致的属性(因此进程的代码段、数据段、bss段都分别用一个vm_area_struct描述)。vm_area_struct的定义如下。\n\n```c\nstruct vm_area_struct {\n\tstruct mm_struct * vm_mm;\t/* VM area parameters */\n\tunsigned long vm_start;\n\tunsigned long vm_end;\n\n\t/* linked list of VM areas per task, sorted by address */\n\tstruct vm_area_struct *vm_next;\n\n\tpgprot_t vm_page_prot;\n\tunsigned short vm_flags;\n\n\t/* AVL tree of VM areas per task, sorted by address */\n\tshort vm_avl_height;\n\tstruct vm_area_struct * vm_avl_left;\n\tstruct vm_area_struct * vm_avl_right;\n\n\t/* For areas with inode, the list inode->i_mmap, for shm areas,\n\t * the list of attaches, otherwise unused.\n\t */\n\tstruct vm_area_struct *vm_next_share;\n\tstruct vm_area_struct **vm_pprev_share;\n\n\tstruct vm_operations_struct * vm_ops;\n\tunsigned long vm_offset;\n\tstruct file * vm_file;\n\tunsigned long vm_pte;\t\t\t/* shared mem */\n};\n```\n\n最终，进程管理其进程空间的实现如下图所示。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 43.png pic43 %}</div>\n\n&nbsp;\n\n### fork与写时复制\n\n传统的fork直接将父进程所有资源复制给子进程，很多时候，操作系统创建一个进程是为了加载一个新的可执行文件，此时复制父进程资源是没有必要的。于是之后的fork采用写时复制技术：创建的子进程以只读方式共享父进程的地址空间(实现方式为仅复制父进程的页表而不复制对应物理内存区域中的内容)，如果父/子进程需要向地址空间写入数据，操作系统再去复制一份地址空间的内容供父/子进程修改。这时，如果fork之后立即执行了exec，则无需复制父进程的地址空间的内容。此外，之后的fork还明确子进程先执行。\n\n### vfork\n\nvfork创建的子进程相当于父进程的线程，它没有复制父进程的页表，直接共用父进程的地址空间，即子进程的task_struct直接复制父进程的task_struct的mm成员，注意到mm是一个mm_struct结构体指针，因此vfork是让子进程共用父进程的地址空间。此外，vfork明确子进程先执行。使用vfork创建子进程后，父进程一直处于阻塞状态，直到子进程退出或执行完exec。\n\n### 创建线程\n\n通过创建与父进程共享某些资源(具体见下表)的子进程，来创建线程。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 82.png pic82 %}</div>\n\n&nbsp;\n\n### 小结\n\n总结一下创建进程的完整过程；\n\n* 分配进程控制块数据结构；\n* 创建进程的内核堆栈；\n* 设置进程的地址空间(如果是创建线程则共享父进程的地址空间)；\n* 修改子进程的状态为不可中断等待状态(还未进行进程加载)；\n\n## 进程加载\n\n将刚刚分配子进程的地址空间重写，其中包括代码段、数据段、堆与栈等等；使用exec调用来实现；\n\n\n## 进程切换\n\n暂停当前运行进程(当前运行进程从运行态变为其他状态)，调度另一个进程(也有可能还是刚刚运行的进程)从就绪状态变成运行状态。\n\n进程切换前，保存被暂停进程的上下文(寄存器、CPU状态)；进程切换后，恢复被调度进程的上下文(寄存器、CPU状态)。\n\n如下是一个进程切换的例子：\n\n<div style=\"width:45%;margin:auto\">{% asset_img 40.png pic40 %}</div>\n\n&nbsp;\n\n\n\n为了对进程进行切换，操作系统将相同状态的PCB放置在同一队列。如下图所示：有就绪(进程)队列、等待(进程)队列以及僵尸队列(要退出的进程)。\n\n<div style=\"width:64%;margin:auto\">{% asset_img 41.png pic41 %}</div>\n\n&nbsp;\n\n当并发的进程数目太多时，使用双向链表来组织PCB使得查找的时间过长，那么这时采用Hash表，Hash值相同PCB组成双向链表，再通过数组将这些双向链表组织起来。\n\n<div style=\"width:45%;margin:auto\">{% asset_img 42.png pic42 %}</div>\n\n&nbsp;\n\n实现进程调度的函数为schedule。\n\n## 进程等待与退出\n\nwait系统调用用于父进程等待子进程的结束；子进程结束时通过exit()向父进程返回一个值，父进程通过wait()接受并处理返回值。\n\n* 当子进程存活时，如果父进程调用了wait，则父进程进入等待状态，等待子进程的返回结果。当子进程结束调用了exit()后，父进程被唤醒，将子进程exit()的返回值作为父进程wait()的返回值；\n* 如果父进程调用wait时已有结束的子进程，wait()立即返回这些已经结束的子进程调用exit()返回值中的一个；\n* 若无子进程存活，wait()立刻返回；\n\nexit被称为有序终止；\n\n* exit()返回的结果作为父进程下一步处理的参数；\n* 进程各种资源的回收(打开的文件，分配的内存空间以及大部分与进程相关的数据结构)；\n* 清理所有处于僵尸状态的子进程；\n* 检查父进程是否存活，若父进程存活，自身进入僵尸状态，等待父进程处理；否则，释放所有的数据结构，进程结束；","tags":["操作系统"],"categories":["course"]},{"title":"第九章 进程与线程","url":"/course/os-ch9.html","content":"\n## 进程的概念\n\n**进程**：具有一定独立功能的程序在一个数据集合上的一次动态执行过程；\n\n程序是有序代码的集合，进程是程序的执行。\n\n## 进程控制块\n\n**进程控制块(PCB)**：操作系统管理控制进程运行所用的信息集合。包含以下信息：\n\n* 调度进程与处理机使用情况；\n* 进程间通信相关的各种标识；\n* 指向进程映像存储空间的数据结构；\n* 进程使用的系统资源；\n* 数据结构连接信息；\n\n## 进程的状态\n\n进程的生命周期划分：创建、运行、等待、抢占、唤醒与结束；这些不同周期的转换如下图所示：\n\n<div style=\"width:32%;margin:auto\">{% asset_img 37.png pic37 %}</div>\n\n&nbsp;\n\n每种状态转换的条件见下表：\n\n| 箭头 |                             条件                             |\n| :--: | :----------------------------------------------------------: |\n| (1)  | 系统初始化；<br />用户请求创建一个新进程；<br />正在运行的进程调用了创建进程的系统调用； |\n| (2)  |                       获得CPU的调度；                        |\n| (3)  | 请求并等待系统服务，无法马上完成；<br />启动某种操作，无法马上完成；<br />需要的数据还未到达； |\n| (4)  |  高优先级进程就绪；<br />操作系统给进程分配的时间片已用完；  |\n| (5)  |               使进程进入等待状态的条件被满足；               |\n| (6)  | 正常退出；<br />错误退出(自愿的)；<br />致命错误(强制性)；<br />被其他进程杀死(强制性)； |\n\n## 进程挂起\n\n**进程挂起**：操作系统将进程从内存移到外存(以节省内存占用)；与之对应的，将进程从外存移入内存称为(进程)激活。\n\n在进程的状态中考虑进程挂起后，就多了就绪挂起与等待挂起两种状态；这时各种状态的转换如下图所示：\n\n<div style=\"width:40%;margin:auto\">{% asset_img 38.png pic38 %}</div>\n\n&nbsp;\n\n相比上一节的状态转换，增加的状态转换的条件见下表：\n\n| 箭头 |                             条件                             |\n| :--: | :----------------------------------------------------------: |\n| (7)  | 操作系统根据当前资源状况和性能要求将就绪态进程对换出去成为挂起就绪态； |\n| (8)  |    没有就绪进程或挂起进程的优先级高于就绪态进程的优先级；    |\n| (9)  |           在抢先式分时系统，高优先级挂起进程就绪；           |\n| (10) |                            同(5)                             |\n| (11) |  其他进程释放了足够内存，且本进程在挂起的进程中优先级最高；  |\n| (12) | 操作系统根据当前资源状况和性能要求将等待态进程对换出去成为挂起等待态； |\n\n&nbsp;\n\n最后，操作系统切换进程的示意图如下：\n\n<div style=\"width:45%;margin:auto\">{% asset_img 39.png pic39 %}</div>\n\n## 线程的概念\n\n线程是进程的一部分，描述指令流执行状态。它是进程中指令执行流的最小单元，是CPU调度的基本单位。\n\n线程=进程-共享资源(地址空间，文件等)\n\n对进程与线程作一个比较：\n\n|          进程          |                  线程                  |\n| :--------------------: | :------------------------------------: |\n|      资源分配单位      |              CPU调度单位               |\n| 拥有程序执行完整的资源 | 只独享指令流执行必要的资源(寄存器、栈) |\n\n### 用户线程\n\n用户自己实现，操作系统并不支持多线程。\n\n### 内核线程\n\n进程由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止与管理。","tags":["操作系统"],"categories":["course"]},{"title":"第八章 面向缓存的页置换算法","url":"/course/os-ch8.html","content":"\n## 访问频率置换算法(FBR)\n\n操作系统维护一个如下形式的栈来存放缓存数据：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 33.png pic33 %}</div>\n\n&nbsp;\n\n栈分为3个部分：新区域、中间区域与旧区域；每个缓存块都有一个引用计数，算法具体处理如下：\n\n* 访问的数据在栈中：缓存块被移到栈顶，若缓存块不在新区域，将其引用计数加1；\n* 访问的数据不在栈中：在访问完数据之后；栈的旧区域中引用计数最小的缓存块被移出；将访问的数据放到栈顶，其引用计数置1；\n\nFBR算法的问题：需要调整参数。\n\n## LRU-K 2Q页置换算法\n\n考虑一下在进程访问数据时，会有哪些模式的访问：\n\n* 顺序访问：数据块一个接一个被访问，不存在重复访问；\n* 循环访问：所有的数据块按照一定的间隔重复访问；\n* 时间密集访问：最近被访问的数据块是将来最可能被访问的；\n* 概率访问：所有数据块都有固定的概率被访问，且被访问的概率相互独立；\n\n### LRU-K页置换算法\n\nLRU-K算法是LRU算法的扩展；增加了一个数据访问历史记录队列，记录数据被访问的次数以及最近的访问时间戳。\n\n如果[数据]在离开历史记录队列之前被访问了K次，则需要将[数据]加入数据缓存队列：如果缓存队列的长度超过最大缓存长度，则先将缓存队列头部的数据删除，然后在缓存队列的队尾加上[数据]，然后[数据]的访问历史记录从历史记录队列中删除。\n\n若缓存队列的[数据]被访问，则将[数据]放到缓存队列的队尾。\n\n综上，LRU-K页置换算法的示意图如下：\n\n<div style=\"width:36%;margin:auto\">{% asset_img 34.png pic34 %}</div>\n\n&nbsp;\n\n其中，LRU-2是综合考虑各种访问模式后的最优选择。\n\n### LRU-2Q页置换算法\n\n进一步改进LRU-2页置换算法；使用两个缓存队列来维护缓存区，示意图如下：\n\n<div style=\"width:36%;margin:auto\">{% asset_img 35.png pic35 %}</div>\n\n&nbsp;\n\n数据块第一次被访问时，数据块缓存到FIFO队列的队尾(如果队列没有空闲空间，就删除队列头部的数据)，如果数据块在离开FIFO队列之前被再次访问，则将数据块移到LRU队列的队尾(同样地，如果队列没有空闲空间，就删除队列头部的数据)；若LRU队列的数据块被访问，则将数据块放到LRU队列的队尾。\n\n## LIRS页置换算法\n\n定义两个属性；R(i,t)：从最近一次访问数据块i之后到当前时刻t，被访问的不重复数据块数；IRR(i)：在最近两次访问数据块i之间，被访问的不重复数据块数。\n\n初始时，每个数据块的IRR=inf, R=0；\n\n有数据块(记为i)被访问后，每个数据块的IRR值与R值更新：\n\n* 被访问：IRR(i,t)=R(i,t-1), R(i, t)=0；\n* 未被访问：IRR(j)不变，R(j,t)=R(j,t-1)+1{最近一次访问数据块j之后到t-1时刻, 数据块i没有被访问过}，j!=i；\n\n**性质1**：每次访问数据块时，除了被访问的数据块，其他数据块的R值均单调不减。\n\nLIRS算法区分IRR值高的数据块与IRR值低的数据块，缓存区分为两个部分：常驻cache与暂驻cache；LIR块(低IRR值的数据块)放在常驻cache，HIR块(高IRR值的数据块)放在暂驻cache；\n\n我们可以看到，**R值其实就是IRR值的一个候选，一旦数据块被访问，它的R值就成为IRR值**；\n\n由于常驻cache与暂驻cache是根据数据块的IRR值进行区分，那么这两个cache的数据块也会因为其IRR值进行调整；因此，当一个HIR块i被访问后，若存在LIR块j，R(j,t)>size且R(j,t)>IIR(i)，则数据块i与数据块j的状态交换。即max{R(j,t)|j in LIR}>max{size, IIR(i)}。\n\nLIRS算法在各种访问模式下均有很好的表现，但是算法要维护两组值(R值与IRR值)使得算法的开销很大；因此，也就有了下面利用栈而不用显式计算R值与IRR值的方法。\n\n<div style=\"width:24%;margin:auto\">{% asset_img 36.png pic36 %}</div>\n\n&nbsp;\n\n维护两个栈：栈S与栈Q；\n\n栈S：LIR块(低IRR值的数据块)与IRR值小于LIR块的最大R值的HIR块(高IRR值的数据块)；\n\n栈Q：常驻cache中的HIR块；\n\n事实上，栈S存放着当前的LIR块与之后有可能成为LIR块的HIR块；下面介绍\"栈裁剪\"操作。\n\n\"栈裁剪\"操作：若栈S底部的LIR块被删除，则一直删除底部数据块直到遇到LIR块。\n\nQ：\"栈裁剪\"操作的合理性是什么?\n\nA：若栈S底部的LIR块被删除，则底部的HIR块将不会成为LIR块。\n\n在证明\"栈裁剪\"操作的合理性之前，注意到如下的性质：\n\n**性质2**：记S栈如下：\n\n```bash\n---------------------------------------\n                q_3 | q_2 | q_1 | q_0 |\n---------------------------------------\n```\n\n那么R(q_i, t)>R(q_i+1, t)，即R(q_i, t)>=R(q_i+1, t)+1。\n\n对栈底部的HIR块i，考虑它再次被访问后：IRR(i)=R(i,t-1)>max{R(j,t-1)|j in LIR} => IRR(i)>=max{R(j,t)|j in LIR}；从而状态交换的条件不成立，因此栈底部的HIR块不会成为LIR块；\n\n考虑访问各种数据块时算法的反应：\n\n```bash\n|\n|—— LIR块：LIR块移到栈顶，执行\"栈裁剪\"操作；\n|\n|—— HIR块\n     |\n     |—— 在S中：HIR块状态变为LIR并被移到S栈顶，S栈底LIR块状态变为HIR并从栈S中移到栈Q中，执行\"栈裁剪\"操作；\n     |\n     |—— 不在S中：HIR块移到Q栈顶；\n```","tags":["操作系统"],"categories":["course"]},{"title":"第七章 全局页面置换算法","url":"/course/os-ch7.html","content":"\n## 工作集置换算法\n\n**工作集**：一个进程当前正在使用的逻辑页面集合，可表示为二元函数W(t,delta)；t为当前执行时刻，delta为一个页面访问时间窗口，称为工作集窗口；W(t,delta)是时刻t前delta时间窗口内所有访问的页面所组成的集合，|W(t,delta)|就是时刻t前delta时间窗口内访问的页面的数目。\n\n**常驻集**：当前时刻，进程实际驻留在内存中的页面集合。\n\n缺页率与(工作集, 常驻集)的关系：\n\n* 常驻集包含工作集时，缺页率较小；\n* 工作集发生剧烈变动时，缺页率较高；\n* 进程常驻集大小到达一定数目后，缺页率不会明显下降；\n\n**工作集置换算法**：每次访问内存后，换出不在工作集中的页面；\n\n## 缺页率置换算法\n\n**缺页率**：缺页时间间隔的倒数。\n\n**缺页率置换算法**：通过(在发生缺页中断时)调节常驻集大小，使进程的缺页率保持在一个合理的范围内。具体来说，在发生缺页时计算相邻两次缺页的时间间隔delta；对于预先设定的T，若delta>T，操作系统将未被引用的内存页面换出内存，记这些页面的数目为nr，则操作系统收回进程的(nr-1)个未被引用的内存页面，并将缺失页写入剩下的那个未被引用的内存页面；若delta<=T，操作系统为进程申请一个内存页面来写入缺失页(相当于将缺失页增加到工作集中)。\n\n## 抖动与负载控制\n\n**抖动**：并发进程数目太多，使得分配给每个进程的内存页面太少而不能包含工作集；造成了大量缺页，从而操作系统需要频繁地进行置换，降低了CPU的工作效率，进程的运行速度变慢。\n\n操作系统通过调节并发进程数(MPL)来进行负载控制。\n\nCPU利用率与并发进程数的关系大致如下图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 32.png pic32 %}</div>\n\n&nbsp;\n\n而图中的Nmax不好确定，因此只能对Nmax作一个估计，使平均缺页间隔时间/缺页异常处理时间=1的并发进程数，这样可以近似地估计Nmax，从而使系统处于均衡的繁忙状态。","tags":["操作系统"],"categories":["course"]},{"title":"第六章 局部页面置换算法","url":"/course/os-ch6.html","content":"\n## 页面置换算法概述\n\n根据页面置换算法可借用的外界条件，将页面置换算法分为局部页面置换算法：置换页面的选择范围仅限于当前进程占用的内存页面，全局页面置换算法：置换页面的选择范围是所有可换出的内存页面(并不是所有的内存页面都可以换出内存，比如内核关键代码所在内存页面；因此对这些页面，会将其页表项的锁定位置1，从而操作系统在换出内存页面时就不会考虑这些页面)。\n\n## 局部页面置换算法\n\n下面介绍三种理论上的局部页面置换算法。\n\n* 最优算法：将未来最长时间不访问的页面换出内存；缺页次数最少，但是无法实现。用来评价其他置换算法的效率。\n\n* 先进先出算法：将在内存中驻留时间最长的页面进行置换。易于实现，但是效率很低；甚至会出现Belady现象。\n\n* 最近最久未使用算法：将内存中最长时间未被引用的页面进行置换。\n\n实际实现的算法在上述置换算法的基础上做一些折中，使得既易于实现，效率又不是太差。\n\n### 时钟置换算法\n\n* 各页面组成环形链表，指针指向最先调入的页面；\n* 若要访问的页面在内存中，则将页面对应页表项的A位置1；\n* 若要访问的页面不在内存中，从指针处开始顺序查找，对于访问过的页面，将页面对应页表项的A位置0；直到找到A位为0的页面(可以想一下此时A位为0与页面未被访问过的区别)，这就是可以置换的页面；\n\n如下是一个使用时钟置换算法进行内存分配的例子：\n\n{% asset_img 31.jpg pic31 %}\n\n&nbsp;\n\n### 改进的时钟置换算法\n\n由于置换修改过的内存页面需要将该页面的数据写到外存，然后再从外存中读取要换入的页面；这样缺页中断的处理时间几乎是置换未被修改的内存页面的两倍(指令执行的时间可以忽略不计，主要是读取数据的时间)；因此，为了提高缺页中断处理的效率，操作系统应该避免在缺页时置换修改过的内存页面，而是在另外合适的时机将修改过的内存页面的数据写入外存对应位置。\n\n因此有了改进的时钟置换算法，相比于经典的时钟置换算法，操作系统在内存页面分配，访问，置换时还要再对页表项的D位进行维护；\n\n### 最不常用置换算法\n\n发生缺页时，置换访问次数最少的内存页面；\n\n## Belady现象\n\n在给进程分配的内存页面数目增加之后，使用某个(局部)页面置换算法反而使得发生缺页的次数增加，这一现象称为Belady现象。而先进先出算法就具有Belady现象，下面举例说明。\n\n|   FIFO   |  1   |  2   |  3   |  4   |  1   |  2   |  5   |  1   |  2   |  3   |  4   |  5   |\n| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|   尾部   |  1   |  2   |  3   |  4   |  1   |  2   |  5   |  5   |  5   |  3   |  4   |  4   |\n|          |      |  1   |  2   |  3   |  4   |  1   |  2   |  2   |  2   |  5   |  3   |  3   |\n|   头部   |      |      |  1   |  2   |  3   |  4   |  1   |  1   |  1   |  2   |  5   |  5   |\n| 缺页状态 |  √   |  √   |  √   |  √   |  √   |  √   |  √   |      |      |  √   |  √   |      |      |\n\n\n\n此时缺页9次；如果分配4个内存页面：\n\n|   FIFO   |  1   |  2   |  3   |  4   |  1   |  2   |  5   |  1   |  2   |  3   |  4   |  5   |\n| :------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|   尾部   |  1   |  2   |  3   |  4   |  4   |  4   |  5   |  1   |  2   |  3   |  4   |  5   |\n|          |      |  1   |  2   |  3   |  3   |  3   |  4   |  5   |  1   |  2   |  3   |  4   |\n|          |      |      |  1   |  2   |  2   |  2   |  3   |  4   |  5   |  1   |  2   |  3   |\n|   头部   |      |      |      |  1   |  1   |  1   |  2   |  3   |  4   |  5   |  1   |  2   |\n| 缺页状态 |  √   |  √   |  √   |  √   |      |      |  √   |  √   |  √   |  √   |  √   |  √   |\n\n此时缺页10次，分配的内存页面增加，而缺页的次数增加。\n\n最优算法无Belady现象。\n","tags":["操作系统"],"categories":["course"]},{"title":"第五章 虚拟存储概念","url":"/course/os-ch5.html","content":"\n## 覆盖与交换技术\n\n**覆盖技术**：依据程序的逻辑结构，将程序划分为若干功能独立的模块，将不会同时执行的模块共享同一块内存区域。\n\n**交换技术**：将暂时不能运行的程序换到外存，再将外存中某一进程的数据读入内存。\n\n\n## 局部性原理\n\n程序在执行过程的一段较短时期内，所执行指令的地址与操作数的地址，分别局限于一定区域。具体来说：\n\n* 时间局部性；一条指令在执行后的较短时间内很可能会再次执行，某个内存地址在被访问后的较短时间内很可能会再次访问；\n* 空间局部性；相邻指令访问的内存地址很可能集中在一个较小的区域；\n* 分支局部性；一条跳转指令的两次执行，很可能会跳到相同的内存地址；\n\n局部性原理给虚拟存储技术提供了理论支持。\n\n## 虚拟存储概述\n\n* 在装载程序时，只将指令执行需要的部分页面或段装入内存；\n* 当指令执行时需要的指令或数据不在内存中时(即缺页或缺段)，处理器通知操作系统将相应的页面或者段读入内存；\n* 此外，操作系统还会时刻监控内存中页或段的使用情况，从而将暂时不用的页或段换到外存；\n\n要实现虚拟存储，需要硬件与操作系统的支持；\n\n对硬件：支持虚拟存储的页或段式地址转换机制；\n\n对操作系统：管理内存与外存间页或段的数据的写入；\n\n## 虚拟页式存储管理\n\n概括地说，虚拟页式存储管理就是在页式存储管理的基础上增加请求调页与页面置换。\n\n上一章指出了页表项的结构，但是对其中的控制位并未作解释；在这里我们指出这些控制位在虚拟页式存储管理中所起的作用。\n\n<div style=\"width:80%;margin:auto\">{% asset_img 29.jpg pic29 %}</div>\n\n&nbsp;\n\n* P位：存在位；1表示该页在内存中，0表示该页在外存中；\n* A位：访问位；若该页被访问过，A位置1，否则A位置0；\n* D位：修改位；若该页被修改过，D位置1，否则D位置0；\n\n下面分析一些关键时刻，操作系统对这些控制位的处理。\n\n**装载**\n\n操作系统给应用程序分配足够的线性地址空间，而事实上，操作系统只是将应用程序此时执行必要的一部分页面装入内存中，那么这些页面对应页表项的P位置1，而没有装入内存的页面对应页表项的P位置0；\n\n**内存访问**\n\n操作系统会将访问过的内存页面对应的页表项的A位置1；如果指令对该页进行了修改，则需要将该页对应页表项的D位置1；\n\n**缺页**\n\n指令要访问的页面不在内存中，操作系统调用缺页中断服务例程将该页读入内存，并将该页对应页表项的P位置1；\n\n**页面换出内存**\n\n若页面对应页表项的D位为0，则只需要将P位置0即可；否则，操作系统要将内存中的该页写到外存中对应位置；\n\n## 缺页中断\n\n下面详细介绍缺页中断处理例程。发生缺页中断时，操作系统会找到外存中的对应页面，之后在内存中申请一个空闲页面，将外存中的页面装载到内存中，如果内存中此时没有空闲页面，那么需要根据页面置换算法将内存中的某些页面换出内存。具体的页面置换算法在下一章介绍。","tags":["操作系统"],"categories":["course"]},{"title":"第四章 物理内存管理：非连续内存分配","url":"/course/os-ch4.html","content":"\n## 背景\n\n如果使用连续内存分配，有时不一定有满足要求的一块连续的物理内存；此外，连续内存分配产生的内/外碎片也降低内存分配效率，并且分配了的内存空间无法动态调整。\n\n## 段式存储管理\n\n段的访问机制为[段选择符 : 段偏移量]，MMU通过段选择符索引段描述符表中的段描述符，以此获得段基址；在开启分页机制之前，段基址+段内偏移=物理地址，而在开启分页机制之后，段基址+段内偏移=线性地址；线性地址在下一节介绍。\n\n## 页式存储管理\n\n开启分页机制后，逻辑地址经上述转换得到的是线性地址，线性地址转换为物理地址的原理如下：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 1.jpg pic1 %}</div>\n\n&nbsp;\n\n转换过程中所用到的页表在下一节介绍。此外，页目录表是存放页表地址的页表。\n\n\n## 页表\n\n页表主要用来存放页框地址，MMU通过线性地址中的页表字段索引页表中的页表项，页表项的结构如下图所示：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 29.jpg pic29 %}</div>\n\n&nbsp;\n\n可以看出，页表项中除了记录对应页框的物理地址，还存放一些控制位(如存在位P)；\n\n但是在线性地址转物理地址的原理图中可以看到除了页表之外，还有页目录表，这就是下一节要介绍的多级页表。\n\n\n## 快表与多级页表\n\n### 快表\n\n为提高内存访问效率，会将访问过的页表项缓存到CPU的关联存储器中，这一区域称为快表，相比在页表中查找，在快表中查找会快很多(CPU的处理速度比内存中的访问速度快很多)；于是，在访问内存时，首先在快表中查找页表项，若快表中缓存了此页表项，直接从快表中读取此页表项然后去访问相应的物理地址即可，若快表中未缓存此页表项，接下来则需要通过页表查询页表项，并且将此页表项缓存到CPU的关联存储器中。\n\n### 多级页表\n\n通过间接引用，将线性地址分为若干级，在转换物理地址时，通过各级页表的索引(上一级索引的页表项中的页框地址作为下一级页表的地址)最终找到页表项。得到的页表项中的页框地址加上页内偏移就是要访问的物理内存地址。\n\n如下是两级页表寻址的示意图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 30.png pic30 %}</div>\n\n&nbsp;\n\n**页表自映射**：考虑一个非常特殊的页表项：页目录表对应的页表项。\n\n页表也是页，因此页目录表也是页表。因此，页目录表中必然有一个指向页目录表的页表项；如下图所示：\n\n<div style=\"width:36%;margin:auto\">{% asset_img 32.png pic32 %}</div>\n\n&nbsp;\n\n页目录表对应的页表项的线性地址记为B1|B2|B3；下面解释为何将B1、B2与B3标注在图所示位置。\n\n图中阴影页表项就是指向页目录表的页表项，而每个页表项占4个字节，因此4×B3应该标注在此；\n\n将页目录表看作一个页，而指向这个页的页目录项就是图中阴影页表项，因此4×B2应该标注在此；\n\n将页目录表看作一个页表，页目录表中指向这个页表的页目录项就是图中阴影页表项，因此B1应该标注在此；\n\n## 页映射机制\n\n&nbsp;\n\n## 开启页表机制\n\n&nbsp;\n","tags":["操作系统"],"categories":["course"]},{"title":"第二步 传输TCP/IP数据","url":"/course/cn-step2.html","content":"\n## 创建套接字\n\n### 协议栈的结构\n\n<div style=\"width:60%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n### 套接字：通信控制信息\n\n套接字记录着通信对象的IP地址与端口号、通信的状态等等；总之，套接字中记录了用于控制通信的各种信息，协议栈根据这些信息判断下一步操作。\n\n### socket的内部实现\n\n以下所示是更详细的收发数据示意图：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n## 连接服务器\n\n### 连接：通信双方交换控制信息\n\n所谓建立连接，就是为通信双方互相交换控制信息，在套接字中记录这些必要信息并准备数据收发的一系列操作。\n\n### 保存控制信息的头部\n\n在数据包的头部，存放着客户端与服务器相互联络所需的控制信息，这些信息在TCP协议中进行了定义，如下表所示。\n\n&nbsp;\n\n<div style=\"width:80%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n&nbsp;\n\n在连接阶段，通信双方只交换控制信息，此时网络包的结构如下图：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\n通信双方建立连接之后，通信双方开始互相发送数据，此时的网络包结构如下图：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 10.png pic10 %}</div>\n\n&nbsp;\n\n### 连接的具体操作\n\n|                           服务器端                           | 方向 |                            客户端                            |\n| :----------------------------------------------------------: | ---- | :----------------------------------------------------------: |\n|                                                              | <    | 创建TCP头部，其中包含表示开始数据收发操作的控制信息；<br /><br />对TCP头部进行初始化设置(源IP与目的IP、源端口与目的端口、SYN位置1、序号设置与窗口大小设置等等)；<br /><br />将TCP头部传给IP层并委托IP层发送给服务器端。 |\n| 服务器端接收到数据，经以太层、IP层解析之后到达TCP层；<br /><br />TCP层根据头部的目的端口号找到连接此请求的套接字，并向该套接字中写入相应的信息；套接字的状态改为正在连接；<br /><br />服务器端也是发送一个TCP头部给客户端(操作与客户端的操作相同，但是有些地方的设置要反过来，比如TCP头部的源IP与目的IP、源端口与目的端口之类)；此外，还要将ACK位置为1，表示已经接收到相应的网络包。 | >    |                                                              |\n|                                                              | <    | 客户端接收到数据，经以太层、IP层解析之后到达TCP层；<br />TCP层通过接收到的TCP头部的SYN位确认连接服务器的操作是否成功；若SYN位为1,(表示连接成功)，此时TCP模块会向套接字中写入服务器的IP地址，端口号等信息；并将套接字的状态设置为连接完毕；<br />同样地，客户端也需要将TCP头部的ACK位置1并将TCP头部传给IP层并委托IP层发送给服务器端。 |\n|    服务器收到客户端第二次发送的网络包，连接操作全部完成。    |      |                                                              |\n\n此后，套接字进入了随时可以收发数据的状态。到这里，也就是connect执行完毕。\n\n## 收发数据\n\n### 请求消息进入协议栈\n\n协议栈收到数据后，先将其存放在内部的发送缓冲区，继续等待应用程序后续的数据；协议栈是否发送数据有以下两个判断要素：\n\n* 缓存的数据包长度是否接近MSS(最大分段大小)。MSS=MTU-ip_head_len-tcp_head_len，MTU(最大传输单元)一般为1500；\n* 等待时间。即使数据包长度还未接近MSS，但是已经等待了一定时间，为避免造成发送延迟，也会将数据包发送出去；\n\n应用程序可以控制数据包发送的时机(长度优先或时间优先)，若应用程序未指定，则由协议栈自行决定。\n\n### 对长数据进行拆分\n\n当应用程序送入协议栈的数据长度大于MSS，数据以MSS个字节为单位进行分组，在每组数据前加上TCP头部后送入IP层，委托IP将数据发送。\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n### 网络包的接收确认\n\n每发送一个网络包，都需要进行确认操作。首先，在客户端(发送方)与服务器端(接收方)建立连接时，客户端(发送方)向服务器(接收方)发送的tcp头部使用一个32位的随机数作为序列号；在(发送方)TCP模块拆分数据时，每一数据块前所加的TCP头部的序列号为在上述序列号(32位的随机数)的基础上加上数据块的位置。服务器端(接收方)在收到网络包后，会计算ACK值(序列号+data_len+1)；\n\n&nbsp;\n\n服务器端(接收方)创建一个TCP头部(ACK的值为上述ACK的值，ACK位置1)，然后发送给客户端(发送方)；客户端(发送方)在没有收到某个数据包对应的ACK号之前，数据包会一直保存在发送缓冲区中，如果没有收到某个数据包对应的ACK号，TCP模块会重新发送此数据包。\n\n以下是TCP数据包传输的示意图(简便起见，没有考虑32随机数的初始序列号)。\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 13.png pic13 %}</div>\n\n&nbsp;\n\n同时，TCP的数据收发是双向的，即服务器端作为发送方、客户端作为接收方，也会为网络包的接收确认做上述操作。\n\n如下是TCP数据双向传输的示意图：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 14.png pic14 %}</div>\n\n&nbsp;\n\n### ACK号等待时间\n\nTCP协议采用动态调整的策略来设置ACK号的等待时间。策略是：在TCP模块发送数据时持续测量ACK号的等待时间，若ACK号的返回变慢，则增大ACK号的等待时间，若ACK号的返回变快，则减小ACK号的等待时间。\n\n### 滑动窗口\n\n接收方告知发送方自己最多能接收的数据，然后发送方根据这个值对发送的数据量进行控制。以下是一个TCP滑动窗口的示例。\n\n<div style=\"width:60%;margin:auto\">{% asset_img 15.png pic15 %}</div>\n\n&nbsp;\n\n### ACK与窗口信息的合并发送\n\nQ1：接收方何时要向发送方发送窗口的更新信息？\n\n答：应用程序从接收缓冲区取出数据后。\n\nQ2：接收方何时要向发送方发送ACK号？\n\n答：收到数据包确认无误后。\n\n为了提高网络的效率，可考虑将这两种信息放入同一tcp头部进行发送。这时，在等待过程中(一种情形是刚刚收到了tcp数据包并确认无误，等待应用程序从接收缓冲区取出数据；另一种情形是应用程序从接收缓冲区取出了数据，等待数据包的到来与确认)，窗口信息或ACK号会有多个值，此时只需要传递最终结果即可。","tags":["计算机网络"],"categories":["course"]},{"title":"AT&T汇编基础知识","url":"/course/ATwithT.html","content":"\n## 基本语法\n\nAT&T与Inter汇编主要有以下几个不同：\n\n* 寄存器的命名；\n```assembly\nAT&T：%eax                   Intel：eax\n```\n* 源操作数与目的操作数的顺序；AT&T赋值方向为从左向右。\n```assembly\nAT&T：movl %eax, %ebx         Intel：mov ebx, eax\n```\n* 常数与立即数的格式；\n```assembly\nAT&T：movl $12, %ebx          Intel：mov eax, 12\n```\n* 地址；\n```assembly\nAT&T：movl $0xd00d, %ebx      Intel：mov eax, 0xd00d\n```\n* 操作数长度标识；\n```assembly\nAT&T：movw %ax, %bx           Intel：mov bx, ax\n```\n* 寻址方式；\n```assembly\n#通用寻址\nAT&T：imm32(base, ip, scale)   Intel：[base+ip×scale+imm32]\n#直接寻址\nAT&T：foo                      Intel：[foo]\n#寄存器间接寻址\nAT&T：(%eax)                   Intel：[eax]\n```\n\n\n## GCC基本内联汇编\n\n基本内联汇编的格式为：`asm(\"statements\");`\n\n## GCC扩展内联汇编\n\nGCC扩展内联汇编的格式为：\n\n```assembly\nasm [volatile]( Assembler Template\n\t: Output Operands\n\t[ : Input Operands\n\t[ : Clobbers ]])\n```\n\n注：如果不希望汇编语句被gcc优化而改变位置，就需要在asm符号后添加volatile关键词；\n\n**样例**\n\n```assembly\n#define read_cr0() ({ \\\nunsigned int __dummy; \\\n__asm__( \\\n\t\"movl %%cr0, %0\\n\\t\" \\\n\t:\"=r\" (__dummy)); \\\n__dummy; \\\n})\n```\n\n**说明**\n\n* 在`__asm__`的括号内，第一行为汇编程序模板；其中`%0`以占位符作为汇编指令的操作数，GCC将这些占位符与C语言表达式按照出现的顺序相对应。即`%0`对应C语言表达式`__dummy`；\n* 第二行为输出部分；输出部分用来规定输出变量如何与寄存器结合的约束，输出部分可以有多个约束，互相以逗号分开，每个约束以\"=\"开头，接着用一个字母来表示操作数的类型，接着是关于变量结合的约束。在上例中，\"r\"代表任一通用寄存器，其他常用约束字母与含义见下表：\n\n<div style=\"width:80%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\n* 如果有输入部分；输入部分与输出部分相似，但是没有\"=\"；\n* 汇编程序模板为必选项，输入部分与输出部分为可选项；当存在输入部分而不存在输出部分时，需要保留\":\"(代表输出部分，即使输出部分不存在)，而当只存在修改部分时，需要保留\":::\"(代表输出部分、输入部分与修改部分)；\n\n**练习**\n\n扩展内联汇编代码：\n\n```c\nint count=1;\nint value=1;\nint buf[10];\nvoid main()\n{\n    asm(\n        \"cld \\n\\t\"\n        \"rep \\n\\t\"\n        \"stosl\"\n    :\n    : \"c\" (count), \"a\" (value) , \"D\" (buf)\n    );\n}\n```\n\n经过GCC编译之后得到的汇编代码为：\n\n```assembly\nmovl count,%ecx\nmovl value,%eax\nmovl buf,%edi\n#APP\ncld\nrep\nstosl\n#NO_APP\n```","tags":["操作系统","assembly"],"categories":["course"]},{"title":"第一步 浏览器生成消息","url":"/course/cn-step1.html","content":"\n## 生成HTTP请求消息\n\n### 浏览器解析URL\n\n* HTTP协议的URL格式：`http://[用户名(可省略)]:[密码(可省略)]@[Web服务器域名]:[端口号(可省略)][文件路径名]`，例如：\n\n  `http://user:password@www.glasscom.com:80/dir/file1.htm`\n\n* FTP协议的URL格式：`ftp://[用户名(可省略)]:[密码(可省略)]@[ftp服务器域名]:[端口号(可省略)][文件路径名]`，例如：\n\n  `ftp://user:password@ftp.glasscom.com:21/dir/file1.htm`\n\n* 计算机本地文件URL格式：`file://[计算机名(可省略)][文件路径名]`，例如：\n\n  `file://localhost/home/user/Desktop/wps-office-prometheus.desktop`\n\n* 发送电子邮件的URL格式：`mailto:[邮件地址]`，例如：\n\n  `mailto:tone@glasscom.com`\n\n浏览器根据开头就能确定是哪种协议，进而根据对应的协议格式对URL进行解析。\n\n例1：解析如下URL\n\n* `http://www.lab.glasscom.com/`：访问/目录下的index.html或default.html；\n* `http://www.lab.glasscom.com`：访问/目录下的index.html或default.html；\n* `http://www.lab.glasscom.com/what`：若/what是文件，则访问/目录下的what文件，若what是目录，则访问/what目录下的index.html或default.html；\n\n### 生成HTTP请求消息\n\nHTTP请求消息格式如下：\n\n&nbsp;\n\n<div style=\"width:64%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n&nbsp;\n\nHTTP的主要方法及其含义如下图所示：\n\n&nbsp;\n\n<div style=\"width:80%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\nHTTP请求消息中主要的头字段有如下这些：\n\n&nbsp;\n\n<div style=\"width:80%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n## 向DNS服务器查询Web服务器的IP地址\n\n<div style=\"width:64%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n* 客户端将查询消息发送给最近的DNS服务器(地址填写在客户端的TCP/IP设置中)；若该DNS服务器的缓存中存放了`www.lab.glasscom.com`Web服务器的IP地址，则直接返回相应IP地址；\n* 如果该DNS服务器中没有存放`www.lab.glasscom.com`Web服务器的IP地址，就需要从根域向下查找(每台DNS服务器都会保存根域DNS服务器的IP地址，共13个)；\n* 该DNS服务器将查询消息发送给根域DNS服务器，根域DNS服务器根据域名结构判断出该域名属于com域，将com域DNS服务器的IP地址返回该DNS服务器，该DNS服务器再向com域DNS服务器发送查询消息；\n* 一直类似以上步骤，直到查询消息到达目标DNS服务器——com.glasscom.lab域DNS服务器；com.glasscom.lab域中如果存在`www.lab.glasscom.com`这个域名，则目标DNS服务器就会将其IP地址发送给离客户端最近的DNS服务器；否则，目标DNS服务器将\"不存在\"这一结果发送给离客户端最近的DNS服务器；\n* 离客户端最近的DNS服务器将查询结果返回给客户端，同时将此次查询结果缓存，以便下次客户端查询时能够快速响应(DNS服务器缓存的信息都会有一个有效期，过了有效期缓存的信息会被删除)；\n\n## 委托协议栈发送消息\n\n数据通过类似管道的结构来流动：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n收发数据大体分为4个阶段：\n\n* 创建套接字阶段；\n* 连接阶段(将管道连接到服务端的套接字上)；\n* 通信阶段(收发数据)；\n* 断开阶段(断开管道并删除套接字)；\n\n如下示意图：\n\n&nbsp;\n\n<div style=\"width:60%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n&nbsp;\n\n**创建套接字阶段**\n\n创建套接字通过调用socket程序组件完成，套接字创建完成后，协议栈(socket程序组件)返回关于此套接字的描述符。\n\n**连接阶段**\n\n连接目的服务器通过调用connect程序组件完成，connect程序组件需接收3个参数：对应套接字的描述符、目的服务器的IP地址与目的端口号(用来指定要连接的服务器端的套接字)。最终，客户端的套接字与服务器端的套接字连接。\n\n**通信阶段**\n\n调用write程序组件将请求消息从客户端的套接字传送到服务器端的套接字。当服务器端接收到请求消息后，将请求消息解析并执行相应的操作，然后向客户端返回响应消息。接收响应消息通过调用read程序组件完成，read程序组件需接收1个参数——接收到的响应消息在内存中的地址，这一内存区域称为接收缓冲区。\n\n**断开阶段**\n\nWeb服务器发送完响应消息后，会主动执行断开操作；断开操作传回客户端之后，客户端调用close程序组件断开连接、删除套接字。\n\n&nbsp;\n\n在HTTP1.0版本中，HTML文档与图片视为独立的对象，每获取一次数据，就要执行一轮创建套接字、连接、通信与断开的操作；因此，如果一个网页中包含多张图片，就必须重复多轮上述操作，因此在HTTP1.1版本中设计了可以在一次连接中收发多个请求与响应的方法，当所有数据都请求完成后，客户端的应用程序会主动执行断开操作。","tags":["计算机网络"],"categories":["course"]},{"title":"第三章 物理内存管理：连续内存分配","url":"/course/os-ch3.html","content":"\n## 计算机体系结构与内存层次\n\n### 计算机体系结构\n\n<div style=\"width:64%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n&nbsp;\n\n### 内存层次\n\n<div style=\"width:50%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n&nbsp;\n\n### 操作系统的内存管理方式\n\n**预备知识**\n\n* 物理地址：将内存当作一个数组，内存单元在数组中的索引就是该内存单元的物理地址；\n* 线性地址(虚拟地址)：操作系统提供的一种对内存的抽象；线性地址到物理地址的转换如下图：\n\n<div style=\"width:50%;margin:auto\">{% asset_img 1.jpg pic1 %}</div>\n\n&nbsp;\n\n注：寄存器CR3用于存放当前进程正在使用的页目录基地址\n\n* 逻辑地址：形式为[段描述符 : 段偏移量]；逻辑地址到线性地址的转换如下图：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 10.jpg pic10 %}</div>\n\n&nbsp;\n\n**正文**\n\n<div style=\"width:50%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n&nbsp;\n\n* 重定位：操作系统把用户程序指令中的相对地址变换成为所在存储中的绝对地址的操作；\n* 分段\n  * 段：段由三个参数定义：段基地址、段限长和段属性；段基地址、段限长以及段的保护属性存储在一个称为段描述符的结构体中。\n  * 分段机制：将虚拟地址空间中的虚拟内存组织成一些长度可变的称为段的内存块单元；\n* 分页：虚拟地址空间按照固定大小划分成称为页面的若干单元，在物理内存中对应的单元称为页框。\n* 虚拟存储：进程的地址空间中有的页映射到内存，有的页映射到外存。当程序需要访问外存中的数据时，进程产生缺页中断，然后操作系统将这部分数据装入内存之中，然后进程重新执行失败的指令。\n\n## 地址空间与地址生成\n\n### 地址空间的定义\n\n地址空间是一个进程用来寻址内存的一套地址集合；地址空间中的地址为线性地址。\n\n### 地址生成\n\n举例说明如下：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\n地址的生成有如下几种时机：\n\n* 编译时(地址已知)；\n* 加载时；使用重定位表，在加载时生成绝对地址；\n* 执行时；需硬件支持的地址转换；\n\n### 地址检查\n\n以指令`mov %eax, $0xfffa620e`执行时的地址检查为例。\n\n<div style=\"width:56%;margin:auto\">{% asset_img 12.png pic12 %}</div>\n\n&nbsp;\n\n## 连续内存分配\n\n以下是在内存分配没有其他技术支持条件下的讨论。此时必须对进程分配连续的地址空间。\n\n### 内存碎片\n\n**外碎片**：由于每个进程的寿命不一致，导致有的进程先从内存中退出，有的进程后从内存中退出，从而在进程占用的内存区域之间出现空闲的内存区域，而该内存区域的长度小于所有进程要求的长度，使得该内存区域变得不可用。这样的空闲内存区域称为外碎片。\n\n**内碎片**：分配给进程区域内无法利用的内存。这是由于分配内存时只能分配2的整数次幂长度的内存区域。\n\n### 动态分配\n\n* 最先匹配：将空闲内存区域按照地址排序，将第一个长度大于进程要求长度的空闲内存区域分配给该进程；\n* 最佳匹配：将空闲内存区域按照长度排序(从小到大)，将第一个长度大于进程要求长度的空闲内存区域分配给该进程；\n* 最差匹配：将空闲内存区域按照长度排序(从大到小)，将第一个空闲内存区域分配给该进程；\n\n## 碎片整理\n\n通过调整进程占用的分区位置来减少或避免分区碎片。\n\n## 伙伴系统\n\n连续内存分配的实例。\n\n## SLUB分配器\n\n### 概述\n\n针对以下情形：\n\n* 一些内核所用到的结构体等对象远比页要小；\n* 并且这些对象会被频繁地申请与释放；\n* 有些对象仅仅初始化的时间就超过了申请到释放的时间；\n\n为满足这些对象申请内存的需求，需要创造页分配管理器之外的内存分配管理器——SLAB分配器，而SLUB分配器是在SLAB分配器的基础上进一步优化；使得效率更高，(分配器的)内存占用更低；下面介绍SLUB分配器的原理。\n\nSLUB将内存分组管理，每个组包含$2^{3},\\cdots,2^{11}$个字节，在4KB为一页的情形下，还有两个特殊的长度分组(96B，192B)，共11组；\n\n可以这样理解：SLUB相当于零售商，伙伴系统相当于厂家，SLUB从伙伴系统那里\"批发\"内存，然后SLUB再零售出去。\n\n整个SLUB系统结构图如下：\n\n{% asset_img 13.jpg pic13 %}\n\n&nbsp;\n\n整个系统的源头就是数组kmalloc_caches[12]，其中每个数组元素kmem_cache结构体相当于超市，每个超市出售一种特定长度的内存；每个超市有两个部门：仓库(kmem_cache_node)与营业厅(kmem_cache_cpu)，营业厅只保留一个slab(从kmem_cache获取的多个内存页)，营业厅在没有空闲object(特定长度的内存)的情况下会从仓库中换出有空闲object的slab；仓库中存放着被完全使用的slab(full链表存放)与被部分使用的slab(partial链表存放)。\n\n### 申请内存块\n\n**第一次申请内存块**\n\n给对象分配object，freelist指向下一空闲的object。\n\n{% asset_img 14.jpg pic14 %}\n\n&nbsp;\n\n**kmem_cache_cpu的slab有空闲的object时申请内存块**\n\n给对象分配object，freelist指向下一空闲的object。\n\n{% asset_img 15.jpg pic15 %}\n\n&nbsp;\n\n这里可能会问一个问题，为什么kmem_cache_cpu的slab中被占用的object是分开的，这是因为中间空闲的object被占用后释放了。\n\n**kmem_cache_cpu的slab无空闲的object时申请内存块，kmem_cache_node的partial链表有slab**\n\nkmem_cache_cpu的slab添加到kmem_cache_node的full链表，再将kmem_cache_cpu的slab换成kmem_cache_node的partial链表中的slab。然后给对象分配object，freelist指向下一空闲的object。\n\n{% asset_img 16.jpg pic16 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 17.jpg pic17 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 18.jpg pic18 %}\n\n&nbsp;\n\n**kmem_cache_cpu的slab无空闲的object时申请内存块，kmem_cache_node的partial链表无slab**\n\nkmem_cache_cpu的slab添加到kmem_cache_node的full链表，向伙伴系统申请slab并初始化slab，然后给对象分配object，freelist指向下一空闲的object；\n\n{% asset_img 19.jpg pic19 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 20.jpg pic20 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 21.jpg pic21 %}\n\n### 释放内存块\n\n**释放kmem_cache_cpu的slab上的object**\n\n将该object放入freelist链表即可。\n\n**释放kmem_cache_node上full链表上的object**\n\n先释放该object，那么该object所在slab的状态从full变成partial，因此需要将该object所在slab从full链表中移除，然后将其添加到partial链表。\n\n{% asset_img 22.jpg pic22 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 23.jpg pic23 %}\n\n&nbsp;\n\n**释放kmem_cache_node上partial链表(有多个object被分配)上的object**\n\n先释放该object，并将该object放入所在slab的freelist链表。\n\n{% asset_img 24.jpg pic24 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 25.jpg pic25 %}\n\n&nbsp;\n\n**释放kmem_cache_node上partial链表(只有一个object被分配)上的object**\n\n先释放该object，之后该object所在slab的状态变成empty，于是还要将该object所在slab也释放。\n\n{% asset_img 26.jpg pic26 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 27.jpg pic27 %}\n\n-------------------------------------------------------------------------\n\n{% asset_img 28.png pic28 %}\n\n&nbsp;\n\n**参考链接**\n\n[SLUB算法原理](https://blog.csdn.net/lukuen/article/details/6935068)\n\n[对各种地址更详细地解释](http://bbs.chinaunix.net/thread-2083672-1-1.html)","tags":["操作系统"],"categories":["course"]},{"title":"第二章 中断、异常与系统调用","url":"/course/os-ch2.html","content":"\n## 基本概念与原理\n\n<div style=\"width:36%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n&nbsp;\n\n**系统调用**：应用程序主动向操作系统发出的服务请求；异步响应。\n\n**异常**：非法指令或其他原因导致当前指令执行失败，(如内存出错)后的处理请求；同步响应。\n\n**中断**：来自硬件设备(外设，device)的处理请求。好处：避免CPU不停地去查询外设的状态，提高CPU的运行效率；异步或同步响应。\n\n<div style=\"width:50%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n## 中断处理机制\n\n* 建立中断服务例程；\n* 设置控制寄存器状态使CPU能够响应中断；\n* 处理中断；\n* 保存与恢复现场；\n\n### 设置CPU可响应中断\n\n* sstaus(硬件)：保存全局中断使能位；\n* sie(硬件)：指出CPU目前能处理或忽略的中断；\n* stvec(硬件)：中断入口地址；\n\n初始化如下：\n\n* 设置sie的TI使能STIE位；\n* 设置sstaus的使能中断SIE位；\n* 实现中断服务总控函数并设置stvec指向该函数的地址；\n\n### 建立中断服务例程\n\n* 初始化\n* 服务例程\n\n### 保存现场&恢复现场\n\n在调用中断服务例程之前，需要保存被中断的应用程序的上下文(也就是所有的寄存器)，具体来说，有如下寄存器：\n\n* x[0-31]：通用寄存器；\n* sstatus：系统状态寄存器；\n* 以及寄存器sepc、scause、stval；\n\n产生中断后，硬件设置如下：\n\n* sepc设置为产生中断后指令的地址；\n* pc设置为stvec(总控中断服务程序的地址)；\n* scause设置为中断的来源；\n* sstatus的SIE位置0以禁用中断；\n* stval保存中断相关的附加信息；\n\n## 系统调用\n\n<div style=\"width:80%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n&nbsp;\n\n* ecall指令与sret指令用于系统调用；\n* 系统调用存在着堆栈切换与特权级的切换，参数验证(内核无法信任应用程序)以及可能的切换页表、拷贝数据操作；\n\n**具体流程**\n\n* 应用发起请求；\n* 函数库发出系统调用请求(设置系统调用号，再执行ecall指令)；\n* 保存被中断的应用程序的上下文；\n* 硬件设置：\n  * sepc：保存请求后的指令地址；\n  * pc设置为stvec(总控中断服务程序的地址)；\n  * scause设置为ecall from u-mode；\n  * sstatus：SIE位置0以禁用中断；\n  * stval保存中断相关的附加信息；\n* 调用中断服务例程；\n* 恢复被中断的应用程序的上下文；\n* 应用继续执行；","tags":["操作系统"],"categories":["course"]},{"title":"第一章 操作系统与系统结构&程序设计语言","url":"/course/os-ch1.html","content":"\n## 从OS角度看计算机系统\n\n使用操作系统，在一个CPU上并发的执行多个程序的实例，我们称为进程。在多个进程相互执行时如何做到相互之间不互相影响，保证系统是安全的，这时需要对程序的执行进行**隔离**。这种隔离就需要计算机系统结构给予支持。而这里主要的隔离技术即**虚拟内存**与**特权模式(中断)**。\n\n### 隔离\n\n* 隔离以避免对整个系统的可用性、可靠性、安全产生影响；\n* 运行的程序通常是隔离的单元；\n* 技术1：地址空间。一个程序只能寻址自己的内存，任一程序若无许可，则不能访问不属于自己的内存。\n* 技术2：特权模式（中断机制）。防止应用程序访问设备与敏感的CPU寄存器。使用中断机制进行特权模式的切换。\n\n### 虚拟内存\n\n由操作系统提供的一种对物理内存的抽象。\n\n### 特权模式&中断\n\n* 内核模式(低特权级)\n* 用户模式(高特权级)\n\n\n## Lab1\n\n安装qemu-system\n\n```bash\napt install -y qemu-system\n```\n\n进入ucore/labcodes/lab1文件夹，使用`make`命令编译。\n\n使用qemu-system-x86启动ucore.img但是并不马上执行，以便我们用gdb对其进行远程调试。如无特别说明，以下命令都是在ucore/labcodes/lab1目录下执行。\n\n```bash\nqemu-system-i386 -S -s -hda bin/ucore.img -monitor stdio\n```\n\n再用以下内容替换~/.gdbinit文件\n\n```bash\nfile bin/kernel\ntarget remote :1234\nbreak kern_init\nset arch i8086\n```\n\n接下来运行gdb，效果如下图所示：\n\n<div style=\"width:64%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\n参考链接：\n\n[清华大学操作系统实验ucore](https://blog.csdn.net/ever_freedom/article/details/105563670)","tags":["操作系统"],"categories":["course"]},{"title":"攻防世界-密码学-Marijuana","url":"/crypto/xctf-Marijuana.html","content":"\n## 题目信息\n\n这个密码系统的开发者在开发过程中使用率很高，也可以说是非常高。 也许他的想法是错的，这个密码系统是非常容易攻破的。\n\n## 分析\n\nRSA的d很小，但是N有3个因子，使用wiener攻击没破解出来，想用boneh_durfee攻击却发现没法列方程，看了writeup才了解到wiener攻击的变种，[论文链接在此](https://web.math.pmf.unizg.hr/~duje/pdf/dujececc.pdf)；总的来说，记$\\{h_{i}/k_{i}\\}$是$e/N$的连分数收敛列，常规的wiener攻击中$d=k_{i}$，而在wiener攻击的变种中，$d=s\\cdot k_{i}+t\\cdot k_{i-1} , s,t \\in Z$，一般来说，$d$越大，$s,t$的取值范围也越大。\n\n## 解题\n\n解题的Python脚本如下：\n```Python\nfrom gmpy2 import is_square,sqrt\nfrom Crypto.Util.number import *\nfrom pwn import pwnlib\nfrom pwnlib.util.iters import mbruteforce\n\nclass Wiener(object):\n    def __init__(self,N,e,mode):\n        self.N=N\n        self.e=e\n        self.mode=mode\n        return\n\n    def next_frac(self):\n        hi_1,hi_2=1,0\n        ki_1,ki_2=0,1\n        a,b=self.e,self.N\n        r=1\n        while r:\n            p,r=divmod(a,b)\n            hi=p*hi_1+hi_2\n            ki=p*ki_1+ki_2\n            hi_1,hi_2=hi,hi_1\n            ki_1,ki_2=ki,ki_1\n            a,b=b,r\n            yield (hi,ki)\n\n    def two(self):\n        N,e=self.N,self.e\n        for frac in self.next_frac():\n            hi,ki=frac\n            if hi==0:\n                continue\n            # f=t^2-(N-(ki*e-1)/hi+1)*t+N ==> delta=[N-(ki*e-1)/hi+1]^2-4*N\n            t1=(ki*e-1)%hi\n            if not t1:\n                t1=N-(ki*e-1)//hi+1\n                delta=pow(t1,2)-4*N\n                if is_square(delta):\n                    t2=int(sqrt(delta))\n                    if not (t1-t2)%2:\n                        P=(t1-t2)//2\n                        Q=(t1+t2)//2\n                        return P,Q\n        return\n\n    def multi(self,rate):\n        N,e=self.N,self.e\n        pt=getRandomRange(2,N-1)\n        ct=pow(pt,e,N)\n        ki_1,ki_2=0,1\n        for frac in self.next_frac():\n            hi,ki=frac\n            ki_1,ki_2=ki,ki_1\n            if hi==0:\n                continue\n            check=lambda rs: pow(ct,int(rs[:rate],2)*ki_1+int(rs[rate:],2)*ki_2,N)==pt\n            rs=mbruteforce(check,'01',2*rate,method='fixed')\n            if rs:\n                return int(rs[:rate],2)*ki_1+int(rs[rate:],2)*ki_2\n        return\n\n    def attack(self):\n        if self.mode:\n            #when there is no solution, maybe you could take greater action, via increase rate.\n            return self.multi(4)\n        else:\n            return self.two()\n\ndef solve():\n    pubkey = (1696852658826990842058316561963467335977986730245296081842693913454799128341723605666024757923000936875008280288574503060506225324560725525210728761064310034604441130912702077320696660565727540525259413564999213382434231194132697630244074950529107794905761549606578049632101483460345878198682237227139704889943489709170676301481918176902970896183163611197618458670928730764124354693594769219086662173889094843054787693685403229558143793832013288487194871165461567L, 814161885590044357190593282132583612817366020133424034468187008267919006610450334193936389251944312061685926620628676079561886595567219325737685515818965422518820810326234612624290774570873983198113409686391355443155606621049101005048872030700143084978689888823664771959905075795440800042648923901406744546140059930315752131296763893979780940230041254506456283030727953969468933552050776243515721233426119581636614777596169466339421956338478341355508343072697451L, 171012227587318507773834753911094468358648971527111097308935888531930900156798659257578479378777764146070352809723708236353390208094909385240006920137781562826981091183813955039359863361624869703055918575613667858215532572602435432258750639197322091887713402631456113333645709142822182724397962837201266977523L, 96969753191136466007366303619618019752521508403657426306543836447071659732926802256183021740376016065813234292694535879838415771865207311953800116203362150588941093508091412441933752168889516206420588410478242229762908362637083786338280959547015086176046206126019992386890758970740552952647510652431386064722L)\n    n,e,a,g=pubkey\n    wiener=Wiener(n,e,1)\n    d=wiener.attack()\n    c1,c2=(1569733526826523065259704222721381245770313117205865099913421859731162526943498524936251685846967970606251353344665893442015804015671457823645874503670136308040791285744658847419176471348768113798503897694020110157476679833746227801224812046930570487233225157924912272791212802495997329083436189937249314855532400635293522270501567950040825794060896420481676398789310029592608176167251882124182145471818654414925639589921023176070657483148482403065241178276749773L, 139537660044872985880471632333334179976891152860359271230202507995985566816703080930428310461057387079799847266510420206696052591677854190150642820963140050439023069266243433278700748622126726137374130247097863526461696642750021196138340072411724739383716017406022211953417323065831672315854246554523225039827L)\n    k=pow(c1,d,n)\n    K=pow(g,k,a)\n    return long_to_bytes(c2*inverse(K,a)%a)\n\nif __name__=='__main__':\n    print solve()\n```\n程序运行结果如下：\n```Bash\n$ python solve.py \n[-] MBruteforcing: No matches found\n......\n[-] MBruteforcing: No matches found\n[+] MBruteforcing: Found key: \"01110110\"\nASIS{Wiener_at7ack_iN_mUlt1_Prim3_RSA_iZ_f34sible_t0O!}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-babyRSA1","url":"/crypto/xctf-Babyrsa1.html","content":"\n## 题目信息\n\n题目无描述。\n\n## 分析\n\n在伽罗华域上实现RSA还是第一次见，该题是典型的论文题，提出这个idea的paper[链接在此](http://www.diva-portal.se/smash/get/diva2:823505/FULLTEXT01.pdf)；\n\n记模数N的分解为$N=P\\cdot Q , s=(2^{deg(P)}-1)\\cdot (2^{deg(Q)}-1)$，其中$deg(\\cdot)$为多项式的次数；则$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ s$。\n\n## 解题\n\n解题的sage脚本如下：\n```Python\nfrom Crypto.Util.number import *\n\ndef solve():\n    p,q=N.factor()\n    p,q=p[0],q[0]\n    #s is the equivalent of phi from classic RSA\n    s=(pow(2,p.degree())-1)*(pow(2,q.degree())-1)\n    #therefore, d is the private key to decrypt\n    d=inverse_mod(e,s)\n    pp=pow(PR(pc),d,N)\n    return long_to_bytes(R(pp).integer_representation())\n\nif __name__=='__main__':\n    PR=PolynomialRing(GF(2),'x')\n    e=31337\n    N=PR('x^2048 + x^2046 + x^2043 + x^2040 + x^2036 + x^2035 + x^2034 + x^2033 + x^2031 + x^2029 + x^2025 + x^2024 + x^2022 + x^2019 + x^2018 + x^2017 + x^2012 + x^2007 + x^2006 + x^2004 + x^2000 + x^1999 + x^1998 + x^1997 + x^1993 + x^1992 + x^1991 + x^1986 + x^1982 + x^1981 + x^1979 + x^1978 + x^1977 + x^1975 + x^1970 + x^1964 + x^1963 + x^1962 + x^1961 + x^1960 + x^1959 + x^1958 + x^1955 + x^1954 + x^1952 + x^1951 + x^1949 + x^1947 + x^1942 + x^1939 + x^1938 + x^1936 + x^1934 + x^1933 + x^1932 + x^1930 + x^1928 + x^1927 + x^1923 + x^1922 + x^1919 + x^1918 + x^1915 + x^1914 + x^1913 + x^1912 + x^1911 + x^1910 + x^1908 + x^1903 + x^1902 + x^1900 + x^1899 + x^1897 + x^1893 + x^1891 + x^1890 + x^1886 + x^1881 + x^1880 + x^1879 + x^1878 + x^1875 + x^1874 + x^1873 + x^1872 + x^1871 + x^1870 + x^1869 + x^1865 + x^1863 + x^1862 + x^1860 + x^1856 + x^1855 + x^1853 + x^1852 + x^1845 + x^1841 + x^1839 + x^1837 + x^1836 + x^1835 + x^1833 + x^1832 + x^1829 + x^1828 + x^1827 + x^1826 + x^1824 + x^1823 + x^1822 + x^1821 + x^1820 + x^1819 + x^1818 + x^1817 + x^1813 + x^1812 + x^1810 + x^1809 + x^1808 + x^1807 + x^1803 + x^1799 + x^1797 + x^1796 + x^1794 + x^1792 + x^1790 + x^1786 + x^1783 + x^1782 + x^1779 + x^1778 + x^1776 + x^1775 + x^1774 + x^1772 + x^1767 + x^1766 + x^1765 + x^1764 + x^1763 + x^1762 + x^1759 + x^1757 + x^1756 + x^1754 + x^1753 + x^1752 + x^1750 + x^1749 + x^1741 + x^1734 + x^1730 + x^1729 + x^1726 + x^1725 + x^1723 + x^1722 + x^1721 + x^1716 + x^1714 + x^1713 + x^1712 + x^1710 + x^1709 + x^1706 + x^1705 + x^1703 + x^1702 + x^1700 + x^1698 + x^1693 + x^1692 + x^1691 + x^1690 + x^1683 + x^1682 + x^1681 + x^1680 + x^1679 + x^1677 + x^1672 + x^1670 + x^1669 + x^1666 + x^1663 + x^1662 + x^1661 + x^1659 + x^1655 + x^1653 + x^1651 + x^1649 + x^1648 + x^1647 + x^1646 + x^1644 + x^1643 + x^1642 + x^1640 + x^1639 + x^1638 + x^1634 + x^1633 + x^1628 + x^1620 + x^1619 + x^1618 + x^1616 + x^1614 + x^1611 + x^1610 + x^1608 + x^1605 + x^1604 + x^1603 + x^1599 + x^1597 + x^1595 + x^1594 + x^1590 + x^1588 + x^1587 + x^1585 + x^1583 + x^1580 + x^1579 + x^1577 + x^1574 + x^1573 + x^1572 + x^1568 + x^1566 + x^1565 + x^1563 + x^1562 + x^1560 + x^1555 + x^1554 + x^1552 + x^1550 + x^1549 + x^1548 + x^1545 + x^1544 + x^1542 + x^1540 + x^1538 + x^1537 + x^1536 + x^1535 + x^1534 + x^1533 + x^1532 + x^1531 + x^1528 + x^1526 + x^1525 + x^1523 + x^1522 + x^1521 + x^1519 + x^1517 + x^1515 + x^1510 + x^1509 + x^1506 + x^1504 + x^1502 + x^1499 + x^1498 + x^1497 + x^1488 + x^1483 + x^1480 + x^1477 + x^1472 + x^1471 + x^1469 + x^1468 + x^1467 + x^1466 + x^1464 + x^1462 + x^1457 + x^1456 + x^1455 + x^1454 + x^1453 + x^1452 + x^1448 + x^1446 + x^1444 + x^1443 + x^1442 + x^1441 + x^1440 + x^1436 + x^1435 + x^1431 + x^1428 + x^1425 + x^1424 + x^1422 + x^1420 + x^1415 + x^1414 + x^1411 + x^1410 + x^1408 + x^1406 + x^1405 + x^1403 + x^1402 + x^1399 + x^1397 + x^1396 + x^1395 + x^1394 + x^1393 + x^1391 + x^1388 + x^1385 + x^1377 + x^1376 + x^1372 + x^1371 + x^1370 + x^1369 + x^1367 + x^1363 + x^1361 + x^1357 + x^1355 + x^1354 + x^1349 + x^1343 + x^1339 + x^1338 + x^1337 + x^1336 + x^1335 + x^1332 + x^1329 + x^1327 + x^1326 + x^1324 + x^1321 + x^1315 + x^1314 + x^1312 + x^1310 + x^1309 + x^1305 + x^1304 + x^1303 + x^1302 + x^1299 + x^1298 + x^1296 + x^1295 + x^1293 + x^1291 + x^1290 + x^1289 + x^1284 + x^1283 + x^1282 + x^1281 + x^1280 + x^1278 + x^1277 + x^1276 + x^1275 + x^1272 + x^1270 + x^1269 + x^1268 + x^1267 + x^1259 + x^1257 + x^1254 + x^1252 + x^1251 + x^1249 + x^1247 + x^1246 + x^1244 + x^1240 + x^1238 + x^1233 + x^1232 + x^1229 + x^1222 + x^1219 + x^1217 + x^1211 + x^1209 + x^1208 + x^1205 + x^1204 + x^1203 + x^1202 + x^1200 + x^1197 + x^1196 + x^1195 + x^1193 + x^1192 + x^1189 + x^1187 + x^1186 + x^1185 + x^1184 + x^1183 + x^1182 + x^1181 + x^1177 + x^1176 + x^1173 + x^1170 + x^1167 + x^1166 + x^1162 + x^1161 + x^1160 + x^1159 + x^1158 + x^1156 + x^1155 + x^1154 + x^1153 + x^1151 + x^1146 + x^1143 + x^1141 + x^1139 + x^1138 + x^1137 + x^1135 + x^1131 + x^1129 + x^1128 + x^1125 + x^1124 + x^1122 + x^1116 + x^1115 + x^1114 + x^1112 + x^1111 + x^1107 + x^1106 + x^1105 + x^1104 + x^1103 + x^1102 + x^1098 + x^1097 + x^1095 + x^1094 + x^1092 + x^1088 + x^1087 + x^1085 + x^1077 + x^1076 + x^1075 + x^1072 + x^1069 + x^1068 + x^1061 + x^1060 + x^1059 + x^1057 + x^1055 + x^1054 + x^1053 + x^1050 + x^1047 + x^1046 + x^1044 + x^1043 + x^1042 + x^1036 + x^1029 + x^1025 + x^1024 + x^1023 + x^1022 + x^1019 + x^1016 + x^1013 + x^1012 + x^1010 + x^1008 + x^1007 + x^1006 + x^1004 + x^1000 + x^996 + x^995 + x^993 + x^992 + x^989 + x^985 + x^983 + x^978 + x^977 + x^975 + x^972 + x^971 + x^970 + x^969 + x^967 + x^963 + x^957 + x^956 + x^952 + x^950 + x^948 + x^945 + x^942 + x^941 + x^940 + x^938 + x^937 + x^936 + x^935 + x^932 + x^931 + x^930 + x^928 + x^927 + x^926 + x^923 + x^921 + x^918 + x^916 + x^914 + x^913 + x^909 + x^906 + x^905 + x^904 + x^902 + x^897 + x^895 + x^892 + x^889 + x^888 + x^887 + x^886 + x^885 + x^884 + x^882 + x^881 + x^879 + x^876 + x^870 + x^868 + x^867 + x^865 + x^862 + x^861 + x^859 + x^858 + x^856 + x^854 + x^848 + x^847 + x^846 + x^843 + x^839 + x^837 + x^836 + x^832 + x^831 + x^830 + x^829 + x^826 + x^823 + x^821 + x^820 + x^817 + x^815 + x^812 + x^809 + x^808 + x^805 + x^803 + x^802 + x^800 + x^799 + x^797 + x^795 + x^793 + x^792 + x^788 + x^786 + x^784 + x^780 + x^775 + x^774 + x^770 + x^768 + x^766 + x^764 + x^761 + x^760 + x^753 + x^752 + x^751 + x^750 + x^747 + x^744 + x^742 + x^741 + x^737 + x^734 + x^732 + x^728 + x^727 + x^724 + x^722 + x^721 + x^719 + x^717 + x^715 + x^714 + x^713 + x^710 + x^709 + x^705 + x^703 + x^701 + x^698 + x^697 + x^695 + x^690 + x^687 + x^685 + x^684 + x^682 + x^681 + x^680 + x^677 + x^676 + x^674 + x^673 + x^672 + x^671 + x^670 + x^669 + x^665 + x^663 + x^659 + x^652 + x^651 + x^650 + x^649 + x^648 + x^647 + x^646 + x^645 + x^642 + x^640 + x^638 + x^632 + x^631 + x^630 + x^629 + x^627 + x^626 + x^623 + x^622 + x^621 + x^620 + x^616 + x^615 + x^610 + x^605 + x^602 + x^601 + x^600 + x^599 + x^598 + x^596 + x^594 + x^593 + x^591 + x^583 + x^581 + x^579 + x^578 + x^577 + x^576 + x^575 + x^573 + x^572 + x^571 + x^570 + x^569 + x^565 + x^563 + x^562 + x^561 + x^559 + x^557 + x^555 + x^552 + x^551 + x^546 + x^544 + x^542 + x^541 + x^540 + x^539 + x^538 + x^537 + x^535 + x^533 + x^530 + x^527 + x^523 + x^522 + x^520 + x^519 + x^515 + x^513 + x^511 + x^509 + x^507 + x^505 + x^504 + x^503 + x^499 + x^497 + x^496 + x^495 + x^493 + x^492 + x^488 + x^486 + x^481 + x^480 + x^479 + x^478 + x^477 + x^472 + x^470 + x^468 + x^467 + x^464 + x^463 + x^460 + x^459 + x^455 + x^454 + x^453 + x^446 + x^445 + x^444 + x^443 + x^440 + x^438 + x^437 + x^432 + x^431 + x^428 + x^427 + x^426 + x^420 + x^419 + x^416 + x^415 + x^414 + x^413 + x^412 + x^411 + x^405 + x^404 + x^401 + x^396 + x^393 + x^392 + x^391 + x^388 + x^387 + x^383 + x^381 + x^380 + x^377 + x^376 + x^369 + x^364 + x^362 + x^358 + x^357 + x^356 + x^355 + x^353 + x^351 + x^349 + x^340 + x^339 + x^338 + x^337 + x^336 + x^335 + x^334 + x^332 + x^330 + x^328 + x^327 + x^326 + x^324 + x^320 + x^318 + x^316 + x^315 + x^309 + x^302 + x^298 + x^292 + x^291 + x^290 + x^289 + x^287 + x^286 + x^285 + x^284 + x^281 + x^279 + x^278 + x^276 + x^274 + x^273 + x^272 + x^271 + x^267 + x^266 + x^264 + x^263 + x^262 + x^260 + x^259 + x^256 + x^254 + x^253 + x^252 + x^251 + x^249 + x^248 + x^247 + x^245 + x^244 + x^241 + x^239 + x^235 + x^234 + x^233 + x^232 + x^231 + x^230 + x^226 + x^224 + x^221 + x^219 + x^218 + x^216 + x^215 + x^214 + x^209 + x^207 + x^206 + x^202 + x^201 + x^198 + x^197 + x^194 + x^193 + x^192 + x^191 + x^189 + x^188 + x^183 + x^182 + x^181 + x^180 + x^179 + x^178 + x^177 + x^175 + x^172 + x^169 + x^168 + x^166 + x^165 + x^164 + x^163 + x^158 + x^157 + x^153 + x^152 + x^149 + x^147 + x^146 + x^144 + x^140 + x^139 + x^136 + x^128 + x^127 + x^126 + x^124 + x^123 + x^122 + x^121 + x^116 + x^115 + x^113 + x^112 + x^109 + x^108 + x^107 + x^106 + x^104 + x^103 + x^102 + x^101 + x^100 + x^99 + x^97 + x^95 + x^94 + x^93 + x^92 + x^87 + x^84 + x^83 + x^82 + x^80 + x^79 + x^78 + x^76 + x^73 + x^70 + x^69 + x^68 + x^67 + x^66 + x^65 + x^63 + x^60 + x^59 + x^57 + x^55 + x^52 + x^51 + x^47 + x^46 + x^45 + x^43 + x^42 + x^40 + x^36 + x^35 + x^30 + x^29 + x^28 + x^27 + x^23 + x^20 + x^17 + x^14 + x^9 + x^7 + x^3 + 1')\n    R.<a> = GF(2^2049)\n    with open('flag.enc','rb') as f:\n        pc=R.fetch_int(bytes_to_long(f.read()))\n    print solve()\n```\n\n程序运行结果如下：\n```Bash\nsage solve.sage\n  ***   Warning: increasing stack size to 2000000.\nflag{P1ea5e_k33p_N_as_A_inTegeR~~~~~~}jIXXXX\n```\n注：后面XXXX代表不可打印明文。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-oneTimePad2","url":"/crypto/xctf-Onetimepad-2.html","content":"\n## 题目信息\n\n看名字也可以猜出来是oneTimePad的升级版。\n\n## 分析\n\nprocess1：GF(2^128)上的乘法操作；也是oneTimePad的唯一考点。\n\nnextrand：将process2视为$\\{(x_{1},x_{2},x_{3},x_{4})|x_{i}\\in GF(2^{128})\\}$上的乘法操作，则函数最后的tmp1就是$(A,B,0,1)^{N}$；而通过几次尝试，发现$(A,B,0,1)^{N}$有形式$(A^{N},A^{N-1}\\cdot B+\\cdots +A\\cdot B+B,0,1)$，即$(A^{N},B(A^{N}-1)\\cdot (A-1)^{-1},0,1)$而这可通过数学归纳法得到证明(证明很简单，此处略)。此外，$N$更新为$N^{2}$(乘法为GF(2^128)上的乘法操作)。从而得到密钥的更新迭代公式为：$k_{i+1}=k_{i}\\cdot A^{N}+B(A^{N}-1)\\cdot (A-1)^{-1}=(k_{i}+B\\cdot (A-1)^{-1})\\cdot A^{N}-B(A-1)^{-1}$，则$k_{i+1}+B\\cdot (A-1)^{-1}=(k_{i}+B\\cdot (A-1)^{-1})\\cdot A^{N}$，记$f(k)=k+B\\cdot (A-1)^{-1}$，则$A^{N}=f(k_{i+1})\\cdot f(k_{i})^{-1}$。128位的离散对数问题sage还是可以搞定的！\n\n而由于题目给了一定长度的明文，因此我们也就得到了一定数量的密钥(3个)，使用第2个和第3个密钥恢复出生成第3个密钥的$N$；得到$N$之后进行同样的操作来恢复出加密消息时的密钥流。\n\n注：我恢复的是生成第3个密钥的$N$，需要更新($N\\leftarrow N^{2}$)才能对接下来的密文(第4组起)解密！\n\n## 解题\n\n解题分为两步，第一步解出$N$，使用的sage脚本如下：\n```Python\nfrom binascii import unhexlify\nfrom Crypto.Util.number import *\n\ndef polify(N):\n    bN=list(bin(N)[2:])\n    bN.reverse()\n    return K(bN)\n\ndef unpolify(Poly):\n    bN=Poly.polynomial().list()\n    bN.reverse()\n    return long(''.join([str(it) for it in bN]),2)\n\nif __name__=='__main__':\n    K.<x>=GF(2L^128,modulus=x^128+x^7+x^2+x+1)\n    cipher='0da8e9e84a99d24d0f788c716ef9e99cc447c3cf12c716206dee92b9ce591dc0722d42462918621120ece68ac64e493a41ea3a70dd7fe2b1d116ac48f08dbf2b26bd63834fa5b4cb75e3c60d496760921b91df5e5e631e8e9e50c9d80350249c'\n    cipher=unhexlify(cipher)\n    cs=[bytes_to_long(cipher[ii:(ii+16)]) for ii in range(0,len(cipher),16)]\n    pre=\"One-Time Pad is used here. You won't know that the flag is flag{\"\n    ps=[bytes_to_long(pre[ii:ii+16]) for ii in range(0,len(pre)-16,16)]\n    ks=[p^^c for p,c in zip(ps,cs)]\n    f=lambda k,a,b: k+b*(a-1)^-1\n    A=0xc6a5777f4dc639d7d1a50d6521e79bfd\n    B=0x2e18716441db24baf79ff92393735345\n    KA,KB=polify(A),polify(B)\n    Kks=[polify(t) for t in ks]\n    tt=f(Kks[2],KA,KB)*f(Kks[1],KA,KB)^-1\n    N=discrete_log(tt,KA)\n    KN=polify(N)\n    print unpolify(pow(KN,2))\n```\n脚本运行结果如下：\n```Bash\n$ sage solve.sage\n139066609048774629292054833219983607544\n```\n注：我最后做了更新操作，因此直接对第四组起的密文解密即可。\n\n第二步，进行同样的操作来恢复出加密消息时的密钥流来解密密文，使用的Python脚本如下：\n```Python\nfrom binascii import unhexlify\nfrom Crypto.Util.number import *\nfrom oneTimePad2 import P,A,B\nfrom oneTimePad2 import process1,process2\n\ndef nextrand(rand):\n    global N, A, B\n    tmp1 = [1, 0, 0, 1]\n    tmp2 = [A, B, 0, 1]\n    s = N\n    N = process1(N, N)\n    while s:\n        if s % 2:\n            tmp1 = process2(tmp2, tmp1)\n        tmp2 = process2(tmp2, tmp2)\n        s = s / 2\n    return process1(rand, tmp1[0]) ^ tmp1[1]\n\ndef keygen():\n    key = bytes_to_long(pre)^bytes_to_long(cipher[0:16])\n    while True:\n        yield key\n        key = nextrand(key)\n\nif __name__=='__main__':\n    N=139066609048774629292054833219983607544\n    cipher='0da8e9e84a99d24d0f788c716ef9e99cc447c3cf12c716206dee92b9ce591dc0722d42462918621120ece68ac64e493a41ea3a70dd7fe2b1d116ac48f08dbf2b26bd63834fa5b4cb75e3c60d496760921b91df5e5e631e8e9e50c9d80350249c'\n    cipher=unhexlify(cipher[64:])\n    pre=\"on't know that t\"\n    res=''\n    for i, key in zip(range(0,64,16),keygen()):\n        res+= long_to_bytes(bytes_to_long(cipher[i:i+16])^key)\n    print res\n```\n注：为了复用P,A,B以及process1,process2，对oneTimePad2.py做了一定调整，P,A,B的定义放在全局，其他的除了函数定义全部放到`if __name__ == '__main__':`下。\n运行脚本结果如下：\n\n```Bash\n$ python solve.py\non't know that the flag is flag{LCG1sN3ver5aFe!!}.XXXX\n```\n注：后面的字符有不可打印字符因此用XXXX代替。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-root","url":"/crypto/xctf-Root.html","content":"\n## 题目信息\n\n附件是一个流量包。\n\n## 分析\n\n在流量包中找到RSA公钥，由于没有提供任何其他信息，且模数位数很高，只能寄希望于因子之差很小，即采用费马攻击。之后将私钥导入流量包即可找出flag。\n\n## 解题\n\n解题的Python脚本如下：\n```Python\nfrom gmpy2 import isqrt,square,is_square\nfrom Crypto.Util.number import *\nfrom Crypto.PublicKey import RSA\n\ndef fermat_factors(n):\n    assert n % 2 != 0\n    a = isqrt(n)\n    b2 = square(a) - n\n    while not is_square(b2):\n        a += 1\n        b2 = square(a) - n\n    factor1 = a + isqrt(b2)\n    factor2 = a - isqrt(b2)\n    return int(factor1), int(factor2)\n\ndef solve():\n    N=0x726f6f7400000000000000000000000000000000001b000000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001fffff7777777b00000000000000001ffffffffffffb00000000000000001ffffffffffb0000000000000000001ffffffffffb0000000000000000001ffffffffffffb00000000000000001fffff2222222b00000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb0000000000000000000000001ffffb00000000000000265293c4422be3532638feeb2a635e865e5bccd4862d1491f8e46ed41afdab32ab1e913c296c45a723a371cc4ad218d273a494ac501a1c677576b84d3a1700b24e38f3d7c8090c952767f8a9da532eb4496a953fa2b2641f93af58321e491ad6b3e1f6600ea1757635a2d47562dff2f245bfc8ed511420931de246d56334d8897d6465b227f6c095ece1ad994c7551f08dbc21f8b40691ee51f5f72d052d9352062f90b0e7c52c2eb18196c2c985101af4eac67499396c6241ad4f2439ed11f87d67e73a239b865c45d65a61cf0f56082de831b97fb28ae8222a7195e0ec06c08281ffc16e7106e77e68b8c4510424beeb5582fe21cc345f53534682b75c368d73c9\n    E=31337\n    p,q=fermat_factors(N)\n    phi=(p-1)*(q-1)\n    assert GCD(E,phi)==1\n    d=inverse(E,phi)\n    rsakey=RSA.construct((N,E,d,p,q))\n    with open('key.pem','wb') as f:\n        f.write(rsakey.exportKey('PEM'))\n    return\n\nif __name__=='__main__':\n    solve()\n```\n之后将私钥导入流量包，如下图所示：\n\n{% asset_img 1.png pic1 %}\n\n然后返回，快捷键Ctrl-Alt-Shift-S来追踪SSL流，在明文的最后以'666c6167'开头，而它正好是flag的16进制编码。将这串字符进行16进制解码即得到flag。\n```Python\n>>> '666c61673a7768656e5f736f6c76696e675f70726f626c656d735f6469675f61745f7468655f726f6f74735f696e73746561645f6f665f6a7573745f6861636b696e675f61745f7468655f6c6561766573'.decode('hex')\n'flag:when_solving_problems_dig_at_the_roots_instead_of_just_hacking_at_the_leaves'\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-babyrsa","url":"/crypto/xctf-Babyrsa.html","content":"\n## 题目信息\n\n点击获取在线场景来得到在线场景。\n\n## 分析\n\n就是一个最常规的RSA Oracle，在CTF Wiki中[RSA部分](https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_chosen_plain_cipher/)有介绍。\n\n## 解题\n\n交互解题的Python脚本如下：\n```Python\nfrom pwn import pwnlib\nfrom pwnlib.tubes.remote import remote\nfrom time import sleep\nfrom Crypto.Util.number import *\n\ne=0x10001\nn=0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db\nc=0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0\n\ndef check(guess,err):\n    for m in range(guess-err,guess+err):\n        if pow(m,e,n)==c:\n            return m\n    return\n\ndef solve():\n    low,high=0,n\n    cnt=0\n    while high-low>4:\n        cnt+=1\n        tt=(pow(2,cnt*e,n)*c)%n\n        r=remote('111.200.241.244',44451)\n        re=r.recv()\n        r.sendline(hex(tt)[2:])\n        re=r.recv().strip('\\n')\n        r.close()\n        if re=='odd':\n            low=(low+high)//2\n        else:\n            high=(low+high)//2\n        print len(bin(high-low))-2\n        sleep(0.5)\n    m=check(low,150)\n    if not m:\n        print 'try again!'\n        return\n    return long_to_bytes(m)\n\nif __name__=='__main__':\n    print(solve())\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-beginners-luck","url":"/crypto/xctf-Beginners-Luck.html","content":"\n## 题目信息\n\n题目无描述。\n\n## 分析\n\n通过对加密脚本的分析可知需通过PNG文件格式与最后的填充破解出密钥，[PNG文件格式详细介绍在此](https://www.cnblogs.com/senior-engineer/p/9548347.html)；大致来说，每个PNG文件的开头都是一串固定的字节来表明其PNG文件格式，你并不需要确切知道这些字节是什么，只需要找一张可正常打开的PNG文件即可！然而，仅通过PNG文件头无法破解密钥的全部24字节，于是还需要借助加密前的填充操作，填充是一串长度相同的字节，且字节的值等于这串字节的长度，通过结合这两点，即可破解出key全部24个字节。\n\n## 解题\n\n如下是解题的Python脚本(找一张可正常打开的PNG文件，命名为sample.png于同目录下)：\n```Python\ndef solve():\n    with open('BITSCTFfullhd.png','rb') as f:\n        d=f.read()\n    with open('sample.png','rb') as f:\n        dd=f.read(24)\n    pre_k=bytes([s^t for s,t in zip(d[:24],dd)])\n    me=bytes([s^t for s,t in zip(pre_k,d[-24:])])\n    L=max(me,key=me.count)\n    end_k=bytes([s^t for s,t in zip(L.to_bytes(1,'little')*L,d[-L:])])\n    key=pre_k[:-L]+end_k\n    ld=len(d)\n    assert not ld%24\n    m=bytes([s^t for s,t in zip(d,key*(ld//24))])\n    with open('FLAG.png','wb') as f:\n        f.write(m[:-L])\n    return\n\nif __name__=='__main__':\n    solve()\n    print('done!')\n```\n程序运行后会在目录下生成FLAG.png，打开即可见flag。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-Handicraft_RSA","url":"/crypto/xctf-Handraft-rsa.html","content":"\n## 题目信息\n\n有人正在他老房子的地下室里开发自己的RSA系统。 证明他这个RSA系统只在他的地下室有效！\n\n## 分析\n\n很明显素数的生成有问题，生成的素数p，其p-1有很多小因子，使用RsaCtfTool即可破解出私钥！\n\n## 解题\n\n```Bash\n$ python3 RsaCtfTool.py -n 21702007965967851183912845012669844623756908507890324243024055496763943595946688940552416734878197459043831494232875785620294668737665396025897150541283087580428261036967329585399916163401369611036124501098728512558174430431806459204349427025717455575024289926516646738721697827263582054632714414433009171634156535642801472435174298248730890036345522414464312932752899972440365978028349224554681969090140541620264972373596402565696085035645624229615500129915303416150964709569033763686335344334340374467597281565279826664494938820964323794098815428802817709142950181265208976166531957235913949338642042322944000000001 -e 65537 --private\n\n[*] Testing key /tmp/tmpeooqiijv.\n[*] Performing boneh_durfee attack on /tmp/tmpeooqiijv.\n[*] Performing comfact_cn attack on /tmp/tmpeooqiijv.\n[*] Performing cube_root attack on /tmp/tmpeooqiijv.\n[*] Performing ecm attack on /tmp/tmpeooqiijv.\n[*] ECM Method can run forever and may never succeed, timeout set to 30sec. Hit Ctrl-C to bail out.\n^C[*] Performing ecm2 attack on /tmp/tmpeooqiijv.\n[*] ECM2 Method can run forever and may never succeed, timeout set to 30sec. Hit Ctrl-C to bail out.\n^C[*] Performing factordb attack on /tmp/tmpeooqiijv.\n\nResults for /tmp/tmpeooqiijv:\n\nPrivate key :\n-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEAq+m7iHurBa9G8ujEiTpZ71aHOVNhQXpd6jCQNhwMN3hD6JHk\nv0HSxmJwfGe0EnXDtjRraWmS6OYzT4+LSrXsz9IkWGzRlJ4lC7WHS8D3NWIWYHCP\n4TRt2N0TlWXWm9nFCrEXqQ3IWgYQpQvKzsdsetnIZJL1tf1wQzGE6rbkbvURlUBb\nzBSuidkmi0kY5Qxp2Jfb6OUI647zx2dPxJpDffSCNffVIDUYOvrgYxIhs5HmCF3X\nECC3VfaKtRceL5JM8R0qz5nVU2Ns8hPvSVP+7/i7G447cjW151si0joB7RpBplu4\n4Vk8TXXDAk0JZdW6KwJn7ITaX04AAAAAAAAAAQIDAQABAoIBAQCEWcr2FXeiRcIS\nit+cYp8QowYyPR4YAfRBsyejcM56+g0WBRQdprh14R2GuXQp7h5BrXOwUQY4ZdnE\n+9caKptpl/hBV222xFXzAMtrp+DqaVye3Kn4kJutJO7JywCBNhP72kFD9odzv02b\nM0vtDB1ZK0ebHoUqmjaOlJYm+a0+OgzRG/VY6PfVs0GWdsSPtbIcautHI/+5V8US\nyG2wRH78JmTobVCLxEmdpjnUNKTM1Vsg/VCatzbkpohrE1cEZHhk+ke9uhyPvIvt\nafOC442Y09eI0vaC24IfgyAVuhOfuU3uik+JT6Vz1x9/53vorAD//wAA//8AAP//\nAAD//wABAoGBAMaX7gnjTwV6mm9o004b07Hk5Ab3PR4oEzniNgtrpP8/3Ed1wpHg\nM54idlm6rYlcLh+XWU4Z7/4v5HaNjbPaRye2tGVfGi+gY+HcrRLbEHUJlhPKUozd\nN6nayALynp7Lso19xaOz6kV86oUw+TFSi1PRnHcV01mJTgAAAAAAAAABAoGBAN2b\nbaKYDQzqBypnO+t/6JQPIvHzY8gC34qdUv7ShqvKgX70QRcFY4BY2C+ZTln0y1jv\ntX3tCwq59dzh1CRpgAfwk5nR2IjA+JLU35vAGB1IVqWmVC/VZ46zOSwy07xCJEy4\nHQ0d+PqANk8Wv2pMFmZZZfDWsYDWAAAAAAAAAAABAoGAK2b69BhEperko6KiQ7jb\nLE7c8xTHu7aAdS8WJqrQ9aQMTWXULzNztITNntCoqpOF1QurzeDnTYNECBDpvjvf\nPzOz+0+slmoUSkGDZdKQpzOAJDUck4KpbqrM+a/ysLvN+xRYxG1Grwcc7h0E6R2k\nK55s9q3DchcK//8AAP//AAECgYAUPbgb28uFXHLfGqLMddhmfaNxegupHyoP3SLR\nh6UpV8vQLrsrQSC/fl3wqw4PBV71dp+bKuWRSz77t9zKnqBFGWJB8HrYsteBgdQS\nw87wDcVsR+70l4dn71LPiKzySxBJuZ9drVkqeD99pdRB/0UkgBHhl5qK7AD//wAA\n//8AAQKBgQCYIKsSiGhJxY9AGaWofVsVe2sgGPHpwj3l2Yv8/PoG5Fpxozy+mzqv\nlDHIzJjsDIhtDeZr2cTkT6ODNM8bswDC62QnG+VUAzltXeN7P/aQzrbEUcGg7zgd\nZzvOJdNjXP9dU/vKGBT9cjjJhvwowfqnDlUVrl12W3AE/jn6U/Xpfg==\n-----END RSA PRIVATE KEY-----\n```\n破解出私钥之后，循环解密多次直到找出flag。如下Python脚本：\n```Python\nfrom base64 import b64decode\nfrom Crypto.Util.number import *\n\ndef solve():\n    N=21702007965967851183912845012669844623756908507890324243024055496763943595946688940552416734878197459043831494232875785620294668737665396025897150541283087580428261036967329585399916163401369611036124501098728512558174430431806459204349427025717455575024289926516646738721697827263582054632714414433009171634156535642801472435174298248730890036345522414464312932752899972440365978028349224554681969090140541620264972373596402565696085035645624229615500129915303416150964709569033763686335344334340374467597281565279826664494938820964323794098815428802817709142950181265208976166531957235913949338642042322944000000001\n    d=16707734744082089987096183760536140050531071284398222525928539910115274945961673413424053379896538639181783084998088831705326266248972451538621553176990679827738650084993005694971585059194288779236578752505246610328862945930341561242587398577636666631640913502943335996493633579116896296237142465786006038646664937384294577512911411958573147328359278328601128101352047028079357406162063405979398633542591758429760763171350524080583743130797539259640940004907846945847664144924968938380506532950172261068535550048712875992662239788993590417593968724043704420879416184807161738395187599580068732017638891008132810473473\n    C=b64decode(b'eER0JNIcZYx/t+7lnRvv8s8zyMw8dYspZlne0MQUatQNcnDL/wnHtkAoNdCalQkpcbnZeAz4qeMX5GBmsO+BXyAKDueMA4uy3fw2k/dqFSsZFiB7I9M0oEkqUja52IMpkGDJ2eXGj9WHe4mqkniIayS42o4p9b0Qlz754qqRgkuaKzPWkZPKynULAtFXF39zm6dPI/jUA2BEo5WBoPzsCzwRmdr6QmJXTsau5BAQC5qdIkmCNq7+NLY1fjOmSEF/W+mdQvcwYPbe2zezroCiLiPNZnoABfmPbWAcASVU6M0YxvnXsh2YjkyLFf4cJSgroM3Aw4fVz3PPSsAQyCFKBA==')\n    f=open('mes','wb')\n    for _ in range(80):\n        C=long_to_bytes(pow(bytes_to_long(C),d,N))\n        f.write(C+b'\\n\\n')\n    return\n\nif __name__=='__main__':\n    solve()\n```\n在mes中第64行：\n\n```Bash\nthe flag is: ASIS{n0t_5O_e4sy___RSA___in_ASIS!!!}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"Paillier同态加密之解密的正确性","url":"/crypto/Correctness-of-decryption-of-Paillier-homomorphic-encryption.html","content":"\n## Paillier同态加密系统\n\n### 符号说明\n\n* p,q为大素数，$p\\neq q$；\n* $n=p\\cdot q$；\n* $\\lambda =(p-1)\\cdot (q-1)$；\n* $B_{\\alpha}=\\{e\\in Z_{n^{2}}^{\\ast}|ord(e)=\\alpha\\cdot n\\}$；\n* $B=\\bigcup_{\\alpha=1}^{\\lambda}B_{\\alpha}$；\n* 函数$L(x,n)=[(x-1)/n]$；\n\n### 密钥生成\n\n* 随机选择指定长度的大素数p,q；(p,q)为私钥；\n* $n=p\\cdot q$；随机选择$g\\in B$；(g,n)为公钥；\n\n### 加密\n\n* 明文m<n，随机选择r<n；\n* 密文$c=g^{m}\\cdot r^{n}\\ \\textrm{mod}\\ n^{2}$；\n\n### 解密\n* 密文$c<n^{2}$；\n* 明文$m=L(c^{\\lambda}\\ \\textrm{mod}\\ n^{2}, n)\\cdot L(g^{\\lambda}\\ \\textrm{mod}\\ n^{2}, n)^{-1}\\ \\textrm{mod}\\ n$；\n\n## 解密的正确性\n\n对于$g=1+n$的情形，网上已有很多证明解密正确性的推导，而我在这里是希望给出更一般的情形下解密正确性的证明；推导参考提出Paillier同态加密系统的这篇论文：《Public-Key Cryptosystems Based on Composite Degree Residuosity Classes》。\n\n**定义1**：定义映射$\\varepsilon_{g}: Z_{n}\\times Z_{n}^{\\ast}\\mapsto Z_{n^{2}}^{\\ast}$，$\\varepsilon_{g}(x,y)=g^{x}\\cdot y^{n}\\ \\textrm{mod}\\ n^{2}$。\n\n**引理1**：若$g$的阶$ord(g)$是$n$的非零整数倍，则$\\varepsilon_{g}$是双射。\n\n证明：由于$Z_{n}\\times Z_{n}^{\\ast}$与$Z_{n^{2}}^{\\ast}$的元素个数均为$n\\phi(n)$(参考《近世代数》(第三版)杨子胥 第149页 定理1)，因此只需证明$\\varepsilon_{g}$是单射；\n\n假设$\\varepsilon_{g}(x_{1},y_{1})=\\varepsilon_{g}(x_{2},y_{2})$；\n\n则$g^{x_{1}-x_{2}}\\cdot (y_{1}\\cdot y_{2}^{-1})^{n}\\equiv 1\\ \\textrm{mod}\\ n^{2}$；\n\n因此$g^{\\lambda(x_{1}-x_{2})}\\cdot (y_{1}\\cdot y_{2}^{-1})^{\\lambda\\cdot n}\\equiv g^{\\lambda(x_{1}-x_{2})}\\equiv 1\\ \\textrm{mod}\\ n^{2}$；\n\n从而$ord(g)|\\lambda(x_{1}-x_{2})$；\n\n又$n|ord(g)\\Rightarrow n|\\lambda(x_{1}-x_{2}) , (n,\\lambda)=1\\Rightarrow n|(x_{1}-x_{2})$；\n\n因此在$x_{1},x_{2}\\in Z_{n}$的意义下，$x_{1}=x_{2}$；\n\n那么$(y_{1}\\cdot y_{2}^{-1})^{n}\\equiv 1\\ \\textrm{mod}\\ n^{2}$，则$y_{1}\\cdot y_{2}^{-1}\\equiv 1\\ \\textrm{mod}\\ n$，理由如下：\n\n假设$x^{n}\\equiv 1\\ \\textrm{mod}\\ n^{2}$，则：\n$$\n\\begin{cases}\nx^{(p-1)\\cdot q+q}\\equiv 1\\ \\textrm{mod}\\ p\\\n\\\\\n\\\\\nx^{(q-1)\\cdot p+p}\\equiv 1\\ \\textrm{mod}\\ q\\\n\\end{cases}\n$$\n即：\n$$\n\\begin{cases}\nx^{q}\\equiv 1\\ \\textrm{mod}\\ p\\\n\\\\\n\\\\\nx^{p}\\equiv 1\\ \\textrm{mod}\\ q\\\n\\end{cases}\n$$\n又$(p,q-1)=1$，$(q,p-1)=1$，从而存在$s,t\\in Z$，使得$p\\cdot s\\equiv 1\\ \\textrm{mod}\\ q-1 , q\\cdot t\\equiv 1\\ \\textrm{mod}\\ p-1$，同理可得：\n$$\n\\begin{cases}\nx\\equiv 1\\ \\textrm{mod}\\ p\\\n\\\\\n\\\\\nx\\equiv 1\\ \\textrm{mod}\\ q\\\n\\end{cases}\n$$\n由中国剩余定理，$x$在模$n$意义下有唯一解，又1满足上述同余方程组，因此$x\\equiv 1\\ \\textrm{mod}\\ n$\n回到本引理的证明，则有$y_{1}\\cdot y_{2}^{-1}\\equiv 1\\ \\textrm{mod}\\ n$，即$y_{1}\\equiv y_{2}\\ \\textrm{mod}\\ n$；\n综上，$\\varepsilon_{g}$是单射，也是双射。\n\n**解密的正确性**\n\n由引理1，存在$(a,b)\\in Z_{n}\\times Z_{n}^{\\ast}$使得$g=(1+n)^{a}\\cdot b^{n}\\ \\textrm{mod}\\ n^{2}$，则：\n\n$g^{\\lambda}\\equiv (1+n)^{a\\cdot\\lambda}\\cdot b^{n\\cdot\\lambda}\\equiv (1+n)^{a\\cdot\\lambda}\\equiv 1+na\\lambda\\ \\textrm{mod}\\ n^{2}$\n\n同理，$c^{\\lambda}\\equiv (g^{m}\\cdot r^{n})^{\\lambda}\\equiv [(1+n)^{a}\\cdot b^{n}]^{m\\lambda}\\cdot r^{n\\lambda}\\equiv (1+n)^{a\\cdot m\\lambda}\\cdot b^{n\\cdot m\\lambda}\\cdot r^{n\\lambda}\\equiv (1+n)^{a\\cdot m\\lambda}\\equiv 1+mna\\lambda\\ \\textrm{mod}\\ n^{2}$\n\n因此，$L(c^{\\lambda})\\cdot [L(g^{\\lambda})]^{-1}\\equiv ma\\lambda\\cdot (a\\lambda)^{-1}\\equiv m\\ \\textrm{mod}\\ n$。","tags":["密码学知识","Paillier"],"categories":["crypto"]},{"title":"使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)","url":"/config/personal-blog.html","content":"**前言** 系统环境为Ubuntu18.04\n\n## 准备工作\n\n### 安装nodejs\n\n从[node官网](https://nodejs.org/en/download/)下载二进制包(最后下载低一点的版本，这样之后配置主题时成功率更高)并命名为nodejs，再进行如下操作：\n```Bash\n$ sudo mv nodejs /opt/\n$ sudo cp /opt/nodejs/bin/node /usr/local/bin/ && chmod +x /usr/local/bin/node\n```\n在/opt/nodejs/bin目录下还有npm、npx两个sh脚本，试过符号链接到/usr/local/bin/目录下但是运行不了，那就只能在运行它们时使用绝对路径精确指定了:(，将npm换淘宝源以便更快下载：\n```Bash\n$ /opt/nodejs/bin/npm config set registry https://registry.npm.taobao.org\n```\n\n### 安装hexo\n使用npm安装hexo：\n```Bash\n# 这种下载方式不会出错，遇到错误的都懂\n$ sudo /opt/nodejs/bin/npm install --unsafe-perm --verbose -g hexo\n```\n\n## 本地博客部署\n新建一个文件夹用来存放博客数据：\n```Bash\n$ mkdir hexo\n```\n在新建的博客文件夹hexo的父目录初始化hexo：\n```Bash\n$ hexo init hexo\n```\n输出警告“Failed to install dependencies”，继续执行下面命令即可；\n```Bash\n$ cd hexo\n$ /opt/nodejs/bin/npm install\n```\n使用hexo编译静态页面：\n```Bash\n$ hexo generate\n$ hexo server\n```\n然后在浏览器中进入`http://localhost:4000`，就可以看到编译好的静态页面。\n\n## 本地配置博客\n\n下载一个自己觉得好看的主题，比如jsimple；\n```Bash\n$ git clone https://github.com/tangkunyin/hexo-theme-jsimple themes/jsimple\n```\n然后将hexo/_config.yml文件中的`theme: landscape`更改为`theme: jsimple`\n手动安装主题所需依赖`hexo-generator-search`：\n```Bash\n/opt/nodejs/bin/npm install hexo-generator-search --save\n```\n还没到打开网页的时候，还要进行一些文件的配置：\n* scaffolds/post.md，用如下内容替换：\n```Bash\ntitle: {{ title }}\ndate: {{ date }}\nauthor: 托码思\navatar: /images/avatar.png\nauthorLink: https://www.tangkunyin.com\nauthorAbout: https://about.tangkunyin.com\nauthorDesc: 一个写代码的「伪文人」\ncategory:\ntags:\ncomments: true\n```\n**注**author、authorLink、authorAbout、authorDesc可以换成自己想写的内容，avatar的/images/favicon.png可以换成自己想换的图片；\n\n* scaffolds/page.md，用如下内容替换：\n```Bash\ntitle: {{ title }}\nauthor: 托码思\navatar: /images/avatar.png\nauthorLink: https://www.tangkunyin.com\nauthorAbout: https://about.tangkunyin.com\nauthorDesc: 一个写代码的「伪文人」\nlayout: {{ title }}\n```\n\n* _config.yml对应内容(原来有的如果不一样改成与下面一样，没有的添加进去)配置得与如下内容一样：\n```Bash\n# 语言配置\nlanguage:\n    - zh-cn\n\n# URL （注意 permalink 格式。其中timestamp是改了源码加上的，具体参见patch目录文件）\nurl: https://shuoit.net\nroot: /\npermalink: :category/:entitle-:timestamp.html\npermalink_defaults:\n  lang: en\n\n# 搜索配置\nsearch:\n  path: search.json\n  field: all\n  content: true\n  \n# 分类和标签别名\ndefault_category: 技术\ncategory_map:\n   技术: tech\n   人文: humanity\ntag_map:\n  hexo: hexo\n  生活: life\n\n# 便于动态配置导航，最新版把左导航写成配置方式了。注意uri前边的\"-\"，这里是object类型，内层包了数组\nleftPagesMenu:\n- uri: pageName    // 这个是创建layout为page类型的页面名称，简而言之，就是独立页面名称\n  title: navName\t  // 故名意思，导航名称，这在大屏幕时体现\n  faName: fa-wifi  // FontAwesome样式名称，最新主题使用了4.7.0，请参考http://fontawesome.io/icons/\n```\n**注** 其中主题配置文件里的menu项需要和category_map键值对一致。二者顺序可以不同，但是主题中的顺序决定网站导航栏菜单的顺序。\n\n然后重新编译静态页面(由于本文接下来会多次进行下述操作，因此提到\"重新编译静态页面\"就是进行下面操作)：\n```Bash\n$ hexo clean && hexo generate\n$ hexo server\n```\n然后在浏览器进入`http://localhost:4000`，可以看到主题已经应用；在终端按Crtl-C退出继续配置；\n\n## 完善页面\n\n### tag|category\n当我们打开这些页面时都显示`Cannot GET /categories/XXX`，因为这些页面还没创建！因此需要创建这些页面：\n```Bash\n# 经过测试，page category及其子页面可以不用生成，如果一个分类下存在文章，那么该分类页面可以正常显示，否则会出现GET: categorise/XXX错误\n$ hexo new page categories\n$ hexo new page tech -p categories/tech\n$ hexo new page humanity -p category/humanity\n#下面这些页面一定要生成\n$ hexo new page tags\n$ hexo new page help\n$ hexo new page about\n$ hexo new page links\n```\n\n重新编辑静态页面，标签(tag)、分类(category)已经没有问题了！\n\n### 数学公式\n\n卸载原Markdown渲染器，安装`hexo-renderer-kramed --save`这款Markdown渲染器：\n```Bash\n$ /opt/nodejs/bin/npm uninstall hexo-renderer-marked --save\n$ /opt/nodejs/bin/npm install hexo-renderer-kramed --save\n```\n安装了新的Markdown渲染器并没有完全解决公式渲染的问题！接下来修改node_modules/kramed/lib/rules/inline.js的内容—第11行与第20行，分别改为：\n```Bash\n# 第11行，原为escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,改为如下：\nescape: /^\\\\([`*\\[\\]()#$+\\-.!_>])/,\n# 第20行，原为em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,改为如下：\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n将主题配置文件_config.yml中的mathjax的enable设置为true，对于需要公式渲染的博客，在开头添加`mathjax: true`，重新编辑静态页面，可以看到该博客内的公式可以被无误渲染！\n\n### 小插曲\n\n正当我兴致冲冲重新编辑静态页面，去看看配置好的另一篇带有数学公式的博客时，神奇的事情发生了，博客页面出现的竟然是hello world！！！整个人发出无数wc，平静下来后在这篇博客的地址栏发现了端倪，地址是这样的：\n```Bash\nhttp://localhost:4000/tech/undefined-undefined.html\n```\n刚看到这个我也不明白是哪里出了问题，不断的研读两篇配置文件，终于找到了一点突破，我们还记得在前面，根据主题作者修改配置文件时有一个`permalink: :category/:entitle-:timestamp.html`，首先是我感觉这有点像地址的构造方式(原谅我还没学过前端，一点小聪明还望大佬勿喷)，category我知道是什么，它就在文章开头设置的，那么基本上就清楚了，地址是根据category、entitle与timestamp三者组合而成的，而我在博客开头压根没有设置什么timestamp，所以地址生成失败，统一生成了undefined-undefined，其实地址这么复杂我也用不到，就自己改成如下：\n```Bash\npermalink: :category/:title.html\npermalink_defaults:\n```\n重新编辑静态页面，终于没问题了！\n\n### 地图(sitemap)\n\n为保证博客可被baidu、Google检索，需安装`hexo-generator-sitemap`插件：\n```Bash\n$ /opt/nodejs/bin/npm install hexo-generator-sitemap --save\n```\n\n### 嵌入图片\n\npost_asset_folder设置为true，对于需要引用图片的博客，首先在与博客的同目录下新建一个与博客名相同的文件夹，想要引用的图片放入该文件夹中，以`{% asset_img 1.png pic1 %}`命令就可以嵌入图片！虽然在Typora中不能显示，但是编辑到博客中可以正常显示。\n\n### 其他\n\n还有一些site_name，头像，cover_title，cover_description等等自己改一下就行了。\n\n## 部署到Gitee\n\n在本地将博客配置得足够满意之后，还要将博客部署到Gitee上面，这样其他人也可以在互联网访问；\n\n### 申请Gitee pages\n\n这个主题必须要求博客是`根目录部署`，就是创建的项目名称与个人空间地址一致，重要的事情说三遍！！！网上大部分教程说的项目名称与用户名一致是因为他们申请Gitee账号后没有更改用户名，从而个人空间地址与用户名一致，因此他们的做法可以正确部署到根目录，但是如果你更改过用户名导致个人空间地址与用户名一致的话，那么这时你创建的项目名称应该与个人空间地址一致，否则就是错误的`根目录部署`！\n\n个人空间地址在：设置-->个人资料-->个人空间地址进行查看。\n\n项目创建好之后，新建一个blog分支；然后开启Gitee Page服务，服务部署到blog分支上，勾选强制使用HTTPS；然后就可以生成Page了，这时我们可以看到什么叫根目录部署了，以我的Gitee Pages服务的地址为例：`https://KangMing-ux.github.io`；\n\n### 部署到Gitee Pages\n\n安装hexo-deployer-git组件：\n\n```Bash\n/opt/nodejs/bin/npm install hexo-deployer-git --save\n```\n\n我这里假定你电脑上面已经安装git，并且公钥已经添加到了Gitee；修改站点配置文件_config.yml的deploy：\n```Bash\ndeploy:\n  type: git\n  repo: ssh地址\n  branch: blog\n```\n\n使用命令`hexo d`就可以将本地的博客数据部署到Gitee上面，可以看到blog分支下已经有了博客数据，但是，但是你如果这个时候打开Gitee Pages服务的地址它还是404，或者和你本地的博客显示不一致，这时因为Gitee Pages还没有更新(Gitee Pages Pro可以自动更新，但是需要氪金)，你只能手动更新：\n\n{% asset_img 1.png pic1 %}\n\n点击上图的更新，等重新部署完成，再次打开Gitee Pages服务地址，可以看到博客的效果终于和本地的博客效果一致了！\n\n注意：\n* 比如我的search功能好像还有些问题，可以再`hexo d`一次然后再更新一次Gitee Pages，如果还不行可以稍等一会儿再看，毕竟没有氪金，更新起来不会很快，我等第二天早上再去博客时search功能就正常了；\n\n* 每次刷新浏览器时不要用Ctrl-R，一定要用Shift-F5强制刷新；\n\n**参考链接**\n\n[使用Gitee+Hexo搭建个人博客](https://xiuxiuing.github.io/blog/2018/08/08/githubpage/)\n\n[jsimple主题](https://github.com/tangkunyin/hexo-theme-jsimple)\n\n[hexo本地与部署不一致](https://blog.csdn.net/GAI159/article/details/105128186)\n\n[Hexo + Gitee采坑指北](https://www.luogu.com.cn/blog/jelly123/hexo-github-cai-keng-zhi-bei)\n\n[渲染公式](https://www.jianshu.com/p/7ab21c7f0674)\n\n[引用图片](https://segmentfault.com/q/1010000019625231)\n\n[sitemap](https://blog.csdn.net/formemorywithyou/article/details/96478453)\n\n","tags":["hexo","github","jsimple"],"categories":["config"]},{"title":"Ubuntu18.04安装ntl库","url":"/config/Ubuntu1804-installs-the-NTL-library.html","content":"## 安装\n\n首先去[官网](https://www.shoup.net/ntl)下载安装包，下列shell脚本与安装包放到同一目录，赋予此脚本执行权限。另外，我这里默认你的电脑上面已经安装gcc，g++，make。\n\n```Bash\n#apt install -y gcc\n#apt install -y g++\n#apt install -y make\napt install -y autoconf\n\napt install -y m4\napt install -y libgmp-dev\napt install -y libgf2x-dev\n\ntar zxvf ntl-11.4.3.tar.gz\n\nmv ntl-11.4.3 ntl\n \necho -e \"\\033[31m start install ntl \\033[0m\"\ncd ntl/src\n./configure NTL_GF2X_LIB=on\nmake && make check && make install\ncd - >> /dev/null\n \nrm -r ntl\n```\n## 测试\n\n新建一个rand.cpp（顾名思义，是输出随机数）\n\n```C++\n#include <NTL/ZZ.h>\n#include <time.h>\nNTL_CLIENT\nint main()\n{\n\tZZ a,b,c;\n\tSetSeed(to_ZZ(time(NULL)));\n\tRandomLen(a, 32);\n\tRandomLen(b, 32);\n\tc = a + b;\n\tcout << \"a=\" << a << \", b=\" << b << \", c=\" << c << \"\\n\";\n\treturn 0;\n}\n```\n按照官网的介绍，使用如下命令编译：\n```Bash\ng++ -g -O2 -std=c++11 -pthread -march=native rand.cpp -o rand -lntl -lgmp -lm\n```\n其中rand.cpp是c++文件，rand是编译后的可执行文件。程序运行效果如下：\n```Bash\n$ ./rand\na=2298665095, b=3622090486, c=5920755581\n```\n\n**参考链接**：\n[NTL库快速上手中文指南](https://blog.csdn.net/tzwh_86/article/details/9372411#commentBox)\n[A Tour of NTL](https://libntl.org/doc/tour.html)","tags":["Ubuntu","ntl"],"categories":["config"]},{"title":"git基础使用&github","url":"/program/The-basic-Git-use-with-Gitee.html","content":"## 在网站上初始化\n\n在[码云](https://github.com/)上创建项目基本是傻瓜式操作。创建一个名为git-test的私有项目以备后续使用。\n\n本文介绍在本地创建仓库、将仓库上传至服务器以及本地与服务器的交互。\n\n## 在本地创建仓库及相关操作\n\n```Bash\n# 初始化一个Git仓库，则执行命令的目录会作为一个仓库\nmkdir /home/github/git-test && cd /home/github/git-test\ngit init\n# 那么git-test文件夹将会作为一个仓库\n# 新建一个文件然后将文件添加到Git的暂存区\necho 'Life is beautiful' > README.md && git add \"README.md\"\n# 查看仓库当前文件提交状态(A：提交成功；AM：文件在添加到缓存之后又有改动)\ngit status -s\n# 从Git的暂存区提交版本到仓库，参数-m后为当次提交的备注信息\ngit commit -m \"1.0.0\"\n```\n\n## 本地与服务器的交互\n\n在本地与服务器交互之前，先配置ssh公钥；保证已经安装了ssh(apt install -y ssh)，使用ssh-keygen生成ssh公钥：\n```Bash\ngit config --global user.email 'github注册邮箱'\ngit config --global user.name 'github用户名'\nssh-keygen -t rsa\n```\n在~/.ssh目录下有一个id_rsa.pub文件，里面的文本以ssh-rsa开头，将这些文本全部复制，转到设置->安全设置->ssh公钥，随便写个标题，将id_rsa.pub中的文本全部复制到公钥下面的框内。\n\n关于项目的ssh地址如何获得，见下图：\n\n{% asset_img 1.png pic1 %}\n\n下面介绍一些本地与服务器的常用交互\n```Bash\n# 在不执行克隆操作时将一个远程仓库添加到本地的仓库\ngit remote add origin ssh地址\n# 如果不需要远程的更新，比如此时远程只是一般性的初始化内容，可使用-f选项进行强制推送(远程仓库默认名为origin)\ngit push origin master -f\n# 克隆服务器中的项目(即在1中新建的名为git-test的项目)到本地\ngit clone ssh地址\n## 文件修改(本地)\n# 修改文件README.md，在文件后面追加一行'local change'\n# 此时查看状态\ngit status -s\n#先将文件添加到Git的暂存区，然后提交\ngit add 'README.md' && git commit -m '1.0.1'\n# 用本地仓库内容更新远程仓库内容\ngit push ssh地址\n# 刷新网站，可以看到服务器上面的内容已经与本地一致\n\n## 文件添加(本地)\n# 创建一个输出hello,world的C文件并将其编译\necho -e '#include <stdio.h>\\n\\nint main()\\n{\\n\\tprintf(\"hello,world\\\\n\");\\n\\treturn 0;\\n}' > hello.c && gcc hello.c -o hello -g\n# 先将新增的文件添加到Git的暂存区\ngit add he*\n# 这里可以查看一下状态\ngit status -s\n# 从Git的暂存区提交版本到仓库\ngit commit -m '1.0.2'\n# 将更改同步到远程服务器\ngit push ssh地址\n# 可以看到网站上已经有新增的文件\n\n## 文件移动(本地)\n# 为增强项目文件的组织性，我将上述的两个新增文件移到一个文件夹中\nmkdir Hello && git mv he* Hello\n# 这里可以查看一下状态\ngit status -s\n# 将更改提交版本到仓库\ngit commit -m '1.0.3'\n# 将更改同步到远程服务器\ngit push ssh地址\n# 可以看到网站上原来新增的两个文件已经在新建的文件夹下\n\n## 文件删除(本地)\n# 如我要将hello这个可执行文件删除\ngit rm Hello/hello\n# 这里可以查看一下状态\ngit status -s\n# 将更改提交版本到仓库\ngit commit -m '1.0.4'\n# 将更改同步到远程服务器\ngit push ssh地址\n\n# 如果是在网站上对项目做出更改(文件修改、添加、移动与删除)，要将更改同步回本地(即拉取)，使用pull命令\ngit pull origin master\n```\n以上基本上包含了使用git常见问题的解决方案。","tags":["Git"],"categories":["program"]},{"title":"鲲鹏计算专场密码学部分详解","url":"/crypto/HUAWEICTF2021.html","content":"## 平平无奇的RSA\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://github.com/KangMing-ux/CTFs-Crypto/tree/master/2020/HUAWEI/task_task_gHXvFLV)\n\n### 分析\n\n题目由三个小问题组合而成，下面分别对他们进行分析。\n\n**Level 3**\n\n从脚本可得的信息如下：\n\n$N_{3}=p\\cdot q$，$\\phi$是$N_{3}$的欧拉函数；\n\n$s\\cdot sinv\\equiv 1\\ \\textrm{mod}\\ q$，再令$e=4s\\cdot sinv+3$(且要保证$(e,\\phi)=1$)；\n\n给你一组已知明-密文$km,kc$，即$kc\\equiv km^{e}\\ \\textrm{mod}\\ N_{3}$；\n\n那么分解$N_{3}$的步骤如下：\n\n$kc\\equiv km^{e}\\ \\textrm{mod}\\ N_{3}\\Rightarrow kc\\equiv km^{e}\\ \\textrm{mod}\\ p\\Rightarrow kc\\equiv km^{4s\\cdot sinv+3}\\ \\textrm{mod}\\ p$\n\n由欧拉定理可得：$km^{s\\cdot sinv}\\equiv km\\ \\textrm{mod}\\ p$，从而$kc\\equiv km^{4+3}\\ \\textrm{mod}\\ p$，即$kc\\equiv km^{7}\\ \\textrm{mod}\\ p$\n\n则$p|(km^{7}-kc)\\Rightarrow p=(km^{7}-kc,N_{3})$，因此$N_{3}$的一个因子是其与$km^{7}-kc$的公约数，进而分解出$N_{3}$；\n\n分解出$N_{3}$后，解密$c_{3}$得到Level 2的密文，下面分析Level 2。\n\n**Level 2**\n\n从脚本可得的信息如下：\n\n$o,s$是两个随机生成的素数，$t$是$o$的下一个素数，$u$是$s$的下一个素数；\n\n已知$os=o\\cdot s,tu=t\\cdot u$，$N_{2}=o\\cdot s\\cdot t\\cdot u\\Rightarrow tu=N_{2}//os$，这道题在18年强网杯的nextrsa的第四关考察过，[此处](https://www.cnblogs.com/WangAoBo/p/8654120.html)是对其的writeup\n\n**Level 1**\n\n这一层很简单，从$(N_{1}//1323)^{1/4}$往下开始试除即可(第一次写的时候疏忽了，往上试除，程序跑了几分钟都没解出来)。\n\n### 解题\n\n上述链接中的solve.py为解题脚本，程序运行结果如下：\n\n```Bash\n$ python3 solve.py\nflag{4c2fd4e6-44de-445f-8c34-1235464de2de}\n```","tags":["CTF比赛","RSA"],"categories":["crypto"]},{"title":"drangon2020密码学部分详解","url":"/crypto/Drangon-2020-Cryptography-Section.html","content":"## Bit_Flip1\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://github.com/KangMing-ux/CTFs-Crypto/tree/master/2020/Drangon/bit_flip_1)\n\n### 分析\n\n**1.过一遍程序**\n\n* 生成16个随机的字节作为alice_seed，与接收到的flip_str异或取后32个字节(不够在前面加\\x00)即为seed；\n\n* 由于alice = DiffieHellman(flip_str(alice_seed))没有设置prime，因此alice初始化时会调用get_prime()来生成素数；\n\n* 重点来看get_prime()这个函数；它不停的调用getbits(512)直到生成的数是一个素数；\n\n* 来看getbits()的原理：先调用more_bytes()积累足够的“随机”字节，每次调用more_bytes()都会在generated后面加上seed的sha256哈希值(长256比特)；\n\n* seed的更新方式为seed=long_to_bytes(bytes_to_long(seed)+1,32)，在这里简单看作seed的值增1即可；\n\n* generated收集到足够的字节之后，取后num比特作为生成的随机数，未用到的“随机”字节仍然保存在generated中；\n\n* 判断getbits(512)生成的是否为素数，若不是继续调用getbits(512)；\n\n* 得到素数之后，会告知你iter——相对于一次生成就能得到素数，对getbits(512)增加的调用次数(易知每调用一次getbits(512)，seed自增2)；\n\n* 返回prime后；调用getbits()生成64位的mysecret(DH算法的私钥)，然后计算$mynumber\\equiv 5^{mysecret}\\ \\textrm{mod}\\ prime$(DH算法的公钥)，设置shared为1337后，alice的初始化工作完成。\n\nbob=DiffieHellman(urandom(16), alice.prime)按照同样的方式完成初始化工作，只不过此时bob的prime直接使用alice的prime；\n\nalice与bob经密钥协商得到双方都知道的协商密钥(与DH算法略有不同，多了一个与1337的异或操作)，该密钥作为AES的加密密钥对FLAG进行加密。\n\n**2.寻找突破**\n\n我相信程序输出的数据都是有它的作用的，print(\"bob number\", bob.my_number)给出bob的公钥是为了让我们得到prime与secret之后可以同样计算出协商密钥；输出iv与enc_flag作用也很明显；那么程序输出iter就值得注意了，一定是对我们解题有用！\n\n**3.利用iter**\n\n那么我们如何借助iter来获取足够多的信息以致于解出FLAG；iter间接体现了get_prime()调用getbits()的次数！\n\n由于程序会接收我发送的flip_str，因此我们可以改变seed的值，即使我们不知道seed的值，但是这仍然有用！\n\n既然我们不知道seed的值(是因为我们不知道alice_seed的值)，那我们记alice_seed的值为$s_{127}\\cdots s_{1}s_{0}$，我们的考虑这样的情况：\n\n我发送如下两个flip_str：\n\nflip_str_1：空字节\n\nflip_str_2：|$1$|$0$|\n\n那么经bit_flip()就能生成如下2种seed：\n\nseed_1：|$s_{127}$|$\\cdots$|$s_{1}$|$s_{0}$|\n\nseed_2：|$s_{127}$|$\\cdots$|$1\\oplus s_{1}$|$s_{0}$|\n\n由这2个seed生成素数的iter分别记为iter_1与iter_2；\n\n分类讨论：\n\n* $s_{1}=0$，seed_1+2=seed_2，如果iter_1非0，必有iter_1-iter_2=1；\n\n* $s_{1}=1$，seed_2+2=seed_1，如果iter_2非0，必有iter_2-iter_1=1；\n\n那么当$iter\\_1\\cdot iter\\_2\\neq 0$时，由于$s_{j}$非0即1，因此此时iter_1-iter_2=1与iter_2-iter_1=1至少(没写错，确实是至少)有一个成立！此时$s_{j}=0\\Rightarrow$iter_1-iter_2=1，因此(原命题的真假性与逆否命题的真假性一致)$iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$，即iter_1-iter_2=-1$\\Rightarrow s_{j}=1$。\n\n那如果$iter\\_1\\cdot iter\\_2=0$怎么办？这时根据iter_1-iter_2的值是无法判断$s_{1}$的值的！由于我们只需要保持|seed_1-seed_2|=2即可，因此我们可以改变flip_str前面的字节，这样得到的seed_x(x=1,2)的哈希值与原来显著不同，从而$iter\\_1\\cdot iter\\_2$的值有可能发生改变，不停的改变flip_str前面的字节直到$iter\\_1\\cdot iter\\_2\\neq 0$，就可以由上述分析过程解出$s_{1}$！\n\n一般地，类似于数学归纳法；假设我已经分析出$s_{j-1}\\cdots s_{1}$(这里没写错，$s_{0}$我是没有分析出来的)，借助已经得到的信息分析出$s_{j}$，思路如下：\n\n* 发送如下4种flip_str：\n\nflip_str_1：| $0$  | $1\\oplus s_{j-1}$ | $\\cdots$ | $1\\oplus s_{1}$ | $0$  |\n\nflip_str_2：| $1$  | $s_{j-1}$ | $\\cdots$ | $s_{1}$ | $0$  |\n\nflip_str_3：| $1$  | $1\\oplus s_{j-1}$ | $\\cdots$ | $1\\oplus s_{1}$ | $0$  |\n\nflip_str_4：| $0$  | $s_{j-1}$ | $\\cdots$ | $s_{1}$ | $0$  |\n\n那么经bit_flip()就能生成如下4种seed：\n\nseed_1：| $s_{127}$ | $\\cdots$ | $s_{j}$ | $1$  | $\\cdots$ | $1$  | $s_{0}$ |\n\nseed_2：| $s_{127}$ | $\\cdots$ | $1\\oplus s_{j}$ | $0$  | $\\cdots$ | $0$  | $s_{0}$ |\n\nseed_3：| $s_{127}$ | $\\cdots$ | $1\\oplus s_{j}$ | $1$  | $\\cdots$ | $1$  | $s_{0}$ |\n\nseed_4：| $s_{127}$ | $\\cdots$ | $s_{j}$ | $0$  | $\\cdots$ | $0$  | $s_{0}$ |\n\n由这4个seed生成素数的iter分别记为iter_1、iter_2、iter_3与iter_4；\n\n分类讨论：\n\n* $s_{j}=0$，seed_1+2=seed_2，如果iter_1非0，必有iter_1-iter_2=1；\n\n* $s_{j}=1$，seed_3+2=seed_4，如果iter_3非0，必有iter_3-iter_4=1；\n\n那么当$iter\\_1\\cdot iter\\_3\\neq 0$，由于此时$s_{j}$非0即1，因此iter_1-iter_2=1与iter_3-iter_4=1必有一个成立！同样地，$iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$；因此，当$iter\\_1\\cdot iter\\_3\\cdot ((iter\\_1-iter\\_2)\\cdot (iter\\_3-iter\\_4)-1)\\neq 0$时，$iter\\_3-iter\\_4=1\\Rightarrow iter\\_1-iter\\_2\\neq 1\\Rightarrow s_{j}\\neq 0\\Rightarrow s_{j}=1$。\n\n如果$iter\\_1\\cdot iter\\_3\\cdot ((iter\\_1-iter\\_2)\\cdot (iter\\_3-iter\\_4)-1)=0$，同样地，改变flip_str前面的字节直到进入上述情形!\n\n综上，我给出了对$s_{1}$的分析思路，也给出了由$s_{j-1}\\cdots s_{1}$推出$s_{j}$的分析思路；最终我可以还原出alice_seed除$s_{0}$之外的所有比特位，而$s_{0}$非0即1，因此最后解出的结果与alice_seed的值相差不超过1！\n\n接下来按照同样的方式生成AES密钥，对密文进行解密即可！\n\n### 解题\n\n这道题我并没有在比赛的时候做出来，因此我对task.py的交互方式作了一些改变；flag是自己设置的；上述链接中的solve.py为解题脚本，程序运行结果如下：\n\n```Bash\nλ python3 solve.py\nb'1\\xbc\\xfa\\x1b+5\\xed1\\x99\\xf7\\xa0\\x07\\x8e\\tQ\\xee'\nDrangon{just_for_test_flag}\n```\n\n## Bit_Flip2\n\n### 题目信息\n\n附件仍然是一个Python脚本，相对于Bit_Flip1只有1行代码不同，它将print(\"bob number\", bob.my_number)这一行注释起来；[Gitee备份在此](https://github.com/KangMing-ux/CTFs-Crypto/tree/master/2020/Drangon/bit_flip_2)\n\n### 分析\n\n同Bit_Flip1的方法可解出alice_seed，可此时我并不知道bob.my_number；虽然当时想过控制alice.my_secret为0，但是觉得太不切实际，而事实上writeup就是这么做的！这需要你对比特币有一定的了解，知道使用块散列算法(可[参见此处](https://KangMing-ux.github.io/crypto/Bitcoin-Block-hashing-algorithm.html))可以生成以一定长度的0字节结尾的哈希值。按同样的方法推测出alice_seed后发送特定的flip_str使得alice以特定的seed初始化，使得alice.my_secret为0，那么bob.my_number就对我们解密出flag无关紧要了。\n\n### 解题\n\n上述链接中的solve.py为解题脚本，同样因为题目没有在比赛的时候做出了，flag是我自己设置的；程序运行结果如下：\n\n```Bash\n$ python solve.py\nb'Drangon{just_for_test_flag}\\x00\\x00\\x00\\x00\\x00'\n```","tags":["bitcoin","CTF比赛"],"categories":["crypto"]},{"title":"Bitcoin—块散列算法","url":"/crypto/Bitcoin-Block-hashing-algorithm.html","content":"## BTC Block\n\n[BTC Block](https://live.blockcypher.com/btc/)\n\n{% asset_img 1.png pic1 %}\n\n点击进入Height为658423的哈希值(000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c)\n\n{% asset_img 2.png pic2 %}\n\n## Block hash算法\n\n[Block hash算法](https://en.bitcoin.it/wiki/Block_hashing_algorithm)\n\n它有多强大呢？举个例子：\n\n```Python\n>>> from hashlib import sha256\n>>> d=bytes.fromhex('01000000'+'81cd02ab7e569e8bcd9317e2fe99f2de44d49ab2b8851ba4a308000000000000'+'e320b6c2fffc8d750423db8b1eb942ae710e951ed797f7affc8892b0f1fc122b'+'c7f5d74d'+'f2b9441a'+'42a14695')\n>>> h=sha256(d).digest()\n>>> sha256(h).hexdigest()\n'1dbd981fe6985776b644b173a4d0385ddc1aa2a829688d1e0000000000000000'\n```\n\n通过它构造的消息，其哈希值后面有很长的一段0！想知道上面的消息怎么构造，请往下看：\n\n### 准备工作\n\n* 安装pyCryptodome库\n\n```Bash\npip3 install pyCryptodome -i https://pypi.douban.com/simple\n```\n\n* 安装curl工具\n\n如果你用的Linux系统，curl工具可通过命令行安装；\n\n对于我使用的Windows系统，去[官网](https://curl.se/windows/)下载工具包，解压到C:\\Windows\\System32目录下或者将bin目录下的curl.exe的路径加入环境变量；\n\n### 获取构造特定哈希值的信息\n\n对我们想要的哈希值000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c，在命令行运行：\n```Bash\n# curl https://blockchain.info/rawblock/000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c > data\n```\n因为返回的消息太多了，因此输出重定向到文件中存下来；我们主要关注的有：ver、prev_block、mrkl_root、time、bits与nonce；这些值提取出来如下：\n```Python\ndata={'ver':541065216,\n'prev_block':'00000000000000000009f1410ac69d92199991a699b268d56d99daf6067c8711',\n'mrkl_root':'9ad7e80cf4a94f57c36876ab999f3cf23de188d482b8a3af8fb5e08ec1e18a6e',\n'time':1606199690,\n'bits':386924253,\n'nonce':232397866}\n```\n注意：ver、time、bits与nonce找最前面的，prev_block与mrkl_root找最后面的，不然算出来的哈希值会不是我们想要的。\n\n接下来，使用我写好的脚本如下，通过将这些信息组合起来就可以构造出消息，其哈希值就是000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c！\n\n```Python\nfrom hashlib import sha256\nfrom binascii import hexlify,unhexlify\nfrom Crypto.Util.number import long_to_bytes\n\n#curl https://blockchain.info/rawblock/000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c\ndata={'ver':541065216,\n'prev_block':'00000000000000000009f1410ac69d92199991a699b268d56d99daf6067c8711',\n'mrkl_root':'9ad7e80cf4a94f57c36876ab999f3cf23de188d482b8a3af8fb5e08ec1e18a6e',\n'time':1606199690,\n'bits':386924253,\n'nonce':232397866}\n\ndef num_to_Bytes(n):\n    byte_n=long_to_bytes(n,4)\n    return byte_n[::-1]\n\ndef hex_to_Bytes(h):\n    s=unhexlify(h)\n    return s[::-1]\n    \ndef Bitcoin_demo():\n    d=num_to_Bytes(data['ver'])+hex_to_Bytes(data['prev_block'])+hex_to_Bytes(data['mrkl_root'])+num_to_Bytes(data['time'])+num_to_Bytes(data['bits'])+num_to_Bytes(data['nonce']%pow(2,32))\n    h=sha256(d).digest()\n    return sha256(h).digest()\n\nif __name__=='__main__':\n    ret=Bitcoin_demo()\n    print(hexlify(ret[::-1]))\n```\n\n程序运行结果如下：\n\n```Bash\n# python3 Bitcoin.py\nb'000000000000000000014788256270fc5db06737c3cfa3b04d258dbdfaacb45c'\n```","tags":["密码学知识","bitcoin"],"categories":["crypto"]},{"title":"win10正版安装+配置记录","url":"/config/Win10-legal-installation-configuration-records.html","content":"## 前言\n\n自己以前作为一个电脑小白，重装系统时直接在百度上面搜索，搜到的全是各种下载站，从这些网站上面下载的系统其实已经改过了，安装完之后会给你预装很多软件，你又要花时间把他们删掉，可以说很不方便；去微软官网上面找，如果不知道怎么找，可能很不容易找到，于是写下这篇博客备忘，也方便他人。\n\n## 下载镜像并制作启动盘\n\n安装前，准备好8GB以上的U盘(必须真的是8G以上，U盘质量一定要过关；另外，U盘里面的数据要备份好，制作启动盘会让原来的数据不复存在)\n\n**1.**先去[微软官方镜像下载地址](https://www.microsoft.com/zh-cn/software-download/windows10/)，下载MediaCreationTool；\n\n**2.**以管理员方式，运行MediaCreationTool；首先给出声明与许可条款，选择接受；此时会给你两种操作，升级本机或者创建安装介质，我习惯创建安装介质；\n\n**3.**选择语言、体系结构与版本，直接默认就好；\n\n**4.**选择要使用的介质，我这里选择U盘；插上事先准备好的U盘，如下图点击下一步：\n\n**5.**等待工具下载win10\n\n**6.**创建安装介质\n\n创建完成后，点击完成，工具做一些清理工作就会退出。\n\n打开文件资源管理器，可以看到启动盘已经制作完毕：\n\n## 安装\n\n1.如果安装时鼠标用不了，可以使用tab键进行切换；\n\n2.安装过程中最好联网；\n\n3.删除不常用文件夹\ncmd-->regedit\n3D对象：HKEY_LOCAL_MACHINE->SOFTWARE->Microsoft->Windows->CurrentVersion->Explorer->MyComputer\n->NameSpace->{0DB7E03F-FC29-4DC6-9020-FF41B59E513A}\n音乐：{3dfdf296-dbec-4fb4-81d1-6a3438bcf4de}\n\n4.“开始”关掉设置、图片。\n\n\n## 安装常用软件\n\n[360zip国际版](https://www.360totalsecurity.com/zh-cn/360zip/)\n\n[百度网盘](http://pan.baidu.com/download)\n\n[Clover](http://en.ejie.me/)\n\n```Bash\n注：我们知道win10下面的文件资源管理器打开多个位置时是多个窗口，这个插件就可以以多标签页来管理，特别好用。\n但是你要忍受经常的广告的骚扰\n```\n\n[Chrome浏览器](https://www.google.cn/intl/zh-CN/chrome/)\n\n[TIM](https://office.qq.com/download.html)\n\n```Bash\n注：窗口设置和微信差不多，感觉比QQ好用。\n```\n\n[迅雷&迅雷影音](https://www.xunlei.com/)\n\n[腾讯会议](https://meeting.tencent.com/download-center.html?from=1001)\n\n[cmder](https://cmder.net/)\n\n```Bash\n控制台模拟器，让你有一种用上Linux终端的感觉。\n更改快捷键Ctrl-T(新建标签页)为Crtl-Shift-T，避免与ctags的快捷键冲突。\n```\n\n[WPS](https://pc.wps.cn/)\n\n```Bash\n记得在“我的电脑”隐藏网盘。\n```\n\n[Python3.6.4](https://www.python.org/downloads/windows/)\n\n```Bash\n注：安装的时候注意勾选添加到环境变量；将python改成python3以与python2程序区分；\nwin10菜单搜索[管理应用执行别名]，关闭下面两个按钮[应用安装程序])；\n安装ctf密码学常用python库。\n```\n\n[VirtualBox](https://www.virtualbox.org/wiki/Downloads)\n\n[Vim](https://github.com/vim/vim-win32-installer/releases)\n\n```Bash\n添加环境变量：右键此电脑->属性->高级系统设置->环境变量，选中Path，并点击编辑，新建->填写vim程序的路径，点击3个确定才算成功添加；\n在安装vim的文件夹下有一个_vimrc文件，备份好之后写上自己的配置)；\n安装ctags插件：http://ctags.sourceforge.net；像ctags58.zip这种名称是支持win10的，下载下来之后只需要将ctags.exe复制到vim的安装目录下即可！\n```\n\n[yafu](https://sourceforge.net/projects/yafu/files/)\n\n```Bash\n强大的因子分解工具。\n```\n\n[Sagemath](https://github.com/sagemath/sage-windows/releases)\n\n[Curl](https://curl.se/windows/)，利用URL规则在命令行下工作的文件传输工具。\n\n[Telegram](https://desktop.telegram.org/)\n\n另外在win10应用商店里有几个不错的应用：微信、网易云音乐，淘宝。\n\nIDA Pro、SSR就看自己了。\n\n注：安装IDA Pro之后会顺带安装python2.7，同样将其安装的路径加入环境变量。","tags":["windows"],"categories":["config"]},{"title":"ByteCTF2020密码学部分详解","url":"/crypto/BytectF2020-cryptography-section-details.html","content":"## noise\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://github.com/KangMing-ux/CTFs-Crypto/tree/master/2020/ByteCTF/noise)\n\n### 分析\n\n穷举通过proof_of_work之后，我们来看代码逻辑：\n\n*   secret=getrandbits(1024)，注意他自己实现的getrandbits(1024)实际上是生成长1017~1024位的随机数；\n*   对上述生成的secret，服务器最多只会与你交互64次；\n*   若op为'god'，服务器会返回num * getrandbits(992) % secret，这里num也由我指定；\n*   若op为'bless'，服务器会判断num与secret是否相等，若相等服务器返回FLAG。\n\n由于我至少要留一次交互机会发送我计算出的secret，因此我必须在63次交互内计算出secret！为下面叙述方便，声明如下记号：\n\n*   第 i 次发送的num记为$n_{i}$；\n*   第 i 次getrandbits(992)记为$g_{i}$；\n*   第 i 次接收的num * getrandbits(992) % secret记为$c_{i}$。\n\n记secret为$m$，则：\n\n$c_{i} \\equiv n_{i}\\cdot g_{i}\\ \\textrm{mod}\\ m,i=1,\\cdots ,63$\n\n即存在$k_{i}\\in Z$，$n_{i}\\cdot g_{i}=c_{i}+k_{i}\\cdot m$\n\n对等式两边模$n_{i}$则有：\n\n$c_{i}+k_{i}\\cdot m \\equiv 0\\ \\textrm{mod}\\ n_{i}$\n\n若我能够控制$k_{i}=1$，那么：\n\n$m \\equiv (n_{i}-c_{i})\\ \\textrm{mod}\\ n_{i}$\n\n同时得到多个如上形式的等式可考虑使用中国剩余定理解出$m$！\n\n### 利用$n_{i}$控制$k_{i}$\n\n$m$有$1/2$的概率长1024比特，$g_{i}$有$1/2$的概率长992比特；此时，要控制$k_{i}=1$，即：\n$$\n\\left\\{\n\\begin{aligned}\nn_{i}\\cdot g_{i} &>m \\\\\nn_{i}\\cdot g_{i} &<2m\n\\end{aligned}\n\\right.\n$$\n对上式两边取对数：\n$$\n\\left\\{\n\\begin{aligned}\nlog(n_{i})+log(g_{i}) &>log(m) \\\\\nlog(n_{i})+log(g_{i}) &<log(m)+1\n\\end{aligned}\n\\right.\n$$\n记$log(g_{i})=991+\\alpha,log(n_{i})=32+\\beta,log(m)=1023+\\gamma;\\alpha,\\beta,\\gamma \\in (0,1)$(其中$X=2^{\\alpha},Y=2^{\\gamma}$服从$[1,2]$上的均匀分布)。上式改写为：\n$$\n\\left\\{\n\\begin{aligned}\n\\alpha+\\beta &>\\gamma \\\\\n\\alpha+\\beta &<1+\\gamma\n\\end{aligned}\n\\right.\n$$\n综上，$P(k_{i}=1)=P(\\alpha+\\beta>\\gamma,\\alpha+\\beta<1+\\gamma)=P(2^{\\beta}\\cdot X>Y,2^{\\beta-1}\\cdot X<Y)$\n\n直观地看，$\\beta$越大越有利于约束条件$\\alpha+\\beta>\\gamma$而不利于约束条件$\\alpha+\\beta<1+\\gamma$，反之，$\\beta$越小越有利于约束条件$\\alpha+\\beta<1+\\gamma$而不利于约束条件$\\alpha+\\beta>\\gamma$。\n\n注意到我可以判断是否满足约束条件$\\alpha+\\beta>\\gamma$—若$n_{i}\\cdot g_{i}<m$则$c_{i}=n_{i}\\cdot g_{i}$从而$c_{i}\\equiv 0\\  \\textrm{mod}\\ n_{i}$。\n\n由此，我选择$n_{i}$时应该尽量满足约束条件$\\alpha+\\beta<1+\\gamma$，即$\\beta$应尽量小，为何不设置$\\beta$为0，理由如下：\n\n当$\\beta=0$时，$P(k_{i}=1)=P(\\alpha>\\gamma,\\alpha<1+\\gamma)=P(\\alpha>\\gamma)=1/2$；\n\n由上述：$n_{i}$长$33$比特，而$m$长$1024$比特；由中国剩余定理可知：我们需要32个如下形式的同余式才能解出$m$！\n\n$m \\equiv (n_{i}-c_{i})\\ \\textrm{mod}\\ n_{i}$\n\n要得到如上形式的同余式，即需要$k_{i}=1$，而$P(k_{i}=1)=1/2$，那么我得到$32$个如上形式的同余式“平均”需要$64$次交互，从而我没有发送secret的交互机会。\n\n综上，$\\beta$应在大于0的前提下尽量小！\n\n### 值得注意的地方\n\n通过2.1，我知道了$n_{i}$值多大时可以解出$m$，结合中国剩余定理，同余式的模数之间是互素的，即我选择的$n_{i}$需两两互素，因此$n_{i}$不是取确定的值而是在一定的取值范围内取素数！\n\n### 解题\n\n上述链接中的solve.py为解题的Python脚本，程序运行(成功时)结果如下：\n\n```bash\n$ python3 solve.py\n[+] Opening connection to 182.92.153.117 on port 30101: Done\n[+] MBruteforcing: Found key: \"l9a\"\nsuccess!\n95613903744255213782277288259288084531700829576284706991256294359734535087821985034716432798049279163174069238632678362676474782669781482301447573436852554131343117198284150657465643396718720128642929008328391123641254705186541184339088382138616985634723733544083949806487213357784626124965521562172300016682\nb'CONGRATULATIONS ByteCTF{Noise_i5_rea11y_ANN0YING}\\n'\n[*] Closed connection to 182.92.153.117 port 30101\n```\n\n注：此程序并非次次运行都能解出secret\n\n## threshold\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份在此](https://github.com/KangMing-ux/CTFs-Crypto/tree/master/2020/ByteCTF/threshold)\n\n### 分析\n\n程序又臭又长，但其实考点特别简单，稍微使用一下欧拉定理即可！我来分析一下程序的逻辑：\n\n在类TSM2初始化时：\n\n$pks \\equiv [(sk+1)\\cdot sks]^{n-2}\\ \\textrm{mod}\\ n$\n\n接着在output_p1函数中：\n\n$s \\equiv (d_{1}\\cdot k_{1}\\cdot s_{2}+d_{1}\\cdot s_{3}-r)\\ \\textrm{mod}\\ n$\n\n其中$d_{1}=sks$，而$r,s_{2},s_{3}$均由我指定，那么我令$r=s_{2}=0,s_{3}=1$，则得到的$s$即为$d_{1}$在模$n$下的值，即：\n\n$s \\equiv sks\\ \\textrm{mod}\\ n$\n\n注意到$n$是素数，欧拉函数$\\phi(n)=n-1$，显然$(n-2,n-1)=1$，即存在$x\\in Z,x\\cdot (n-2)\\equiv 1\\ \\textrm{mod}\\ \\phi(n)$\n\n由欧拉定理：$pks^{x}\\equiv [(sk+1)\\cdot sks]^{(n-2)x}\\equiv (sk+1)\\cdot sks\\ \\textrm{mod}\\ n$\n\n因此$(sk+1)\\equiv pks^{x}\\cdot sks^{-1}\\equiv pks^{x}\\cdot s^{-1}\\ \\textrm{mod}\\ n$，而密钥$sk$是小于阶$n$的，因此解出密钥$sk$，有了密钥干什么不行呢，按照程序的要求，对消息b'Hello, Welcome to ByteCTF2020!'签名即可！\n\n### 解题\n\n略","tags":["CTF比赛","CRT","SM"],"categories":["crypto"]},{"title":"Ubuntu安装metasploit-framework(方便安全可秒全网现有各种方法)","url":"/config/Ubuntu-Installs-Metasploit-Framework-Easy-Secure-Instable.html","content":"## 前言\n\n做项目需要用到metasploit-framework这款强大的渗透工具，学长给的[GitHub链接](https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers)下载起来巨慢，重新在网上找方法：网上几乎都是添加Kali源来安装metasploit-framework，但是自己手残在apt update后加了一条apt upgrade -y，然后电脑开始下很多奇奇怪怪的东西直到电脑完全动不了，最后只能重装Ubuntu！所以总结一下网上在Ubuntu安装metasploit-framework的两种方法要么慢，要么危险。\n\n## deb包安装\n\n推荐一种安全又快捷的方法，使用deb包进行安装：[deb包链接在此](https://apt.metasploit.com/)；翻到最下面，可以看到有metasploit-framework的deb包\n\n\n\n选择最新版的下载下来，使用gdebi来安装deb包即可\n```Bash\nsudo gdebi metasploit-framework_6.0.13+20201023102229~1rapid7-1_amd64.deb\n```\n可以看看安装好的效果：\n\n\n## 后记\n\n我来说一下上面的deb包链接是怎么找到的；从上述的[GitHub链接](https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers)开始，下面的Installing\n\n\n点击the free installer,再到下面的Linux manual installation\n\n\nhttps://apt.metasploit.com 就是deb包的链接。","tags":["Ubuntu","metasploit"],"categories":["config"]},{"title":"return2libc实验","url":"/program/Return2libc-experiment.html","content":"**前言**\n[实验程序GitHub链接](https://github.com/coderall/return-to-libc-attack)\n注：实验环境为Ubuntu16.04的32位虚拟机(virtualbox)\n\n## 预备工作\n关闭地址随机化，否则攻击失败\n```Bash\nsudo sysctl -w kernel.randomize_va_space=0\n```\n<div style=\"width:80%;margin:auto\">{% asset_img 1.png pic1 %}</div>\n\n## 任务1—查找libc函数的地址\n编译retlib.c，设置-fno-stack-protector关闭ubuntu上StackGuard保护机制，设置-z -execstack/noexecstack可打开或关闭可执行栈的机制，使用gdb来获取当前system()与exit()的地址\n```Bash\nsudo gcc retlib.c -fno-stack-protector -z noexecstack -o retlib -g\nsudo chmod 4755 retlib\ngdb -q retlib\n#进入gdb命令行\nb main\nr\np system\np exit\nq\n```\n<div style=\"width:90%;margin:auto\">{% asset_img 2.png pic2 %}</div>\n\n&nbsp;\n\n我们可以看到system()函数的地址是0xb7e43da0，exit()函数的地址是0xb7e379d0，使用上述得到的地址更改程序exploit.c：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 3.png pic3 %}</div>\n\n&nbsp;\n\n改完之后：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 4.png pic4 %}</div>\n\n## 任务2—将shell字符串放入内存中\n创建环境变量MYSH来记录/bin/sh路径，编译getenv.c，运行getenv程序获取/bin/sh的地址\n```Bash\nexport MYSH=\"/bin/sh\"\ngcc getenv.c -z noexecstack -o getenv -g\n./getenv MYSH ./retlib\n```\n<div style=\"width:75%;margin:auto\">{% asset_img 5.png pic5 %}</div>\n\n&nbsp;\n\n可以看到/bin/sh的地址为0xbffffe41，使用上述得到的地址更改程序exploit.c：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 6.png pic6 %}</div>\n\n&nbsp;\n\n改完之后：\n\n<div style=\"width:56%;margin:auto\">{% asset_img 7.png pic7 %}</div>\n\n## 任务3—找出栈溢出地址相对buffer的偏移\n\n下面我们介绍  *(long *) &buf[24] = 0xb7e5f430 ;   //  system()  中的24是怎么得到的；\n首先你应该对return to libc的原理有一定了解(不了解先参见[此处](https://www.ibm.com/developerworks/cn/linux/1402_liumei_rilattack/index.html))(原理看完就可以回来了，实验部分这里讲得更清楚^_^)\n这里的24就是栈溢出地址相对buffer的偏移；一种有用的办法是这样做的：生成较长的由a-zA-Z组成的随机字符串(比如我生成长100的这样的字符串)，将它写入badfile文件，然后用gdb调试retlib程序；\nrand.py程序如下：\n\n```Python\nfrom string import ascii_letters as al\nfrom random import randint\n\nX=[randint(0,51) for _ in range(100)]\nprint ''.join([al[x] for x in X])\n```\n\n```Bash\npython rand.py >> badfile\ngdb -q retlib\n#进入gdb命令行\nr\n```\n\n<div style=\"width:75%;margin:auto\">{% asset_img 8.png pic8 %}</div>\n\n&nbsp;\n\n不用设置断点，直接运行然后会发生栈溢出错误，并且告诉你栈溢出的地址，在我调试的过程中，栈溢出的地址为0x4a4c4e49，把这个地址转换为字符串并反转是INLJ(之所以要反转是因为地址的表示为大端表示)，INLJ在上述生成的随机字符串中的索引就是24，说明栈溢出地址相对buffer的偏移为24；\n\n## 任务4—利用缓冲区溢出漏洞\n编译exploit.c，攻击，进入/bin/sh程序\n```Bash\ngcc exploit.c -z noexecstack -o exploit\n./exploit\n./retlib\n```\n<div style=\"width:75%;margin:auto\">{% asset_img 9.png pic9 %}</div>\n\n## 任务5—增加调用setuid进行提权\n首先按照同样的方式获取setuid()函数的地址，然后更改程序exploit.c；\n```Bash\ngdb -q retlib\n#进入gdb命令行\nb main\nr\np setuid\nq\n```\n<div style=\"width:75%;margin:auto\">{% asset_img 10.png pic10 %}</div>\n\n&nbsp;\n\n可以看到setuid()函数的地址为0xb7eba2e0，使用上述得到的地址更改程序exploit.c，改完之后：\n\n<div style=\"width:60%;margin:auto\">{% asset_img 11.png pic11 %}</div>\n\n&nbsp;\n\n重新编译exploit.c然后进行攻击(如果攻击失败，尝试：重启->关闭地址随机化->export MYSH=\"/bin/sh\"，然后重新执行下面三行命令)\n```Bash\ngcc exploit.c -z noexecstack -o exploit\n./exploit\n./retlib\n```\n攻击结果如下。\n\n<div style=\"width:75%;margin:auto\">{% asset_img 12.png pic12 %}</div>","tags":["实验","ret2libc"],"categories":["program"]},{"title":"Makefile初探","url":"/program/The-Makefile-que.html","content":"## 背景\n\n如果做过工程，或者读过一些优秀的开源代码的话；了解.c文件需要分开写，每个.c文件实现特定的一小部分功能，另外还有一些.h文件，这种文件主要引用一些头文件，声明一些函数(虽然函数可以直接定义无需声明，但是先声明再定义是一个好习惯，另外一些虚函数是仅仅声明而不定义的)与宏；这些.c文件再被不同的目录组织；以上就是工程一般的框架，这些.c文件既可能依赖.h文件，也可能依赖其他.c文件，单单一行gcc的编译命令已经解决不了，这时需要Makefile来指导编译过程！\n\n## 语法规则\n\n目标文件：依赖文件\n|tab|编译规则\n\n注：|tab|代表一个tab键\n\n## Demo\n\n我的文件组织如下：\n```Bash\n.\n├── include\n│   └── head.h\n├── Makefile\n└── src\n    ├── add.c\n    ├── div.c\n    ├── master.c\n    ├── mul.c\n    └── sub.c\n```\n\nhead.h的代码如下：\n```C\n#include <stdio.h>\n\nint add(int a,int b);\n\nint sub(int a,int b);\n\nlong mul(long a,long b);\n\nfloat div(float a,float b);\n```\n\nadd.c的代码如下：\n```C\n#include \"head.h\"\n\nint add(int a,int b)\n{\n\treturn a+b;\n}\n```\n差不多这个意思，其他的代码就自己完善吧；\n\n最后master.c代码如下：\n```C\n#include \"head.h\"\n\nint main()\n{\n\tint a,b;\n\ta=12;\n\tb=3;\n\tprintf(\"%d add %d = %d\\n\",a,b,add(a,b));\n\tprintf(\"%d sub %d = %d\\n\",a,b,sub(a,b));\n\tlong ma,mb;\n\tma=12;\n\tmb=3;\n\tprintf(\"%ld mul %ld = %ld\\n\",ma,mb,mul(ma,mb));\n\tfloat fa,fb;\n\tfa=12;\n\tfb=3;\n\tprintf(\"%f div %f = %f\\n\",fa,fb,div(fa,fb));\n\treturn 0;\n}\n```\n\n下面是Makefile文件：\n```Makefile\nmaster:rely1.o rely2.o rely3.o rely4.o rely5.o\n\tgcc -o master src/add.o src/sub.o src/mul.o src/div.o src/master.o\nrely1.o: src/master.c include/head.h\n\tgcc -c -I include src/master.c -o src/master.o\nrely2.o: src/add.c include/head.h\n\tgcc -c -I include src/add.c -o src/add.o\nrely3.o: src/sub.c include/head.h\n\tgcc -c -I include src/sub.c -o src/sub.o\nrely4.o: src/mul.c include/head.h\n\tgcc -c -I include src/mul.c -o src/mul.o\nrely5.o: src/div.c include/head.h\n\tgcc -c -I include src/div.c -o src/div.o\n.PHONY:clean\nclean:\n\tfind . -name '*.o'  | xargs rm -f\n```\n\n下面make生成可执行文件：\n```Bash\n$ make && make clean\ngcc -c -I include src/master.c -o src/master.o\ngcc -c -I include src/add.c -o src/add.o\ngcc -c -I include src/sub.c -o src/sub.o\ngcc -c -I include src/mul.c -o src/mul.o\ngcc -c -I include src/div.c -o src/div.o\ngcc -o master src/add.o src/sub.o src/mul.o src/div.o src/master.o\nfind . -name '*.o'  | xargs rm -f\n```\n\nmake clean会执行Makefile文件中clean下的命令，它会清除所有的目标文件(.o文件)，因为已经不需要了！\n\n我们测试一下可执行文件是否正确执行：\n```Bash\n$ ./master\n12 add 3 = 15\n12 sub 3 = 9\n12 mul 3 = 36\n12.000000 div 3.000000 = 4.000000\n```\n\n注：可以看到Makefile中的rely1.o等等只是代号，真正目标文件的名称设定由编译规则指定。","tags":["C语言","makefile"],"categories":["program"]},{"title":"i春秋\"巅峰极客\"2020密码学部分详解","url":"/crypto/I-Spring-and-Autumn-Peak-Geek-2020-Cryptography-in-detail.html","content":"## tryecc\n\n### 题目信息\n\n附件是一个sage脚本与一个文本文件，[Gitee备份](https://github.com/KangMing-ux/CTFs-Crypto/tree/master/2020/iCHUNQIU/tryecc)在此\n\n### 分析\n\n$$\nE_{1}: y^{2}\\equiv x^{3}+ax+c\\ \\textrm{mod}\\ N\n$$\n\n$$\nE_{2}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ N\n$$\n\n我们总结一下已知量和未知量：\n\n| 已知            | 未知      |\n| :-: | :-: |\n| $N,C,P_{1},P_{2},P_{3},P_{4}$ | $A,B,m_{1},m_{2}$ |\n\n那么已知$P_{1}(x_{1},y_{1}),P_{2}(x_{2},y_{2})$就可以计算出$a,b$：\n$$\ny_{1}^{2}\\equiv x_{1}^{3}+a\\cdot x_{1}+c\\ \\textrm{mod}\\ N\n$$\n$$\ny_{2}^{2}\\equiv x_{2}^{3}+a\\cdot x_{2}+b\\ \\textrm{mod}\\ N\n$$\n\n$$\na=(y_{1}^{2}-x_{1}^{3}-c)\\cdot x_{1}^{-1}\\ \\textrm{mod}\\ N\n$$\n\n$$\nb=y_{2}^{2}-x_{2}^{3}-a\\cdot x_{2}\\ \\textrm{mod}\\ N\n$$\n\n\n\n好在$x_{1}$在模$N$下有逆，于是$a,b$就可以解出，到此得到了$E_{1},E_{2}$；\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ in\\ E_{2}\n$$\n$$\nP_{4}=m_{2}\\cdot P_{2}\\ in\\ E_{2}\n$$\n\n\n\n丢到sgaemath里面去解离散对数，结果发现解不出来！\n\n但是发现$N$不是素数，用yafu分解一下$N$，发现$N$是两个素数的乘积，记为$N=p\\cdot q$，那么椭圆曲线$E_{2}$可重写为\n$$\nE_{2}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ p\\cdot q\n$$\n这样$E_{2}$上的点也满足下面两个等式：\n$$\nE_{p}: y^{2}\\equiv x^{3}+ax+b\\ \\textrm{mod}\\ p\n$$\n\n\n即$E_{2}$上的点同时在$E_{p}$与$E_{q}$上(试了一下，我们可以求解$P_{3},P_{4}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数)\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ in\\ E_{2}\n$$\n 则有：\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ \\ in\\ E_{p}\n$$\n$$\nP_{3}=m_{1}\\cdot P_{2}\\ \\ in\\ E_{q}\n$$\n\n\n\n那是不是意味着我们解出$P_{3}$在椭圆曲线$E_{p}$上关于基点$P_{2}$的离散对数就是$m_{1}$呢？非也！我们解出的只是$m_{1}\\ \\textrm{mod}\\ order_{E_{p}}(P_{2})$，即$m_{1}$模了$P_{2}$在椭圆曲线$E_{p}$上的阶之后的值！\n\n要想解出$m_{1}$，需要将$P_{3}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数结合起来！\n$$\nm_{1}\\equiv s_{p}(1)\\ \\textrm{mod}\\ order_{E_{p}}(P_{2})\n$$\n$$\nm_{1}\\equiv s_{q}(1)\\ \\textrm{mod}\\ order_{E_{q}}(P_{2})\n$$\n\n\n\n这里$s_{p}(1),s_{q}(1)$分别是$P_{3}$在椭圆曲线$E_{p},E_{q}$上关于基点$P_{2}$的离散对数；\n\n使用中国剩余定理解上述方程组即可解出$m_{1}$，同理解出$m_{2}$\n\n### 解题\n\n上述链接中的solve.sage为解题的脚本；程序运行结果如下(运行时间有点长，稍微等一下)：\n\n```Bash\n$ sage solve.sage\n  ***   Warning: increasing stack size to 2000000.\nflag{de7a89ab1d074ef3930fb3054c0e3ac8}\n```\n\n## 后记\n\n一直在等师傅们关于密码学题目的writeup，结果一直没有找到；就只能把自己唯一做出来的一道题目的writeup写一下。","tags":["CTF比赛","CRT","ECC"],"categories":["crypto"]},{"title":"Sagemath在ctf密码学中的使用","url":"/crypto/Use-of-Sagemath-in-CTF-Cryptography.html","content":"## 基本的环和域\n\n```Python\n#整数域,有理数域和实数域\nZZ(3)\nQQ(0.25)\nRR(2^0.5)\n#复数域\nCC(1,2)\n#生成虚数单位i\ni=ComplexField().gen();(2+i)*(4+3*i)\n\n#构造多项式环,返回具有给定属性和变量名的全局唯一的单变量或多元多项式环\n#定义在整数域上的多项式环R，变量为w;ZZ也可换成其他数域\nR.<w>=PolynomialRing(ZZ);R\n(1 + w)^3\n\n#有限环\nRN=IntegerModRing(63)\nFR=Integers(17);FR\n#自身的代数扩展;exR=FR[w]/(w^2+3)\nexR=FR.extension(w^2+3)；exR\n#以python整数的形式返回所有可逆元素的列表\nFR.list_of_elements_of_multiplicative_group()\n#假设环的乘法群是循环的，返回这个环的乘法群的生成元\nFR.multiplicative_generator()\n#返回这个环的一个随机元素\nFR.random_element()\n#上述几种方法对如下的域同样支持\n\n#有限域\n#素数域\nG1=GF(37);G1\n#伽罗瓦域\nG2=GF(3^5);G2\n```\n\n## 数论基本函数\n\n```Python\n#同时求商与余数\nq,r=divmod(12,5)\n\n#求公约数\nd=gcd(12,5)\n\n#扩展的欧几里得算法\nd,u,v=xgcd(12,5)\n\n#12在模5下的逆\nu=inverse_mod(12,5)\n\n#生成[lb,ub)之间的随机素数,注意ub在前,lb在后,lb可缺省为0\n#可通过这种方式生成128位的随机素数\np=random_prime(2L**128,2L**127)\n\n#判断是否为素数\nis_prime(65537)\n\n#第20个素数\nnth_prime(20)\n\n#计算x^y mod n\nz=power_mod(12,5,17)\n\n#欧拉函数\neuler_phi(111)\n\n#中国剩余定理,A=[a1,...,an],M=[m1,...,mn]\n#ai=x mod mi,i=1,...,n\ncrt([1,2,3,4],[7,5,12,23])\n\n#求自身的n次根\nFR(12).nth_root(7,all='True')\n\n#求多项式的根，roots方法必须作用在域上\nR.<x>=PolynomialRing(G1)\nxt=G1(12)\nyt=xt^6\nf=x^6-yt\nf.roots()\n```\n\n## 线性代数\n\n```Python\n#定义矩阵，默认定义在实数域\nA = matrix([[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\nA^-1\n#定义在其他域上的矩阵，如有限域\nA = matrix(GF(13),[[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\nA^-1\n#可以看到两个逆矩阵不一样\n\n#定义向量，定义在有限域，默认定义在实数域\nw = vector(GF(13),[1,1,4,3])\nY=A*w;Y\nZ=w*A;Z\n\n#解线性方程组AX=Y\nX = A.solve_right(Y);X\n#也可以使用符号\\\nA\\Y\n#解线性方程组XA=Y\nX = A.solve_left(Z);X\n\n#格基约减\nA = matrix([[1,2,3,5],[3,2,1,2],[1,1,1,0],[3,7,2,2]])\n#LLL算法\nA.LLL()\n#BKZ算法\nA.BKZ()\n```\n\n## 离散椭圆曲线\n以国密SM2算法使用的椭圆曲线为例；\n\n```Python\np=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF',16)\na=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC',16)\nb=ZZ('28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93',16)\n#有限域GF(p)上的椭圆曲线y^2 = x^3 + a*x + b mod p\nE=EllipticCurve(GF(p),[0,0,0,a,b])\n#基点\ng=E([ZZ('32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7',16),ZZ('bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0',16)])\n#基点的阶\nn=ZZ('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123',16)\n#生成密钥\nsk=random_prime(2*n//3,n//3)\n#生成公钥\nG=sk*g\n```\n\n## 离散对数\n\n前言：求解以base为底，a的对数；ord为base的阶，可以缺省，operation可以是'+'与'\\*'，默认为'\\*'；bounds是一个区间(ld,ud)，需要保证所计算的对数在此区间内。\n\n```Python\n#通用的求离散对数的方法\nx=discrete_log(a,base,ord,operation)\n\n#求离散对数的Pollard-Rho算法\nx=discrete_log_rho(a,base,ord,operation)\n\n#求离散对数的Pollard-kangaroo算法(也称为lambda算法)\nx=discrete_log_lambda(a,base,bounds,operation)\n\n#小步大步法\nx=bsgs(base,a,bounds,operation)\n```\n\n## coppersmith算法\n\n[coppersmith算法介绍链接](https://www.cnblogs.com/coming1890/p/13506057.html)\n\n使用sage实现coppersmith相关攻击，[GitHub链接](https://github.com/mimoo/RSA-and-LLL-attacks)\n\n最后，sage的[官方文档链接](https://doc.sagemath.org/html/en/reference/)","tags":["工具","sagemath"],"categories":["crypto"]},{"title":"Elgamal&RSA小结","url":"/crypto/Elgamal-RSA-summary.html","content":"## 前言\n\n要解决的问题：$c\\equiv m^{e}\\ \\textrm{mod}\\ N$($m<N$，$N$已被分解，但$(e,\\phi(N))>1$)。\n\n## 分类讨论\n\n首先给出求解方程($q,e$为素数)$y\\equiv x^{e}\\ \\textrm{mod}\\ q^{k}$的[Python脚本](https://github.com/KangMing-ux/AllRootModqk)\n\n注：当$k=1$时，可(使用Sagemath)直接在有限域$GF(q)$上对$y$开$e$次方；\n\n### $N=p^{a}$\n\n记$g=(e,\\phi(N)),e_{1}=e/g$，则$(e_{1},\\phi(N))=1$，因此可以计算$d_{1}\\equiv e_{1}^{-1}\\ \\textrm{mod}\\ \\phi(N)$；$c^{d_{1}}\\equiv m^{e\\cdot d_{1}}\\equiv (m^{g})^{d_{1}\\cdot e_{1}}\\equiv m^{g}\\ \\textrm{mod}\\ N$，从而可得$m^{g}\\ \\textrm{mod}\\ p^{a}$，接下来使用上述工具求解(最多有$g$个解)。\n\n### $N=p_{1}^{a_{1}}\\cdots p_{k}^{a_{k}}$\n$c\\equiv m^{e}\\ \\textrm{mod}\\ N\\Rightarrow c\\equiv m^{e}\\ \\textrm{mod}\\ (p_{1}^{a_{1}}\\cdots p_{k}^{a_{k}})$，则有\n$$\nc\\equiv m^{e}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nc\\equiv m^{e}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n记$\\phi_{i}=\\phi(p_{i}^{a_{i}})$，$g_{i}=(e,\\phi_{i})$，$e_{i}=e/g_{i}$，$d_{i}\\equiv e_{i}^{-1}\\ \\textrm{mod}\\ \\phi_{i}$\n$$\nm^{g_{1}}\\equiv c^{d_{1}}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nm^{g_{k}}\\equiv c^{d_{k}}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n这时处理的方式不唯一；我们只考虑那些$g_{i}$很小的线程同余方程，不妨设$g_{1},\\cdots,g_{t}$很小；\n\n(1)$g_{1}=\\cdots =g_{s}=r$，$s\\leqslant t$(不妨设前$s$个$g_{i}$相等)\n\n利用中国剩余定理求解前$s$个方程组成的方程组，得到方程组在模$p_{1}^{a_{1}}\\cdots p_{s}^{a_{s}}$下的解；当$m^{r}<p_{1}^{a_{1}}\\cdots p_{s}^{a_{s}}$时，直接对解开$r$次方即得$m$；\n\n(2)一般情况，$g_{i}(i=1,\\cdots,t)$很小但是大多数各不相同\n\n那么首先对每个方程组利用上述工具求解(记$x_{i}$为第$i$个方程的解，此时大多数方程组有多个解，每个方程组的解最多有$g_{i}$个)\n\n$$\nm\\equiv x_{1}\\ \\textrm{mod}\\ p_{1}^{a_{1}}\\\\\n\\vdots \\\\\nm\\equiv x_{k}\\ \\textrm{mod}\\ p_{k}^{a_{k}}\\\\\n$$\n\n利用中国剩余定理求解前$t$个方程组成的方程组，得到方程组在模$p_{1}^{a_{1}}\\cdots p_{k}^{a_{t}}$下的解；当$m<p_{1}^{a_{1}}\\cdots p_{t}^{a_{t}}$时，$m$必在这些解中。\n\n注：其实这里也解释了为什么考虑那些$g_{i}$很小的线程同余方程，我们最多要求解$g_{1}\\cdots g_{t}$个这样的方程组，每个方程组会求出一个解；如果$g_{i}$很大，那么候选的解太多；但是我们要保证$p_{1}^{a_{1}}\\cdots p_{t}^{a_{t}}>m$。","tags":["密码学知识","CRT","RSA"],"categories":["crypto"]},{"title":"攻防世界-密码学-onetimepad","url":"/crypto/xctf-Onetimepad.html","content":"## 题目信息\n\n附件中包含实现加密的Python脚本，与密文文件。\n\n## 分析\n\n### 有限域$GF(2^{n})$\n\n构造有限域$GF(2^{n})$时，首先需要$GF(2)$上次数为n的本原多项式$g(x)$；对于$GF(2^{n})$上的每个元素$a$，都可以用一个次数不超过$n$的多项式$f_{a}$表示：$f_{a}(x)=\\sum_{i=0}^{n-1}a_{i}\\cdot x^{i}$，其中$a_{n-1}\\cdots a_{0}$是$a$的二进制表示；从而$GF(2^{n})$上的四则运算定义如下：\n\n* 加法：对于$a,b\\in GF(2^{n})$，它们的多项式表示分别为$f_{a},f_{b}$，记$f_{c}=f_{a}+f_{b}$(其中系数的加法为$GF(2)$上的加法，即异或运算)，则$c_{n-1}\\cdots c_{0}$的二进制值$c$为$a+b$的值；\n\n* 减法：由于$GF(2)$上的加法与减法等价，因此对于$a,b\\in GF(2^{n})$，$a+b=a-b$；\n\n* 乘法：同样地，$a,b$的多项式表示$f_{a},f_{b}$，记$f_c=f_{a}\\cdot f_{b}\\ \\textrm{mod}\\ g$，由于多项式$g$的次数为$n$，故多项式$f_{c}$的次数不超过$n$，则$c_{n-1}\\cdots c_{0}$的二进制值$c$为$a\\cdot b$的值；\n\n* 除法：先介绍(乘法)逆元，本原多项式是一种具有特殊性质的不可约多项式，对GF(2)上任意次数不超过$n$的多项式f，都存在$GF(2)$上次数不超过n的多项式$h$，使得$f\\cdot h \\equiv 1\\ \\textrm{mod}\\ g$；与$f$作除法等价于与$f$的逆元$h$作乘法；\n\n### process(m,k)\n\n考虑$t^{2},t\\in GF(2^{256})$，构造$GF(2^{256})$的本原多项式为$g=x^{256}+x^{10}+x^{5}+x^{2}+1$，记$t$的二进制表示为$t_{n-1}\\cdots t_{0}$，则$t$的多项式表示$f_{t}(x)=\\sum_{i=0}^{n-1}t_{i}\\cdot x^{i}=(((t_{n-1}\\cdot x+t_{n-2})\\cdot x+\\cdots +t_{1})\\cdot x+t_{0})$，考虑$t^{2}$：\n\n$f_{t}^{2}\\ \\textrm{mod}\\ g$\n\n$=(((t_{n-1}\\cdot x+t_{n-2})\\cdot x+\\cdots +t_{1})\\cdot x+t_{0})\\cdot f_{t}\\ \\textrm{mod}\\ g$\n\n$=((((t_{n-1}\\cdot f_{t})\\cdot x+t_{n-2}\\cdot f_{t})\\cdot x+\\cdots +t_{1}\\cdot f_{t})\\cdot x+t_{0}\\cdot f_{t})\\ \\textrm{mod}\\ g$\n\n$=((((((t_{n-1}\\cdot f_{t})\\cdot x+t_{n-2}\\cdot f_{t})\\ \\textrm{mod}\\ g)\\cdot x+\\cdots +t_{1}\\cdot f_{t})\\ \\textrm{mod}\\ g)\\cdot x+t_{0}\\cdot f_{t})\\ \\textrm{mod}\\ g$\n\n我们再来对比函数process(m,k)：\n\n```Python\ndef process(m, k):\n    tmp = m ^ k\n    res = 0\n    for i in bin(tmp)[2:]:\n        res = res << 1;\n        if (int(i)):\n            res = res ^ tmp\n        if (res >> 256):\n            res = res ^ P\n    return res\n```\nres=res<<1代表乘以x，多项式的系数全体左移一位；\n\nif (int(i)):res^=tmp等价于res^=int(i)*tmp，代表$+t_{i}\\cdot f_{t}$；\n\nif (res>>256):res^=P代表模本原多项式g；\n\n综上，process(m,k)实际上实现了$GF(2^256)$上的元素$m$与$k$之和的平方$(m+k)^{2}$；\n\n### 解密过程\n\n$k_{2}=(k_{1}+secret)^{2},k_{3}=(k_{2}+secret)^{2}$(在GF(2^256)上的运算)\n\n$c_{1}=m_{1}\\oplus k_{1},c_{2}=m_{2}\\oplus k_{2},c_{3}=m_{3}\\oplus k_{3}$，其中$c_{i}(i=1,2,3),m_{i}(i=1,2)$已知\n\n则$k_{2}=m_{2}\\oplus c_{2},k_{3}=m_{3}\\oplus c_{3}$，可解出secret：$secret=k_{3}^{1/2}+k_{2}$(在GF(2^256)上的运算)\n\n接下来解出$k_{1}$：$k_{1}=k_{2}^{1/2}+secret$(在GF(2^256)上的运算)\n\n然后解出flag(即$m_{1}$)：$m_{1}=c_{1}\\oplus k_{1}$\n\n## 解题\n\n实现的sage脚本如下：\n\n```Python\nfrom Crypto.Util.number import bytes_to_long,long_to_bytes\n\nK.<x>=GF(2L**256,modulus=x^256+x^10+x^5+x^2+1)\n\ndef polify(N):\n    bN=list(bin(N)[2:])\n    bN.reverse()\n    return K(bN)\n\ndef unpolify(Poly):\n    bN=Poly.polynomial().list()\n    bN.reverse()\n    return long(''.join([str(it) for it in bN]),2)\n\ndef solve():\n    cip1=polify(0xaf3fcc28377e7e983355096fd4f635856df82bbab61d2c50892d9ee5d913a07f)\n    cip2=polify(0x630eb4dce274d29a16f86940f2f35253477665949170ed9e8c9e828794b5543c)\n    cip3=polify(0xe913db07cbe4f433c7cdeaac549757d23651ebdccf69d7fbdfd5dc2829334d1b)\n    msg2=polify(bytes_to_long('I_am_not_a_secret_so_you_know_me'))\n    msg3=polify(bytes_to_long('feeddeadbeefcafefeeddeadbeefcafe'))\n    secret=cip2+msg2+(cip3+msg3).sqrt()\n    key1=(cip2+msg2).sqrt()+secret\n    msg1=cip1+key1\n    return long_to_bytes(unpolify(msg1))\n\nif __name__=='__main__':\n    print 'flag{'+solve()+'}'\n```\n\n程序运行结果如下：\n```Bash\n$ sage solve.sage\nflag{t0_B3_r4ndoM_en0Ugh_1s_nec3s5arY}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-sleeping-guard","url":"/crypto/xctf-Sleeping-Guard.html","content":"## 题目信息\n\n点击还原比赛场景后，会给出镜像服务器的ip以及连接端口。且提示：“只有真正的hacker才能看到这张图片”\n\n## 分析\n\n连接上服务器之后，服务器返回的数据看上去像base64编码，对此，解码即可；根据题目的提示，flag藏在图片中，解码后文件头数据不是png,jpg,bmp文件头格式(说明不是直接解码这么简单)，也不是zip,rar,7z文件头格式(说明不是将图片加密压缩)；实际上，原比赛的此题还有一个Python脚本，大致意思是使用长度为12的密钥与图片数据进行(循环)异或加密，有了这个信息之后，尝试使用各种图片格式的文件头与加密数据进行异或得到密钥，使用png格式的文件头与加密数据进行异或时，得到的结果“很像”密钥；接下来使用密钥解密即可。\n\n## 解题\n\n首先从服务器接收全部的数据，再进行base64解码(将解码后的数据存入文件data)；\n\n然后通过png文件头解出密钥，然后通过密钥解密，实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\nfrom binascii import unhexlify\nfrom Crypto.Util.strxor import strxor\n\ndef enc(data,key):\n    key=(key*(len(data)/len(key)+1))[:len(data)]\n    return strxor(data,key)\n\ndef solve(data):\n    head=unhexlify('89504e470d0a1a0a0000000d49484452')\n    key=strxor(head,data[:16])\n    with open('sleeping-guard.png','wb') as f:\n        f.write(enc(data,key[:12]))\n\nif __name__=='__main__':\n    with open('data','rb') as f:\n        solve(f.read())\n```\n\n最后解密出图片\n\n{% asset_img 1.png pic1 %}","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-streamgame1","url":"/crypto/xctf-StreamGame1.html","content":"## 题目信息\n\n附件给出实现流加密的Python脚本与一段输出的密钥流。\n\n## 分析\n\n通过对加密脚本的理解，可得本题的LFSR模型：\n{% asset_img 1.png pic1 %}\n\n其中 $a_{n-1},a_{n-2},\\cdots,a_0$ 为程序中 mask 的二进制位，当 $a_i=1$ 时，将 $b_i$ 输入异或运算，否则 $b_i$ 不输入异或运算；根据模型我们可以得到如下等式：\n\n$$\n\\begin{pmatrix}\nk_{1} \\\\\nk_{2} \\\\\n\\vdots \\\\\nk_{n-1} \\\\\nk_{n} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nb_{n-1} & b_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nb_{n-2} & b_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots  & \\vdots  & \\ddots & \\vdots & \\vdots \\\\\nb_{1}   & b_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nb_{0}   & k_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-1} \\\\\na_{n-2} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n其中的加法为异或，因为$a_{n-1} =1$，将上式重写如下：\n\n$$\n\\begin{pmatrix}\nk_{1} \\\\\nk_{2} \\\\\n\\vdots \\\\\nk_{n-1} \\\\\nk_{n} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nb_{n-1} \\\\\nb_{n-2} \\\\\n\\vdots \\\\\nb_{1} \\\\\nb_{0} \\\\\n\\end{pmatrix}\\oplus \\begin{pmatrix}\nb_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nb_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots  & \\ddots & \\vdots & \\vdots \\\\\nb_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nk_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-2} \\\\\na_{n-3} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n由异或性质：\n\n$$\n\\begin{pmatrix}\nb_{n-1} \\\\\nb_{n-2} \\\\\n\\vdots \\\\\nb_{1} \\\\\nb_{0} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nk_{1} \\\\\nk_{2} \\\\\n\\vdots \\\\\nk_{n-1} \\\\\nk_{n} \\\\\n\\end{pmatrix}\\oplus \\begin{pmatrix}\nb_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nb_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots  & \\ddots & \\vdots & \\vdots \\\\\nb_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nk_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-2} \\\\\na_{n-3} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n再将等式“还原”：\n\n$$\n\\begin{pmatrix}\nb_{n-1} \\\\\nb_{n-2} \\\\\n\\vdots \\\\\nb_{1} \\\\\nb_{0} \\\\\n\\end{pmatrix}=\\begin{pmatrix}\nk_{1} & b_{n-2} & \\cdots & b_{1}  & b_{0}  \\\\\nk_{2} & b_{n-3} & \\cdots & b_{0}  & k_{1}  \\\\\n\\vdots & \\vdots  & \\ddots & \\vdots & \\vdots \\\\\nk_{n-1} & b_{0}   & \\cdots & k_{n-3}&k_{n-2}  \\\\\nk_{n} & k_{1}   & \\cdots & k_{n-2}&k_{n-1}  \\\\\n\\end{pmatrix}\\cdot \\begin{pmatrix}\na_{n-1} \\\\\na_{n-2} \\\\\n\\vdots \\\\\na_{1} \\\\\na_{0} \\\\\n\\end{pmatrix}\n$$\n\n计算的顺序由下至上，即可解出初始状态的所有比特位。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom gmpy2 import c_div\n\ndef lfsr(R,mask):\n    output = (R << 1) & 0xffffff    \n    i=(R&mask)&0xffffff             \n    lastbit=0\n    while i!=0:\n        lastbit^=(i&1)    \n        i=i>>1\n    output^=lastbit\n    return (output,lastbit)\n\ndef cal(s,mask):\n    lm=len(bin(mask))-2\n    R=int(s[-1:]+s[:-1],2)\n    ss=''\n    for j in range(lm,0,-1):\n        (_,tk)=lfsr(R,mask)\n        ss=str(tk)+ss\n        R=int(s[j-2]+str(tk)+bin(R)[2:].rjust(lm,'0')[1:-1],2)\n    return ss\n\ndef solve():\n    mask=0b1010011000100011100\n    lm=len(bin(mask))-2\n    with open('key','rb') as f:\n        stream=f.read(c_div(lm,8))\n    s=''.join([bin(256+ord(it))[3:] for it in stream])\n    flag='flag{'+cal(s[:lm],mask)+'}'\n    return flag\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nflag{1110101100001101011}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"GACTF2020密码学部分详解","url":"/crypto/GACTF2020-Cryptography-Section.html","content":"### 前言\n\n比赛网址：[GACTF2020](https://adworld.xctf.org.cn/match/contest_challenge?event=147&hash=cf494a33-0f22-4e85-a48d-7a02efeedc90.event)\n[writeup参考链接](https://0xdktb.top/2020/08/30/WriteUp-GACTF2020-Crypto/)\n\n## ezAES\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://github.com/KangMing-ux/CTFs-Crypto/tree/master/2020/GACTF/ezAES)的challeng.py。\n\n### 分析\n\n整体浏览Python脚本后，可得此题考察CBC分组加密工作模式；总结一下脚本给出的信息：\n* key给出前14位(key长16位，即最后2位未知)\n* message的长度为86字节，因此明文最后一组填充10个'\\n'\n* 密文最后一组给出后10个字节\n\n因此，可穷举key的最后2位，每一位考虑所有可打印字符，有100种可能，因此穷举key的最后2位有$10^{4}$种可能，处于合理范围；对每一个key，解密最后一组密文，将解密出的明文后10位与上一组密文后10位异或，若异或后均为'\\n'，则说明穷举出正确的key；\n解出正确的key之后，可按照同样的方式计算出SECRET，从而获取整个明文；\n已知所有明文之后，由CBC工作模式：$m_{i}=D(c_{i};key)\\oplus c_{i-1},i=n,\\cdots,1$，其中$c_{0}=IV$，那么已知最后一组密文，就可以递推出IV：$c_{i-1}=D(c_{i};key)\\oplus m_{i},i=n,\\cdots,1$\n\n### 解题\n\n上述链接中的solve.py为解题的Python脚本；\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\n[+] MBruteforcing: Found key: \"pd\"\n9j_for_aes_cbc!!\n```\n\n## what_r_the_noise\n\n### 题目信息\n\n噪音太大，听不见，China:124.71.145.165:9999(现在应该已经失效了)。\n\n### 分析\n\n大致意思是服务器返回的数据是加入了噪声的，让你去掉噪声，解出正确的明文；有点概率论知识应该想到获取多次数据取平均值。\n\n### 解题\n\n解题的Python脚本在[Gitee备份](https://github.com/KangMing-ux/CTFs-Crypto/tree/master/2020/GACTF2020/what_r_the_noise)中；\n\n解出的flag可能不完全正确，但是你基本可以猜出是什么单词了！\n\n最后得到flag为gactf{you_know_much_about_differential_privacy}\n\n## da Vinci after rsa\n\n### 题目信息\n\n附件中包含两个文本文件encryption与output；encryption中是一列数，output给出“RSA公钥”与密文；[Gitee备份](https://github.com/KangMing-ux/CTFs-Crypto/tree/master/2020/GACTF2020/da_Vinci_after_rsa)\n\n### 分析\n\nda Vinci翻译了一下(英语不好)是达芬奇，这既然是密码学题目，自然去查了一下达芬奇密码，发现这是一本书，在网上不停地查这本书，找到一个片段，“打乱的数字”一下引起我的注意，后面马上提到“斐波那契数列”，回去一看，encryption中的那一列数确实是打乱的斐波那契数列，到此encryption的作用弄明白了；\n\n接下来将公钥的模数N放到yafu中分解，得到三个因子；但是我想，不怕，和RSA问题一样求解$d\\equiv e^{-1}\\ \\textrm{mod}\\ \\phi(N)$即可解出$m\\equiv c^{d}\\ \\textrm{mod}\\ N$，编好程序运行时发现$e$在$\\phi(N)$下没有逆，这一下子就不知道怎么办了，其实这样的方程也是有办法求解的，[求解思路链接在此](https://KangMing-ux.github.io/crypto/Elgamal-RSA-summary.html)\n\n解出的$m$虽然有多个，但是flag每个字符都是可见字符，这样最后只剩下一个$m$，这还不是flag；花括号内正好25个字符，encryption中正好25个数，按照一样的规则打乱花括号内的25个字符即得到真正的flag；\n\n### 解题\n\n上述GitHub备份链接中的solve.sage脚本为解题的sage脚本；\n\n程序运行结果如下：\n\n```Bash\n$ sage solve.sage\nflag{w5awd4fa994f87_dwad3123_2}\n```\n\n## elgamal_rsa\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://github.com/KangMing-ux/CTFs-Crypto/tree/master/2020/GACTF2020/elgamal_rsa)\n\n### 分析\n\n$g^{q}\\equiv 1\\ \\textrm{mod}\\ p,h\\equiv g^{d}\\ \\textrm{mod}\\ p$\n\n$c_{1}\\equiv g^{r_{1}}\\ \\textrm{mod}\\ p,c_{2}\\equiv m\\cdot h^{r_{1}}\\ \\textrm{mod}\\ p$\n\n$c_{11}\\equiv g^{r_{2}}\\ \\textrm{mod}\\ p,c_{22}\\equiv m\\cdot h^{r_{2}}\\ \\textrm{mod}\\ p$\n\n其中，$r_{2}\\equiv (B\\cdot r_{1}+A)\\ \\textrm{mod}\\ q$\n\n这里的$m$就是$secret$，$secret$是下面“RSA”加密的模数，因此首先要解出$secret$，这也是很好解的；\n\n$c_{2}^{B}\\cdot h^{A}\\equiv (m\\cdot h^{r_{1}})^{B}\\cdot h^{A}\\equiv m^{B}\\cdot h^{B\\cdot r_{1}+A}\\equiv m^{B-1}\\cdot c_{22}\\ \\textrm{mod}\\ p$\n\n$m^{B-1}\\equiv c_{2}^{B}\\cdot h^{A}\\cdot c_{22}^{-1}\\ \\textrm{mod}\\ p$，计算$t\\equiv (B-1)^{-1}\\ \\textrm{mod}\\ (p-1)$\n\n那么$(c_{2}^{B}\\cdot h^{A}\\cdot c_{22}^{-1})^{t}\\equiv m\\ \\textrm{mod}\\ p$\n\n解出$secret$后，放到yafu里面分解(因子是真的多，一度怀疑自己解错了)，[求解flag的思路链接](https://www.cnblogs.com/coming1890/p/13616763.html)\n\n### 解题\n\n上述GitHub备份链接中的solve文件夹中为解题的脚本，解题分两步；第一步，解出secret；第二步，求解方程$c\\equiv m^{e}\\ \\textrm{mod}\\ N$($m<N$，$N$已被分解，但是$(e,\\phi(N))>1$)；\n\n程序运行结果如下：\n\n```Bash\n$ python step1.py\n329380824451982777596468080979390700896875051159309053251427777390225223390054462862874890632092714850180031743329031313028975903871751004003831036860000454098274963081490031808010876171935539110201531253322208564941373067673598629247111527738724700328114569409692796434368030258427126193825227856160081569366870307559297674909108870298864572520476006338972072593434914773857347865349086098662711283463352902488164071184362082990162654586995346553108747183805073294471613391819978413596510467204977114038549473397779377039088475929677184284430986636686769839308217865627271293739711926018699557041530631349486791876338842184994986024157099233298972714917732995013317087756483\n```\n\n```Bash\n$ sage step2.sage\nyou_4re_good_at_b0th_el94mal_and_rs4\n```\n\n## babycrypto\n\n### 题目信息\n\n附件是一个Python脚本，[Gitee备份](https://github.com/KangMing-ux/CTFs-Crypto/tree/master/2020/GACTF2020/babycrypto)\n\n### 分析\n\n在GF(p)上定义的点集$\\{(x,y)|x,y\\in GF(p)\\}$上定义加法\"+\"：$(x_{1},y_{1})+(x_{2},y_{2})=(x_{1}x_{2}-y_{1}y_{2},x_{1}y_{2}+x_{2}y_{1})$，定义乘法\"$\\cdot$\"：$k\\cdot (x,y)=(x,y)+\\cdots +(x,y)$\n\n给出基点g，$A=a\\cdot g,B=b\\cdot g$，给出A,B；\n\n$shared=b\\cdot A$，再利用shared生成AES密钥进行加密；\n\np未知！！！先介绍Edwards曲线E：$x^{2}+y^{2}\\equiv 1+dx^{2}y^{2}\\ \\textrm{mod}\\ p$，曲线上的加法定义为$(x_{1},y_{1})+(x_{2},y_{2})=((x_{1}y_{2}+x_{2}y_{1})/(1+dx_{1}x_{2}y_{1}y_{2}),(x_{1}x_{2}-y_{1}y_{2})/(1-dx_{1}x_{2}y_{1}y_{2}))$\n\n令d=0，则E：$x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p$，则加法重写为$(x_{1},y_{1})+(x_{2},y_{2})=(x_{1}y_{2}+x_{2}y_{1},x_{1}x_{2}-y_{1}y_{2})$\n\n若我们设定d=0，那么$A(x_{1},y_{1}),B(x_{2},y_{2})$满足方程$x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p$，求$x_{1}^{2}+y_{1}^{2}-1$与$x_{2}^{2}+y_{2}^{2}-1$的公约数，则p是其最大素因子；\n\n下面考虑如何解出b，这是一个离散对数问题，难点是sage并未实现Edwards曲线及其运算；\n\n给出一个有用的结论：$\\{(x,y)|x,y\\in GF(p),x^{2}+y^{2}\\equiv 1\\ \\textrm{mod}\\ p\\}$与$H=F_{p}(w)/(w^{2}+1)$(有限域$F_{p}$上的多项式在模$w^{2}+1$下的剩余环)同构，同构映射$\\sigma :E\\rightarrow H$，$\\sigma((x,y))=x+yw$\n\n在sage中通过extend函数就可以生成H，从而可以求解此离散对数问题；\n\n### 解题\n\n上述GitHub备份链接中的solve文件夹中为解题的脚本，解题分两步；第一步，解出p；第二步，解出b然后以同样的方式生成AES密钥再对消息进行解密；\n\n程序运行结果如下：\n\n```Bash\n$ python step1.py\n435393448000740628395634230535241428961470055780764193459123534837759996\n```\n\n使用yafu分解，可得到p(在solve.sage中有给出)\n\n```Bash\n$ sage solve.sage\ngactf{354b6ce4c03387a828a3c30061213204}\n```","tags":["CTF比赛","CRT","Edwards"],"categories":["crypto"]},{"title":"攻防世界-密码学-xor_game","url":"/crypto/xctf-XOR-GAME.html","content":"## 题目信息\n\n题目给出实现加密的程序，且指出明文是一首诗。\n\n## 分析\n\n先总结一下有用的信息：\n* 明文是有意义的英文，即明文均为可见字符且明文中的各字母出现的频率接近统计规律(在够长的一段话里，各个字母的占比大致稳定，并且这个稳定值已经用巨大的语料库统计出来了，这就是字母频率)\n\n* 密钥均为可见字符\n\n* 加密时对密钥进行了重用\n\n解决方案可分为程序分析与如果人工分析两部分；\n(1)程序分析：穷举密钥的长度，对每一长度的密钥，筛选密钥每一位可行的字符集合(要求此密钥位为可见字符，且那些被此密钥位解密出的明文位亦为可见字符)，如果密钥某一位可行的字符集合为空，则说明当前穷举的长度不是密钥的长度，这一步结束之后，可确定密钥的长度，以及密钥每一位可能的字符值；\n\n注：就实际情况来看，如果穷举的长度不是密钥的长度，几乎一定会有密钥某一位可行的字符集合为空。\n\n接下来，利用词频分析对密钥每一位进行爆破：对密钥的每一位，使用上一步得到的候选字符集中不同字符将解密出不同的明文，其中各字母出现的频率也不会相同，计算各字母出现的频率分布与统计规律的相似程度，选择相似程度最高的字符作为此密钥位。\n\n注：相似度计算公式：$score=\\sum_{i=1}^{26}p_{i}*q_{i}$，其中$p_{i}$是明文中第$i$个字母出现的频率，$q_{i}$是已统计出的第$i$个字母的频率。$q_{i}$的值见下面的程序。\n\n(2)人工分析：经过(1)，可猜对大部分密钥位，之后再结合解密出的明文对错误的密钥位进行修正。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom Crypto.Util.strxor import strxor\nfrom string import printable\nfrom base64 import b64decode\n\nfreq={'e':0.12702,'t':0.09056,'a':0.08167,'o':0.07507,\n        'i':0.06966,'n':0.06749,'s':0.06327,'h':0.06094,\n        'r':0.05987,'d':0.04253,'l':0.04025,'c':0.02782,\n        'u':0.02758,'m':0.02406,'w':0.02360,'f':0.02228,\n        'g':0.02015,'y':0.01974,'p':0.01929,'b':0.01492,\n        'v':0.00978,'k':0.00772,'j':0.00153,'x':0.00150,\n        'q':0.00095,'z':0.00074\n        }\n\ndef frequency(msg):\n    global freq\n    cnum=[len([s for s in msg if s==cc or s==cc.upper()]) for cc in freq.keys()]\n    csum=sum(cnum)\n    if csum==0:\n        return 0\n    return sum([x*y for x,y in zip(freq.values(),cnum)])/csum\n\ndef analysis(ks,cip):\n    lks=[len(sk) for sk in ks]\n    lc=len(cip)\n    step=len(lks)\n    key=[]\n    for ii,sk in enumerate(ks):\n        scores=[frequency(''.join([strxor(cip[ind],ik) for ind in range(ii,lc,step)])) for ik in sk]\n        key.append(sk[scores.index(max(scores))])\n    return key\n\ndef guessK(cip,low=4,high=33):\n    lc=len(cip)\n    for step in range(low,high):\n        ks=[]\n        for c1 in range(step):\n            optK=list(printable[:-6])\n            optK=[ik for ik in optK if ik not in \"{}'\\\"`^\"]\n            for ind in range(c1,lc,step):\n                tt=optK[:]\n                for ik in tt:\n                    if not strxor(cip[ind],ik) in printable:\n                        optK.remove(ik)\n            if len(optK)==0:\n                break\n            ks.append(optK[:])\n        if len(ks)<step:\n            continue\n        return analysis(ks,cip)\n\ndef enc(data, key):\n    key=(key*(len(data)/len(key)+1))[:len(data)]\n    return strxor(data,key)\n\ndef solve():\n    with open('cipher.txt','r') as f:\n        cip=b64decode(f.read())\n    key=guessK(cip)\n    lc=len(cip)\n    lk=len(key)\n    while 1:\n        while 1:\n        print('\\033[1;31m'+''.join(key)+'\\033[0m')\n        msg=enc(cip,''.join(key))\n        out=['['+str(ii/lk)+']['+msg[ii:(ii+lk)]+']' for ii in range(0,lc-lk,lk)]\n        out.append('['+str(lc/lk)+']['+msg[-(lc%lk+lk):-(lc%lk)]+']')\n        if lc%lk:\n            out.append('['+str(lc/lk+1)+']['+msg[-(lc%lk):]+']')\n        print ''.join(out)\n        if raw_input('\\033[1;31m need correction(y) or not(n)\\033[0m')=='n':\n            break\n        row=int(raw_input('\\033[1;31m row \\033[0m'))\n        col=int(raw_input('\\033[1;31m col \\033[0m'))\n        cor=raw_input('\\033[1;31m correction \\033[0m')\n        key[col]=strxor(cip[row*lk+col],cor)\n    with open('msg','w') as f:\n        f.write(msg)\n    print('\\033[1;31m'+''.join(key)+'\\033[0m')\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```txt\n$ python solve.py\nxo7_is_,nte,estingn@f\n[0][\nL,fe, 1hin~and li(h1][1][-o#f ti(e a0d timeoa\"][2][ai+\nFri3olo+s tire#e6][3][s\n*ne\nIehea,d the *c-][4][o,efromethe~valley< $][5][ndethe -ear*\nOpen ;oe][6][th  lon ly -oul ofos,][7][ck)e ha7ves*ing\nRe?e$][8][t *utri\"htl', but .l6][9][o 7epea1 th; well--e,][10][ngeof\nE3ent+ally s8a<][11][in\" in 1he :esert  a6][12][isOI be)iev; I am\no7][13][n $s th  br7ght su\"m ][14][r #lowe7s\nD1 not w&t-][15][er d un!efe?ted fi*r<][16][ d mon 7uleTHeart =a1][17][e $nd b7eat6ing toob ][18][arethe )oad~of theoc0][19][mb rsom \nBo,ed\nTwoEIe][20][he$rd t-e m+sic, f=o(][21][ t-e mo*n a0d carc.s6][22][\nA0xili$ry ;xtremeoa ][23][st-etic,sm <ait tooc$][24][pt0re m,styTFillin( 1][25][heeinte+se 2ife, b:te][26][al6o fi)lin9 the p:r ][27][\nT-ere $re ?lways \"e(][28][or,es t-rou9hout t'ee][29][ea7th\nIebel7eve I .mO][30][Di d asethe~quiet -e$][31][ut< of $utu3n leav*sO][32][Sh ng i6 no* chaosc 6][33][mo.e ge6tur;\nEven 8i)][34][t $lso 7eta7ned bo!ee][35][pr*udlyeQin9 Feng \"u6][36][cl \nOcc0lt\n\nhree\nIoh ][37][arelovei I <elieveoi+][38][ l*ve\nL*ve 7s a po le][39][ofestru\"gli0g bluebg7][40][ee+ alg$e\nA- desol.t ][41][ m,cro-'urs* of wi!dO][42][Bl edin\" th,ough m6 3][43][ei+s\nYe$rs -tation*de][44][inethe 'eli;f\nFourEIe][45][be)ieveetha* all c.ne][46][he$r\nEv n a0ticipa;ee][47][di6cret , I~met th* *][48][th r th ir 1wn\nSom* &][49][anenot \"ras. the m m ][50][ntOLefteto *he Eas; 1][51][o \"o We6t, *he dea+ (][52][us1 noteret+rn to !o2][53][he7e\nSe , I~wear Z.ne][54][Fl*werseon 3y headc ,][55][n #ull 'loo3 alongot-][56][e 2ay a)l t6e way\n\tr ][57][qu ntlyemis-ed som*,e][58][bu1 als* de;ply mo9e!][59][ b< win!, f,ost, s!o2][60][ o7 rai+\nFi(e\nPraj!ae][61][Pa7amit$, s1on as <o*][62][n $s\nli#e b; beaut&f0][63][l )ike 6umm;r flow*r6][64][ a+d de$th 2ike au;u(][65][n )eave6\nAl-o careoa'][66][n )eave6\nAl-o careoa'][67][ou1 wha1 ha-]\nneed correction(y) or not(n)y\nrow: 0\ncol: 2\ncorrection: i\nxor_is_,nte,estingn@f\n[0][\nLife, 1hin~and li(h1][1][-off ti(e a0d timeoa\"][2][ain\nFri3olo+s tire#e6][3][s\none\nIehea,d the *c-][4][o, fromethe~valley< $][5][nd the -ear*\nOpen ;oe][6][the lon ly -oul ofos,][7][ckle ha7ves*ing\nRe?e$][8][t outri\"htl', but .l6][9][o repea1 th; well--e,][10][ng of\nE3ent+ally s8a<][11][ing in 1he :esert  a6][12][is\nI be)iev; I am\no7][13][n as th  br7ght su\"m ][14][r flowe7s\nD1 not w&t-][15][ered un!efe?ted fi*r<][16][ demon 7uleTHeart =a1][17][e and b7eat6ing toob ][18][ar the )oad~of theoc0][19][mbersom \nBo,ed\nTwoEIe][20][heard t-e m+sic, f=o(][21][ the mo*n a0d carc.s6][22][\nAuxili$ry ;xtremeoa ][23][sthetic,sm <ait tooc$][24][pture m,styTFillin( 1][25][he inte+se 2ife, b:te][26][also fi)lin9 the p:r ][27][\nThere $re ?lways \"e(][28][ories t-rou9hout t'ee][29][earth\nIebel7eve I .mO][30][Died asethe~quiet -e$][31][uty of $utu3n leav*sO][32][Sheng i6 no* chaosc 6][33][moke ge6tur;\nEven 8i)][34][t also 7eta7ned bo!ee][35][proudlyeQin9 Feng \"u6][36][cle\nOcc0lt\n\nhree\nIoh ][37][ar lovei I <elieveoi+][38][ love\nL*ve 7s a po le][39][of stru\"gli0g bluebg7][40][een alg$e\nA- desol.t ][41][ micro-'urs* of wi!dO][42][Bleedin\" th,ough m6 3][43][eins\nYe$rs -tation*de][44][in the 'eli;f\nFourEIe][45][believeetha* all c.ne][46][hear\nEv n a0ticipa;ee][47][discret , I~met th* *][48][ther th ir 1wn\nSom* &][49][an not \"ras. the m m ][50][nt\nLefteto *he Eas; 1][51][o go We6t, *he dea+ (][52][ust noteret+rn to !o2][53][here\nSe , I~wear Z.ne][54][Flowerseon 3y headc ,][55][n full 'loo3 alongot-][56][e way a)l t6e way\n\tr ][57][quentlyemis-ed som*,e][58][but als* de;ply mo9e!][59][ by win!, f,ost, s!o2][60][ or rai+\nFi(e\nPraj!ae][61][Paramit$, s1on as <o*][62][n as\nli#e b; beaut&f0][63][l like 6umm;r flow*r6][64][ and de$th 2ike au;u(][65][n leave6\nAl-o careoa'][66][n leave6\nAl-o careoa'][67][out wha1 ha-]\nneed correction(y) or not(n)y\nrow: 0\ncol: 7\ncorrection: t\nxor_is_inte,estingn@f\n[0][\nLife, thin~and li(h1][1][-off time a0d timeoa\"][2][ain\nFrivolo+s tire#e6][3][s\none\nI hea,d the *c-][4][o, from the~valley< $][5][nd the hear*\nOpen ;oe][6][the lonely -oul ofos,][7][ckle harves*ing\nRe?e$][8][t outrightl', but .l6][9][o repeat th; well--e,][10][ng of\nEvent+ally s8a<][11][ing in the :esert  a6][12][is\nI believ; I am\no7][13][n as the br7ght su\"m ][14][r flowers\nD1 not w&t-][15][ered undefe?ted fi*r<][16][ demon ruleTHeart =a1][17][e and breat6ing toob ][18][ar the load~of theoc0][19][mbersome\nBo,ed\nTwoEIe][20][heard the m+sic, f=o(][21][ the moon a0d carc.s6][22][\nAuxiliary ;xtremeoa ][23][stheticism <ait tooc$][24][pture mistyTFillin( 1][25][he intense 2ife, b:te][26][also fillin9 the p:r ][27][\nThere are ?lways \"e(][28][ories throu9hout t'ee][29][earth\nI bel7eve I .mO][30][Died as the~quiet -e$][31][uty of autu3n leav*sO][32][Sheng is no* chaosc 6][33][moke gestur;\nEven 8i)][34][t also reta7ned bo!ee][35][proudly Qin9 Feng \"u6][36][cle\nOccult\n```\n\n\n\n```txt\nhree\nIoh ][37][ar love, I <elieveoi+][38][ love\nLove 7s a po le][39][of struggli0g bluebg7][40][een algae\nA- desol.t ][41][ micro-burs* of wi!dO][42][Bleeding th,ough m6 3][43][eins\nYears -tation*de][44][in the beli;f\nFourEIe][45][believe tha* all c.ne][46][hear\nEven a0ticipa;ee][47][discrete, I~met th* *][48][ther their 1wn\nSom* &][49][an not gras. the m m ][50][nt\nLeft to *he Eas; 1][51][o go West, *he dea+ (][52][ust not ret+rn to !o2][53][here\nSee, I~wear Z.ne][54][Flowers on 3y headc ,][55][n full bloo3 alongot-][56][e way all t6e way\n\tr ][57][quently mis-ed som*,e][58][but also de;ply mo9e!][59][ by wind, f,ost, s!o2][60][ or rain\nFi(e\nPraj!ae][61][Paramita, s1on as <o*][62][n as\nlife b; beaut&f0][63][l like summ;r flow*r6][64][ and death 2ike au;u(][65][n leaves\nAl-o careoa'][66][n leaves\nAl-o careoa'][67][out what ha-]\nneed correction(y) or not(n)y\nrow: 0\ncol: 11\ncorrection:  \nxor_is_interestingn@f\n[0][\nLife, thin and li(h1][1][-off time and timeoa\"][2][ain\nFrivolous tire#e6][3][s\none\nI heard the *c-][4][o, from the valley< $][5][nd the heart\nOpen ;oe][6][the lonely soul ofos,][7][ckle harvesting\nRe?e$][8][t outrightly, but .l6][9][o repeat the well--e,][10][ng of\nEventually s8a<][11][ing in the desert  a6][12][is\nI believe I am\no7][13][n as the bright su\"m ][14][r flowers\nDo not w&t-][15][ered undefeated fi*r<][16][ demon rule\nHeart =a1][17][e and breathing toob ][18][ar the load of theoc0][19][mbersome\nBored\nTwoEIe][20][heard the music, f=o(][21][ the moon and carc.s6][22][\nAuxiliary extremeoa ][23][stheticism bait tooc$][24][pture misty\nFillin( 1][25][he intense life, b:te][26][also filling the p:r ][27][\nThere are always \"e(][28][ories throughout t'ee][29][earth\nI believe I .mO][30][Died as the quiet -e$][31][uty of autumn leav*sO][32][Sheng is not chaosc 6][33][moke gesture\nEven 8i)][34][t also retained bo!ee][35][proudly Qing Feng \"u6][36][cle\nOccult\nThree\nIoh ][37][ar love, I believeoi+][38][ love\nLove is a po le][39][of struggling bluebg7][40][een algae\nAs desol.t ][41][ micro-burst of wi!dO][42][Bleeding through m6 3][43][eins\nYears station*de][44][in the belief\nFourEIe][45][believe that all c.ne][46][hear\nEven anticipa;ee][47][discrete, I met th* *][48][ther their own\nSom* &][49][an not grasp the m m ][50][nt\nLeft to the Eas; 1][51][o go West, the dea+ (][52][ust not return to !o2][53][here\nSee, I wear Z.ne][54][Flowers on my headc ,][55][n full bloom alongot-][56][e way all the way\n\tr ][57][quently missed som*,e][58][but also deeply mo9e!][59][ by wind, frost, s!o2][60][ or rain\nFive\nPraj!ae][61][Paramita, soon as <o*][62][n as\nlife be beaut&f0][63][l like summer flow*r6][64][ and death like au;u(][65][n leaves\nAlso careoa'][66][n leaves\nAlso careoa'][67][out what has]\nneed correction(y) or not(n)y\nrow: 0\ncol: 18\ncorrection: g\nxor_is_interesting!@f\n[0][\nLife, thin and ligh1][1][-off time and time a\"][2][ain\nFrivolous tirele6][3][s\none\nI heard the ec-][4][o, from the valleys $][5][nd the heart\nOpen toe][6][the lonely soul of s,][7][ckle harvesting\nRepe$][8][t outrightly, but al6][9][o repeat the well-be,][10][ng of\nEventually swa<][11][ing in the desert oa6][12][is\nI believe I am\nBo7][13][n as the bright summ ][14][r flowers\nDo not wit-][15][ered undefeated fier<][16][ demon rule\nHeart ra1][17][e and breathing to b ][18][ar the load of the c0][19][mbersome\nBored\nTwo\nIe][20][heard the music, fro(][21][ the moon and carcas6][22][\nAuxiliary extreme a ][23][stheticism bait to c$][24][pture misty\nFilling 1][25][he intense life, bute][26][also filling the pur ][27][\nThere are always me(][28][ories throughout thee][29][earth\nI believe I amO][30][Died as the quiet be$][31][uty of autumn leavesO][32][Sheng is not chaos, 6][33][moke gesture\nEven wi)][34][t also retained bonee][35][proudly Qing Feng mu6][36][cle\nOccult\nThree\nI h ][37][ar love, I believe i+][38][ love\nLove is a poole][39][of struggling blue-g7][40][een algae\nAs desolat ][41][ micro-burst of windO][42][Bleeding through my 3][43][eins\nYears stationede][44][in the belief\nFour\nIe][45][believe that all cane][46][hear\nEven anticipatee][47][discrete, I met the *][48][ther their own\nSome &][49][an not grasp the mom ][50][nt\nLeft to the East 1][51][o go West, the dead (][52][ust not return to no2][53][here\nSee, I wear Zane][54][Flowers on my head, ,][55][n full bloom along t-][56][e way all the way\nFr ][57][quently missed some,e][58][but also deeply move!][59][ by wind, frost, sno2][60][ or rain\nFive\nPrajnae][61][Paramita, soon as so*][62][n as\nlife be beautif0][63][l like summer flower6][64][ and death like autu(][65][n leaves\nAlso care a'][66][n leaves\n```\n\n\n\n```txt\nAlso care a'][67][out what has]\nneed correction(y) or not(n)y\nrow: 0\ncol: 20\ncorrection: t\nxor_is_interesting!@#\n[0][\nLife, thin and light][1][-off time and time ag][2][ain\nFrivolous tireles][3][s\none\nI heard the ech][4][o, from the valleys a][5][nd the heart\nOpen to ][6][the lonely soul of si][7][ckle harvesting\nRepea][8][t outrightly, but als][9][o repeat the well-bei][10][ng of\nEventually sway][11][ing in the desert oas][12][is\nI believe I am\nBor][13][n as the bright summe][14][r flowers\nDo not with][15][ered undefeated fiery][16][ demon rule\nHeart rat][17][e and breathing to be][18][ar the load of the cu][19][mbersome\nBored\nTwo\nI ][20][heard the music, from][21][ the moon and carcass][22][\nAuxiliary extreme ae][23][stheticism bait to ca][24][pture misty\nFilling t][25][he intense life, but ][26][also filling the pure][27][\nThere are always mem][28][ories throughout the ][29][earth\nI believe I am\n][30][Died as the quiet bea][31][uty of autumn leaves\n][32][Sheng is not chaos, s][33][moke gesture\nEven wil][34][t also retained bone ][35][proudly Qing Feng mus][36][cle\nOccult\nThree\nI he][37][ar love, I believe in][38][ love\nLove is a pool ][39][of struggling blue-gr][40][een algae\nAs desolate][41][ micro-burst of wind\n][42][Bleeding through my v][43][eins\nYears stationed ][44][in the belief\nFour\nI ][45][believe that all can ][46][hear\nEven anticipate ][47][discrete, I met the o][48][ther their own\nSome c][49][an not grasp the mome][50][nt\nLeft to the East t][51][o go West, the dead m][52][ust not return to now][53][here\nSee, I wear Zan ][54][Flowers on my head, i][55][n full bloom along th][56][e way all the way\nFre][57][quently missed some, ][58][but also deeply moved][59][ by wind, frost, snow][60][ or rain\nFive\nPrajna ][61][Paramita, soon as soo][62][n as\nlife be beautifu][63][l like summer flowers][64][ and death like autum][65][n leaves\nAlso care ab][66][n leaves\nAlso care ab][67][out what has]\nneed correction(y) or not(n)n\nxor_is_interesting!@#\n```\n\n","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-equation-2","url":"/crypto/xctf-Equation-2.html","content":"## 题目信息\n\n题目描述“RSA私钥上面的部分被屏蔽了请恢复私钥并解密文件”，附件给出私钥编码的截图，但是只能看见最后5行。\n\n## 分析\n\n### OpenSSL私钥结构\n\n私钥信息按如下顺序排列：\nversion | pad | n | pad | e | pad | d | pad | p | pad | q | pad | x1 | pad | x2 | pad | x3\n其中，pad是填充信息，各pad并不同，$x_{1}= d\\ \\textrm{mod}\\ (p-1),x_{2}= d\\ \\textrm{mod}\\ (q-1),x_{3}=p^{-1}\\ \\textrm{mod}\\ q$，填充pad用来注释接下来的大数的(字节)长度，\\x02为pad开头的标记，有时后面接\\x81或\\x82，这用来标记长度值所占用的字节(\\x81代表占用1个字节，\\x82代表占用2个字节)，有时后面不接\\x81或\\x82而直接放置长度；\n例：\\x02\\x03代表接下来的大数的字节长度为3个字节；\\x02\\x81\\x80，首先，\\x81代表长度占用1个字节，因此\\x80就是长度值，即128，表明接下来的大数的字节长度为128个字节。\n\n将私钥信息按照上述顺序排列好之后，再进行base64编码。\n\n### 利用已知信息恢复私钥\n\n截图可见编码为\n```Bash\nOs9mhOQRdqW2cwVrnNI72DLcAXpXUJ1HGwJBANWiJcDUGxZpnERxVw7s0913WXNtV4GqdxCzG0pG5EHThtoTRbyX0aqRP4U/hQ9tRoSoDmBn+3HPITsnbCy67VkCQBM4xZPTtUKM6Xi+16VTUnFVs9E4rqwIQCDAxn9UuVMBXlX2Cl0xOGUF4C5hItrX2woF7LVS5EizR63CyRcPovMCQQDVyNbcWD7N88MhZjujKuSrHJot7WcCaRmTGEIJ6TkU8NWt9BVjR4jVkZ2EqNd0KZWdQPukeynPcLlDEkIXyaQx\n```\n\n解码后结合OpenSSL私钥结构分析可得：x1,x2,x3为已知；但是仅有x1,x2,x3并不能恢复出p,q与d，若我们假设e为常用的指数3,65537等等，则可试出p与q：\n\n$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ (p-1)(q-1)$\n则有$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ (p-1)$与$d\\cdot e\\equiv 1\\ \\textrm{mod}\\ (q-1)$；\n由$x_{1}$与$x_{2}$的定义可得$x_{1}\\cdot e\\equiv 1\\ \\textrm{mod}\\ (p-1)$，$x_{2}\\cdot e\\equiv 1\\ \\textrm{mod}\\ (q-1)$；\n因此$(p-1)|(x_{1}\\cdot e-1)$；\n记$x_{1}\\cdot e-1=r_{1}\\cdot (p-1)$；\n由于$x_{1}= d\\ \\textrm{mod}\\ (p-1)$，则$x_{1}<(p-1)$；\n几乎可以看做$x_{1}\\cdot e=r_{1}\\cdot (p-1)$，那么必有$r_{1}<e$；\n同理可得$r_{2}<e$，其中$x_{2}\\cdot e-1=r_{2}\\cdot (q-1)$\n可以看到，$r_{i}<e,i=1,2$，从而可使用试除法求出$r_{i},i=1,2$；\n则$p=(x_{1}\\cdot e-1)/r_{1}+1,q=(x_{2}\\cdot e-1)/r_{2}+1$；\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom Crypto.Util.number import bytes_to_long,isPrime,inverse\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5\n\ndef genKey(X1,X2,X3):\n    e=65537L\n    N1=X1*e-1\n    N2=X2*e-1\n    for r in range(e):\n        if N1%(e-r)==0:\n            p=N1/(e-r)+1\n            if isPrime(p):\n                break\n    for r in range(e):\n        if N2%(e-r)==0:\n            q=N2/(e-r)+1\n            if isPrime(q):\n                break\n    N=p*q\n    phi=(p-1)*(q-1)\n    d=inverse(e,phi)\n    assert inverse(q,p)==X3\n    return RSA.construct((N,e,long(d),p,q))\n\ndef solve():\n    X1=bytes_to_long('\\xd5\\xa2%\\xc0\\xd4\\x1b\\x16i\\x9cDqW\\x0e\\xec\\xd3\\xddwYsmW\\x81\\xaaw\\x10\\xb3\\x1bJF\\xe4A\\xd3\\x86\\xda\\x13E\\xbc\\x97\\xd1\\xaa\\x91?\\x85?\\x85\\x0fmF\\x84\\xa8\\x0e`g\\xfbq\\xcf!;\\'l,\\xba\\xedY')\n    X2=bytes_to_long('\\x138\\xc5\\x93\\xd3\\xb5B\\x8c\\xe9x\\xbe\\xd7\\xa5SRqU\\xb3\\xd18\\xae\\xac\\x08@ \\xc0\\xc6\\x7fT\\xb9S\\x01^U\\xf6\\n]18e\\x05\\xe0.a\"\\xda\\xd7\\xdb\\n\\x05\\xec\\xb5R\\xe4H\\xb3G\\xad\\xc2\\xc9\\x17\\x0f\\xa2\\xf3')\n    X3=bytes_to_long('\\xd5\\xc8\\xd6\\xdcX>\\xcd\\xf3\\xc3!f;\\xa3*\\xe4\\xab\\x1c\\x9a-\\xedg\\x02i\\x19\\x93\\x18B\\t\\xe99\\x14\\xf0\\xd5\\xad\\xf4\\x15cG\\x88\\xd5\\x91\\x9d\\x84\\xa8\\xd7t)\\x95\\x9d@\\xfb\\xa4{)\\xcfp\\xb9C\\x12B\\x17\\xc9\\xa41')\n    rsa_key=genKey(X1,X2,X3)\n    key= PKCS1_v1_5.new(rsa_key)\n    with open('flag.enc','rb') as f:\n        return key.decrypt(f.read(),'')\n\nif __name__=='__main__':\n    print solve()[:-1]\n```\n\n注：这里之所以猜测e为65537而不是3是因为$r_{i}<e,i=1,2$，如果e=3可能情况太少。\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\n0ctf{Keep_ca1m_and_s01ve_the_RSA_Eeeequati0n!!!}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-SM","url":"/crypto/xctf-SM.html","content":"## 题目信息\n\n附件中包含一个Python脚本sm.py，3个文本文件。\n\n## 分析\n\n读完一遍sm.py后，可以确定解题的思路是先由ps与r解出bchoose，再由bchoose按照同样的过程计算出密钥key，最后进行AES解密求出flag。首先看生成r的代码：\n\n```Python\nr=0\nfor i in range(512):\n    if bchoose[i]=='1':\n        r=r^ps[i]\n```\n\n即$r=\\sum_{i=1}^{512}\\textrm{bchoose[i]}\\cdot \\textrm{ps[i]}$(此处的加法是异或)；虽然生成方式类似背包加密，但是由于ps具有很好的性质，我们不使用破解背包加密的方法来解此题；我们来分析生成ps的gen512num函数：\n\n```Python\ndef gen512num():\n    order=[]\n    while len(order)!=512:\n        tmp=randint(1,512)\n        if tmp not in order:\n            order.append(tmp)\n    ps=[]\n    for i in range(512):\n        p=getPrime(512-order[i]+10)\n        pre=bin(p)[2:][0:(512-order[i])]+\"1\"\n        ps.append(int(pre+\"0\"*(512-len(pre)),2))\n    return ps\n```\n\norder是1,2,...,512的一个随机的排列，对ps[i]:首先生成一个长度为512-order[i]+10的素数，去掉此素数的最后10位，同时在尾部追加一个二进制位1，最后在后面填充0使得长度为512；我们首先考虑生成r的最后1个二进制位，ps中只有1个数最后1位为1，其余数最后1位均为0，那么最后1位为1的数如果没有“加入”异或运算，那么r的最后1位一定为0，否则，一定为1，这样我们通过r的最后1位就可以推断出bchoose的第j位(记order[j]=1)。接下来，$r\\oplus (\\textrm{bchoose[j]}\\cdot \\textrm{ps[j]})=\\sum_{i\\neq j}\\textrm{bchoose[i]}\\cdot \\textrm{ps[i]}$，在{ps[i]| i$\\neq$j}中，只有1个数倒数第2位为1，同理，可推断出bchoose的第k位(记order[k]=2)，直到推断出bchoose所有位。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\nfrom hashlib import md5\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.number import long_to_bytes\n\ndef cal_k():\n    with open('ps','r') as f:\n        ps=[long(x) for x in f.read().split('\\n')[:-1]]\n    with open('r','r') as f:\n        r=long(f.read())\n    pbits=[bin(x).rfind('1')-2 for x in ps]\n    bc=['0']*512\n    for le in range(512):\n        ind=pbits.index(511-le)\n        tt=bin(r)[2:].rjust(512,'0')[511-le]\n        if tt=='1':\n            bc[ind]='1'\n            r^=ps[ind]\n    return long(''.join(bc),2)\n\ndef solve():\n    with open('ef','rb') as f:\n        ef=b64decode(f.read())\n    key=long_to_bytes(int(md5(long_to_bytes(cal_k())).hexdigest(),16))\n    aes_obj = AES.new(key, AES.MODE_ECB)\n    return aes_obj.decrypt(ef)\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nflag{shemir_alotof_in_wctf_fun!}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-Decode_The_File","url":"/crypto/xctf-DECODE-THE-FILE.html","content":"## 题目信息\n\n附件是一个文本文件，里面有658行base64编码。\n\n## 分析\n\n先将附件中每行base64编码进行解码，得到一个Python脚本。但其实信息并非隐藏在解码后的数据中，而是隐藏在编码中。首先介绍[base64编码的原理](https://KangMing-ux.github.io//tech/B32-64-encode-explanation.html)，当需要编码的数据剩下1或2字节时，编码与解码过程如下：\n{% asset_img 1.png pic1 %}\n\n\n可以看到，即使$a_{i} \\neq 0$，解码过程也能正确进行；从而可以使用$a_{i}$传递一些信息。因此，只要我们将编码中的$a_{i}$提取出来，就可以解出flag。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\nfrom string import uppercase,lowercase,digits\nfrom Crypto.Util.number import long_to_bytes\n\ndef solve():\n    with open('encode','r') as f:\n        codes=f.read()\n    Lc=codes.split('\\n')[:-1]\n    base=uppercase+lowercase+digits+'+/'\n    re2=[]\n    for code in Lc:\n        if '==' in code:\n            re2.append(bin(base.find(code[-3]))[2:].rjust(6,'0')[2:])\n        elif '=' in code:\n            re2.append(bin(base.find(code[-2]))[2:].rjust(6,'0')[4:])\n    ret=''.join(re2)\n    return long_to_bytes(long(ret[:ret.rfind('1')+1],2))\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nROIS{base_GA_caN_b3_d1ffeR3nT}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-简单流量分析","url":"/crypto/xctf-Simple-Traffic-Analysis.html","content":"## 题目信息\n\n题目背景：运维人员在日常安全检查的时候发现现场某设备会不时向某不知名ip发出非正常的ICMP PING包。这引起了运维人员的注意，他在过滤出ICMP包分析并马上开始做应急处理很可能已被攻击的设备，附件给出可疑流量包。\n\n## 分析\n\n流量分析题，分析的方法基本上有：binwalk、查找一些可疑字符串或16进制数据，排序流量包的长度(最长的流量包一般很可疑)；当我们对流量包的长度进行排序时，发现流量包最短90字节，最长也不过164字节，其中的data段数据长度从48到122，而ascii表中第48至122个字符为0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz，于是将每个流量包的长度转换为对应字符，然后连接成一段长字符串，看上去像base64编码，对字符串进行base64解码即可!\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom pyshark.capture.file_capture import FileCapture\nfrom base64 import b64decode\nfrom sys import argv\n\ndef solve(file_name):\n    packets=FileCapture(input_file=file_name)\n    res=''\n    for packet in packets:\n        for pkt in packet:\n            if pkt.layer_name=='icmp' and int(pkt.type,16):\n                res+=chr(int(pkt.data_len))\n    return b64decode(res)\n\nif __name__=='__main__':\n    print solve(argv[1])\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py fetus_pcap.pcap\n::\\nmongodb:!:17843:0:99999:7:::\\nubuntu:$6$LhHRomTE$M7C4n84UcFLAG{xx2b8a_6mm64c_fsociety}::\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-shanghai","url":"/crypto/xctf-Shanghai.html","content":"## 题目信息\n\n题目给出提示“维吉利亚密码”，密文在附件中。\n\n## 分析\n\n由于维吉利亚密码加密时密钥重用，导致可通过分析密文进行破解；由于明文中存在一些出现频率很高的单词：the,and,for,with等等，因此很有可能这些单词再次被同样的密钥加密，从而生成同样的密文，其间隔一定是密钥长度的倍数，因此可通过对密文进行分析得到密钥的长度；另外，由于这些密文对应着那些出现频率高的明文，因此可破解出密钥；自己写了一个[工具](https://github.com/KangMing-ux/CTFs-Crypto/tree/tool/TRA/Virginia-analysis)来求解这类问题。\n\n## 解题\n\n如下是我使用工具的解题过程，注释是我自己加的，并非程序的输出\n```Bash\n$ python solve.py shanghai.txt\n# 先寻找密文中多次出现(本程序设定的至少3次)的词汇，并计算它们之间的距离，这有助于分析出密钥的长度\nword:  bju\ndistance:  [1078, 2222, 154, 814, 132, 264]\nthe minimum distance:  132\n\nword:  glv\ndistance:  [660, 408, 186, 374, 88, 66, 836, 44, 649, 110, 880, 88, 209, 66]\nthe minimum distance:  44\n\nword:  vxz\ndistance:  [1936, 154, 264, 253, 121, 517, 154, 440, 11, 220, 66]\nthe minimum distance:  11\n\nword:  bni\ndistance:  [22, 979, 2002, 583, 165, 132, 22]\nthe minimum distance:  22\n\nword:  xpg\ndistance:  [11, 396, 660, 2409, 11, 374, 37, 51, 572]\nthe minimum distance:  11\n\nword:  jcm\ndistance:  [1595, 88, 99, 297, 781, 11, 22, 110, 66, 231, 627]\nthe minimum distance:  11\n\nword:  zlr\ndistance:  [286, 583, 583, 154, 22, 154, 22, 407, 55, 396, 1155]\nthe minimum distance:  22\n\nword:  klm\ndistance:  [594, 308, 605, 2145, 231, 297, 44, 44, 198]\nthe minimum distance:  44\n\nword:  mfr\ndistance:  [44, 99, 99, 715, 1884, 536]\nthe minimum distance:  44\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  tyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  yiz\ndistance:  [165, 968, 550, 275, 220, 2167, 246, 106]\nthe minimum distance:  106\n\nword:  opk\ndistance:  [66, 1342, 385, 11, 1771, 583, 374]\nthe minimum distance:  11\n\nword:  tyi\ndistance:  [165, 968, 488, 62, 275, 220, 37, 1639, 491, 352]\nthe minimum distance:  37\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  pkv\ndistance:  [297, 33, 407, 1221, 572, 88]\nthe minimum distance:  33\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  xui\ndistance:  [638, 682, 77, 154, 55, 649, 363, 143]\nthe minimum distance:  55\n\nword:  tui\ndistance:  [55, 1628, 154, 286, 787, 797]\nthe minimum distance:  55\n\nword:  gvtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n\nword:  vtyiz\ndistance:  [165, 968, 550, 275, 220, 2167, 352]\nthe minimum distance:  165\n#到此我们应该也能看出，密钥的长度为11\n#接下来，进行已知明文攻击\n```\n```Bash\n#密文中有一段：frxnimp 1914 qil 1940，猜测是between 1914 and 1940\nplaintext:betweenand\ncipher:frxnimpqil\npossible key:enereicqvi len:10\n#如果需要更多的明-密文对分析，则输入y；否则，已计算出密钥，则可以进行解密你需要解密的内容\ntry more plain-cipher(y) or start decrypt(n)y\nplaintext:the\ncipher:opk\npossible key:vig len:3\ntry more plain-cipher(y) or start decrypt(n)n\nkey:enereicqvig\ncipher:jtcw, '{' vvj 'zvkvrmtudabiecveaaxpp' grq '}'\nfgyf, '{' rnh 'jacpnzpdzszsjupanwglh' ebv '}'\ndpps, '{' erb 'xfpnligqmwtgohnywntyl' ypa '}'\nbnyj, '{' ref 'rtuajgphzjxacmawuwkly' cjo '}'\nolws, '{' irs 'vnifwenqqwkewafjsutcl' pni '}'\ntyuq, '{' rif 'irctbrloznxrautofsrlc' cam '}'\nhdho, '{' prw 'vegnpwymxwoenynckfpjl' tnz '}'\nbrmb, '{' npf 'mrtrjkdzvuxvalrwykchj' cem '}'\nflag, '{' and 'vigenereisveryeasyhuh' and '}'\nspuu, '{' fab 'trxrailsnftcaprnwsvzu' ylm '}'\nfcyo, '{' tfo 'rpginvpmbkgayyiajwpnz' ljk '}'\nwpls, '{' ntt 'enereicqvylnwwrrwjthn' qwi '}'\n```\n\n解出flag为flag{vigenereisveryeasyhuh}。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-OldDriver","url":"/crypto/xctf-OldDriver.html","content":"## 题目信息\n\n附件是一份密文，其中包含10组RSA密钥-密文对。\n\n## 分析\n\nRSA秘钥的指数e=10，这些特征暗示低加密指数广播攻击；当加密一份消息给多人时，$c_{i}=m^{e} \\ \\textrm{mod}\\ N_{i},i=1,\\cdots,k$，当$k \\geq e$时，可由中国剩余定理求解$m^{e}$，再开方即得明文$m$。\n\n## 解题\n\n实现的sage脚本如下：\n\n```Python\nfrom Crypto.Util.number import long_to_bytes\nfrom gmpy2 import mpz,iroot\n\ncip_keys=[\n{\"c\": 7366067574741171461722065133242916080495505913663250330082747465383676893970411476550748394841437418105312353971095003424322679616940371123028982189502042, \"e\": 10, \"n\": 25162507052339714421839688873734596177751124036723831003300959761137811490715205742941738406548150240861779301784133652165908227917415483137585388986274803},\n{\"c\": 21962825323300469151795920289886886562790942771546858500842179806566435767103803978885148772139305484319688249368999503784441507383476095946258011317951461, \"e\": 10, \"n\": 23976859589904419798320812097681858652325473791891232710431997202897819580634937070900625213218095330766877190212418023297341732808839488308551126409983193},\n{\"c\": 6569689420274066957835983390583585286570087619048110141187700584193792695235405077811544355169290382357149374107076406086154103351897890793598997687053983, \"e\": 10, \"n\": 18503782836858540043974558035601654610948915505645219820150251062305120148745545906567548650191832090823482852604346478335353784501076761922605361848703623},\n{\"c\": 4508246168044513518452493882713536390636741541551805821790338973797615971271867248584379813114125478195284692695928668946553625483179633266057122967547052, \"e\": 10, \"n\": 23383087478545512218713157932934746110721706819077423418060220083657713428503582801909807142802647367994289775015595100541168367083097506193809451365010723},\n{\"c\": 22966105670291282335588843018244161552764486373117942865966904076191122337435542553276743938817686729554714315494818922753880198945897222422137268427611672, \"e\": 10, \"n\": 31775649089861428671057909076144152870796722528112580479442073365053916012507273433028451755436987054722496057749731758475958301164082755003195632005308493},\n{\"c\": 17963313063405045742968136916219838352135561785389534381262979264585397896844470879023686508540355160998533122970239261072020689217153126649390825646712087, \"e\": 10, \"n\": 22246342022943432820696190444155665289928378653841172632283227888174495402248633061010615572642126584591103750338919213945646074833823905521643025879053949},\n{\"c\": 1652417534709029450380570653973705320986117679597563873022683140800507482560482948310131540948227797045505390333146191586749269249548168247316404074014639, \"e\": 10, \"n\": 25395461142670631268156106136028325744393358436617528677967249347353524924655001151849544022201772500033280822372661344352607434738696051779095736547813043},\n{\"c\": 15585771734488351039456631394040497759568679429510619219766191780807675361741859290490732451112648776648126779759368428205194684721516497026290981786239352, \"e\": 10, \"n\": 32056508892744184901289413287728039891303832311548608141088227876326753674154124775132776928481935378184756756785107540781632570295330486738268173167809047},\n{\"c\": 8965123421637694050044216844523379163347478029124815032832813225050732558524239660648746284884140746788823681886010577342254841014594570067467905682359797, \"e\": 10, \"n\": 52849766269541827474228189428820648574162539595985395992261649809907435742263020551050064268890333392877173572811691599841253150460219986817964461970736553},\n{\"c\": 13560945756543023008529388108446940847137853038437095244573035888531288577370829065666320069397898394848484847030321018915638381833935580958342719988978247, \"e\": 10, \"n\": 30415984800307578932946399987559088968355638354344823359397204419191241802721772499486615661699080998502439901585573950889047918537906687840725005496238621}\n]\n\ncips=[]\nkeys=[]\n\nfor cip_key in cip_keys:\n\tcips.append(cip_key['c'])\n\tkeys.append(cip_key['n'])\n\nsol=crt(cips,keys)\nmsg,flag=iroot(mpz(str(sol)),mpz(str(10)))\nprint msg\nprint flag\nprint long_to_bytes(long(msg))\n```\n\n程序运行效果如下：\n\n```Bash\n$ sage wp.sage\n854589733786598088127099154138504953368140761371523704656865879247874533963639770706597129057405\nTrue\nflag{wo0_th3_tr4in_i5_leav1ng_g3t_on_it}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-Decrypt-the-Message","url":"/crypto/xctf-Decrypt-the-Message.html","content":"## 题目信息\n\n题目要求我们解密附件中的信息；打开附件，里面是一首诗，最后给出需要解密的信息。\n\n## 分析\n\n此题考察[Poem加密](http://wmbriggs.com/post/1001/)；举例说明加密过程。\n诗：for my purpose holds to sail beyond the sunset, and the baths of all the western stars until I die.\n明文：We have run out of cigars, situation desperate.\n从诗中选择5个词for,sail,all,stars,die，将这些词中的每个字母排序(相同的不合并)，即：\n```Bash\n f  o  r  s  a  i  l  a  l  l  s  t  a  r  s  d  i  e\n 6 12 13 15  1  7  9  2 10 11 16 18  3 14 17  4  8  5\n```\n上表共有18个字母，将明文以18个字母一组分成若干行，最后一行未满之处用a,b,...进行填充，即\n```Bash\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18\n w e h a v e r u n o  u  t  o  f  c  i  g  a\n r s s i t u a t i o  n  d  e  s  p  e  r  a\n t e a b c d e f g h  i  j  k  l  m  n  o  p\n```\n\n再根据第一个表将各列置换，即eud tdj ...，最后连接起来生成密文。\n\n破解的思路就是从诗中穷举各种取词情况，然后进行解密，然后选择可读的“明文”，已有人写好破解的[工具](https://github.com/abpolym/crypto-tools/tree/master/poemcode)\n\n## 解题\n\n将诗与密文分别存为poem.txt，cip.txt并移到与poemcode.py同目录下，使用工具破解：\n\n```Bash\n$ python poemcode.py poem.txt cip.txt\n...\nifytuothikcrnyptorapyisheansnweroyoturprbletheyoulodnotnowkwhatourrobemiuasbcdfgheijklnoprst\nifyouthinkcryptographyistheanswertoyourproblemthenyoudonotknowwhatyourproblemisabcdefghijklmnopqrstu\npakprictiyorhftyselorohyphurbeewterunhwooaywtooonrbpofjhsgkeilncmbrt\n...\n```\n中间的为明文。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-工业协议分析1","url":"/crypto/xctf-Industrial-Protocol-Analysis-1.html","content":"## 题目信息\n\n工业网络中存在异常，尝试通过分析PCAP流量包，分析出流量数据中的异常点，并拿到FLAG。flag形式为 flag{}，流量包在附件。\n\n## 分析\n\n将流量包的长度排序(由大到小)，第一个流量包的长度为10120，比第二长的流量包超过太多，猜测有问题；一段乱码之后，data=\"data:image/png;base64,后面是一段很长的base64编码。\n\n## 解题\n\n先将流量包中的base64编码复制到文本文件data.txt中，再进行解码，最后将解码的数据写入png文件，实现的Python脚本如下：\n\n```Python\nfrom base64 import b64decode\n\nwith open('data.txt','r') as f:\n    da=f.read()\n\ndata=b64decode(da)\n\nwith open('flag.png','w') as g:\n    g.write(data)\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-fanfie","url":"/crypto/xctf-fanfile.html","content":"## 题目信息\n\n附件是一个文本文件，里面是一段长34的字符串。\n\n## 分析\n\n文本中的字符串看上去像base32编码，加填充后解码得乱码；很多时候比赛的名称是解密的谜面，对字符串BITSCTF进行base32编码得字符串IJEVIU2DKRDA====，与文本中的字符串MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI进行对比，发现字符I两次对应M，猜测是移位密码或仿射密码，加密运算的有限集为{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,2,3,4,5,6,7}，不理解的可以参见[对base编码的介绍](https://www.cnblogs.com/coming1890/p/13503574.html),尝试之后得加密方式为仿射密码，求得解密式为$x=5y+12\\ \\textrm{mod}\\ 32$。\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom base64 import b32decode\n\ndef solve():\n    s='MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI'\n    dic='ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'\n    msg=''.join([dic[(5*dic.find(x)+12)%32] for x in s])\n    return b32decode(msg+'='*(8-len(msg)%8))\n\nif __name__=='__main__':\n    #python solve.py\n    print solve()\n```\n\n运行程序得如下结果：\n```Bash\n$ python solve.py\nBITSCTF{S2VyY2tob2Zm}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-ecb,_it’s_easy_as_123","url":"/crypto/xctf-ECB-it-is-easy-as-123.html","content":"## 题目信息\n\n附件提供了背景介绍(Somebody leaked a still from the upcoming Happy Feet Three movie, which will be released in 4K, but Warner Bros. was smart enough to encrypt it. But those idiots used a black and white bmp format, and that wasn't their biggest mistake. Show 'em who's boss and get the flag.)，与一个bmp文件。\n\n## 分析\n\n根据背景介绍，原图片应该是bmp格式，经ecb工作模式加密得ecb.bmp；由于ecb工作模式不会掩盖明文的统计规律，因此只要能够修复ecb.bmp就可以见到明文，要修复ecb.bmp，则要求文件的前128字节为bmp文件格式特有的字节。\n\n## 解题\n\n将ecb.bmp的前128字节替换为bmp文件格式特有的字节，则可以见到明文信息，实现的Python脚本如下：\n\n```Python\nfrom Crypto.Util.number import long_to_bytes\n\nwith open('ecb.bmp','rb') as f:\n    data=f.read()\npre=0x424d76483f00000000007600000028000000000f000070080000010004000000000000483f00000000000000000000000000000000000000000000008000008000000080800080000000800080008080000080808000c0c0c0000000ff0000ff000000ffff00ff000000ff00ff00ffff0000ffffff00ffffffffffffffffffffL\nout=long_to_bytes(pre)+data[128:]\n\nwith open('out.bmp','wb') as g:\n    g.write(out)\n```\n\nout.bmp可被照片查看器打开，从而见到flag。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-safer-than-rot13","url":"/crypto/xctf-Safer-Than-Rot13.html","content":"## 题目信息\n\n附件是一个文本文件，题目名称safer-than-rot13。\n\n## 分析\n\n由题目名称safer-than-rot13，先对密文进行rot13置换；依然看不出任何逻辑，再进行词频分析,找到flag。\n\n## 解题\n\n对密文进行rot13置换：\n\n```Bash\ncat cry100 | tr A-Za-z N-ZA-Mn-za-m > dec100\n```\n\n再进行[词频分析](https://quipqiup.com/)，找到flag为NO THIS IS NOT CRYPTO MY DEAR。","tags":["攻防世界"],"categories":["crypto"]},{"title":"ctf密码学常用python库","url":"/crypto/CTF-cryptography-uses-Python-libraries.html","content":"## pyCryptodome库\n\n```Bash\npip3 install pyCryptodome -i https://pypi.douban.com/simple\n```\n这个库是实现各种算法和协议的密码模块的集合，包含Cipher，Hash，Protocol，PublicKey，Signature，Util这些子包；\n\n### Cipher子包\n\n实现了分组加密(AES，DES，DES3，CAST，Blowfish，RC2)，流加密(RC4，XOR)与公钥加密(RSA PKCS#1与PKCS#1 OAEP，这两个区别在于加密前对数据的填充不同)；如下是文档给出的例子：\n\n```Python\nfrom Crypto.Cipher import AES\nfrom Crypto import Random\nkey = b'Sixteen byte key'\niv = Random.new().read(AES.block_size)\ncipher = AES.new(key, AES.MODE_CFB, iv)\nmsg = iv + cipher.encrypt(b'Attack at dawn')\nprint msg.encode('hex')\n```\n\n有时在解RSA的题时，已经知道了密钥，解出来的flag却是乱码，也许是加了一些填充如OAEP，PKCS#1导致的；这时就需要使用对应的秘钥解密；如下是一个PKCS#1填充的例子，加密的明文(字节)长度必须严格小于密钥(字节)长度-11\n\n```Python\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5\nfrom gmpy2 import invert\nfrom base64 import b64decode\n\ncip='bT633yPu4dOHEL66eKCHjg6cZb09CElt2mSSQZkRDHk='\n\nn=87924348264132406875276140514499937145050893665602592992418171647042491658461L\ne=65537L\n#http://factordb.com/\np=275127860351348928173285174381581152299L\nq=319576316814478949870590164193048041239L\nphi=(p-1)*(q-1)\nd=invert(e,phi)\n\nprivkey=RSA.construct((n,e,long(d),p,q))\n\n#原生RSA\nprint privkey.decrypt(b64decode(cip))\n\n#PKCS#1填充\nkey= PKCS1_v1_5.new(privkey)\nprint key.decrypt(b64decode(cip),'')\n```\n\n再举个OAEP填充的例子，加密的明文(字节)长度必须严格小于密钥(字节)长度减去41；你可以试一下在下面代码中的明文中多加一个字符运行就会报错。\n\n```Python\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_OAEP\nfrom base64 import b64encode,b64decode\n\nrsa_key=RSA.generate(1024)\nkey=PKCS1_OAEP.new(rsa_key)\ncip=b64encode(key.encrypt('PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}PCTF{256b_i5_m3dium}abcdef'))\nprint cip\n\nmsg=key.decrypt(b64decode(cip))\nprint msg\n```\n\n### Hash子包\n\n实现了哈希算法(MD2，MD4，MD5，RIPEMD，SHA，SHA224，SHA256，SHA384，SHA512，HMAC，hashalgo)；如下是文档给出的例子：\n\n```Python\nfrom Crypto.Hash import MD2\nh = MD2.new()\nh.update(b'Hello')\nprint h.hexdigest()\n```\n\n但是没有实现SHA1，要使用SHA1，需要导入hashlib库，正好验证一下Google之前给出的求得两个 sha1 值一样的pdf对：https://shattered.io/\n\n```Python\nfrom hashlib import sha1\n\nwith open('shattered-1.pdf','rb') as f1:\n    da1=f1.read()\nwith open('shattered-2.pdf','rb') as f2:\n    da2=f2.read()\n\nprint sha1(da1).hexdigest()\nprint sha1(da2).hexdigest()\n```\n\n### PublicKey子包\n\n实现了公钥加密和签名算法(RSA，DSA，ElGamal)；文档给出的例子：\n\n```Python\nfrom Crypto.PublicKey import RSA\nkey0 = RSA.generate(2048)\nwith open('mykey.pem','w') as f:\n    f.write(key0.exportKey('PEM'))\n\nwith open('mykey.pem','r') as g:\n    key = RSA.importKey(g.read())\n```\n\n### Util子包\n\n实现了各种有用的模块和功能(Util.number：数论函数，Util.randpool：随机数生成，Util.RFC1751：在128位键和可读的字串之间进行转换，Util.asn1：对ASN.1 DER编码的最小支持)；自己写个例子如下：\n\n```Python\nfrom Crypto.Util import number\ns='this is a demo'\n#字节转换为long型整数\nls=number.bytes_to_long(s)\n\nbits=8*len(s)\n#生成长度为bits的素数\ngp=number.getPrime(bits)\n\n#生成长度小于bits的随机数\ngri=number.getRandomInteger(bits)\n \n#生成长度为bits的随机数\ngrnbi=number.getRandomNBitInteger(bits)\n\n#生成长度不超过bits的随机数\ngrn=number.getRandomNumber(bits)\n \n#生成grn与2*grn之间的随机数\ngrr=number.getRandomRange(grn,2*grn)\n\n#生成强的素数（gsp-1，gsp+1均至少具有一个大的素因子）\ngsp=number.getStrongPrime(1024)\n\n#计算gri在模grn下的逆\niin=number.inverse(gri,grn)\n\n#判断iin是否为素数\nip=number.isPrime(iin)\n\n#long型整数转换为字节\ntb=number.long_to_bytes(ls)\n```\n\n由于这个库很多函数都很有用，因此我们直接使用\n```Python\nfrom Crypto.Util.number import *\n```\n来导入这个包的所有函数。\n\n## pwntools库\n\n```Bash\npip3 install pwntools -i https://pypi.douban.com/simple\n```\n\n这个库内容很多，只介绍比赛中用到的。\n\n### mbruteforce函数\n\n多线程穷举函数，详细定义如下：mbruteforce(func, alphabet, length, method='upto', start=None, threads=None)，其中，\n* func输入参数为字符串，输出布尔值，mbruteforce穷举直到func输出True；\n* alphabet为组成输入参数字符串的字符集合；\n* length指定输入参数字符串的长度上界；\n* method默认为'upto'，指定穷举的字符串长度从1增大到length；另外两个选项为'fixed'、'downfrom'，fixed'指定穷举的字符串长度仅为ength，'downfrom'指定穷举的字符串长度从length减小到1；\n* start=(N,i)，就是把搜索空间分成N块从第i块开始穷举；默认为(1,1)\n* threads指定穷举时的线程数，默认值是内核的数量；\n\n举个例子：\n\n```Python\nfrom pwn import pwnlib\nfrom pwnlib.util.iters import mbruteforce\nmbruteforce(lambda x: x == 'hello','helo',5,method='fixed')\n```\n\n### remote类\n\n用来与服务器交互；常用函数的用法注释到如下脚本中。\n\n```Python\nfrom pwn import pwnlib\nfrom pwnlib.tubes.remote import remote\n\n#创建到远程主机的TCP或udp连接，主机为cn.bing.com，连接主机的端口为443\n#ssl=True代表用SSL包装套接字\nr=remote('cn.bing.com',443,ssl=True)\n\n#向主机发送数据，只不过数据只能是一行\nr.sendline('GET /')\n\n#向主机发送数据，数据可以是多行\nr.send(b'\\r\\n\\r\\n')\n\n##上面两行代码等价于r.send(b'GET /\\r\\n\\r\\n')\n\n#从主机接收4个字节的数据\nre=r.recvn(4)\nprint re\n\n#从主机一直接收数据直到'Please'出现\nre=r.recvuntil('Please')\nprint re\n\n#从主机一直接收数据，最多接收4096字节\nre=r.recv()\nprint re\n\n#关闭连接\nr.close()\n```","tags":["工具","Python"],"categories":["crypto"]},{"title":"RSA攻击大全及其实现","url":"/crypto/RSA-attack-Daquo-and-its-implementation.html","content":"## RSA攻击大全\n\n### 模数分解\n\n* Small q：模数N有小素数因子；\n* fermat：模数N的因子p与q非常接近；\n* 模不互素：给出多组公钥，但是其中的模数共用了素因子；\n\n### 针对指数进行攻击\n\n* 小公钥指数攻击：指数很小；\n* 低加密指数广播攻击：相同的消息发送给多个接收者，且加密指数较低；\n\n### 针对私钥进行攻击\n\n* 维纳攻击：指数很大(理论上$d<N^{0.25}$此攻击起作用)；\n* Boneh-Durfee攻击：同样针对指数很大的情形，理论上$d<N^{0.29}$此攻击起作用；\n\n### Coppersmith相关攻击\n\nCoppersmith算法用于求解模$N$多项式$F(X)$($X$为单变量、二元变量甚至多元变量)所有小整数根($\\big\\|X\\big\\|<cN^{\\beta^{2}/\\delta}$，其中$\\delta$为多项式$F$的次数，假设$N$具有不小于$N^{\\beta}$的因子)\n\n* 明文高位泄露：明文的二进制位表示为$m_{b} \\cdots m_{t+1}m_{t} \\cdots m_{1}$，其高位$m_{b} \\cdots m_{t+1}$泄露，记$m'=m_{b} \\cdots m_{t+1}0 \\cdots 0$，则$m'$已知，但$\\Delta m=m_{t} \\cdots m_{1}$未知；由$c \\equiv m^{e}\\ \\textrm{mod}\\ N$，则$\\Delta m$是模多项式$F(X)=(m'+X)^{e}\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 因子低位泄露：因子的二进制位表示为$p_{b} \\cdots p_{t+1}p_{t} \\cdots p_{1}$，其高位$p_{b} \\cdots p_{t+1}$泄露，记$p'=p_{b} \\cdots p_{t+1}0 \\cdots 0$，则$p'$已知，但$\\Delta p=p_{t} \\cdots p_{1}$未知；由$p \\cdot q=N$，则$\\Delta p$是模多项式$F(X)=(p'+X)\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 明文低位泄露：明文的二进制位表示为$m_{b} \\cdots m_{t+1}m_{t} \\cdots m_{1}$，其低位$m_{t} \\cdots m_{1}$泄露，记$m'=m_{t} \\cdots m_{1}$，则$m'$已知，但$\\Delta m=m_{b} \\cdots m_{t+1}$未知；由$c \\equiv m^{e}\\ \\textrm{mod}\\ N$，则$\\Delta m$是模多项式$F(X)=(m'+2^{t}X)^{e}\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n* 因子低位泄露：因子的二进制位表示为$p_{b} \\cdots p_{t+1}p_{t} \\cdots p_{1}$，其低位$p_{t} \\cdots p_{1}$泄露，记$p'=p_{t} \\cdots p_{1}$，则$p'$已知，但$\\Delta p=p_{b} \\cdots p_{t+1}$未知；由$p \\cdot q=N$，则$\\Delta p$是模多项式$F(X)=(p'+2^{t}X)\\ \\textrm{mod}\\ N$的小整数根。接下来使用Coppersmith算法求解。\n\n[GithHub实现链接](https://github.com/mimoo/RSA-and-LLL-attacks)\n\n## 攻击工具\n\n### RsaCtfTool\nGitHub链接：[RsaCtfTool](https://github.com/Ganapati/RsaCtfTool)\n\n在Ubuntu18.04下的安装RsaCtfTool(进入RsaCtfTool目录下)：\n\n```Bash\napt install -y libgmp-dev\napt install -y libmpfr-dev\napt install -y libmpc-dev\npip3 install gmpy2 -i https://pypi.douban.com/simple\npip3 install -r requirements.txt -i https://pypi.douban.com/simple\n```\n\n### yafu\n\n我认为最强大的分解因子的工具。\n\n### 在线分解因子网站\n\n[factordb](http://factordb.com/)","tags":["密码学知识","工具","RSA"],"categories":["crypto"]},{"title":"b32&64encode详解","url":"/crypto/B32-64-encode-explanation.html","content":"以前只是用这些函数，从没想过这些编码的原理；还是因为一道ctf题让我好好的了解了一下这些编码方式！\n\n## b32encode\n\n我们知道每个字节是8比特，b32encode将5个字节分成8块，每块前三位补0，从而将5个字节扩展为8个字节；那么扩展后的每个字节的值不超过32，与32个字符\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"对应，有时我们发现编码的字符串中还有\"=\"这个字符，但是它是填充字符，以上就是b32encode；用Python写一个脚本来帮助理解：\n```Python\nfrom string import uppercase,digits\nfrom base64 import b32encode\n\ndef my_b32encode(s):\n    base=uppercase+digits[2:8]\n    assert(len(s))==5\n    bs=''.join([bin(ord(x))[2:].rjust(8,'0') for x in s])\n    assert len(bs)==40\n    sbs=[bs[5*ind:5*(ind+1)] for ind in range(8)]\n    re=[base[int(x,2)] for x in sbs]\n    return ''.join(re)\n\nif __name__=='__main__':\n    print my_b32encode('BITSC')\n    print b32encode('BITSC')\n```\n\n## b64encode\n\nb64encode将3个字节分成4块，每块前两位补0，从而将3个字节扩展为4个字节；那么扩展后的每个字节的值不超过64，与64个字符 \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"对应，同样地，\"=\"作为填充字符，以上就是b64encode；用Python写一个脚本来帮助理解：\n```Python\nfrom string import uppercase,lowercase,digits\nfrom base64 import b64encode\n\ndef my_b64encode(s):\n    base=uppercase+lowercase+digits+'+/'\n    assert len(s)==3\n    bs=''.join([bin(ord(x))[2:].rjust(8,'0') for x in s])\n    assert len(bs)==24\n    sbs=[bs[6*ind:6*(ind+1)] for ind in range(4)]\n    re=[base[int(x,2)] for x in sbs]\n    return ''.join(re)\n\nif __name__=='__main__':\n    print my_b64encode('BIT')\n    print b64encode('BIT')\n```","tags":["密码学知识","base64"],"categories":["crypto"]},{"title":"WMCTF2020密码学部分详解","url":"/crypto/WMCTF2020-Cryptography-Part-Detail.html","content":"比赛网址：[WMCTF2020](https://adworld.xctf.org.cn/match/contest_challenge?event=146&hash=684a58cc-1140-4937-99f2-ef347d777d9f.event)\n\n## piece_of_cake\n\n### 题目信息\n附件是一个py脚本，[Gitee备份](https://github.com/KangMing-ux/CTFs-Crypto/tree/master/2020/WMCTF/piece_of_cake)中的task.py。\n\n### 分析\n\neat_cake函数中的各个变量的定义如下：\n\n* $p,q$为512位随机素数，$ph=(p-1) \\cdot (q+1),N=p \\cdot q,d=e^{-1}\\ \\textrm{mod}\\ ph$\n\n* $cake$为768位随机素数，$q$重新赋值为1536位随机素数，将$d$的值赋给$f$，$g$为随机素数，$g$的位数等于$q$的位数减去$f$的位数再减去1\n\n* $h=f^{-1} \\cdot g\\ \\textrm{mod}\\ q$，$r$为512位随机素数，$c=(r \\cdot h+cake)\\ \\textrm{mod}\\ q$\n\n由：\n$$\nh=f^{-1} \\cdot g\\ \\textrm{mod}\\ q\n$$\n可得：\n$$\nf \\cdot h \\equiv g\\ \\textrm{mod}\\ q\n$$\n即存在$t\\in Z$，使得：\n$$\nf \\cdot h-t \\cdot q=g\n$$\n构造矩阵$M$如下：\n$$\nM=\\begin{pmatrix}\n1 & h\\\\\n0 & q\n\\end{pmatrix}\n$$\n则有：\n$$\n\\begin{pmatrix}\nf & -t\n\\end{pmatrix} \\cdot \\begin{pmatrix}\n1 & h\\\\\n0 & q\n\\end{pmatrix} = \\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$$\n则$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$是格$L(M)$上的短格基，因此有可能可使用LLL算法或BKZ算法求出，这里说有可能求出，因为在解题时并不是每次都能找到短格基$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$\n假设我们求出的短格基为$\n\\begin{pmatrix}\nf & g\n\\end{pmatrix}\n$，再由公式$c=(r \\cdot h+cake)\\ \\textrm{mod}\\ q$\n\n则：\n\n$$\nf \\cdot c \\equiv f \\cdot (r \\cdot h+cake) \\equiv (r \\cdot g+f \\cdot cake)\\ \\textrm{mod}\\ q\n$$\n\n\n从而：\n\n$$\n(r \\cdot g+f \\cdot cake)= f \\cdot c\\ \\textrm{mod}\\ q\n$$\n\n\n两边模$g$可得：\n\n$$\nf \\cdot cake \\equiv (f \\cdot c\\ \\textrm{mod}\\ q)\\ \\textrm{mod}\\ g\n$$\n\n\n于是：\n\n$$\ncake=f^{-1} \\cdot (f \\cdot c\\ \\textrm{mod}\\ q)\\ \\textrm{mod}\\ g\n$$\n\n\n注意，上面等式中$f^{-1}$是$f$在$g$下的逆，不能与括号内的$f$抵消。\n\n### 解题\n\n上述链接中的solve.sage为解题的sage脚本。\n\n### 备注\n\n此exp并不能保证次次成功！不过它的有效性不可否认，上述链接中的test.sage即可验证。\n\n以下是我对test.sage四次的运行结果：\n\n```Bash\n$ sage test.sage\nsuccess! 48 -th\n$ sage test.sage\nsuccess! 2 -th\n$ sage test.sage\nsuccess! 50 -th\n$ sage test.sage\nsuccess! 24 -th\n```\n\n从而验证了解题脚本solve.sage的有效性。\n\n## babySum\n\n### 题目信息\n\n附件是两个py脚本与一个json文件，[Gitee备份](https://github.com/KangMing-ux/CTFs-Crypto/tree/master/2020/WMCTF/babySum)中的task.py与check.py。\n\n### 分析\n\ntask.py告诉我们生成data中数据的逻辑，其实很好理解：生成$n=120$个150位的随机数，组成数组$A$，从中选$k=20$个相加生成和$s$；\n\n记数组$A=[a_{1},\\cdots,a_{n}]$，check.py读入120个数$b_{1},\\cdots,b_{n}(b_{i}={0,1})$，其中20个为1，另外100个为1，检验$\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s$，如果等式成立，就打印出flag。\n\n到这里我们共有3个约束条件：\n$$\n\\begin{cases}\n\\sum_{i=1}^{n}b_{i}=k\\\\\n\\\\\n\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s\\\\\n\\\\\nb_{i}=0,1;i=1,\\cdots,n\n\\end{cases}\n$$\n遇到这种问题一般转化为格基约减问题，构造矩阵$M$如下：\n$$\nM=\n\\begin{pmatrix}\n1 &   &   &   & a_{1} & 1 \\\\\n  & 1 &   &   & a_{2} & 1 \\\\\n  &   &\\ddots &   &\\vdots &\\vdots \\\\\n  &   &   & 1 & a_{n} & 1 \\\\\n  &   &   &   & -s & -k &\n\\end{pmatrix}\n$$\n\n\n那么$\n\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 1\n\\end{pmatrix} \\cdot M=\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 0 & 0\n\\end{pmatrix}\n$\n\n即通过格基约减可以求出$b_{1},\\cdots,b_{n}$。\n\n理想很丰满，现实很骨感！\n\n约减后的格基无法达到我们需要的结果！直到看到writeup，这里需要记住一个很有用的技巧，可类比约束优化问题对约束条件的处理，当不满足如下约束条件时\n$$\n\\begin{cases}\n\\sum_{i=1}^{n}b_{i}=k\\\\\n\\\\\n\\sum_{i=1}^{n}a_{i} \\cdot b_{i}=s\n\\end{cases}\n$$\n\n\n\n\n加大“惩罚”，我们重新设计格基矩阵$M$如下：\n$$\nM=\n\\begin{pmatrix}\n1 &   &   &   & N \\cdot a_{1} & N \\\\\n  & 1 &   &   & N \\cdot a_{2} & N \\\\\n  &   &\\ddots &   &\\vdots &\\vdots \\\\\n  &   &   & 1 & N \\cdot a_{n} & N \\\\\n  &   &   &   & -N \\cdot s & -N \\cdot k &\n\\end{pmatrix}\n$$\n其中$N=[\\sqrt{n}]$，此时仍然有$\n\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 1\n\\end{pmatrix} \\cdot M=\\begin{pmatrix}\nb_{1} & b_{2} & \\cdots & b_{n} & 0 & 0\n\\end{pmatrix}\n$\n\n然后就是比较玄学的问题，对同一格，改变格基矩阵行的顺序，约减的结果也会不同，官方的writeup就是不断打乱格基矩阵的行，然后进行格基约减；再就是为了更快得到结果，需要进行多线程编程；上述链接中的solve.sage为解题的sage脚本；官方设置的8个线程，我自己改成6个线程，跑了几次，基本上都是20分钟左右出结果。\n\n```Bash\n$ sage solve.sage   \n(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0)\ncost time:  0:25:27\n```","tags":["CTF比赛","number","LLL"],"categories":["crypto"]},{"title":"攻防世界-密码学-说我作弊需要证据","url":"/crypto/xctf-Need-proof-that-I-cheated.html","content":"## 题目信息\n\n题目背景为在一次考试中两名学生作弊，给出他们的RSA公钥，附件两者通信的pcapng流量包。\n\n## 分析\n\n鉴于Alice与Bob的密钥位数如此地低，通过yafu或者去[factordb](http://factordb.com/)立马就分解出模数，进而计算出私钥。\n\n用wireshark打开流量包，按下Ctrl+Alt+Shift+T快捷键来追踪TCP流(并保存下来，比如我保存为data.txt)；通过数据格式应该可以确定是base64编码后的数据格式，那么先解码前三个看看编码的数据；\n```Bash\nSEQ = 13; DATA = 0x3b04b26a0adada2f67326bb0c5d6L; SIG = 0x2e5ab24f9dc21df406a87de0b3b4L;\nSEQ = 0; DATA = 0x7492f4ec9001202dcb569df468b4L; SIG = 0xc9107666b1cc040a4fc2e89e3e7L;\nSEQ = 5; DATA = 0x94d97e04f52c2d6f42f9aacbf0b5L; SIG = 0x1e3b6d4eaf11582e85ead4bf90a9L;\n```\n\nDATA应该是密文，但是另外两个数据也很重要，SEQ是明文的顺序，SIG是对明文的签名；因此对保存的TCP流依次解码，使用Bob的私钥对密文DATA解密，再验证SIG是否为Alice对明文的签名，如果是则放到明文列表的第SEQ位置；\n\n## 解题\n\n实现的Python脚本如下：\n\n```Python\nfrom Crypto.PublicKey import RSA\nfrom gmpy2 import invert,powmod\nfrom base64 import b64decode\n\ndef solve():\n    N1=0x53a121a11e36d7a84dde3f5d73cfL\n    N2=0x99122e61dc7bede74711185598c7L\n    e=0x10001L\n#   p1,q1=38456719616722997L,44106885765559411L\n    p2,q2=49662237675630289L,62515288803124247L\n    \n#   phi1=(p1-1)*(q1-1)\n    phi2=(p2-1)*(q2-1)\n#   d1=invert(e,phi1)\n    d2=invert(e,phi2)\n    \n#   rsa_key1=RSA.construct((N1,e,long(d1),p1,q1))\n    rsa_key2=RSA.construct((N2,e,long(d2),p2,q2))\n\n    with open('data.txt','r') as f:\n        data=f.read()\n\n    cips=data.split('\\n')\n    res=['']*len(cips)\n    for cip in cips[:-1]:\n        data=b64decode(cip)\n        seq=int(data[(data.find('= ')+2):data.find(';')])\n        cipher=data[(data.find('x')+1):data.find('L')]\n        sig=data[(data.rfind('x')+1):data.rfind('L')]\n        msg=rsa_key2.decrypt(long(cipher,16))\n        if msg==powmod(long(sig,16),e,N1):\n            res[seq]+=chr(msg)\n    return res\n\nif __name__=='__main__':\n    #python solve.py\n    print ''.join(solve())\n```\n\n运行结果如下：\n\n```Bash\n$ python solve.py\nflag{n0th1ng_t0_533_h3r3_m0v3_0n}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-Easy one","url":"/crypto/xctf-Easy-One.html","content":"## 题目信息\n\n题目这样描述：“破解密文，解密msg002.enc文件”，并且提供附件下载，附件中有4个文件：encryptor.c、msg001、msg001.enc与msg002.enc。\n\n## 分析\n\nencryptor.c向我们展示了加密的原理,\n\n```C\nc = (p + (k[i % strlen(k)] ^ t) + i*i) & 0xff;\n```\n对明文的每个字符p，按照上述代码生成密文c，之后t更新为p，i增1，再加密下一个字符。只不过，当我写了对应的解密程序进行解密时，得到的明文是乱码。\n\n我用encryptor.c重新加密了一遍msg001，发现得到的密文与所给的msg001.enc不同，结合加密程序分析，怀疑t的初值或者k被“做了手脚”，我首先穷举了t的256个初值，发现加密的结果均与msg001.enc不同，那么应该是真正加密所用的k并不是encryptor.c展示的k，所以第一步应该解出真正加密所用的k，根据加密原理，k的每一个字符x都能通过下式求出，也就是考察已知明密文求解密钥。\n\n```Python\nx=(ord(c)-ord(m)-ii*ii)&0xff\nx^=t\n```\n\n## 解题\n\n由密文求明文的程序很简单，难点在于你需要先通过msg001、msg001.enc求解出真正加密所用的密钥。\n\n```Python\ndef get_true_key(msg_data,cip_data):\n    xs=''\n    ii,t=0,0\n    for m,c in zip(msg_data,cip_data):\n        x=(ord(c)-ord(m)-ii*ii)&0xff\n        x^=t\n        t=ord(m)\n        ii+=1\n        xs+=chr(x)\n    return xs[:(xs[1:].find(xs[0])+1)]\n\ndef test(msg_data,cip_data,o_k):\n    tt=0\n    cip=''\n    lk=len(o_k)\n    for ii,m in enumerate(msg_data):\n        c=(ord(m)+(o_k[ii%lk]^tt)+ii*ii)&0xff\n        cip+=chr(c)\n        tt=ord(m)\n    return all(x==c for x,c in zip(cip,cip_data))\n\ndef solve():\n    with open('msg001','r') as f:\n        msg_data=f.read().strip()\n    with open('msg001.enc','r') as f:\n        cip_data=f.read().strip()\n    with open('msg002.enc','r') as f:\n        data=f.read().strip()\n    k=get_true_key(msg_data,cip_data)\n    print 'the true key is : ',k\n    o_k=[ord(c) for c in k]\n    assert test(msg_data,cip_data,o_k)\n    t=0\n    msg=''\n    for ii,c in enumerate(data):\n        p=(ord(c)-ii*ii-(o_k[ii%28]^t))&0xff\n        t=p\n        msg+=chr(p)\n    with open('msg002','w') as f:\n        f.write(msg)\n    return msg\n\nif __name__=='__main__':\n#   python solve.py\n    print solve().strip()\n```\n\n解出加密所用密钥，破解密文：\n\n```Bash\n$ python solve.py\nthe true key is : VeryLongKeyYouWillNeverGuess\nThe known-plaintext attack (KPA) is an attack model for cryptanalysis where the attacker has samples of both the plaintext (called a crib), and its encrypted version (ciphertext). These can be used to reveal further secret information such as secret keys and code books. The term \"crib\" originated at Bletchley Park, the British World War II decryption operation. \nThe flag is CTF{6d5eba48508efb13dc87220879306619}\n```\n简要介绍了已知明文攻击之后，后面给出flag。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-wtc_rsa_bbq","url":"/crypto/xctf-WTC-RSA-BBQ.html","content":"## 题目信息\n\n附件是一个压缩包，解压之后还是一个压缩包，再解压(禁止套娃!!!)得一个文件夹，里面包含公钥(key.pem)与密文(cipher.bin)信息。\n\n## 分析\n\n使用openssl查看公钥信息：\n\n```Bash\nopenssl rsa -pubin -in key.pem -text -modulus\n```\n\n发现模数很大，8587位；本来分解模数无脑丢到yafu里面分解就行，但是几个小时都没有分解出来，去[factordb](http://factordb.com/)也分解不出来；回顾针对RSA的各种攻击，对本题可以使用的剩下Small q,费马分解(p与q接近)，试着用费马分解时分解成功。\n\n## 解题\n\n使用工具[RSACTFTool](https://github.com/Ganapati/RsaCtfTool)进行分解,将key.pem与cipher.bin移到与RsaCtfTool.py同目录下：\n\n```Bash\nsudo python3 RsaCtfTool.py --publickey key.pem --uncipherfile cipher.bin --attack fermat\n```\n\n在明文最后给出flag为flag{how_d0_you_7urn_this_0n?}。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-banana-princess","url":"/crypto/xctf-Banana-Princess.html","content":"## 题目信息\n\n附件给出一个PDF文件，但是用阅读器打开显示文件已损坏。\n\n## 分析\n\n用vim打开PDF文件，开头为%CQS-1.5，既然是PDF文件，那就找找CQS与PDF的关系，首先想到的是凯撒密码，结果发现这三个字母均在字母表中相隔13，另外PDF文件中的小写字母也需要进行解密替换。\n\n## 解题\n使用Shell，一行就可以完成解密：\n\n```Bash\n$ cat cip.pdf | tr A-Za-z N-ZA-Mn-za-m > msg.pdf\n```\n\n结果发现flag被遮住了，另存为图片，flag可见，为BITSCTF{save_the_kid}。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-你猜猜","url":"/crypto/xctf-Guess.html","content":"## 题目信息\n\n附件是一个文本文件，里面是一串16进制数据。\n\n## 分析\n\n504B0304开头一般代表zip数据(另外还有526172211a0701开头代表rar数据，377abcaf271c开头代表7z数据)，于是将这一串16进制数据另存为一个zip文件，不用说，压缩时肯定进行了加密，使用fcrackzip工具进行破解。\n\n## 解题\n\n首先使用Python将16进制数据另存为一个zip文件：\n\n```Python\nfrom Crypto.Util.number import long_to_bytes\n\ns=0x504B03040A0001080000626D0A49F4B5091F1E0000001200000008000000666C61672E7478746C9F170D35D0A45826A03E161FB96870EDDFC7C89A11862F9199B4CD78E7504B01023F000A0001080000626D0A49F4B5091F1E00000012000000080024000000000000002000000000000000666C61672E7478740A0020000000000001001800AF150210CAF2D1015CAEAA05CAF2D1015CAEAA05CAF2D101504B050600000000010001005A000000440000000000\nwith open('data.zip','wb') as f:\n    f.write(long_to_bytes(s))\n```\n\n再使用fcrackzip工具破解密码：\n\n```Bash\n$ fcrackzip -b -c '1' -l 4-8 -u data.zip\n\nPASSWORD FOUND!!!!: pw == 123456\n```\n解密得到flag.txt，里面保存着flag。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-sherlock","url":"/crypto/xctf-Sherlock.html","content":"## 题目信息\n\n附件是网页上的一篇文章，先复制到txt中保存。\n\n## 分析\n\n如下是文章开头：\n\n```Bash\n(additional editing by jose menendeZ)\n\nthE adventuRes Of\nsherlOck holmes\n\nby\n\nsir arthur coNan doylE\n```\n\n奇怪之处是有些位置不应该使用大写字母，但是使用了大写字母，推断这些大写字母是用来传递消息的。将文章中的所有大写字母提取出来，得到一串全部由ZERO与ONE组成的字符串，ZERO替换为数字0，ONE替换为数字1，从而得到一个二进制表示的数，再将此数转换为字符串即可。\n\n## 解题\n\nPython代码如下：\n\n```Python\nfrom string import uppercase\nfrom Crypto.Util.number import long_to_bytes\n\ndef solve():\n    with open('paper','r') as f:\n        data=f.read()\n    cip=''\n    for c in data:\n        if c in uppercase:\n            cip+=c\n    cip=cip.replace('ZERO','0')\n    cip=cip.replace('ONE','1')\n    return long_to_bytes(long(cip,2))\n\nif __name__=='__main__':\n    print solve()\n```\n\n程序运行结果如下：\n\n```Bash\n$ python solve.py\nBITSCTF{h1d3_1n_pl41n_5173}\n```","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-告诉你一个秘密","url":"/crypto/xctf-Tells-you-a-secret.html","content":"## 题目信息\n\n附件为两行数字与字母组成的字符串。\n\n## 分析\n\n字符串中的字母均未超过E，猜测是16进制编码，于是先将字符串进行16进制解码，解码之后看上去像base64编码，于是接着进行base64解码，得到两段全由字母组成的字符串，并且被空格隔开，每小段字符串包含3-4个字母，解密的方法就在眼前——键盘，每小段字符串的字母围起来的字母就是明文。\n\n## 解题\n\nPython代码如下：\n\n```Python\nfrom base64 import b64decode\n\ndef solve():\n    cips=[\n            '636A56355279427363446C4A49454A7154534230526D6843',\n            '56445A31614342354E326C4B4946467A5769426961453067'\n            ]\n    msgs=[]\n    for cip in cips:\n        msgs.append(b64decode(cip.decode('hex')))\n    return msgs\n\nif __name__=='__main__':\n    print solve()\n```\n\n运行程序得到如下结果：\n\n```Bash\n$ python solve.py\n['r5yG lp9I BjM tFhB', 'T6uh y7iJ QsZ bhM ']\n```\n\n接下来在键盘上找每小段字符串的字母围起来的字母，得到flag为tongyuan。","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-flag in your hand","url":"/crypto/xctf-Flag-in-Your-Hand.html","content":"## 题目信息\n\n题目给了两个文件：index.html与script-min.js。\n\n## 分析\n\n先分析index.html的逻辑，第58行：\n\n```HTML\n<input type=\"button\" value=\"Get flag!\" onclick=\"getFlag()\" />\n```\n\n结合浏览器打开index.html的效果，我们知道点击 'Get flag!' 按钮时会调用getFlag()函数；\n\ngetFlag()函数的定义在第32行：\n```JavaScript\nfunction getFlag() {\n\tvar token = document.getElementById(\"secToken\").value;\n\tic = checkToken(token);\n\tfg = bm(token);\n\tshowFlag()\n}\n```\n\n在显示flag之前会调用checkToken(token)与bm(token)两个函数，我们先看一下显示flag的showFlag()函数，它定义在第39行：\n\n```JavaScript\nfunction showFlag() {\n\tvar t = document.getElementById(\"flagTitle\");\n\tvar f = document.getElementById(\"flag\");\n\tt.innerText = !!ic ? \"You got the flag below!!\" : \"Wrong!\";\n\tt.className = !!ic ? \"rightflag\" : \"wrongflag\";\n\tf.innerText = fg;\n}\n```\n\n可以看到是通过ic的布尔值判断我们是否输入正确的token，而ic由函数checkToken(token)返回，跳转到script-min.js中定义函数checkToken的地方看一下：\n\n```JavaScript\nfunction checkToken(s) {\n    return s === \"FAKE-TOKEN\";\n}\n```\n\n难不成FAKE-TOKEN就是正确的token？当然不是，还是抱着希望去试了一下，果然不是！那么问题只能出在函数bm中，它改变了ic的布尔值！\n\n于是去看一下函数bm，它定义如下：\n\n```JavaScript\nfunction bm(s){\n\treturn rb(rstr(str2rstr_utf8(s)));\n}\n```\n\n函数str2rstr_utf8与rb并没有改变ic的布尔值，是rstr调用的函数ck改变了ic的布尔值；函数ck的定义如下：\n\n```JavaScript\nfunction ck(s){\n    try {\n        ic\n    } catch (e) {\n        return;\n    }\n    var a = [118, 104, 102, 120, 117, 108, 119, 124, 48,123,101,120];\n    if (s.length == a.length) {\n        for (i = 0; i < s.length; i++) {\n            if (a[i] - s.charCodeAt(i) != 3)\n                return ic = false;\n        }\n        return ic = true;\n    }\n    return ic = false;\n}\n```\n\n看到这里明白了，checkToken就是个幌子，这里才决定ic布尔值！对函数ic的输入参数(字符串)s，只有s与列表a等长，且s每个字符在ascii表中的序号比列表a中每个对应元素小3时，ic才为True。\n\n于是可以写个python脚本求一下这里会让ic=True的s：\n\n```Python\na=[118,104,102,120,117,108,119,124,48,123,101,120];\nprint ''.join([chr(x-3) for x in a])\n```\n\n得到s为security-xbu字符串。\n\n综上，当函数ck的输入为字符串security-xbu时，会使ic的布尔值为True，从而得到正确的flag；通过分析调用过程，函数ck的输入为str2rstr_utf8(token)，那么token为何值时str2rstr_utf8(token)为字符串security-xbu呢？是不是要写个str2rstr_utf8的逆程序？其实不用，我们将script-min.js中的函数bm改一下，如下：\n\n```JavaScript\nfunction bm(s){\n\t//return rb(rstr(str2rstr_utf8(s)));\n\treturn rb(rstr(s))\n}\n```\n\n刷新index.html，填入security-xbu，就可以得到正确的flag！","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-工业协议分析2","url":"/crypto/xctf-Industrial-Protocol-Analysis-II.html","content":"## 题目信息\n\n在进行工业企业检查评估工作中，发现了疑似感染恶意软件的上位机。现已提取出上位机通信流量，尝试分析出异常点，获取FLAG。 flag形式为 flag{}。\n\n## 分析\n字符串'flag'的16进制编码为0x666c6167，在筛选器输入data contains \"666c61677b\"筛选包含666c61677b的流量包，筛选出两个包。\n\n## 解题\n任选一个提取出数据666c61677b37466f4d3253746b6865507a7d，再进行16进制解码得到flag{7FoM2StkhePz}","tags":["攻防世界"],"categories":["crypto"]},{"title":"攻防世界-密码学-新手练习区","url":"/crypto/xctf-Beginner-Practice-Area.html","content":"## Caeser\n\n凯撒密码：替换加密——明文中的所有字母都在字母表上向后按照一个固定数目offset进行偏移后被替换成密文。由于不知道偏移量，因此将每个偏移量都试一下进行解密;事实上，解密过程既可以看作密文中的所有字母都在字母表上向前按照一个固定数目offset进行偏移，也可以看作密文中的所有字母都在字母表上向后按照一个固定数目(26-offset)进行偏移！\n\n如下是解题的Python代码：\n\n```Python\nfrom string import lowercase\n\nclass Caeser():\n    def __init__(self,dic=None):\n        if dic==None:\n            self.dic=lowercase\n        else:\n            self.dic=dic\n\n    def enc(self,msg,ofst):\n        dic=self.dic\n        ld=len(dic)\n        cip=''\n        for c in msg:\n            if c in dic:\n                index=dic.find(c)\n                cip+=dic[(index+ofst)%ld]\n            else:\n                cip+=c\n        return cip\n\ndef solve():\n    msg='oknqdbqmoq{kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz}'\n    caeser=Caeser()\n    for ii in range(len(caeser.dic)):\n        print caeser.enc(msg,ii)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp1.py\noknqdbqmoq{kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz}\nplorecrnpr{lbh_unir_yrnearq_pnrfne_rapelcgvba}\nqmpsfdsoqs{mci_vojs_zsofbsr_qosgof_sbqfmdhwcb}\nrnqtgetprt{ndj_wpkt_atpgcts_rpthpg_tcrgneixdc}\nsoruhfuqsu{oek_xqlu_buqhdut_squiqh_udshofjyed}\ntpsvigvrtv{pfl_yrmv_cvrievu_trvjri_vetipgkzfe}\nuqtwjhwsuw{qgm_zsnw_dwsjfwv_uswksj_wfujqhlagf}\nvruxkixtvx{rhn_atox_extkgxw_vtxltk_xgvkrimbhg}\nwsvyljyuwy{sio_bupy_fyulhyx_wuymul_yhwlsjncih}\nxtwzmkzvxz{tjp_cvqz_gzvmizy_xvznvm_zixmtkodji}\nyuxanlawya{ukq_dwra_hawnjaz_ywaown_ajynulpekj}\nzvybombxzb{vlr_exsb_ibxokba_zxbpxo_bkzovmqflk}\nawzcpncyac{wms_fytc_jcyplcb_aycqyp_clapwnrgml}\nbxadqodzbd{xnt_gzud_kdzqmdc_bzdrzq_dmbqxoshnm}\ncyberpeace{you_have_learned_caesar_encryption}\ndzcfsqfbdf{zpv_ibwf_mfbsofe_dbftbs_fodszqujpo}\neadgtrgceg{aqw_jcxg_ngctpgf_ecguct_gpetarvkqp}\nfbehushdfh{brx_kdyh_ohduqhg_fdhvdu_hqfubswlrq}\ngcfivtiegi{csy_lezi_pievrih_geiwev_irgvctxmsr}\nhdgjwujfhj{dtz_mfaj_qjfwsji_hfjxfw_jshwduynts}\niehkxvkgik{eua_ngbk_rkgxtkj_igkygx_ktixevzout}\njfilywlhjl{fvb_ohcl_slhyulk_jhlzhy_lujyfwapvu}\nkgjmzxmikm{gwc_pidm_tmizvml_kimaiz_mvkzgxbqwv}\nlhknaynjln{hxd_qjen_unjawnm_ljnbja_nwlahycrxw}\nmilobzokmo{iye_rkfo_vokbxon_mkockb_oxmbizdsyx}\nnjmpcaplnp{jzf_slgp_wplcypo_nlpdlc_pyncjaetzy}\n```\n\n看上去像句人话的就是cyberpeace{you_have_learned_caesar_encryption}，这就是flag。\n\n## Morse\n\n摩尔斯密码：使用0,1两种状态的二进制代码组合表示字母与数字；解密就是一个查找操作。如下是解题的Python代码：\n\n```Python\n#Morse Code\n\nclass Morse():\n    def __init__(self):\n        self.dic = {'a': '01',     'b': '1000',   'c': '1010',\n                'd': '100',    'e': '0',      'f': '0010',\n                'g': '110',    'h': '0000',   'i': '00',\n                'j': '0111',   'k': '101',    'l': '0100',\n                'm': '11',     'n': '10',     'o': '111',\n                'p': '0110',   'q': '1101',   'r': '010',\n                's': '000',    't': '1',      'u': '001',\n                'v': '0001',   'w': '011',    'x': '1001',\n                'y': '1011',   'z': '1100',   '_': '001101',\n                '0': '11111',  '1': '01111',  '2': '00111',\n                '3': '00011',  '4': '00001',  '5': '00000',\n                '6': '10000',  '7': '11000',  '8': '11100',\n                '9': '11110'\n                }\n\n    def enc(self,msg):\n        cip=''\n        dic=self.dic\n        for c in msg:\n            cip+=dic[c]\n            cip+=''\n        return cip\n\n    def dec(self,cip):\n        msg=''\n        dic=self.dic\n        key=list(dic.keys())\n        val=list(dic.values())\n        for c in cip.split():\n            msg+=key[val.index(c)]\n        return msg\n\ndef solve():\n    cip='11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110'\n    morse=Morse()\n    print morse.dec(cip)\n\nif __name__=='__main__':\n#   python wp2.py\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp2.py\nmorsecodeissointeresting\n```\n\n## 不仅仅是Morse\n\n由于得到的数据格式与上一个相同，因此仍然进行Morse解密，解密出\n```Bash\nmay_be_have_another_decodehhhhaaaaabaabbbaabbaaaaaaaabaababaaaaaaabbabaaabbaaabbaabaaaababaabaaabbabaaabaaabaababbaabbbabaaabababbaaabbabaaabaabaabaaaabbabbaabbaabaabaaabaabaabaababaabbabaaaabbabaabba\n```\n\n这还不是明文，提示你还需要一种解码；这种密码是培根密码：替换密码——根据所给表对应转换即可加密解密。\n\n如下是解题的Python代码：\n\n```Python\n#Morse code + Bacon cipher\n\nfrom wp2 import Morse\n\nclass Bacon():\n    def __init__(self):\n        self.dic={'a':'aaaaa','b':'aaaab','c':'aaaba','d':'aaabb',\n                'e':'aabaa','f':'aabab','g':'aabba','h':'aabbb',\n                'i':'abaaa','j':'abaab','k':'ababa','l':'ababb',\n                'm':'abbaa','n':'abbab','o':'abbba','p':'abbbb',\n                'q':'baaaa','r':'baaab','s':'baaba','t':'baabb',\n                'u':'babaa','v':'babab','w':'babba','x':'babbb',\n                'y':'bbaaa','z':'bbaab'\n                }\n\n    def enc(self,msg):\n        cip=''\n        dic=self.dic\n        for c in msg:\n            cip+=dic[c]\n        return cip\n\n    def dec(self,cip):\n        msg=''\n        dic=self.dic\n        key=list(dic.keys())\n        val=list(dic.values())\n        for c in [cip[5*ii:5*(ii+1)] for ii in range(len(cip)/5)]:\n            msg+=key[val.index(c)]\n        return msg\n\ndef solve():\n    cip='11 01 1011 001101 1000 0 001101 0000 01 0001 0 001101 01 10 111 1 0000 0 010 001101 100 0 1010 111 100 0 0000 0000 0000 0000 01 01 01 01 01 1000 01 01 1000 1000 1000 01 01 1000 1000 01 01 01 01 01 01 01 01 1000 01 01 1000 01 1000 01 01 01 01 01 01 01 1000 1000 01 1000 01 01 01 1000 1000 01 01 01 1000 1000 01 01 1000 01 01 01 01 1000 01 1000 01 01 1000 01 01 01 1000 1000 01 1000 01 01 01 1000 01 01 01 1000 01 01 1000 01 1000 1000 01 01 1000 1000 1000 01 1000 01 01 01 1000 01 1000 01 1000 1000 01 01 01 1000 1000 01 1000 01 01 01 1000 01 01 1000 01 01 1000 01 01 01 01 1000 1000 01 1000 1000 01 01 1000 1000 01 01 1000 01 01 1000 01 01 01 1000 01 01 1000 01 01 1000 01 01 1000 01 1000 01 01 1000 1000 01 1000 01 01 01 01 1000 1000 01 1000 01 01 1000 1000 01'\n    morse=Morse()\n    cip=morse.dec(cip)\n    print cip\n    cip=cip[cip.find('hhhh')+4:]\n    bacon=Bacon()\n    print bacon.dec(cip)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp3.py\nattackanddefenceworldisinteresting\n```\n\n## 幂数加密\n\n这题实际是云影密码：26个英文字母在字母表中的次序ord(x)<$2^{5}$，因此5位二进制数可以表示一个英文字母，即1,2,4,8,16的组合(求和)可表示一个英文字母，例如L在字母表中的次序为12=4+8，因此组合48就可以表示字母L；同时0作为分隔符。\n\n如下是解题的Python代码：\n\n```Python\ns='8842101220480224404014224202480122'\nls=s.split('0')\ndic='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nm=''\nfor c in ls:\n    t=0\n    for cc in c:\n        t+=int(cc)\n    m+=dic[t-1]\nprint m\n```\n\n运行上述程序：\n\n```Bash\n$ python wp4.py\nWELLDONE\n```\n\n## Railfence\n\n栅栏密码：将明文row个为一组，排列为col行(明文的长度可能小于为row$\\cdot$col，即最后一行可能不会填满)，再将第一列的字母从上至下连接起来，接下来是第二列，直到第row列，生成密文。\n\n但是此题是栅栏密码的一个变种——W型栅栏密码；例如，如下是一个密钥为5的W型栅栏密码，明文为1-19的自然数，将其按照W的形状排列，再由上至下，从左至右连接数字，生成密文[1,9,17,2,8,10,16,18,3,7,11,15,19,4,6,12,14,5,13]。\n\n```Bash\n1             9               17\n  2         8   10          16  18\n    3      7      11      15      19\n      4   6         12  14\n        5             13\n```\n\n如下是解题的Python代码(此题的密钥为5)：\n\n```Python\n#W kind Railfence cipher\n\nclass Railfence_W():\n    def __init__(self,key=2):\n        self.key=key\n\n    def enc(self,msg,mode):\n        #mode = 0 means decrypt,mode = 1 means encrypt\n        ls=len(msg)\n        key=self.key\n        rep=range(0,ls,2*(key-1))\n        for dd in range(1,key-1):\n            ind=dd\n            de1=2*(key-1-dd)\n            de2=2*dd\n            while ind<ls:\n                rep.append(ind)\n                ind+=de1\n                if ind>=ls:\n                    break\n                rep.append(ind)\n                ind+=de2\n        rep.extend(range(key-1,ls,2*(key-1)))\n        if mode:\n            cips=''.join([msg[ii] for ii in rep])\n        else:\n            cip=rep[:]\n            for ii in range(ls):\n                cip[rep[ii]]=msg[ii]\n            cips=''.join(cip)\n        return cips\n\ndef solve():\n    cip='ccehgyaefnpeoobe{lcirg}epriec_ora_g'\n    for step in range(2,8):\n        railfence_w=Railfence_W(step)\n        print railfence_w.enc(cip,0)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp5.py\ncccierhgg}yeaperfinepce_ooorbae_{gl\ncnipceeoeocbhe_{glocyirraga}ee_pfrg\ncal_cecfiornepgr}ehoeapogbr_iey{egc\ncyberpeace{railfence_cipher_gogogo}\ncgecraiioycaore_cgbeefe}_goe{nhplpr\nchfbriaegengcyp{}c__eleaeeocpogrrio\n```\n\n## easychallenge\n\n附件是一个pyc文件，使用uncompyle6进行反编译得到py脚本，脚本中定义了3个编码函数，这3个编码函数都是可逆的，从而可求解出与给定编码数据对应的明文。\n\n如下是解题的Python代码：\n\n```Python\nfrom base64 import b32decode\n\ndef decode1(ans):\n    s = ''\n    for i in ans:\n        x=ord(i)-25\n        x^=36\n        s+=chr(x)\n    return s\n\ndef decode2(ans):\n    s = ''\n    for i in ans:\n        x=ord(i)^36\n        x-=36\n        s+=chr(x)\n    return s\n\ndef decode3(ans):\n    return b32decode(ans)\n\ndef solve():\n    final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E==='\n    return decode1(decode2(decode3(final)))\n\nif __name__=='__main__':\n    print solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp6.py\ncyberpeace{interestinghhhhh}\n```\n\n## 转轮机加密\n\n题目提示托马斯·杰斐逊，搜索一下有一个关于此人的密码——杰斐逊密码：首先，转轮机每一圈有若干字母，共有若干圈；加密时，将转轮机调整至某一列为明文，然后任选其他的某一列，作为密文。因此解密时，转轮机调整至某一列为密文，然后分析其他列，找到语句通顺的就是明文。\n\n如下是解题的Python代码：\n\n```Python\n#Jefferson cipher\n\nclass Jefferson():\n    def __init__(self,key):\n        self.box=[\n                'ZWAXJGDLUBVIQHKYPNTCRMOSFE',\n                'KPBELNACZDTRXMJQOYHGVSFUWI',\n                'BDMAIZVRNSJUWFHTEQGYXPLOCK',\n                'RPLNDVHGFCUKTEBSXQYIZMJWAO',\n                'IHFRLABEUOTSGJVDKCPMNZQWXY',\n                'AMKGHIWPNYCJBFZDRUSLOQXVET',\n                'GWTHSPYBXIZULVKMRAFDCEONJQ',\n                'NOZUTWDCVRJLXKISEFAPMYGHBQ',\n                'XPLTDSRFHENYVUBMCQWAOIKZGJ',\n                'UDNAJFBOWTGVRSCZQKELMXYIHP',\n                'MNBVCXZQWERTPOIUYALSKDJFHG',\n                'LVNCMXZPQOWEIURYTASBKJDFHG',\n                'JZQAWSXCDERFVBGTYHNUMKILOP'\n                ]\n        self.key=key\n\n    def dec(self,cip):\n        box=self.box\n        key=self.key\n        lb=len(box)\n        tbox=[box[x-1] for x in key]\n        assert lb==len(cip)\n        for ii in range(lb):\n            ind=tbox[ii].find(cip[ii])\n            tbox[ii]=tbox[ii][ind:]+tbox[ii][:ind]\n        for ii in range(len(box[0])):\n            print (''.join([x[ii] for x in tbox])).lower()\n\ndef solve():\n    cip='NFQKSEVOQOFNP'\n    key=[2,3,7,5,13,12,9,1,8,10,4,11,6]\n    jefferson=Jefferson(key)\n    jefferson.dec(cip)\n\nif __name__=='__main__':\n    solve()\n```\n\n运行上述程序：\n\n```Bash\n$ python wp7.py\n...\nsambkvlqsiaav\nfireinthehole\nuzaulcdkfprst\n...\n```\n\n唯一一句人话就是fireinthehole，这就是flag。","tags":["攻防世界"],"categories":["crypto"]},{"title":"简历","url":"/job/SelfIntro.html","content":"\n<div style=\"width:100%;margin:auto\">{% asset_img resume.png resume %}</div>\n\n","tags":["introduction"],"categories":["job"]},{"title":"about","url":"/about/index.html","content":"\n姓名：褚康明\n\n籍贯：湖北省孝感市\n\n本科：西安电子科技大学，数学与应用数学\n\n硕士：中国科学院大学信息工程研究所，电子信息\n\n方向：CTF密码学，Linux内核\n"},{"title":"help","url":"/help/index.html","content":"\n**1**这博客很好看，是怎么做的？\n答：本博客使用Hexo制作，采用的jsimple主题，部署在Gitee Pages上，搭建步骤请参考：[使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)](https://KangMing-ux.github.io/conf/Build-a-personal-blog-based-on-Gitee-Pages-using-Hexo-with-JSimple-Theme.html)，也可以多参考[主题作者的README](https://github.com/tangkunyin/hexo-theme-jsimple/blob/master/README.zhCN.md)\n\n**2**部署到Gitee Pages上面时布局一团糟怎么办？\n答：这可能是因为你没有做到`根目录部署`，导致数据索引不到，同样建议参考[使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)](https://KangMing-ux.github.io/conf/Build-a-personal-blog-based-on-Gitee-Pages-using-Hexo-with-JSimple-Theme.html)这篇博客，在最后指出如何正确创建`根目录部署`\n\n**3**Gitee Pages与本地的博客效果不一致是为什么？\n答：因为您没有氪金，单用`hexo deploy`是不会更新Gitee Pages的，还需要手动更新，同样建议参考[使用Hexo搭建基于Gitee Pages的个人博客(jsimple主题)](https://KangMing-ux.github.io/conf/Build-a-personal-blog-based-on-Gitee-Pages-using-Hexo-with-JSimple-Theme.html)这篇博客\n\n**4**怎么才能多给我打赏？\n答：好意心领了，我相信千里送鹅毛，礼轻情意重\n"},{"title":"links","url":"/links/index.html","content":"\n[hexo文档](https://hexo.io/zh-cn/docs/)\n\n[hexo 主题大全](https://hexo.io/themes/)\n\n[jsimple主题](https://github.com/tangkunyin/hexo-theme-jsimple)\n\n[攻防世界](https://adworld.xctf.org.cn)\n\n[pexels](https://www.pexels.com/)\n\n[Gnome-look](https://www.gnome-look.org)\n\n[中文马克思主义文库：毛泽东](https://www.marxists.org/chinese/maozedong/index.htm)\n\n[抗美援朝](http://www.12371.cn/2020/10/12/VIDA1602474174035898.shtml)\n\n[国务院公报](http://www.gov.cn/zwgk/2011-11/09/content_1989024.htm)\n\n\n\n\n\n"},{"title":"tags","url":"/tags/index.html"}]